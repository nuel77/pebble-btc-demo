(function () {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a
                }
                var p = n[i] = {exports: {}};
                e[i][0].call(p.exports, function (r) {
                    var n = e[i][1][r];
                    return o(n || r)
                }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
        }

        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o
    }

    return r
})()({
    1: [function (require, module, exports) {
        'use strict'

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
        }

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup['-'.charCodeAt(0)] = 62
        revLookup['_'.charCodeAt(0)] = 63

        function getLens(b64) {
            var len = b64.length

            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42
            var validLen = b64.indexOf('=')
            if (validLen === -1) validLen = len

            var placeHoldersLen = validLen === len
                ? 0
                : 4 - (validLen % 4)

            return [validLen, placeHoldersLen]
        }

// base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
        }

        function toByteArray(b64) {
            var tmp
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]

            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

            var curByte = 0

            // if there are placeholders, only get up to the last complete 4 chars
            var len = placeHoldersLen > 0
                ? validLen - 4
                : validLen

            var i
            for (i = 0; i < len; i += 4) {
                tmp =
                    (revLookup[b64.charCodeAt(i)] << 18) |
                    (revLookup[b64.charCodeAt(i + 1)] << 12) |
                    (revLookup[b64.charCodeAt(i + 2)] << 6) |
                    revLookup[b64.charCodeAt(i + 3)]
                arr[curByte++] = (tmp >> 16) & 0xFF
                arr[curByte++] = (tmp >> 8) & 0xFF
                arr[curByte++] = tmp & 0xFF
            }

            if (placeHoldersLen === 2) {
                tmp =
                    (revLookup[b64.charCodeAt(i)] << 2) |
                    (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[curByte++] = tmp & 0xFF
            }

            if (placeHoldersLen === 1) {
                tmp =
                    (revLookup[b64.charCodeAt(i)] << 10) |
                    (revLookup[b64.charCodeAt(i + 1)] << 4) |
                    (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[curByte++] = (tmp >> 8) & 0xFF
                arr[curByte++] = tmp & 0xFF
            }

            return arr
        }

        function tripletToBase64(num) {
            return lookup[num >> 18 & 0x3F] +
                lookup[num >> 12 & 0x3F] +
                lookup[num >> 6 & 0x3F] +
                lookup[num & 0x3F]
        }

        function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp =
                    ((uint8[i] << 16) & 0xFF0000) +
                    ((uint8[i + 1] << 8) & 0xFF00) +
                    (uint8[i + 2] & 0xFF)
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }

        function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(
                    uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
                ))
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                parts.push(
                    lookup[tmp >> 2] +
                    lookup[(tmp << 4) & 0x3F] +
                    '=='
                )
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1]
                parts.push(
                    lookup[tmp >> 10] +
                    lookup[(tmp >> 4) & 0x3F] +
                    lookup[(tmp << 2) & 0x3F] +
                    '='
                )
            }

            return parts.join('')
        }

    }, {}],
    2: [function (require, module, exports) {

    }, {}],
    3: [function (require, module, exports) {
        (function (Buffer) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
            /* eslint-disable no-proto */

            'use strict'

            var base64 = require('base64-js')
            var ieee754 = require('ieee754')
            var customInspectSymbol =
                (typeof Symbol === 'function' && typeof Symbol.for === 'function')
                    ? Symbol.for('nodejs.util.inspect.custom')
                    : null

            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50

            var K_MAX_LENGTH = 0x7fffffff
            exports.kMaxLength = K_MAX_LENGTH

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Print warning and recommend using `buffer` v4.x which has an Object
             *               implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * We report that the browser does not support typed arrays if the are not subclassable
             * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
             * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
             * for __proto__ and has a buggy typed array implementation.
             */
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
                typeof console.error === 'function') {
                console.error(
                    'This browser lacks typed array (Uint8Array) support which is required by ' +
                    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
                )
            }

            function typedArraySupport() {
                // Can typed array instances can be augmented?
                try {
                    var arr = new Uint8Array(1)
                    var proto = {
                        foo: function () {
                            return 42
                        }
                    }
                    Object.setPrototypeOf(proto, Uint8Array.prototype)
                    Object.setPrototypeOf(arr, proto)
                    return arr.foo() === 42
                } catch (e) {
                    return false
                }
            }

            Object.defineProperty(Buffer.prototype, 'parent', {
                enumerable: true,
                get: function () {
                    if (!Buffer.isBuffer(this)) return undefined
                    return this.buffer
                }
            })

            Object.defineProperty(Buffer.prototype, 'offset', {
                enumerable: true,
                get: function () {
                    if (!Buffer.isBuffer(this)) return undefined
                    return this.byteOffset
                }
            })

            function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"')
                }
                // Return an augmented `Uint8Array` instance
                var buf = new Uint8Array(length)
                Object.setPrototypeOf(buf, Buffer.prototype)
                return buf
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer(arg, encodingOrOffset, length) {
                // Common case.
                if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') {
                        throw new TypeError(
                            'The "string" argument must be of type string. Received type number'
                        )
                    }
                    return allocUnsafe(arg)
                }
                return from(arg, encodingOrOffset, length)
            }

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            if (typeof Symbol !== 'undefined' && Symbol.species != null &&
                Buffer[Symbol.species] === Buffer) {
                Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: true,
                    enumerable: false,
                    writable: false
                })
            }

            Buffer.poolSize = 8192 // not used by this implementation

            function from(value, encodingOrOffset, length) {
                if (typeof value === 'string') {
                    return fromString(value, encodingOrOffset)
                }

                if (ArrayBuffer.isView(value)) {
                    return fromArrayLike(value)
                }

                if (value == null) {
                    throw new TypeError(
                        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                        'or Array-like Object. Received type ' + (typeof value)
                    )
                }

                if (isInstance(value, ArrayBuffer) ||
                    (value && isInstance(value.buffer, ArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length)
                }

                if (typeof SharedArrayBuffer !== 'undefined' &&
                    (isInstance(value, SharedArrayBuffer) ||
                        (value && isInstance(value.buffer, SharedArrayBuffer)))) {
                    return fromArrayBuffer(value, encodingOrOffset, length)
                }

                if (typeof value === 'number') {
                    throw new TypeError(
                        'The "value" argument must not be of type number. Received type number'
                    )
                }

                var valueOf = value.valueOf && value.valueOf()
                if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length)
                }

                var b = fromObject(value)
                if (b) return b

                if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
                    typeof value[Symbol.toPrimitive] === 'function') {
                    return Buffer.from(
                        value[Symbol.toPrimitive]('string'), encodingOrOffset, length
                    )
                }

                throw new TypeError(
                    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                    'or Array-like Object. Received type ' + (typeof value)
                )
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length)
            }

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
            Object.setPrototypeOf(Buffer, Uint8Array)

            function assertSize(size) {
                if (typeof size !== 'number') {
                    throw new TypeError('"size" argument must be of type number')
                } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"')
                }
            }

            function alloc(size, fill, encoding) {
                assertSize(size)
                if (size <= 0) {
                    return createBuffer(size)
                }
                if (fill !== undefined) {
                    // Only pay attention to encoding if it's a string. This
                    // prevents accidentally sending in a number that would
                    // be interpretted as a start offset.
                    return typeof encoding === 'string'
                        ? createBuffer(size).fill(fill, encoding)
                        : createBuffer(size).fill(fill)
                }
                return createBuffer(size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
                return alloc(size, fill, encoding)
            }

            function allocUnsafe(size) {
                assertSize(size)
                return createBuffer(size < 0 ? 0 : checked(size) | 0)
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
                return allocUnsafe(size)
            }
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(size)
            }

            function fromString(string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') {
                    encoding = 'utf8'
                }

                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('Unknown encoding: ' + encoding)
                }

                var length = byteLength(string, encoding) | 0
                var buf = createBuffer(length)

                var actual = buf.write(string, encoding)

                if (actual !== length) {
                    // Writing a hex string, for example, that contains invalid characters will
                    // cause everything after the first invalid character to be ignored. (e.g.
                    // 'abxxcd' will be treated as 'ab')
                    buf = buf.slice(0, actual)
                }

                return buf
            }

            function fromArrayLike(array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0
                var buf = createBuffer(length)
                for (var i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255
                }
                return buf
            }

            function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds')
                }

                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds')
                }

                var buf
                if (byteOffset === undefined && length === undefined) {
                    buf = new Uint8Array(array)
                } else if (length === undefined) {
                    buf = new Uint8Array(array, byteOffset)
                } else {
                    buf = new Uint8Array(array, byteOffset, length)
                }

                // Return an augmented `Uint8Array` instance
                Object.setPrototypeOf(buf, Buffer.prototype)

                return buf
            }

            function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0
                    var buf = createBuffer(len)

                    if (buf.length === 0) {
                        return buf
                    }

                    obj.copy(buf, 0, 0, len)
                    return buf
                }

                if (obj.length !== undefined) {
                    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                        return createBuffer(0)
                    }
                    return fromArrayLike(obj)
                }

                if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data)
                }
            }

            function checked(length) {
                // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= K_MAX_LENGTH) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
                }
                return length | 0
            }

            function SlowBuffer(length) {
                if (+length != length) { // eslint-disable-line eqeqeq
                    length = 0
                }
                return Buffer.alloc(+length)
            }

            Buffer.isBuffer = function isBuffer(b) {
                return b != null && b._isBuffer === true &&
                    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
            }

            Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
                if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError(
                        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                    )
                }

                if (a === b) return 0

                var x = a.length
                var y = b.length

                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i]
                        y = b[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true
                    default:
                        return false
                }
            }

            Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers')
                }

                if (list.length === 0) {
                    return Buffer.alloc(0)
                }

                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; ++i) {
                        length += list[i].length
                    }
                }

                var buffer = Buffer.allocUnsafe(length)
                var pos = 0
                for (i = 0; i < list.length; ++i) {
                    var buf = list[i]
                    if (isInstance(buf, Uint8Array)) {
                        buf = Buffer.from(buf)
                    }
                    if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers')
                    }
                    buf.copy(buffer, pos)
                    pos += buf.length
                }
                return buffer
            }

            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length
                }
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength
                }
                if (typeof string !== 'string') {
                    throw new TypeError(
                        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                        'Received type ' + typeof string
                    )
                }

                var len = string.length
                var mustMatch = (arguments.length > 2 && arguments[2] === true)
                if (!mustMatch && len === 0) return 0

                // Use a for loop to avoid recursion
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                            return len
                        case 'utf8':
                        case 'utf-8':
                            return utf8ToBytes(string).length
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return len * 2
                        case 'hex':
                            return len >>> 1
                        case 'base64':
                            return base64ToBytes(string).length
                        default:
                            if (loweredCase) {
                                return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                            }
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }

            Buffer.byteLength = byteLength

            function slowToString(encoding, start, end) {
                var loweredCase = false

                // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.

                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                    start = 0
                }
                // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                    return ''
                }

                if (end === undefined || end > this.length) {
                    end = this.length
                }

                if (end <= 0) {
                    return ''
                }

                // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0
                start >>>= 0

                if (end <= start) {
                    return ''
                }

                if (!encoding) encoding = 'utf8'

                while (true) {
                    switch (encoding) {
                        case 'hex':
                            return hexSlice(this, start, end)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end)

                        case 'ascii':
                            return asciiSlice(this, start, end)

                        case 'latin1':
                        case 'binary':
                            return latin1Slice(this, start, end)

                        case 'base64':
                            return base64Slice(this, start, end)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
            Buffer.prototype._isBuffer = true

            function swap(b, n, m) {
                var i = b[n]
                b[n] = b[m]
                b[m] = i
            }

            Buffer.prototype.swap16 = function swap16() {
                var len = this.length
                if (len % 2 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 16-bits')
                }
                for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1)
                }
                return this
            }

            Buffer.prototype.swap32 = function swap32() {
                var len = this.length
                if (len % 4 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 32-bits')
                }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3)
                    swap(this, i + 1, i + 2)
                }
                return this
            }

            Buffer.prototype.swap64 = function swap64() {
                var len = this.length
                if (len % 8 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 64-bits')
                }
                for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7)
                    swap(this, i + 1, i + 6)
                    swap(this, i + 2, i + 5)
                    swap(this, i + 3, i + 4)
                }
                return this
            }

            Buffer.prototype.toString = function toString() {
                var length = this.length
                if (length === 0) return ''
                if (arguments.length === 0) return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
            }

            Buffer.prototype.toLocaleString = Buffer.prototype.toString

            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
            }

            Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
                if (this.length > max) str += ' ... '
                return '<Buffer ' + str + '>'
            }
            if (customInspectSymbol) {
                Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
            }

            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength)
                }
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError(
                        'The "target" argument must be one of type Buffer or Uint8Array. ' +
                        'Received type ' + (typeof target)
                    )
                }

                if (start === undefined) {
                    start = 0
                }
                if (end === undefined) {
                    end = target ? target.length : 0
                }
                if (thisStart === undefined) {
                    thisStart = 0
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length
                }

                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError('out of range index')
                }

                if (thisStart >= thisEnd && start >= end) {
                    return 0
                }
                if (thisStart >= thisEnd) {
                    return -1
                }
                if (start >= end) {
                    return 1
                }

                start >>>= 0
                end >>>= 0
                thisStart >>>= 0
                thisEnd >>>= 0

                if (this === target) return 0

                var x = thisEnd - thisStart
                var y = end - start
                var len = Math.min(x, y)

                var thisCopy = this.slice(thisStart, thisEnd)
                var targetCopy = target.slice(start, end)

                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i]
                        y = targetCopy[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                // Empty buffer means no match
                if (buffer.length === 0) return -1

                // Normalize byteOffset
                if (typeof byteOffset === 'string') {
                    encoding = byteOffset
                    byteOffset = 0
                } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff
                } else if (byteOffset < -0x80000000) {
                    byteOffset = -0x80000000
                }
                byteOffset = +byteOffset // Coerce to Number.
                if (numberIsNaN(byteOffset)) {
                    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                    byteOffset = dir ? 0 : (buffer.length - 1)
                }

                // Normalize byteOffset: negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                if (byteOffset >= buffer.length) {
                    if (dir) return -1
                    else byteOffset = buffer.length - 1
                } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0
                    else return -1
                }

                // Normalize val
                if (typeof val === 'string') {
                    val = Buffer.from(val, encoding)
                }

                // Finally, search either indexOf (if dir is true) or lastIndexOf
                if (Buffer.isBuffer(val)) {
                    // Special case: looking for empty string/buffer always fails
                    if (val.length === 0) {
                        return -1
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                } else if (typeof val === 'number') {
                    val = val & 0xFF // Search for a byte value [0-255]
                    if (typeof Uint8Array.prototype.indexOf === 'function') {
                        if (dir) {
                            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                        }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                }

                throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1
                var arrLength = arr.length
                var valLength = val.length

                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase()
                    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                        encoding === 'utf16le' || encoding === 'utf-16le') {
                        if (arr.length < 2 || val.length < 2) {
                            return -1
                        }
                        indexSize = 2
                        arrLength /= 2
                        valLength /= 2
                        byteOffset /= 2
                    }
                }

                function read(buf, i) {
                    if (indexSize === 1) {
                        return buf[i]
                    } else {
                        return buf.readUInt16BE(i * indexSize)
                    }
                }

                var i
                if (dir) {
                    var foundIndex = -1
                    for (i = byteOffset; i < arrLength; i++) {
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1) foundIndex = i
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                        } else {
                            if (foundIndex !== -1) i -= i - foundIndex
                            foundIndex = -1
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                    for (i = byteOffset; i >= 0; i--) {
                        var found = true
                        for (var j = 0; j < valLength; j++) {
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false
                                break
                            }
                        }
                        if (found) return i
                    }
                }

                return -1
            }

            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1
            }

            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            }

            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            }

            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                    length = remaining
                } else {
                    length = Number(length)
                    if (length > remaining) {
                        length = remaining
                    }
                }

                var strLen = string.length

                if (length > strLen / 2) {
                    length = strLen / 2
                }
                for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (numberIsNaN(parsed)) return i
                    buf[offset + i] = parsed
                }
                return i
            }

            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }

            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write(string, offset, length, encoding) {
                // Buffer#write(string)
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                    // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                    // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                    offset = offset >>> 0
                    if (isFinite(length)) {
                        length = length >>> 0
                        if (encoding === undefined) encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
                } else {
                    throw new Error(
                        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                    )
                }

                var remaining = this.length - offset
                if (length === undefined || length > remaining) length = remaining

                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('Attempt to write outside buffer bounds')
                }

                if (!encoding) encoding = 'utf8'

                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'hex':
                            return hexWrite(this, string, offset, length)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length)

                        case 'ascii':
                            return asciiWrite(this, string, offset, length)

                        case 'latin1':
                        case 'binary':
                            return latin1Write(this, string, offset, length)

                        case 'base64':
                            // Warning: maxLength not taken into account in base64Write
                            return base64Write(this, string, offset, length)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }

            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }

            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                } else {
                    return base64.fromByteArray(buf.slice(start, end))
                }
            }

            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []

                var i = start
                while (i < end) {
                    var firstByte = buf[i]
                    var codePoint = null
                    var bytesPerSequence = (firstByte > 0xEF) ? 4
                        : (firstByte > 0xDF) ? 3
                            : (firstByte > 0xBF) ? 2
                                : 1

                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint

                        switch (bytesPerSequence) {
                            case 1:
                                if (firstByte < 0x80) {
                                    codePoint = firstByte
                                }
                                break
                            case 2:
                                secondByte = buf[i + 1]
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                    if (tempCodePoint > 0x7F) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 3:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 4:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                fourthByte = buf[i + 3]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                        codePoint = tempCodePoint
                                    }
                                }
                        }
                    }

                    if (codePoint === null) {
                        // we did not generate a valid codePoint so insert a
                        // replacement char (U+FFFD) and advance only 1 byte
                        codePoint = 0xFFFD
                        bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                        // encode to utf16 (surrogate pair dance)
                        codePoint -= 0x10000
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                        codePoint = 0xDC00 | codePoint & 0x3FF
                    }

                    res.push(codePoint)
                    i += bytesPerSequence
                }

                return decodeCodePointsArray(res)
            }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000

            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                }

                // Decode in chunks to avoid "call stack size exceeded".
                var res = ''
                var i = 0
                while (i < len) {
                    res += String.fromCharCode.apply(
                        String,
                        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                    )
                }
                return res
            }

            function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                }
                return ret
            }

            function latin1Slice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i])
                }
                return ret
            }

            function hexSlice(buf, start, end) {
                var len = buf.length

                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len

                var out = ''
                for (var i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]]
                }
                return out
            }

            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
                }
                return res
            }

            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end

                if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                } else if (start > len) {
                    start = len
                }

                if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                } else if (end > len) {
                    end = len
                }

                if (end < start) end = start

                var newBuf = this.subarray(start, end)
                // Return an augmented `Uint8Array` instance
                Object.setPrototypeOf(newBuf, Buffer.prototype)

                return newBuf
            }

            /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
            function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }

                return val
            }

            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                }

                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                }

                return val
            }

            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
            }

            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }

            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }

            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return ((this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                    (this[offset + 3] * 0x1000000)
            }

            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) |
                        (this[offset + 2] << 8) |
                        this[offset + 3])
            }

            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }

            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16) |
                    (this[offset + 3] << 24)
            }

            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] << 24) |
                    (this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    (this[offset + 3])
            }

            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }

            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }

            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }

            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }

            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                this[offset] = (value & 0xff)
                return offset + 1
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
                return offset + 2
            }

            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
                return offset + 2
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                this[offset + 3] = (value >>> 24)
                this[offset + 2] = (value >>> 16)
                this[offset + 1] = (value >>> 8)
                this[offset] = (value & 0xff)
                return offset + 4
            }

            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
                return offset + 4
            }

            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                    var limit = Math.pow(2, (8 * byteLength) - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = 0
                var mul = 1
                var sub = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                    var limit = Math.pow(2, (8 * byteLength) - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = byteLength - 1
                var mul = 1
                var sub = 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (value < 0) value = 0xff + value + 1
                this[offset] = (value & 0xff)
                return offset + 1
            }

            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
                return offset + 2
            }

            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
                return offset + 2
            }

            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
                this[offset + 2] = (value >>> 16)
                this[offset + 3] = (value >>> 24)
                return offset + 4
            }

            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
                return offset + 4
            }

            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
                if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert)
            }

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert)
            }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start

                // Copy 0 bytes; we're done
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0

                // Fatal error conditions
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')

                // Are we oob?
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                }

                var len = end - start

                if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                    // Use built-in when available, missing from IE11
                    this.copyWithin(targetStart, start, end)
                } else if (this === target && start < targetStart && targetStart < end) {
                    // descending copy from end
                    for (var i = len - 1; i >= 0; --i) {
                        target[i + targetStart] = this[i + start]
                    }
                } else {
                    Uint8Array.prototype.set.call(
                        target,
                        this.subarray(start, end),
                        targetStart
                    )
                }

                return len
            }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === 'string') {
                    if (typeof start === 'string') {
                        encoding = start
                        start = 0
                        end = this.length
                    } else if (typeof end === 'string') {
                        encoding = end
                        end = this.length
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') {
                        throw new TypeError('encoding must be a string')
                    }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                        throw new TypeError('Unknown encoding: ' + encoding)
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0)
                        if ((encoding === 'utf8' && code < 128) ||
                            encoding === 'latin1') {
                            // Fast path: If `val` fits into a single byte, use that numeric value.
                            val = code
                        }
                    }
                } else if (typeof val === 'number') {
                    val = val & 255
                } else if (typeof val === 'boolean') {
                    val = Number(val)
                }

                // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError('Out of range index')
                }

                if (end <= start) {
                    return this
                }

                start = start >>> 0
                end = end === undefined ? this.length : end >>> 0

                if (!val) val = 0

                var i
                if (typeof val === 'number') {
                    for (i = start; i < end; ++i) {
                        this[i] = val
                    }
                } else {
                    var bytes = Buffer.isBuffer(val)
                        ? val
                        : Buffer.from(val, encoding)
                    var len = bytes.length
                    if (len === 0) {
                        throw new TypeError('The value "' + val +
                            '" is invalid for argument "value"')
                    }
                    for (i = 0; i < end - start; ++i) {
                        this[i + start] = bytes[i % len]
                    }
                }

                return this
            }

// HELPER FUNCTIONS
// ================

            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

            function base64clean(str) {
                // Node takes equal signs as end of the Base64 encoding
                str = str.split('=')[0]
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = str.trim().replace(INVALID_BASE64_RE, '')
                // Node converts strings with length < 2 to ''
                if (str.length < 2) return ''
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                    str = str + '='
                }
                return str
            }

            function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []

                for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i)

                    // is surrogate component
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        // last char was a lead
                        if (!leadSurrogate) {
                            // no lead yet
                            if (codePoint > 0xDBFF) {
                                // unexpected trail
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                // unpaired lead
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            }

                            // valid lead
                            leadSurrogate = codePoint

                            continue
                        }

                        // 2 leads in a row
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            leadSurrogate = codePoint
                            continue
                        }

                        // valid surrogate pair
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) {
                        // valid bmp char, but last char was a lead
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    }

                    leadSurrogate = null

                    // encode utf8
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break
                        bytes.push(
                            codePoint >> 0x6 | 0xC0,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break
                        bytes.push(
                            codePoint >> 0xC | 0xE0,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break
                        bytes.push(
                            codePoint >> 0x12 | 0xF0,
                            codePoint >> 0xC & 0x3F | 0x80,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else {
                        throw new Error('Invalid code point')
                    }
                }

                return bytes
            }

            function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                }
                return byteArray
            }

            function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0) break

                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }

                return byteArray
            }

            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
            }

            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                }
                return i
            }

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
            function isInstance(obj, type) {
                return obj instanceof type ||
                    (obj != null && obj.constructor != null && obj.constructor.name != null &&
                        obj.constructor.name === type.name)
            }

            function numberIsNaN(obj) {
                // For IE11 support
                return obj !== obj // eslint-disable-line no-self-compare
            }

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
            var hexSliceLookupTable = (function () {
                var alphabet = '0123456789abcdef'
                var table = new Array(256)
                for (var i = 0; i < 16; ++i) {
                    var i16 = i * 16
                    for (var j = 0; j < 16; ++j) {
                        table[i16 + j] = alphabet[i] + alphabet[j]
                    }
                }
                return table
            })()

        }).call(this, require("buffer").Buffer)

    }, {"base64-js": 1, "buffer": 3, "ieee754": 6}],
    4: [function (require, module, exports) {
        (function (Buffer) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

            function isArray(arg) {
                if (Array.isArray) {
                    return Array.isArray(arg);
                }
                return objectToString(arg) === '[object Array]';
            }

            exports.isArray = isArray;

            function isBoolean(arg) {
                return typeof arg === 'boolean';
            }

            exports.isBoolean = isBoolean;

            function isNull(arg) {
                return arg === null;
            }

            exports.isNull = isNull;

            function isNullOrUndefined(arg) {
                return arg == null;
            }

            exports.isNullOrUndefined = isNullOrUndefined;

            function isNumber(arg) {
                return typeof arg === 'number';
            }

            exports.isNumber = isNumber;

            function isString(arg) {
                return typeof arg === 'string';
            }

            exports.isString = isString;

            function isSymbol(arg) {
                return typeof arg === 'symbol';
            }

            exports.isSymbol = isSymbol;

            function isUndefined(arg) {
                return arg === void 0;
            }

            exports.isUndefined = isUndefined;

            function isRegExp(re) {
                return objectToString(re) === '[object RegExp]';
            }

            exports.isRegExp = isRegExp;

            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }

            exports.isObject = isObject;

            function isDate(d) {
                return objectToString(d) === '[object Date]';
            }

            exports.isDate = isDate;

            function isError(e) {
                return (objectToString(e) === '[object Error]' || e instanceof Error);
            }

            exports.isError = isError;

            function isFunction(arg) {
                return typeof arg === 'function';
            }

            exports.isFunction = isFunction;

            function isPrimitive(arg) {
                return arg === null ||
                    typeof arg === 'boolean' ||
                    typeof arg === 'number' ||
                    typeof arg === 'string' ||
                    typeof arg === 'symbol' ||  // ES6 symbol
                    typeof arg === 'undefined';
            }

            exports.isPrimitive = isPrimitive;

            exports.isBuffer = Buffer.isBuffer;

            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }

        }).call(this, {"isBuffer": require("../../is-buffer/index.js")})

    }, {"../../is-buffer/index.js": 8}],
    5: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill
        var objectKeys = Object.keys || objectKeysPolyfill
        var bind = Function.prototype.bind || functionBindPolyfill

        function EventEmitter() {
            if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
                this._events = objectCreate(null);
                this._eventsCount = 0;
            }

            this._maxListeners = this._maxListeners || undefined;
        }

        module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10;

        var hasDefineProperty;
        try {
            var o = {};
            if (Object.defineProperty) Object.defineProperty(o, 'x', {value: 0});
            hasDefineProperty = o.x === 0;
        } catch (err) {
            hasDefineProperty = false
        }
        if (hasDefineProperty) {
            Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
                enumerable: true,
                get: function () {
                    return defaultMaxListeners;
                },
                set: function (arg) {
                    // check whether the input is a positive number (whose value is zero or
                    // greater and not a NaN).
                    if (typeof arg !== 'number' || arg < 0 || arg !== arg)
                        throw new TypeError('"defaultMaxListeners" must be a positive number');
                    defaultMaxListeners = arg;
                }
            });
        } else {
            EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || isNaN(n))
                throw new TypeError('"n" argument must be a positive number');
            this._maxListeners = n;
            return this;
        };

        function $getMaxListeners(that) {
            if (that._maxListeners === undefined)
                return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return $getMaxListeners(this);
        };

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
        function emitNone(handler, isFn, self) {
            if (isFn)
                handler.call(self);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                    listeners[i].call(self);
            }
        }

        function emitOne(handler, isFn, self, arg1) {
            if (isFn)
                handler.call(self, arg1);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                    listeners[i].call(self, arg1);
            }
        }

        function emitTwo(handler, isFn, self, arg1, arg2) {
            if (isFn)
                handler.call(self, arg1, arg2);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                    listeners[i].call(self, arg1, arg2);
            }
        }

        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
            if (isFn)
                handler.call(self, arg1, arg2, arg3);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                    listeners[i].call(self, arg1, arg2, arg3);
            }
        }

        function emitMany(handler, isFn, self, args) {
            if (isFn)
                handler.apply(self, args);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                    listeners[i].apply(self, args);
            }
        }

        EventEmitter.prototype.emit = function emit(type) {
            var er, handler, len, args, i, events;
            var doError = (type === 'error');

            events = this._events;
            if (events)
                doError = (doError && events.error == null);
            else if (!doError)
                return false;

            // If there is no 'error' event listener then throw.
            if (doError) {
                if (arguments.length > 1)
                    er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                } else {
                    // At least give some kind of context to the user
                    var err = new Error('Unhandled "error" event. (' + er + ')');
                    err.context = er;
                    throw err;
                }
                return false;
            }

            handler = events[type];

            if (!handler)
                return false;

            var isFn = typeof handler === 'function';
            len = arguments.length;
            switch (len) {
                // fast cases
                case 1:
                    emitNone(handler, isFn, this);
                    break;
                case 2:
                    emitOne(handler, isFn, this, arguments[1]);
                    break;
                case 3:
                    emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                    break;
                case 4:
                    emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                    break;
                // slower
                default:
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    emitMany(handler, isFn, this, args);
            }

            return true;
        };

        function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;

            if (typeof listener !== 'function')
                throw new TypeError('"listener" argument must be a function');

            events = target._events;
            if (!events) {
                events = target._events = objectCreate(null);
                target._eventsCount = 0;
            } else {
                // To avoid recursion in the case that type === "newListener"! Before
                // adding it to the listeners, first emit "newListener".
                if (events.newListener) {
                    target.emit('newListener', type,
                        listener.listener ? listener.listener : listener);

                    // Re-assign `events` because a newListener handler could have caused the
                    // this._events to be assigned to a new object
                    events = target._events;
                }
                existing = events[type];
            }

            if (!existing) {
                // Optimize the case of one listener. Don't need the extra array object.
                existing = events[type] = listener;
                ++target._eventsCount;
            } else {
                if (typeof existing === 'function') {
                    // Adding the second element, need to change to array.
                    existing = events[type] =
                        prepend ? [listener, existing] : [existing, listener];
                } else {
                    // If we've already got an array, just append.
                    if (prepend) {
                        existing.unshift(listener);
                    } else {
                        existing.push(listener);
                    }
                }

                // Check for listener leak
                if (!existing.warned) {
                    m = $getMaxListeners(target);
                    if (m && m > 0 && existing.length > m) {
                        existing.warned = true;
                        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' "' + String(type) + '" listeners ' +
                            'added. Use emitter.setMaxListeners() to ' +
                            'increase limit.');
                        w.name = 'MaxListenersExceededWarning';
                        w.emitter = target;
                        w.type = type;
                        w.count = existing.length;
                        if (typeof console === 'object' && console.warn) {
                            console.warn('%s: %s', w.name, w.message);
                        }
                    }
                }
            }

            return target;
        }

        EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.prependListener =
            function prependListener(type, listener) {
                return _addListener(this, type, listener, true);
            };

        function onceWrapper() {
            if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                switch (arguments.length) {
                    case 0:
                        return this.listener.call(this.target);
                    case 1:
                        return this.listener.call(this.target, arguments[0]);
                    case 2:
                        return this.listener.call(this.target, arguments[0], arguments[1]);
                    case 3:
                        return this.listener.call(this.target, arguments[0], arguments[1],
                            arguments[2]);
                    default:
                        var args = new Array(arguments.length);
                        for (var i = 0; i < args.length; ++i)
                            args[i] = arguments[i];
                        this.listener.apply(this.target, args);
                }
            }
        }

        function _onceWrap(target, type, listener) {
            var state = {fired: false, wrapFn: undefined, target: target, type: type, listener: listener};
            var wrapped = bind.call(onceWrapper, state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
        }

        EventEmitter.prototype.once = function once(type, listener) {
            if (typeof listener !== 'function')
                throw new TypeError('"listener" argument must be a function');
            this.on(type, _onceWrap(this, type, listener));
            return this;
        };

        EventEmitter.prototype.prependOnceListener =
            function prependOnceListener(type, listener) {
                if (typeof listener !== 'function')
                    throw new TypeError('"listener" argument must be a function');
                this.prependListener(type, _onceWrap(this, type, listener));
                return this;
            };

// Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener =
            function removeListener(type, listener) {
                var list, events, position, i, originalListener;

                if (typeof listener !== 'function')
                    throw new TypeError('"listener" argument must be a function');

                events = this._events;
                if (!events)
                    return this;

                list = events[type];
                if (!list)
                    return this;

                if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                        this._events = objectCreate(null);
                    else {
                        delete events[type];
                        if (events.removeListener)
                            this.emit('removeListener', type, list.listener || listener);
                    }
                } else if (typeof list !== 'function') {
                    position = -1;

                    for (i = list.length - 1; i >= 0; i--) {
                        if (list[i] === listener || list[i].listener === listener) {
                            originalListener = list[i].listener;
                            position = i;
                            break;
                        }
                    }

                    if (position < 0)
                        return this;

                    if (position === 0)
                        list.shift();
                    else
                        spliceOne(list, position);

                    if (list.length === 1)
                        events[type] = list[0];

                    if (events.removeListener)
                        this.emit('removeListener', type, originalListener || listener);
                }

                return this;
            };

        EventEmitter.prototype.removeAllListeners =
            function removeAllListeners(type) {
                var listeners, events, i;

                events = this._events;
                if (!events)
                    return this;

                // not listening for removeListener, no need to emit
                if (!events.removeListener) {
                    if (arguments.length === 0) {
                        this._events = objectCreate(null);
                        this._eventsCount = 0;
                    } else if (events[type]) {
                        if (--this._eventsCount === 0)
                            this._events = objectCreate(null);
                        else
                            delete events[type];
                    }
                    return this;
                }

                // emit removeListener for all listeners on all events
                if (arguments.length === 0) {
                    var keys = objectKeys(events);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                        key = keys[i];
                        if (key === 'removeListener') continue;
                        this.removeAllListeners(key);
                    }
                    this.removeAllListeners('removeListener');
                    this._events = objectCreate(null);
                    this._eventsCount = 0;
                    return this;
                }

                listeners = events[type];

                if (typeof listeners === 'function') {
                    this.removeListener(type, listeners);
                } else if (listeners) {
                    // LIFO order
                    for (i = listeners.length - 1; i >= 0; i--) {
                        this.removeListener(type, listeners[i]);
                    }
                }

                return this;
            };

        function _listeners(target, type, unwrap) {
            var events = target._events;

            if (!events)
                return [];

            var evlistener = events[type];
            if (!evlistener)
                return [];

            if (typeof evlistener === 'function')
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];

            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }

        EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
        };

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
        };

        EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
                return emitter.listenerCount(type);
            } else {
                return listenerCount.call(emitter, type);
            }
        };

        EventEmitter.prototype.listenerCount = listenerCount;

        function listenerCount(type) {
            var events = this._events;

            if (events) {
                var evlistener = events[type];

                if (typeof evlistener === 'function') {
                    return 1;
                } else if (evlistener) {
                    return evlistener.length;
                }
            }

            return 0;
        }

        EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };

// About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
                list[i] = list[k];
            list.pop();
        }

        function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
            return copy;
        }

        function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
            }
            return ret;
        }

        function objectCreatePolyfill(proto) {
            var F = function () {
            };
            F.prototype = proto;
            return new F;
        }

        function objectKeysPolyfill(obj) {
            var keys = [];
            for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
            }
            return k;
        }

        function functionBindPolyfill(context) {
            var fn = this;
            return function () {
                return fn.apply(context, arguments);
            };
        }

    }, {}],
    6: [function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = (nBytes * 8) - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {
            }

            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {
            }

            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
            } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = (nBytes * 8) - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * Math.pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }

                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = ((value * c) - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {
            }

            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {
            }

            buffer[offset + i - d] |= s * 128
        }

    }, {}],
    7: [function (require, module, exports) {
        if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    })
                }
            };
        } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor
                    var TempCtor = function () {
                    }
                    TempCtor.prototype = superCtor.prototype
                    ctor.prototype = new TempCtor()
                    ctor.prototype.constructor = ctor
                }
            }
        }

    }, {}],
    8: [function (require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
        }

        function isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
        }

// For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
        }

    }, {}],
    9: [function (require, module, exports) {
        var toString = {}.toString;

        module.exports = Array.isArray || function (arr) {
            return toString.call(arr) == '[object Array]';
        };

    }, {}],
    10: [function (require, module, exports) {
        (function (process) {
            'use strict';

            if (typeof process === 'undefined' ||
                !process.version ||
                process.version.indexOf('v0.') === 0 ||
                process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
                module.exports = {nextTick: nextTick};
            } else {
                module.exports = process
            }

            function nextTick(fn, arg1, arg2, arg3) {
                if (typeof fn !== 'function') {
                    throw new TypeError('"callback" argument must be a function');
                }
                var len = arguments.length;
                var args, i;
                switch (len) {
                    case 0:
                    case 1:
                        return process.nextTick(fn);
                    case 2:
                        return process.nextTick(function afterTickOne() {
                            fn.call(null, arg1);
                        });
                    case 3:
                        return process.nextTick(function afterTickTwo() {
                            fn.call(null, arg1, arg2);
                        });
                    case 4:
                        return process.nextTick(function afterTickThree() {
                            fn.call(null, arg1, arg2, arg3);
                        });
                    default:
                        args = new Array(len - 1);
                        i = 0;
                        while (i < args.length) {
                            args[i++] = arguments[i];
                        }
                        return process.nextTick(function afterTick() {
                            fn.apply(null, args);
                        });
                }
            }


        }).call(this, require('_process'))

    }, {"_process": 11}],
    11: [function (require, module, exports) {
// shim for using process in browser
        var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }

        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }

        (function () {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }())

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }


        }

        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

// v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }

        Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {
        }

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
            return []
        }

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
            return '/'
        };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
            return 0;
        };

    }, {}],
    12: [function (require, module, exports) {
        module.exports = require('./lib/_stream_duplex.js');

    }, {"./lib/_stream_duplex.js": 13}],
    13: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

        'use strict';

        /*<replacement>*/

        var pna = require('process-nextick-args');
        /*</replacement>*/

        /*<replacement>*/
        var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
                keys.push(key);
            }
            return keys;
        };
        /*</replacement>*/

        module.exports = Duplex;

        /*<replacement>*/
        var util = Object.create(require('core-util-is'));
        util.inherits = require('inherits');
        /*</replacement>*/

        var Readable = require('./_stream_readable');
        var Writable = require('./_stream_writable');

        util.inherits(Duplex, Readable);

        {
            // avoid scope creep, the keys array can then be collected
            var keys = objectKeys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
            }
        }

        function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options);

            Readable.call(this, options);
            Writable.call(this, options);

            if (options && options.readable === false) this.readable = false;

            if (options && options.writable === false) this.writable = false;

            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

            this.once('end', onend);
        }

        Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
                return this._writableState.highWaterMark;
            }
        });

// the no-half-open enforcer
        function onend() {
            // if we allow half-open state, or if the writable side ended,
            // then we're ok.
            if (this.allowHalfOpen || this._writableState.ended) return;

            // no more data can be written.
            // But allow more writes to happen in this tick.
            pna.nextTick(onEndNT, this);
        }

        function onEndNT(self) {
            self.end();
        }

        Object.defineProperty(Duplex.prototype, 'destroyed', {
            get: function () {
                if (this._readableState === undefined || this._writableState === undefined) {
                    return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function (value) {
                // we ignore the value if the stream
                // has not been initialized yet
                if (this._readableState === undefined || this._writableState === undefined) {
                    return;
                }

                // backward compatibility, the user is explicitly
                // managing destroyed
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        });

        Duplex.prototype._destroy = function (err, cb) {
            this.push(null);
            this.end();

            pna.nextTick(cb, err);
        };
    }, {
        "./_stream_readable": 15,
        "./_stream_writable": 17,
        "core-util-is": 4,
        "inherits": 7,
        "process-nextick-args": 10
    }],
    14: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

        'use strict';

        module.exports = PassThrough;

        var Transform = require('./_stream_transform');

        /*<replacement>*/
        var util = Object.create(require('core-util-is'));
        util.inherits = require('inherits');
        /*</replacement>*/

        util.inherits(PassThrough, Transform);

        function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);

            Transform.call(this, options);
        }

        PassThrough.prototype._transform = function (chunk, encoding, cb) {
            cb(null, chunk);
        };
    }, {"./_stream_transform": 16, "core-util-is": 4, "inherits": 7}],
    15: [function (require, module, exports) {
        (function (process, global) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            /*<replacement>*/

            var pna = require('process-nextick-args');
            /*</replacement>*/

            module.exports = Readable;

            /*<replacement>*/
            var isArray = require('isarray');
            /*</replacement>*/

            /*<replacement>*/
            var Duplex;
            /*</replacement>*/

            Readable.ReadableState = ReadableState;

            /*<replacement>*/
            var EE = require('events').EventEmitter;

            var EElistenerCount = function (emitter, type) {
                return emitter.listeners(type).length;
            };
            /*</replacement>*/

            /*<replacement>*/
            var Stream = require('./internal/streams/stream');
            /*</replacement>*/

            /*<replacement>*/

            var Buffer = require('safe-buffer').Buffer;
            var OurUint8Array = global.Uint8Array || function () {
            };

            function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
            }

            function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }

            /*</replacement>*/

            /*<replacement>*/
            var util = Object.create(require('core-util-is'));
            util.inherits = require('inherits');
            /*</replacement>*/

            /*<replacement>*/
            var debugUtil = require('util');
            var debug = void 0;
            if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog('stream');
            } else {
                debug = function () {
                };
            }
            /*</replacement>*/

            var BufferList = require('./internal/streams/BufferList');
            var destroyImpl = require('./internal/streams/destroy');
            var StringDecoder;

            util.inherits(Readable, Stream);

            var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

            function prependListener(emitter, event, fn) {
                // Sadly this is not cacheable as some libraries bundle their own
                // event emitter implementation with them.
                if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

                // This is a hack to make sure that our error handler is attached before any
                // userland ones.  NEVER DO THIS. This is here only because this code needs
                // to continue to work with older versions of Node.js that do not include
                // the prependListener() method. The goal is to eventually remove this hack.
                if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]];
            }

            function ReadableState(options, stream) {
                Duplex = Duplex || require('./_stream_duplex');

                options = options || {};

                // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream.
                // These options can be provided separately as readableXXX and writableXXX.
                var isDuplex = stream instanceof Duplex;

                // object stream flag. Used to make read(n) ignore n and to
                // make all the buffer merging and length checks go away
                this.objectMode = !!options.objectMode;

                if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

                // the point at which it stops calling _read() to fill the buffer
                // Note: 0 is a valid value, means "don't call _read preemptively ever"
                var hwm = options.highWaterMark;
                var readableHwm = options.readableHighWaterMark;
                var defaultHwm = this.objectMode ? 16 : 16 * 1024;

                if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm;

                // cast to ints.
                this.highWaterMark = Math.floor(this.highWaterMark);

                // A linked list is used to store data chunks instead of an array because the
                // linked list can remove elements from the beginning faster than
                // array.shift()
                this.buffer = new BufferList();
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;

                // a flag to be able to tell if the event 'readable'/'data' is emitted
                // immediately, or on a later tick.  We set this to true at first, because
                // any actions that shouldn't happen until "later" should generally also
                // not happen before the first read call.
                this.sync = true;

                // whenever we return null, then we set a flag to say
                // that we're awaiting a 'readable' event emission.
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.resumeScheduled = false;

                // has it been destroyed
                this.destroyed = false;

                // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || 'utf8';

                // the number of writers that are awaiting a drain event in .pipe()s
                this.awaitDrain = 0;

                // if true, a maybeReadMore has been scheduled
                this.readingMore = false;

                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                }
            }

            function Readable(options) {
                Duplex = Duplex || require('./_stream_duplex');

                if (!(this instanceof Readable)) return new Readable(options);

                this._readableState = new ReadableState(options, this);

                // legacy
                this.readable = true;

                if (options) {
                    if (typeof options.read === 'function') this._read = options.read;

                    if (typeof options.destroy === 'function') this._destroy = options.destroy;
                }

                Stream.call(this);
            }

            Object.defineProperty(Readable.prototype, 'destroyed', {
                get: function () {
                    if (this._readableState === undefined) {
                        return false;
                    }
                    return this._readableState.destroyed;
                },
                set: function (value) {
                    // we ignore the value if the stream
                    // has not been initialized yet
                    if (!this._readableState) {
                        return;
                    }

                    // backward compatibility, the user is explicitly
                    // managing destroyed
                    this._readableState.destroyed = value;
                }
            });

            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function (err, cb) {
                this.push(null);
                cb(err);
            };

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
            Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState;
                var skipChunkCheck;

                if (!state.objectMode) {
                    if (typeof chunk === 'string') {
                        encoding = encoding || state.defaultEncoding;
                        if (encoding !== state.encoding) {
                            chunk = Buffer.from(chunk, encoding);
                            encoding = '';
                        }
                        skipChunkCheck = true;
                    }
                } else {
                    skipChunkCheck = true;
                }

                return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };

// Unshift should *always* be something directly out of read()
            Readable.prototype.unshift = function (chunk) {
                return readableAddChunk(this, chunk, null, true, false);
            };

            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                var state = stream._readableState;
                if (chunk === null) {
                    state.reading = false;
                    onEofChunk(stream, state);
                } else {
                    var er;
                    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                    if (er) {
                        stream.emit('error', er);
                    } else if (state.objectMode || chunk && chunk.length > 0) {
                        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                            chunk = _uint8ArrayToBuffer(chunk);
                        }

                        if (addToFront) {
                            if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event')); else addChunk(stream, state, chunk, true);
                        } else if (state.ended) {
                            stream.emit('error', new Error('stream.push() after EOF'));
                        } else {
                            state.reading = false;
                            if (state.decoder && !encoding) {
                                chunk = state.decoder.write(chunk);
                                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                            } else {
                                addChunk(stream, state, chunk, false);
                            }
                        }
                    } else if (!addToFront) {
                        state.reading = false;
                    }
                }

                return needMoreData(state);
            }

            function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                    stream.emit('data', chunk);
                    stream.read(0);
                } else {
                    // update the buffer info.
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);

                    if (state.needReadable) emitReadable(stream);
                }
                maybeReadMore(stream, state);
            }

            function chunkInvalid(state, chunk) {
                var er;
                if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
                    er = new TypeError('Invalid non-string/buffer chunk');
                }
                return er;
            }

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
            function needMoreData(state) {
                return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }

            Readable.prototype.isPaused = function () {
                return this._readableState.flowing === false;
            };

// backwards compatibility.
            Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
                return this;
            };

// Don't raise the hwm > 8MB
            var MAX_HWM = 0x800000;

            function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) {
                    n = MAX_HWM;
                } else {
                    // Get the next highest power of 2 to prevent increasing hwm excessively in
                    // tiny amounts
                    n--;
                    n |= n >>> 1;
                    n |= n >>> 2;
                    n |= n >>> 4;
                    n |= n >>> 8;
                    n |= n >>> 16;
                    n++;
                }
                return n;
            }

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
            function howMuchToRead(n, state) {
                if (n <= 0 || state.length === 0 && state.ended) return 0;
                if (state.objectMode) return 1;
                if (n !== n) {
                    // Only flow one buffer at a time
                    if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
                }
                // If we're asking for more than the current hwm, then raise the hwm.
                if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
                if (n <= state.length) return n;
                // Don't have enough
                if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                }
                return state.length;
            }

// you can override either this method, or the async _read(n) below.
            Readable.prototype.read = function (n) {
                debug('read', n);
                n = parseInt(n, 10);
                var state = this._readableState;
                var nOrig = n;

                if (n !== 0) state.emittedReadable = false;

                // if we're doing read(0) to trigger a readable event, but we
                // already have a bunch of data in the buffer, then just trigger
                // the 'readable' event and move on.
                if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                    debug('read: emitReadable', state.length, state.ended);
                    if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
                    return null;
                }

                n = howMuchToRead(n, state);

                // if we've ended, and we're now clear, then finish it up.
                if (n === 0 && state.ended) {
                    if (state.length === 0) endReadable(this);
                    return null;
                }

                // All the actual chunk generation logic needs to be
                // *below* the call to _read.  The reason is that in certain
                // synthetic stream cases, such as passthrough streams, _read
                // may be a completely synchronous operation which may change
                // the state of the read buffer, providing enough data when
                // before there was *not* enough.
                //
                // So, the steps are:
                // 1. Figure out what the state of things will be after we do
                // a read from the buffer.
                //
                // 2. If that resulting state will trigger a _read, then call _read.
                // Note that this may be asynchronous, or synchronous.  Yes, it is
                // deeply ugly to write APIs this way, but that still doesn't mean
                // that the Readable class should behave improperly, as streams are
                // designed to be sync/async agnostic.
                // Take note if the _read call is sync or async (ie, if the read call
                // has returned yet), so that we know whether or not it's safe to emit
                // 'readable' etc.
                //
                // 3. Actually pull the requested chunks out of the buffer and return.

                // if we need a readable event, then we need to do some reading.
                var doRead = state.needReadable;
                debug('need readable', doRead);

                // if we currently have less than the highWaterMark, then also read some
                if (state.length === 0 || state.length - n < state.highWaterMark) {
                    doRead = true;
                    debug('length less than watermark', doRead);
                }

                // however, if we've ended, then there's no point, and if we're already
                // reading, then it's unnecessary.
                if (state.ended || state.reading) {
                    doRead = false;
                    debug('reading or ended', doRead);
                } else if (doRead) {
                    debug('do read');
                    state.reading = true;
                    state.sync = true;
                    // if the length is currently zero, then we *need* a readable event.
                    if (state.length === 0) state.needReadable = true;
                    // call internal read method
                    this._read(state.highWaterMark);
                    state.sync = false;
                    // If _read pushed data synchronously, then `reading` will be false,
                    // and we need to re-evaluate how much data we can return to the user.
                    if (!state.reading) n = howMuchToRead(nOrig, state);
                }

                var ret;
                if (n > 0) ret = fromList(n, state); else ret = null;

                if (ret === null) {
                    state.needReadable = true;
                    n = 0;
                } else {
                    state.length -= n;
                }

                if (state.length === 0) {
                    // If we have nothing in the buffer, then we want to know
                    // as soon as we *do* get something into the buffer.
                    if (!state.ended) state.needReadable = true;

                    // If we tried to read() past the EOF, then emit end on the next tick.
                    if (nOrig !== n && state.ended) endReadable(this);
                }

                if (ret !== null) this.emit('data', ret);

                return ret;
            };

            function onEofChunk(stream, state) {
                if (state.ended) return;
                if (state.decoder) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                        state.buffer.push(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                    }
                }
                state.ended = true;

                // emit 'readable' now to make sure it gets picked up.
                emitReadable(stream);
            }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = false;
                if (!state.emittedReadable) {
                    debug('emitReadable', state.flowing);
                    state.emittedReadable = true;
                    if (state.sync) pna.nextTick(emitReadable_, stream); else emitReadable_(stream);
                }
            }

            function emitReadable_(stream) {
                debug('emit readable');
                stream.emit('readable');
                flow(stream);
            }

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
            function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                    state.readingMore = true;
                    pna.nextTick(maybeReadMore_, stream, state);
                }
            }

            function maybeReadMore_(stream, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                    debug('maybeReadMore read 0');
                    stream.read(0);
                    if (len === state.length)
                        // didn't get any data, stop spinning.
                        break; else len = state.length;
                }
                state.readingMore = false;
            }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
            Readable.prototype._read = function (n) {
                this.emit('error', new Error('_read() is not implemented'));
            };

            Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this;
                var state = this._readableState;

                switch (state.pipesCount) {
                    case 0:
                        state.pipes = dest;
                        break;
                    case 1:
                        state.pipes = [state.pipes, dest];
                        break;
                    default:
                        state.pipes.push(dest);
                        break;
                }
                state.pipesCount += 1;
                debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

                var endFn = doEnd ? onend : unpipe;
                if (state.endEmitted) pna.nextTick(endFn); else src.once('end', endFn);

                dest.on('unpipe', onunpipe);

                function onunpipe(readable, unpipeInfo) {
                    debug('onunpipe');
                    if (readable === src) {
                        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                            unpipeInfo.hasUnpiped = true;
                            cleanup();
                        }
                    }
                }

                function onend() {
                    debug('onend');
                    dest.end();
                }

                // when the dest drains, it reduces the awaitDrain counter
                // on the source.  This would be more elegant with a .once()
                // handler in flow(), but adding and removing repeatedly is
                // too slow.
                var ondrain = pipeOnDrain(src);
                dest.on('drain', ondrain);

                var cleanedUp = false;

                function cleanup() {
                    debug('cleanup');
                    // cleanup event handlers once the pipe is broken
                    dest.removeListener('close', onclose);
                    dest.removeListener('finish', onfinish);
                    dest.removeListener('drain', ondrain);
                    dest.removeListener('error', onerror);
                    dest.removeListener('unpipe', onunpipe);
                    src.removeListener('end', onend);
                    src.removeListener('end', unpipe);
                    src.removeListener('data', ondata);

                    cleanedUp = true;

                    // if the reader is waiting for a drain event from this
                    // specific writer, then it would cause it to never start
                    // flowing again.
                    // So, if this is awaiting a drain, then we just call it now.
                    // If we don't know, then assume that we are waiting for one.
                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                }

                // If the user pushes more data while we're writing to dest then we'll end up
                // in ondata again. However, we only want to increase awaitDrain once because
                // dest will only emit one 'drain' event for the multiple writes.
                // => Introduce a guard on increasing awaitDrain.
                var increasedAwaitDrain = false;
                src.on('data', ondata);

                function ondata(chunk) {
                    debug('ondata');
                    increasedAwaitDrain = false;
                    var ret = dest.write(chunk);
                    if (false === ret && !increasedAwaitDrain) {
                        // If the user unpiped during `dest.write()`, it is possible
                        // to get stuck in a permanently paused state if that write
                        // also returned false.
                        // => Check whether `dest` is still a piping destination.
                        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                            debug('false write response, pause', src._readableState.awaitDrain);
                            src._readableState.awaitDrain++;
                            increasedAwaitDrain = true;
                        }
                        src.pause();
                    }
                }

                // if the dest has an error, then stop piping into it.
                // however, don't suppress the throwing behavior for this.
                function onerror(er) {
                    debug('onerror', er);
                    unpipe();
                    dest.removeListener('error', onerror);
                    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
                }

                // Make sure our error handler is attached before userland ones.
                prependListener(dest, 'error', onerror);

                // Both close and finish should trigger unpipe, but only once.
                function onclose() {
                    dest.removeListener('finish', onfinish);
                    unpipe();
                }

                dest.once('close', onclose);

                function onfinish() {
                    debug('onfinish');
                    dest.removeListener('close', onclose);
                    unpipe();
                }

                dest.once('finish', onfinish);

                function unpipe() {
                    debug('unpipe');
                    src.unpipe(dest);
                }

                // tell the dest that it's being piped to
                dest.emit('pipe', src);

                // start the flow if it hasn't been started already.
                if (!state.flowing) {
                    debug('pipe resume');
                    src.resume();
                }

                return dest;
            };

            function pipeOnDrain(src) {
                return function () {
                    var state = src._readableState;
                    debug('pipeOnDrain', state.awaitDrain);
                    if (state.awaitDrain) state.awaitDrain--;
                    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                        state.flowing = true;
                        flow(src);
                    }
                };
            }

            Readable.prototype.unpipe = function (dest) {
                var state = this._readableState;
                var unpipeInfo = {hasUnpiped: false};

                // if we're not piping anywhere, then do nothing.
                if (state.pipesCount === 0) return this;

                // just one destination.  most common case.
                if (state.pipesCount === 1) {
                    // passed in one, but it's not the right one.
                    if (dest && dest !== state.pipes) return this;

                    if (!dest) dest = state.pipes;

                    // got a match.
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    if (dest) dest.emit('unpipe', this, unpipeInfo);
                    return this;
                }

                // slow case. multiple pipe destinations.

                if (!dest) {
                    // remove all.
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;

                    for (var i = 0; i < len; i++) {
                        dests[i].emit('unpipe', this, unpipeInfo);
                    }
                    return this;
                }

                // try to find the right one.
                var index = indexOf(state.pipes, dest);
                if (index === -1) return this;

                state.pipes.splice(index, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];

                dest.emit('unpipe', this, unpipeInfo);

                return this;
            };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
            Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);

                if (ev === 'data') {
                    // Start flowing on next tick if stream isn't explicitly paused
                    if (this._readableState.flowing !== false) this.resume();
                } else if (ev === 'readable') {
                    var state = this._readableState;
                    if (!state.endEmitted && !state.readableListening) {
                        state.readableListening = state.needReadable = true;
                        state.emittedReadable = false;
                        if (!state.reading) {
                            pna.nextTick(nReadingNextTick, this);
                        } else if (state.length) {
                            emitReadable(this);
                        }
                    }
                }

                return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;

            function nReadingNextTick(self) {
                debug('readable nexttick read 0');
                self.read(0);
            }

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
            Readable.prototype.resume = function () {
                var state = this._readableState;
                if (!state.flowing) {
                    debug('resume');
                    state.flowing = true;
                    resume(this, state);
                }
                return this;
            };

            function resume(stream, state) {
                if (!state.resumeScheduled) {
                    state.resumeScheduled = true;
                    pna.nextTick(resume_, stream, state);
                }
            }

            function resume_(stream, state) {
                if (!state.reading) {
                    debug('resume read 0');
                    stream.read(0);
                }

                state.resumeScheduled = false;
                state.awaitDrain = 0;
                stream.emit('resume');
                flow(stream);
                if (state.flowing && !state.reading) stream.read(0);
            }

            Readable.prototype.pause = function () {
                debug('call pause flowing=%j', this._readableState.flowing);
                if (false !== this._readableState.flowing) {
                    debug('pause');
                    this._readableState.flowing = false;
                    this.emit('pause');
                }
                return this;
            };

            function flow(stream) {
                var state = stream._readableState;
                debug('flow', state.flowing);
                while (state.flowing && stream.read() !== null) {
                }
            }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
            Readable.prototype.wrap = function (stream) {
                var _this = this;

                var state = this._readableState;
                var paused = false;

                stream.on('end', function () {
                    debug('wrapped end');
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length) _this.push(chunk);
                    }

                    _this.push(null);
                });

                stream.on('data', function (chunk) {
                    debug('wrapped data');
                    if (state.decoder) chunk = state.decoder.write(chunk);

                    // don't skip over falsy values in objectMode
                    if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;

                    var ret = _this.push(chunk);
                    if (!ret) {
                        paused = true;
                        stream.pause();
                    }
                });

                // proxy all the other methods.
                // important when wrapping filters and duplexes.
                for (var i in stream) {
                    if (this[i] === undefined && typeof stream[i] === 'function') {
                        this[i] = function (method) {
                            return function () {
                                return stream[method].apply(stream, arguments);
                            };
                        }(i);
                    }
                }

                // proxy certain important events.
                for (var n = 0; n < kProxyEvents.length; n++) {
                    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                }

                // when we try to consume some more bytes, simply unpause the
                // underlying stream.
                this._read = function (n) {
                    debug('wrapped _read', n);
                    if (paused) {
                        paused = false;
                        stream.resume();
                    }
                };

                return this;
            };

            Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function () {
                    return this._readableState.highWaterMark;
                }
            });

// exposed for testing purposes only.
            Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
            function fromList(n, state) {
                // nothing buffered
                if (state.length === 0) return null;

                var ret;
                if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
                    // read it all, truncate the list
                    if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
                    state.buffer.clear();
                } else {
                    // read part of list
                    ret = fromListPartial(n, state.buffer, state.decoder);
                }

                return ret;
            }

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
            function fromListPartial(n, list, hasStrings) {
                var ret;
                if (n < list.head.data.length) {
                    // slice is the same for buffers and strings
                    ret = list.head.data.slice(0, n);
                    list.head.data = list.head.data.slice(n);
                } else if (n === list.head.data.length) {
                    // first chunk is a perfect match
                    ret = list.shift();
                } else {
                    // result spans more than one buffer
                    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
                }
                return ret;
            }

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
            function copyFromBufferString(n, list) {
                var p = list.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while (p = p.next) {
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str; else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) list.head = p.next; else list.head = list.tail = null;
                        } else {
                            list.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                list.length -= c;
                return ret;
            }

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
            function copyFromBuffer(n, list) {
                var ret = Buffer.allocUnsafe(n);
                var p = list.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while (p = p.next) {
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) list.head = p.next; else list.head = list.tail = null;
                        } else {
                            list.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                list.length -= c;
                return ret;
            }

            function endReadable(stream) {
                var state = stream._readableState;

                // If we get here before consuming all the bytes, then that is a
                // bug in node.  Should never happen.
                if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

                if (!state.endEmitted) {
                    state.ended = true;
                    pna.nextTick(endReadableNT, state, stream);
                }
            }

            function endReadableNT(state, stream) {
                // Check that we didn't get one last unshift.
                if (!state.endEmitted && state.length === 0) {
                    state.endEmitted = true;
                    stream.readable = false;
                    stream.emit('end');
                }
            }

            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x) return i;
                }
                return -1;
            }
        }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {
        "./_stream_duplex": 13,
        "./internal/streams/BufferList": 18,
        "./internal/streams/destroy": 19,
        "./internal/streams/stream": 20,
        "_process": 11,
        "core-util-is": 4,
        "events": 5,
        "inherits": 7,
        "isarray": 9,
        "process-nextick-args": 10,
        "safe-buffer": 21,
        "string_decoder/": 22,
        "util": 2
    }],
    16: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

        'use strict';

        module.exports = Transform;

        var Duplex = require('./_stream_duplex');

        /*<replacement>*/
        var util = Object.create(require('core-util-is'));
        util.inherits = require('inherits');
        /*</replacement>*/

        util.inherits(Transform, Duplex);

        function afterTransform(er, data) {
            var ts = this._transformState;
            ts.transforming = false;

            var cb = ts.writecb;

            if (!cb) {
                return this.emit('error', new Error('write callback called multiple times'));
            }

            ts.writechunk = null;
            ts.writecb = null;

            if (data != null) // single equals check for both `null` and `undefined`
                this.push(data);

            cb(er);

            var rs = this._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
                this._read(rs.highWaterMark);
            }
        }

        function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);

            Duplex.call(this, options);

            this._transformState = {
                afterTransform: afterTransform.bind(this),
                needTransform: false,
                transforming: false,
                writecb: null,
                writechunk: null,
                writeencoding: null
            };

            // start out asking for a readable event once data is transformed.
            this._readableState.needReadable = true;

            // we have implemented the _read method, and done the other things
            // that Readable wants before the first _read call, so unset the
            // sync guard flag.
            this._readableState.sync = false;

            if (options) {
                if (typeof options.transform === 'function') this._transform = options.transform;

                if (typeof options.flush === 'function') this._flush = options.flush;
            }

            // When the writable side finishes, then flush out anything remaining.
            this.on('prefinish', prefinish);
        }

        function prefinish() {
            var _this = this;

            if (typeof this._flush === 'function') {
                this._flush(function (er, data) {
                    done(_this, er, data);
                });
            } else {
                done(this, null, null);
            }
        }

        Transform.prototype.push = function (chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
        };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function (chunk, encoding, cb) {
            throw new Error('_transform() is not implemented');
        };

        Transform.prototype._write = function (chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
            }
        };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
        Transform.prototype._read = function (n) {
            var ts = this._transformState;

            if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
                // mark that we need a transform, so that any data that comes in
                // will get processed, now that we've asked for it.
                ts.needTransform = true;
            }
        };

        Transform.prototype._destroy = function (err, cb) {
            var _this2 = this;

            Duplex.prototype._destroy.call(this, err, function (err2) {
                cb(err2);
                _this2.emit('close');
            });
        };

        function done(stream, er, data) {
            if (er) return stream.emit('error', er);

            if (data != null) // single equals check for both `null` and `undefined`
                stream.push(data);

            // if there's nothing in the write buffer, then that means
            // that nothing more will ever be provided
            if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

            if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

            return stream.push(null);
        }
    }, {"./_stream_duplex": 13, "core-util-is": 4, "inherits": 7}],
    17: [function (require, module, exports) {
        (function (process, global, setImmediate) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

            'use strict';

            /*<replacement>*/

            var pna = require('process-nextick-args');
            /*</replacement>*/

            module.exports = Writable;

            /* <replacement> */
            function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
                this.next = null;
            }

// It seems a linked list but it is not
// there will be only 2 of these for each stream
            function CorkedRequest(state) {
                var _this = this;

                this.next = null;
                this.entry = null;
                this.finish = function () {
                    onCorkedFinish(_this, state);
                };
            }

            /* </replacement> */

            /*<replacement>*/
            var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
            /*</replacement>*/

            /*<replacement>*/
            var Duplex;
            /*</replacement>*/

            Writable.WritableState = WritableState;

            /*<replacement>*/
            var util = Object.create(require('core-util-is'));
            util.inherits = require('inherits');
            /*</replacement>*/

            /*<replacement>*/
            var internalUtil = {
                deprecate: require('util-deprecate')
            };
            /*</replacement>*/

            /*<replacement>*/
            var Stream = require('./internal/streams/stream');
            /*</replacement>*/

            /*<replacement>*/

            var Buffer = require('safe-buffer').Buffer;
            var OurUint8Array = global.Uint8Array || function () {
            };

            function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
            }

            function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }

            /*</replacement>*/

            var destroyImpl = require('./internal/streams/destroy');

            util.inherits(Writable, Stream);

            function nop() {
            }

            function WritableState(options, stream) {
                Duplex = Duplex || require('./_stream_duplex');

                options = options || {};

                // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream.
                // These options can be provided separately as readableXXX and writableXXX.
                var isDuplex = stream instanceof Duplex;

                // object stream flag to indicate whether or not this stream
                // contains buffers or objects.
                this.objectMode = !!options.objectMode;

                if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

                // the point at which write() starts returning false
                // Note: 0 is a valid value, means that we always return false if
                // the entire buffer is not flushed immediately on write()
                var hwm = options.highWaterMark;
                var writableHwm = options.writableHighWaterMark;
                var defaultHwm = this.objectMode ? 16 : 16 * 1024;

                if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm;

                // cast to ints.
                this.highWaterMark = Math.floor(this.highWaterMark);

                // if _final has been called
                this.finalCalled = false;

                // drain event flag.
                this.needDrain = false;
                // at the start of calling end()
                this.ending = false;
                // when end() has been called, and returned
                this.ended = false;
                // when 'finish' is emitted
                this.finished = false;

                // has it been destroyed
                this.destroyed = false;

                // should we decode strings into buffers before passing to _write?
                // this is here so that some node-core streams can optimize string
                // handling at a lower level.
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;

                // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || 'utf8';

                // not an actual buffer we keep track of, but a measurement
                // of how much we're waiting to get pushed to some underlying
                // socket or file.
                this.length = 0;

                // a flag to see when we're in the middle of a write.
                this.writing = false;

                // when true all writes will be buffered until .uncork() call
                this.corked = 0;

                // a flag to be able to tell if the onwrite cb is called immediately,
                // or on a later tick.  We set this to true at first, because any
                // actions that shouldn't happen until "later" should generally also
                // not happen before the first write call.
                this.sync = true;

                // a flag to know if we're processing previously buffered items, which
                // may call the _write() callback in the same tick, so that we don't
                // end up in an overlapped onwrite situation.
                this.bufferProcessing = false;

                // the callback that's passed to _write(chunk,cb)
                this.onwrite = function (er) {
                    onwrite(stream, er);
                };

                // the callback that the user supplies to write(chunk,encoding,cb)
                this.writecb = null;

                // the amount that is being written when _write is called.
                this.writelen = 0;

                this.bufferedRequest = null;
                this.lastBufferedRequest = null;

                // number of pending user-supplied write callbacks
                // this must be 0 before 'finish' can be emitted
                this.pendingcb = 0;

                // emit prefinish if the only thing we're waiting for is _write cbs
                // This is relevant for synchronous Transform streams
                this.prefinished = false;

                // True if the error was already emitted and should not be thrown again
                this.errorEmitted = false;

                // count buffered requests
                this.bufferedRequestCount = 0;

                // allocate the first CorkedRequest, there is always
                // one allocated and free to use, and we maintain at most two
                this.corkedRequestsFree = new CorkedRequest(this);
            }

            WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest;
                var out = [];
                while (current) {
                    out.push(current);
                    current = current.next;
                }
                return out;
            };

            (function () {
                try {
                    Object.defineProperty(WritableState.prototype, 'buffer', {
                        get: internalUtil.deprecate(function () {
                            return this.getBuffer();
                        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
                    });
                } catch (_) {
                }
            })();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
            var realHasInstance;
            if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
                realHasInstance = Function.prototype[Symbol.hasInstance];
                Object.defineProperty(Writable, Symbol.hasInstance, {
                    value: function (object) {
                        if (realHasInstance.call(this, object)) return true;
                        if (this !== Writable) return false;

                        return object && object._writableState instanceof WritableState;
                    }
                });
            } else {
                realHasInstance = function (object) {
                    return object instanceof this;
                };
            }

            function Writable(options) {
                Duplex = Duplex || require('./_stream_duplex');

                // Writable ctor is applied to Duplexes, too.
                // `realHasInstance` is necessary because using plain `instanceof`
                // would return false, as no `_writableState` property is attached.

                // Trying to use the custom `instanceof` for Writable here will also break the
                // Node.js LazyTransform implementation, which has a non-trivial getter for
                // `_writableState` that would lead to infinite recursion.
                if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                    return new Writable(options);
                }

                this._writableState = new WritableState(options, this);

                // legacy.
                this.writable = true;

                if (options) {
                    if (typeof options.write === 'function') this._write = options.write;

                    if (typeof options.writev === 'function') this._writev = options.writev;

                    if (typeof options.destroy === 'function') this._destroy = options.destroy;

                    if (typeof options.final === 'function') this._final = options.final;
                }

                Stream.call(this);
            }

// Otherwise people can pipe Writable streams, which is just wrong.
            Writable.prototype.pipe = function () {
                this.emit('error', new Error('Cannot pipe, not readable'));
            };

            function writeAfterEnd(stream, cb) {
                var er = new Error('write after end');
                // TODO: defer error events consistently everywhere, not just the cb
                stream.emit('error', er);
                pna.nextTick(cb, er);
            }

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
            function validChunk(stream, state, chunk, cb) {
                var valid = true;
                var er = false;

                if (chunk === null) {
                    er = new TypeError('May not write null values to stream');
                } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
                    er = new TypeError('Invalid non-string/buffer chunk');
                }
                if (er) {
                    stream.emit('error', er);
                    pna.nextTick(cb, er);
                    valid = false;
                }
                return valid;
            }

            Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                var isBuf = !state.objectMode && _isUint8Array(chunk);

                if (isBuf && !Buffer.isBuffer(chunk)) {
                    chunk = _uint8ArrayToBuffer(chunk);
                }

                if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }

                if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding;

                if (typeof cb !== 'function') cb = nop;

                if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
                    state.pendingcb++;
                    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                }

                return ret;
            };

            Writable.prototype.cork = function () {
                var state = this._writableState;

                state.corked++;
            };

            Writable.prototype.uncork = function () {
                var state = this._writableState;

                if (state.corked) {
                    state.corked--;

                    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
                }
            };

            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                // node::ParseEncoding() requires lower case.
                if (typeof encoding === 'string') encoding = encoding.toLowerCase();
                if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
                this._writableState.defaultEncoding = encoding;
                return this;
            };

            function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
                    chunk = Buffer.from(chunk, encoding);
                }
                return chunk;
            }

            Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function () {
                    return this._writableState.highWaterMark;
                }
            });

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) {
                    var newChunk = decodeChunk(state, chunk, encoding);
                    if (chunk !== newChunk) {
                        isBuf = true;
                        encoding = 'buffer';
                        chunk = newChunk;
                    }
                }
                var len = state.objectMode ? 1 : chunk.length;

                state.length += len;

                var ret = state.length < state.highWaterMark;
                // we must ensure that previous needDrain will not be reset to false.
                if (!ret) state.needDrain = true;

                if (state.writing || state.corked) {
                    var last = state.lastBufferedRequest;
                    state.lastBufferedRequest = {
                        chunk: chunk,
                        encoding: encoding,
                        isBuf: isBuf,
                        callback: cb,
                        next: null
                    };
                    if (last) {
                        last.next = state.lastBufferedRequest;
                    } else {
                        state.bufferedRequest = state.lastBufferedRequest;
                    }
                    state.bufferedRequestCount += 1;
                } else {
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                }

                return ret;
            }

            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
            }

            function onwriteError(stream, state, sync, er, cb) {
                --state.pendingcb;

                if (sync) {
                    // defer the callback if we are being called synchronously
                    // to avoid piling up things on the stack
                    pna.nextTick(cb, er);
                    // this can emit finish, and it will always happen
                    // after error
                    pna.nextTick(finishMaybe, stream, state);
                    stream._writableState.errorEmitted = true;
                    stream.emit('error', er);
                } else {
                    // the caller expect this to happen before if
                    // it is async
                    cb(er);
                    stream._writableState.errorEmitted = true;
                    stream.emit('error', er);
                    // this can emit finish, but finish must
                    // always follow error
                    finishMaybe(stream, state);
                }
            }

            function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
            }

            function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;

                onwriteStateUpdate(state);

                if (er) onwriteError(stream, state, sync, er, cb); else {
                    // Check if we're actually ready to finish, but don't emit yet
                    var finished = needFinish(state);

                    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                        clearBuffer(stream, state);
                    }

                    if (sync) {
                        /*<replacement>*/
                        asyncWrite(afterWrite, stream, state, finished, cb);
                        /*</replacement>*/
                    } else {
                        afterWrite(stream, state, finished, cb);
                    }
                }
            }

            function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
            }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
            function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit('drain');
                }
            }

// if there's something in the buffer waiting, then process it
            function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                var entry = state.bufferedRequest;

                if (stream._writev && entry && entry.next) {
                    // Fast case, write everything using _writev()
                    var l = state.bufferedRequestCount;
                    var buffer = new Array(l);
                    var holder = state.corkedRequestsFree;
                    holder.entry = entry;

                    var count = 0;
                    var allBuffers = true;
                    while (entry) {
                        buffer[count] = entry;
                        if (!entry.isBuf) allBuffers = false;
                        entry = entry.next;
                        count += 1;
                    }
                    buffer.allBuffers = allBuffers;

                    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

                    // doWrite is almost always async, defer these to save a bit of time
                    // as the hot path ends with doWrite
                    state.pendingcb++;
                    state.lastBufferedRequest = null;
                    if (holder.next) {
                        state.corkedRequestsFree = holder.next;
                        holder.next = null;
                    } else {
                        state.corkedRequestsFree = new CorkedRequest(state);
                    }
                    state.bufferedRequestCount = 0;
                } else {
                    // Slow case, write chunks one-by-one
                    while (entry) {
                        var chunk = entry.chunk;
                        var encoding = entry.encoding;
                        var cb = entry.callback;
                        var len = state.objectMode ? 1 : chunk.length;

                        doWrite(stream, state, false, len, chunk, encoding, cb);
                        entry = entry.next;
                        state.bufferedRequestCount--;
                        // if we didn't call the onwrite immediately, then
                        // it means that we need to wait until it does.
                        // also, that means that the chunk and cb are currently
                        // being processed, so move the buffer counter past them.
                        if (state.writing) {
                            break;
                        }
                    }

                    if (entry === null) state.lastBufferedRequest = null;
                }

                state.bufferedRequest = entry;
                state.bufferProcessing = false;
            }

            Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new Error('_write() is not implemented'));
            };

            Writable.prototype._writev = null;

            Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState;

                if (typeof chunk === 'function') {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                } else if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }

                if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

                // .end() fully uncorks
                if (state.corked) {
                    state.corked = 1;
                    this.uncork();
                }

                // ignore unnecessary end() calls.
                if (!state.ending && !state.finished) endWritable(this, state, cb);
            };

            function needFinish(state) {
                return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }

            function callFinal(stream, state) {
                stream._final(function (err) {
                    state.pendingcb--;
                    if (err) {
                        stream.emit('error', err);
                    }
                    state.prefinished = true;
                    stream.emit('prefinish');
                    finishMaybe(stream, state);
                });
            }

            function prefinish(stream, state) {
                if (!state.prefinished && !state.finalCalled) {
                    if (typeof stream._final === 'function') {
                        state.pendingcb++;
                        state.finalCalled = true;
                        pna.nextTick(callFinal, stream, state);
                    } else {
                        state.prefinished = true;
                        stream.emit('prefinish');
                    }
                }
            }

            function finishMaybe(stream, state) {
                var need = needFinish(state);
                if (need) {
                    prefinish(stream, state);
                    if (state.pendingcb === 0) {
                        state.finished = true;
                        stream.emit('finish');
                    }
                }
                return need;
            }

            function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                    if (state.finished) pna.nextTick(cb); else stream.once('finish', cb);
                }
                state.ended = true;
                stream.writable = false;
            }

            function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry;
                corkReq.entry = null;
                while (entry) {
                    var cb = entry.callback;
                    state.pendingcb--;
                    cb(err);
                    entry = entry.next;
                }
                if (state.corkedRequestsFree) {
                    state.corkedRequestsFree.next = corkReq;
                } else {
                    state.corkedRequestsFree = corkReq;
                }
            }

            Object.defineProperty(Writable.prototype, 'destroyed', {
                get: function () {
                    if (this._writableState === undefined) {
                        return false;
                    }
                    return this._writableState.destroyed;
                },
                set: function (value) {
                    // we ignore the value if the stream
                    // has not been initialized yet
                    if (!this._writableState) {
                        return;
                    }

                    // backward compatibility, the user is explicitly
                    // managing destroyed
                    this._writableState.destroyed = value;
                }
            });

            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function (err, cb) {
                this.end();
                cb(err);
            };
        }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("timers").setImmediate)

    }, {
        "./_stream_duplex": 13,
        "./internal/streams/destroy": 19,
        "./internal/streams/stream": 20,
        "_process": 11,
        "core-util-is": 4,
        "inherits": 7,
        "process-nextick-args": 10,
        "safe-buffer": 21,
        "timers": 30,
        "util-deprecate": 31
    }],
    18: [function (require, module, exports) {
        'use strict';

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        var Buffer = require('safe-buffer').Buffer;
        var util = require('util');

        function copyBuffer(src, target, offset) {
            src.copy(target, offset);
        }

        module.exports = function () {
            function BufferList() {
                _classCallCheck(this, BufferList);

                this.head = null;
                this.tail = null;
                this.length = 0;
            }

            BufferList.prototype.push = function push(v) {
                var entry = {data: v, next: null};
                if (this.length > 0) this.tail.next = entry; else this.head = entry;
                this.tail = entry;
                ++this.length;
            };

            BufferList.prototype.unshift = function unshift(v) {
                var entry = {data: v, next: this.head};
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            };

            BufferList.prototype.shift = function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
                --this.length;
                return ret;
            };

            BufferList.prototype.clear = function clear() {
                this.head = this.tail = null;
                this.length = 0;
            };

            BufferList.prototype.join = function join(s) {
                if (this.length === 0) return '';
                var p = this.head;
                var ret = '' + p.data;
                while (p = p.next) {
                    ret += s + p.data;
                }
                return ret;
            };

            BufferList.prototype.concat = function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                if (this.length === 1) return this.head.data;
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while (p) {
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            };

            return BufferList;
        }();

        if (util && util.inspect && util.inspect.custom) {
            module.exports.prototype[util.inspect.custom] = function () {
                var obj = util.inspect({length: this.length});
                return this.constructor.name + ' ' + obj;
            };
        }
    }, {"safe-buffer": 21, "util": 2}],
    19: [function (require, module, exports) {
        'use strict';

        /*<replacement>*/

        var pna = require('process-nextick-args');
        /*</replacement>*/

// undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
            var _this = this;

            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;

            if (readableDestroyed || writableDestroyed) {
                if (cb) {
                    cb(err);
                } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                    pna.nextTick(emitErrorNT, this, err);
                }
                return this;
            }

            // we set destroyed to true before firing error callbacks in order
            // to make it re-entrance safe in case destroy() is called within callbacks

            if (this._readableState) {
                this._readableState.destroyed = true;
            }

            // if this is a duplex stream mark the writable part as destroyed as well
            if (this._writableState) {
                this._writableState.destroyed = true;
            }

            this._destroy(err || null, function (err) {
                if (!cb && err) {
                    pna.nextTick(emitErrorNT, _this, err);
                    if (_this._writableState) {
                        _this._writableState.errorEmitted = true;
                    }
                } else if (cb) {
                    cb(err);
                }
            });

            return this;
        }

        function undestroy() {
            if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
            }

            if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
            }
        }

        function emitErrorNT(self, err) {
            self.emit('error', err);
        }

        module.exports = {
            destroy: destroy,
            undestroy: undestroy
        };
    }, {"process-nextick-args": 10}],
    20: [function (require, module, exports) {
        module.exports = require('events').EventEmitter;

    }, {"events": 5}],
    21: [function (require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require('buffer')
        var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
            for (var key in src) {
                dst[key] = src[key]
            }
        }

        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
            module.exports = buffer
        } else {
            // Copy properties from require('buffer')
            copyProps(buffer, exports)
            exports.Buffer = SafeBuffer
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length)
        }

// Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === 'number') {
                throw new TypeError('Argument must not be a number')
            }
            return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            var buf = Buffer(size)
            if (fill !== undefined) {
                if (typeof encoding === 'string') {
                    buf.fill(fill, encoding)
                } else {
                    buf.fill(fill)
                }
            } else {
                buf.fill(0)
            }
            return buf
        }

        SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            return buffer.SlowBuffer(size)
        }

    }, {"buffer": 3}],
    22: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        /*<replacement>*/

        var Buffer = require('safe-buffer').Buffer;
        /*</replacement>*/

        var isEncoding = Buffer.isEncoding || function (encoding) {
            encoding = '' + encoding;
            switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                    return true;
                default:
                    return false;
            }
        };

        function _normalizeEncoding(enc) {
            if (!enc) return 'utf8';
            var retried;
            while (true) {
                switch (enc) {
                    case 'utf8':
                    case 'utf-8':
                        return 'utf8';
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return 'utf16le';
                    case 'latin1':
                    case 'binary':
                        return 'latin1';
                    case 'base64':
                    case 'ascii':
                    case 'hex':
                        return enc;
                    default:
                        if (retried) return; // undefined
                        enc = ('' + enc).toLowerCase();
                        retried = true;
                }
            }
        };

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc);
            if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
            return nenc || enc;
        }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
        exports.StringDecoder = StringDecoder;

        function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding);
            var nb;
            switch (this.encoding) {
                case 'utf16le':
                    this.text = utf16Text;
                    this.end = utf16End;
                    nb = 4;
                    break;
                case 'utf8':
                    this.fillLast = utf8FillLast;
                    nb = 4;
                    break;
                case 'base64':
                    this.text = base64Text;
                    this.end = base64End;
                    nb = 3;
                    break;
                default:
                    this.write = simpleWrite;
                    this.end = simpleEnd;
                    return;
            }
            this.lastNeed = 0;
            this.lastTotal = 0;
            this.lastChar = Buffer.allocUnsafe(nb);
        }

        StringDecoder.prototype.write = function (buf) {
            if (buf.length === 0) return '';
            var r;
            var i;
            if (this.lastNeed) {
                r = this.fillLast(buf);
                if (r === undefined) return '';
                i = this.lastNeed;
                this.lastNeed = 0;
            } else {
                i = 0;
            }
            if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
            return r || '';
        };

        StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function (buf) {
            if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
            this.lastNeed -= buf.length;
        };

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
            if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
            return byte >> 6 === 0x02 ? -1 : -2;
        }

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1;
            if (j < i) return 0;
            var nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
                if (nb > 0) self.lastNeed = nb - 1;
                return nb;
            }
            if (--j < i || nb === -2) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
                if (nb > 0) self.lastNeed = nb - 2;
                return nb;
            }
            if (--j < i || nb === -2) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
                if (nb > 0) {
                    if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
                }
                return nb;
            }
            return 0;
        }

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
        function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 0xC0) !== 0x80) {
                self.lastNeed = 0;
                return '\ufffd';
            }
            if (self.lastNeed > 1 && buf.length > 1) {
                if ((buf[1] & 0xC0) !== 0x80) {
                    self.lastNeed = 1;
                    return '\ufffd';
                }
                if (self.lastNeed > 2 && buf.length > 2) {
                    if ((buf[2] & 0xC0) !== 0x80) {
                        self.lastNeed = 2;
                        return '\ufffd';
                    }
                }
            }
        }

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed;
            var r = utf8CheckExtraBytes(this, buf, p);
            if (r !== undefined) return r;
            if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, p, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, p, 0, buf.length);
            this.lastNeed -= buf.length;
        }

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
        function utf8Text(buf, i) {
            var total = utf8CheckIncomplete(this, buf, i);
            if (!this.lastNeed) return buf.toString('utf8', i);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            buf.copy(this.lastChar, 0, end);
            return buf.toString('utf8', i, end);
        }

// For UTF-8, a replacement character is added when ending on a partial
// character.
        function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed) return r + '\ufffd';
            return r;
        }

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
        function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
                var r = buf.toString('utf16le', i);
                if (r) {
                    var c = r.charCodeAt(r.length - 1);
                    if (c >= 0xD800 && c <= 0xDBFF) {
                        this.lastNeed = 2;
                        this.lastTotal = 4;
                        this.lastChar[0] = buf[buf.length - 2];
                        this.lastChar[1] = buf[buf.length - 1];
                        return r.slice(0, -1);
                    }
                }
                return r;
            }
            this.lastNeed = 1;
            this.lastTotal = 2;
            this.lastChar[0] = buf[buf.length - 1];
            return buf.toString('utf16le', i, buf.length - 1);
        }

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed) {
                var end = this.lastTotal - this.lastNeed;
                return r + this.lastChar.toString('utf16le', 0, end);
            }
            return r;
        }

        function base64Text(buf, i) {
            var n = (buf.length - i) % 3;
            if (n === 0) return buf.toString('base64', i);
            this.lastNeed = 3 - n;
            this.lastTotal = 3;
            if (n === 1) {
                this.lastChar[0] = buf[buf.length - 1];
            } else {
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
            }
            return buf.toString('base64', i, buf.length - n);
        }

        function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
            return r;
        }

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
            return buf.toString(this.encoding);
        }

        function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : '';
        }
    }, {"safe-buffer": 21}],
    23: [function (require, module, exports) {
        module.exports = require('./readable').PassThrough

    }, {"./readable": 24}],
    24: [function (require, module, exports) {
        exports = module.exports = require('./lib/_stream_readable.js');
        exports.Stream = exports;
        exports.Readable = exports;
        exports.Writable = require('./lib/_stream_writable.js');
        exports.Duplex = require('./lib/_stream_duplex.js');
        exports.Transform = require('./lib/_stream_transform.js');
        exports.PassThrough = require('./lib/_stream_passthrough.js');

    }, {
        "./lib/_stream_duplex.js": 13,
        "./lib/_stream_passthrough.js": 14,
        "./lib/_stream_readable.js": 15,
        "./lib/_stream_transform.js": 16,
        "./lib/_stream_writable.js": 17
    }],
    25: [function (require, module, exports) {
        module.exports = require('./readable').Transform

    }, {"./readable": 24}],
    26: [function (require, module, exports) {
        module.exports = require('./lib/_stream_writable.js');

    }, {"./lib/_stream_writable.js": 17}],
    27: [function (require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require('buffer')
        var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
            for (var key in src) {
                dst[key] = src[key]
            }
        }

        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
            module.exports = buffer
        } else {
            // Copy properties from require('buffer')
            copyProps(buffer, exports)
            exports.Buffer = SafeBuffer
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === 'number') {
                throw new TypeError('Argument must not be a number')
            }
            return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            var buf = Buffer(size)
            if (fill !== undefined) {
                if (typeof encoding === 'string') {
                    buf.fill(fill, encoding)
                } else {
                    buf.fill(fill)
                }
            } else {
                buf.fill(0)
            }
            return buf
        }

        SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== 'number') {
                throw new TypeError('Argument must be a number')
            }
            return buffer.SlowBuffer(size)
        }

    }, {"buffer": 3}],
    28: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        module.exports = Stream;

        var EE = require('events').EventEmitter;
        var inherits = require('inherits');

        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
        Stream.Stream = Stream;


// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

        function Stream() {
            EE.call(this);
        }

        Stream.prototype.pipe = function (dest, options) {
            var source = this;

            function ondata(chunk) {
                if (dest.writable) {
                    if (false === dest.write(chunk) && source.pause) {
                        source.pause();
                    }
                }
            }

            source.on('data', ondata);

            function ondrain() {
                if (source.readable && source.resume) {
                    source.resume();
                }
            }

            dest.on('drain', ondrain);

            // If the 'end' option is not supplied, dest.end() will be called when
            // source gets the 'end' or 'close' events.  Only dest.end() once.
            if (!dest._isStdio && (!options || options.end !== false)) {
                source.on('end', onend);
                source.on('close', onclose);
            }

            var didOnEnd = false;

            function onend() {
                if (didOnEnd) return;
                didOnEnd = true;

                dest.end();
            }


            function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;

                if (typeof dest.destroy === 'function') dest.destroy();
            }

            // don't leave dangling pipes when there are errors.
            function onerror(er) {
                cleanup();
                if (EE.listenerCount(this, 'error') === 0) {
                    throw er; // Unhandled stream error in pipe.
                }
            }

            source.on('error', onerror);
            dest.on('error', onerror);

            // remove all the event listeners that were added.
            function cleanup() {
                source.removeListener('data', ondata);
                dest.removeListener('drain', ondrain);

                source.removeListener('end', onend);
                source.removeListener('close', onclose);

                source.removeListener('error', onerror);
                dest.removeListener('error', onerror);

                source.removeListener('end', cleanup);
                source.removeListener('close', cleanup);

                dest.removeListener('close', cleanup);
            }

            source.on('end', cleanup);
            source.on('close', cleanup);

            dest.on('close', cleanup);

            dest.emit('pipe', source);

            // Allow for unix-like usage: A.pipe(B).pipe(C)
            return dest;
        };

    }, {
        "events": 5,
        "inherits": 7,
        "readable-stream/duplex.js": 12,
        "readable-stream/passthrough.js": 23,
        "readable-stream/readable.js": 24,
        "readable-stream/transform.js": 25,
        "readable-stream/writable.js": 26
    }],
    29: [function (require, module, exports) {
        arguments[4][22][0].apply(exports, arguments)
    }, {"dup": 22, "safe-buffer": 27}],
    30: [function (require, module, exports) {
        (function (setImmediate, clearImmediate) {
            var nextTick = require('process/browser.js').nextTick;
            var apply = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;

// DOM APIs, for completeness

            exports.setTimeout = function () {
                return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
            };
            exports.setInterval = function () {
                return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
            };
            exports.clearTimeout =
                exports.clearInterval = function (timeout) {
                    timeout.close();
                };

            function Timeout(id, clearFn) {
                this._id = id;
                this._clearFn = clearFn;
            }

            Timeout.prototype.unref = Timeout.prototype.ref = function () {
            };
            Timeout.prototype.close = function () {
                this._clearFn.call(window, this._id);
            };

// Does not start the time, just sets up the members needed.
            exports.enroll = function (item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
            };

            exports.unenroll = function (item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
            };

            exports._unrefActive = exports.active = function (item) {
                clearTimeout(item._idleTimeoutId);

                var msecs = item._idleTimeout;
                if (msecs >= 0) {
                    item._idleTimeoutId = setTimeout(function onTimeout() {
                        if (item._onTimeout)
                            item._onTimeout();
                    }, msecs);
                }
            };

// That's not how node.js implements it but the exposed api is the same.
            exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
                var id = nextImmediateId++;
                var args = arguments.length < 2 ? false : slice.call(arguments, 1);

                immediateIds[id] = true;

                nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                        // fn.call() is faster so we optimize for the common use-case
                        // @see http://jsperf.com/call-apply-segu
                        if (args) {
                            fn.apply(null, args);
                        } else {
                            fn.call(null);
                        }
                        // Prevent ids from leaking
                        exports.clearImmediate(id);
                    }
                });

                return id;
            };

            exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
                delete immediateIds[id];
            };
        }).call(this, require("timers").setImmediate, require("timers").clearImmediate)

    }, {"process/browser.js": 11, "timers": 30}],
    31: [function (require, module, exports) {
        (function (global) {

            /**
             * Module exports.
             */

            module.exports = deprecate;

            /**
             * Mark that a method should not be used.
             * Returns a modified function which warns once by default.
             *
             * If `localStorage.noDeprecation = true` is set, then it is a no-op.
             *
             * If `localStorage.throwDeprecation = true` is set, then deprecated functions
             * will throw an Error when invoked.
             *
             * If `localStorage.traceDeprecation = true` is set, then deprecated functions
             * will invoke `console.trace()` instead of `console.error()`.
             *
             * @param {Function} fn - the function to deprecate
             * @param {String} msg - the string to print to the console when `fn` is invoked
             * @returns {Function} a new "deprecated" version of `fn`
             * @api public
             */

            function deprecate(fn, msg) {
                if (config('noDeprecation')) {
                    return fn;
                }

                var warned = false;

                function deprecated() {
                    if (!warned) {
                        if (config('throwDeprecation')) {
                            throw new Error(msg);
                        } else if (config('traceDeprecation')) {
                            console.trace(msg);
                        } else {
                            console.warn(msg);
                        }
                        warned = true;
                    }
                    return fn.apply(this, arguments);
                }

                return deprecated;
            }

            /**
             * Checks `localStorage` for boolean values for the given `name`.
             *
             * @param {String} name
             * @returns {Boolean}
             * @api private
             */

            function config(name) {
                // accessing global.localStorage can trigger a DOMException in sandboxed iframes
                try {
                    if (!global.localStorage) return false;
                } catch (_) {
                    return false;
                }
                var val = global.localStorage[name];
                if (null == val) return false;
                return String(val).toLowerCase() === 'true';
            }

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {}],
    32: [function (require, module, exports) {
        (function (Buffer) {
            "use strict";
            let bitcoin = require('bitcoinjs-lib')
            let bip39 = require('bip39')


            window.getAddress = function (userAccount) {
                const seed = bip39.mnemonicToSeed(userAccount)
                let result = {}
                return seed.then(seed => {

                    const bitcoinNetwork = bitcoin.networks.testnet
                    const hdMaster = bitcoin.bip32.fromSeed(seed, bitcoinNetwork) // seed from above
                    const keyPair = hdMaster.derivePath('m/0')
                    // try to get private key as readable string
                    const privateKeyBuffer = Buffer.from(keyPair.privateKey)
                    const privateKey = privateKeyBuffer.toString('hex')
                    result.privateKey = privateKey;
                    result.publicKey = keyPair.publicKey.toString('hex');
                    // fail to get private key as readable string
                    const {address} = bitcoin.payments.p2pkh({pubkey: keyPair.publicKey})
                    result.address = address;
                    return result

                })


            }

            window.generateMultiAddr = function (publicKey1, publicKey2, networkType) {
                const pubkeys = [publicKey1, publicKey2].map(hex => Buffer.from(hex, 'hex'));
                if (networkType == "test3") {
                    const {address} = bitcoin.payments.p2sh({
                        redeem: bitcoin.payments.p2wsh({
                            redeem: bitcoin.payments.p2ms({m: 2, pubkeys, network: bitcoin.networks.testnet})
                        })
                    });
                    return address;
                } else {
                    const {address} = bitcoin.payments.p2sh({
                        redeem: bitcoin.payments.p2wsh({
                            redeem: bitcoin.payments.p2ms({m: 2, pubkeys})
                        })
                    });
                    return address;
                }

            }

        }).call(this, require("buffer").Buffer)

    }, {"bip39": 62, "bitcoinjs-lib": 80, "buffer": 3}],
    33: [function (require, module, exports) {
        'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
        var _Buffer = require('safe-buffer').Buffer

        function base(ALPHABET) {
            if (ALPHABET.length >= 255) {
                throw new TypeError('Alphabet too long')
            }
            var BASE_MAP = new Uint8Array(256)
            for (var j = 0; j < BASE_MAP.length; j++) {
                BASE_MAP[j] = 255
            }
            for (var i = 0; i < ALPHABET.length; i++) {
                var x = ALPHABET.charAt(i)
                var xc = x.charCodeAt(0)
                if (BASE_MAP[xc] !== 255) {
                    throw new TypeError(x + ' is ambiguous')
                }
                BASE_MAP[xc] = i
            }
            var BASE = ALPHABET.length
            var LEADER = ALPHABET.charAt(0)
            var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
            var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
            function encode(source) {
                if (Array.isArray(source) || source instanceof Uint8Array) {
                    source = _Buffer.from(source)
                }
                if (!_Buffer.isBuffer(source)) {
                    throw new TypeError('Expected Buffer')
                }
                if (source.length === 0) {
                    return ''
                }
                // Skip & count leading zeroes.
                var zeroes = 0
                var length = 0
                var pbegin = 0
                var pend = source.length
                while (pbegin !== pend && source[pbegin] === 0) {
                    pbegin++
                    zeroes++
                }
                // Allocate enough space in big-endian base58 representation.
                var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
                var b58 = new Uint8Array(size)
                // Process the bytes.
                while (pbegin !== pend) {
                    var carry = source[pbegin]
                    // Apply "b58 = b58 * 256 + ch".
                    var i = 0
                    for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
                        carry += (256 * b58[it1]) >>> 0
                        b58[it1] = (carry % BASE) >>> 0
                        carry = (carry / BASE) >>> 0
                    }
                    if (carry !== 0) {
                        throw new Error('Non-zero carry')
                    }
                    length = i
                    pbegin++
                }
                // Skip leading zeroes in base58 result.
                var it2 = size - length
                while (it2 !== size && b58[it2] === 0) {
                    it2++
                }
                // Translate the result into a string.
                var str = LEADER.repeat(zeroes)
                for (; it2 < size; ++it2) {
                    str += ALPHABET.charAt(b58[it2])
                }
                return str
            }

            function decodeUnsafe(source) {
                if (typeof source !== 'string') {
                    throw new TypeError('Expected String')
                }
                if (source.length === 0) {
                    return _Buffer.alloc(0)
                }
                var psz = 0
                // Skip leading spaces.
                if (source[psz] === ' ') {
                    return
                }
                // Skip and count leading '1's.
                var zeroes = 0
                var length = 0
                while (source[psz] === LEADER) {
                    zeroes++
                    psz++
                }
                // Allocate enough space in big-endian base256 representation.
                var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
                var b256 = new Uint8Array(size)
                // Process the characters.
                while (source[psz]) {
                    // Decode character
                    var carry = BASE_MAP[source.charCodeAt(psz)]
                    // Invalid character
                    if (carry === 255) {
                        return
                    }
                    var i = 0
                    for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
                        carry += (BASE * b256[it3]) >>> 0
                        b256[it3] = (carry % 256) >>> 0
                        carry = (carry / 256) >>> 0
                    }
                    if (carry !== 0) {
                        throw new Error('Non-zero carry')
                    }
                    length = i
                    psz++
                }
                // Skip trailing spaces.
                if (source[psz] === ' ') {
                    return
                }
                // Skip leading zeroes in b256.
                var it4 = size - length
                while (it4 !== size && b256[it4] === 0) {
                    it4++
                }
                var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
                vch.fill(0x00, 0, zeroes)
                var j = zeroes
                while (it4 !== size) {
                    vch[j++] = b256[it4++]
                }
                return vch
            }

            function decode(string) {
                var buffer = decodeUnsafe(string)
                if (buffer) {
                    return buffer
                }
                throw new Error('Non-base' + BASE + ' character')
            }

            return {
                encode: encode,
                decodeUnsafe: decodeUnsafe,
                decode: decode
            }
        }

        module.exports = base

    }, {"safe-buffer": 172}],
    34: [function (require, module, exports) {
        'use strict'
        var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

// pre-compute lookup table
        var ALPHABET_MAP = {}
        for (var z = 0; z < ALPHABET.length; z++) {
            var x = ALPHABET.charAt(z)

            if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
            ALPHABET_MAP[x] = z
        }

        function polymodStep(pre) {
            var b = pre >> 25
            return ((pre & 0x1FFFFFF) << 5) ^
                (-((b >> 0) & 1) & 0x3b6a57b2) ^
                (-((b >> 1) & 1) & 0x26508e6d) ^
                (-((b >> 2) & 1) & 0x1ea119fa) ^
                (-((b >> 3) & 1) & 0x3d4233dd) ^
                (-((b >> 4) & 1) & 0x2a1462b3)
        }

        function prefixChk(prefix) {
            var chk = 1
            for (var i = 0; i < prefix.length; ++i) {
                var c = prefix.charCodeAt(i)
                if (c < 33 || c > 126) throw new Error('Invalid prefix (' + prefix + ')')

                chk = polymodStep(chk) ^ (c >> 5)
            }
            chk = polymodStep(chk)

            for (i = 0; i < prefix.length; ++i) {
                var v = prefix.charCodeAt(i)
                chk = polymodStep(chk) ^ (v & 0x1f)
            }
            return chk
        }

        function encode(prefix, words, LIMIT) {
            LIMIT = LIMIT || 90
            if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')

            prefix = prefix.toLowerCase()

            // determine chk mod
            var chk = prefixChk(prefix)
            var result = prefix + '1'
            for (var i = 0; i < words.length; ++i) {
                var x = words[i]
                if ((x >> 5) !== 0) throw new Error('Non 5-bit word')

                chk = polymodStep(chk) ^ x
                result += ALPHABET.charAt(x)
            }

            for (i = 0; i < 6; ++i) {
                chk = polymodStep(chk)
            }
            chk ^= 1

            for (i = 0; i < 6; ++i) {
                var v = (chk >> ((5 - i) * 5)) & 0x1f
                result += ALPHABET.charAt(v)
            }

            return result
        }

        function decode(str, LIMIT) {
            LIMIT = LIMIT || 90
            if (str.length < 8) throw new TypeError(str + ' too short')
            if (str.length > LIMIT) throw new TypeError('Exceeds length limit')

            // don't allow mixed case
            var lowered = str.toLowerCase()
            var uppered = str.toUpperCase()
            if (str !== lowered && str !== uppered) throw new Error('Mixed-case string ' + str)
            str = lowered

            var split = str.lastIndexOf('1')
            if (split === -1) throw new Error('No separator character for ' + str)
            if (split === 0) throw new Error('Missing prefix for ' + str)

            var prefix = str.slice(0, split)
            var wordChars = str.slice(split + 1)
            if (wordChars.length < 6) throw new Error('Data too short')

            var chk = prefixChk(prefix)
            var words = []
            for (var i = 0; i < wordChars.length; ++i) {
                var c = wordChars.charAt(i)
                var v = ALPHABET_MAP[c]
                if (v === undefined) throw new Error('Unknown character ' + c)
                chk = polymodStep(chk) ^ v

                // not in the checksum?
                if (i + 6 >= wordChars.length) continue
                words.push(v)
            }

            if (chk !== 1) throw new Error('Invalid checksum for ' + str)
            return {prefix: prefix, words: words}
        }

        function convert(data, inBits, outBits, pad) {
            var value = 0
            var bits = 0
            var maxV = (1 << outBits) - 1

            var result = []
            for (var i = 0; i < data.length; ++i) {
                value = (value << inBits) | data[i]
                bits += inBits

                while (bits >= outBits) {
                    bits -= outBits
                    result.push((value >> bits) & maxV)
                }
            }

            if (pad) {
                if (bits > 0) {
                    result.push((value << (outBits - bits)) & maxV)
                }
            } else {
                if (bits >= inBits) throw new Error('Excess padding')
                if ((value << (outBits - bits)) & maxV) throw new Error('Non-zero padding')
            }

            return result
        }

        function toWords(bytes) {
            return convert(bytes, 8, 5, true)
        }

        function fromWords(words) {
            return convert(words, 5, 8, false)
        }

        module.exports = {
            decode: decode,
            encode: encode,
            toWords: toWords,
            fromWords: fromWords
        }

    }, {}],
    35: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const parser_1 = require('../parser');

        function combine(psbts) {
            const self = psbts[0];
            const selfKeyVals = parser_1.psbtToKeyVals(self);
            const others = psbts.slice(1);
            if (others.length === 0) throw new Error('Combine: Nothing to combine');
            const selfTx = getTx(self);
            if (selfTx === undefined) {
                throw new Error('Combine: Self missing transaction');
            }
            const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
            const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
            const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
            for (const other of others) {
                const otherTx = getTx(other);
                if (
                    otherTx === undefined ||
                    !otherTx.toBuffer().equals(selfTx.toBuffer())
                ) {
                    throw new Error(
                        'Combine: One of the Psbts does not have the same transaction.',
                    );
                }
                const otherKeyVals = parser_1.psbtToKeyVals(other);
                const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
                otherGlobalSet.forEach(
                    keyPusher(
                        selfGlobalSet,
                        selfKeyVals.globalKeyVals,
                        otherKeyVals.globalKeyVals,
                    ),
                );
                const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
                otherInputSets.forEach((inputSet, idx) =>
                    inputSet.forEach(
                        keyPusher(
                            selfInputSets[idx],
                            selfKeyVals.inputKeyVals[idx],
                            otherKeyVals.inputKeyVals[idx],
                        ),
                    ),
                );
                const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
                otherOutputSets.forEach((outputSet, idx) =>
                    outputSet.forEach(
                        keyPusher(
                            selfOutputSets[idx],
                            selfKeyVals.outputKeyVals[idx],
                            otherKeyVals.outputKeyVals[idx],
                        ),
                    ),
                );
            }
            return parser_1.psbtFromKeyVals(selfTx, {
                globalMapKeyVals: selfKeyVals.globalKeyVals,
                inputKeyVals: selfKeyVals.inputKeyVals,
                outputKeyVals: selfKeyVals.outputKeyVals,
            });
        }

        exports.combine = combine;

        function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
            return key => {
                if (selfSet.has(key)) return;
                const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
                selfKeyVals.push(newKv);
                selfSet.add(key);
            };
        }

        function getTx(psbt) {
            return psbt.globalMap.unsignedTx;
        }

        function getKeySet(keyVals) {
            const set = new Set();
            keyVals.forEach(keyVal => {
                const hex = keyVal.key.toString('hex');
                if (set.has(hex))
                    throw new Error('Combine: KeyValue Map keys should be unique');
                set.add(hex);
            });
            return set;
        }

    }, {"../parser": 53}],
    36: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');
            const range = n => [...Array(n).keys()];

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
                    throw new Error(
                        'Decode Error: could not decode globalXpub with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
                    throw new Error(
                        'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                if ((keyVal.value.length / 4) % 1 !== 0) {
                    throw new Error(
                        'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
                    );
                }
                const extendedPubkey = keyVal.key.slice(1);
                const data = {
                    masterFingerprint: keyVal.value.slice(0, 4),
                    extendedPubkey,
                    path: 'm',
                };
                for (const i of range(keyVal.value.length / 4 - 1)) {
                    const val = keyVal.value.readUInt32LE(i * 4 + 4);
                    const isHard = !!(val & 0x80000000);
                    const idx = val & 0x7fffffff;
                    data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
                }
                return data;
            }

            exports.decode = decode;

            function encode(data) {
                const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
                const key = Buffer.concat([head, data.extendedPubkey]);
                const splitPath = data.path.split('/');
                const value = Buffer.allocUnsafe(splitPath.length * 4);
                data.masterFingerprint.copy(value, 0);
                let offset = 4;
                splitPath.slice(1).forEach(level => {
                    const isHard = level.slice(-1) === "'";
                    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
                    if (isHard) num += 0x80000000;
                    value.writeUInt32LE(num, offset);
                    offset += 4;
                });
                return {
                    key,
                    value,
                };
            }

            exports.encode = encode;
            exports.expected =
                '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';

            function check(data) {
                const epk = data.extendedPubkey;
                const mfp = data.masterFingerprint;
                const p = data.path;
                return (
                    Buffer.isBuffer(epk) &&
                    epk.length === 78 &&
                    [2, 3].indexOf(epk[45]) > -1 &&
                    Buffer.isBuffer(mfp) &&
                    mfp.length === 4 &&
                    typeof p === 'string' &&
                    !!p.match(/^m(\/\d+'?)+$/)
                );
            }

            exports.check = check;

            function canAddToArray(array, item, dupeSet) {
                const dupeString = item.extendedPubkey.toString('hex');
                if (dupeSet.has(dupeString)) return false;
                dupeSet.add(dupeString);
                return (
                    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
                );
            }

            exports.canAddToArray = canAddToArray;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    37: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function encode(data) {
                return {
                    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
                    value: data.toBuffer(),
                };
            }

            exports.encode = encode;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    38: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const typeFields_1 = require('../typeFields');
        const globalXpub = require('./global/globalXpub');
        const unsignedTx = require('./global/unsignedTx');
        const finalScriptSig = require('./input/finalScriptSig');
        const finalScriptWitness = require('./input/finalScriptWitness');
        const nonWitnessUtxo = require('./input/nonWitnessUtxo');
        const partialSig = require('./input/partialSig');
        const porCommitment = require('./input/porCommitment');
        const sighashType = require('./input/sighashType');
        const witnessUtxo = require('./input/witnessUtxo');
        const bip32Derivation = require('./shared/bip32Derivation');
        const checkPubkey = require('./shared/checkPubkey');
        const redeemScript = require('./shared/redeemScript');
        const witnessScript = require('./shared/witnessScript');
        const globals = {
            unsignedTx,
            globalXpub,
            // pass an Array of key bytes that require pubkey beside the key
            checkPubkey: checkPubkey.makeChecker([]),
        };
        exports.globals = globals;
        const inputs = {
            nonWitnessUtxo,
            partialSig,
            sighashType,
            finalScriptSig,
            finalScriptWitness,
            porCommitment,
            witnessUtxo,
            bip32Derivation: bip32Derivation.makeConverter(
                typeFields_1.InputTypes.BIP32_DERIVATION,
            ),
            redeemScript: redeemScript.makeConverter(
                typeFields_1.InputTypes.REDEEM_SCRIPT,
            ),
            witnessScript: witnessScript.makeConverter(
                typeFields_1.InputTypes.WITNESS_SCRIPT,
            ),
            checkPubkey: checkPubkey.makeChecker([
                typeFields_1.InputTypes.PARTIAL_SIG,
                typeFields_1.InputTypes.BIP32_DERIVATION,
            ]),
        };
        exports.inputs = inputs;
        const outputs = {
            bip32Derivation: bip32Derivation.makeConverter(
                typeFields_1.OutputTypes.BIP32_DERIVATION,
            ),
            redeemScript: redeemScript.makeConverter(
                typeFields_1.OutputTypes.REDEEM_SCRIPT,
            ),
            witnessScript: witnessScript.makeConverter(
                typeFields_1.OutputTypes.WITNESS_SCRIPT,
            ),
            checkPubkey: checkPubkey.makeChecker([
                typeFields_1.OutputTypes.BIP32_DERIVATION,
            ]),
        };
        exports.outputs = outputs;

    }, {
        "../typeFields": 56,
        "./global/globalXpub": 36,
        "./global/unsignedTx": 37,
        "./input/finalScriptSig": 39,
        "./input/finalScriptWitness": 40,
        "./input/nonWitnessUtxo": 41,
        "./input/partialSig": 42,
        "./input/porCommitment": 43,
        "./input/sighashType": 44,
        "./input/witnessUtxo": 45,
        "./shared/bip32Derivation": 46,
        "./shared/checkPubkey": 47,
        "./shared/redeemScript": 48,
        "./shared/witnessScript": 49
    }],
    39: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
                    throw new Error(
                        'Decode Error: could not decode finalScriptSig with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                return keyVal.value;
            }

            exports.decode = decode;

            function encode(data) {
                const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
                return {
                    key,
                    value: data,
                };
            }

            exports.encode = encode;
            exports.expected = 'Buffer';

            function check(data) {
                return Buffer.isBuffer(data);
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return !!currentData && !!newData && currentData.finalScriptSig === undefined;
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    40: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
                    throw new Error(
                        'Decode Error: could not decode finalScriptWitness with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                return keyVal.value;
            }

            exports.decode = decode;

            function encode(data) {
                const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
                return {
                    key,
                    value: data,
                };
            }

            exports.encode = encode;
            exports.expected = 'Buffer';

            function check(data) {
                return Buffer.isBuffer(data);
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return (
                    !!currentData && !!newData && currentData.finalScriptWitness === undefined
                );
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    41: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
                    throw new Error(
                        'Decode Error: could not decode nonWitnessUtxo with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                return keyVal.value;
            }

            exports.decode = decode;

            function encode(data) {
                return {
                    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
                    value: data,
                };
            }

            exports.encode = encode;
            exports.expected = 'Buffer';

            function check(data) {
                return Buffer.isBuffer(data);
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return (
                    !!currentData &&
                    !!newData &&
                    currentData.witnessUtxo === undefined &&
                    currentData.nonWitnessUtxo === undefined
                );
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    42: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
                    throw new Error(
                        'Decode Error: could not decode partialSig with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                if (
                    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
                    ![2, 3, 4].includes(keyVal.key[1])
                ) {
                    throw new Error(
                        'Decode Error: partialSig has invalid pubkey in key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                const pubkey = keyVal.key.slice(1);
                return {
                    pubkey,
                    signature: keyVal.value,
                };
            }

            exports.decode = decode;

            function encode(pSig) {
                const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
                return {
                    key: Buffer.concat([head, pSig.pubkey]),
                    value: pSig.signature,
                };
            }

            exports.encode = encode;
            exports.expected = '{ pubkey: Buffer; signature: Buffer; }';

            function check(data) {
                return (
                    Buffer.isBuffer(data.pubkey) &&
                    Buffer.isBuffer(data.signature) &&
                    [33, 65].includes(data.pubkey.length) &&
                    [2, 3, 4].includes(data.pubkey[0]) &&
                    isDerSigWithSighash(data.signature)
                );
            }

            exports.check = check;

            function isDerSigWithSighash(buf) {
                if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
                if (buf[0] !== 0x30) return false;
                if (buf.length !== buf[1] + 3) return false;
                if (buf[2] !== 0x02) return false;
                const rLen = buf[3];
                if (rLen > 33 || rLen < 1) return false;
                if (buf[3 + rLen + 1] !== 0x02) return false;
                const sLen = buf[3 + rLen + 2];
                if (sLen > 33 || sLen < 1) return false;
                if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
                return true;
            }

            function canAddToArray(array, item, dupeSet) {
                const dupeString = item.pubkey.toString('hex');
                if (dupeSet.has(dupeString)) return false;
                dupeSet.add(dupeString);
                return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
            }

            exports.canAddToArray = canAddToArray;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    43: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
                    throw new Error(
                        'Decode Error: could not decode porCommitment with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                return keyVal.value.toString('utf8');
            }

            exports.decode = decode;

            function encode(data) {
                const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
                return {
                    key,
                    value: Buffer.from(data, 'utf8'),
                };
            }

            exports.encode = encode;
            exports.expected = 'string';

            function check(data) {
                return typeof data === 'string';
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return !!currentData && !!newData && currentData.porCommitment === undefined;
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    44: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
                    throw new Error(
                        'Decode Error: could not decode sighashType with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                return keyVal.value.readUInt32LE(0);
            }

            exports.decode = decode;

            function encode(data) {
                const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
                const value = Buffer.allocUnsafe(4);
                value.writeUInt32LE(data, 0);
                return {
                    key,
                    value,
                };
            }

            exports.encode = encode;
            exports.expected = 'number';

            function check(data) {
                return typeof data === 'number';
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return !!currentData && !!newData && currentData.sighashType === undefined;
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "buffer": 3}],
    45: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const typeFields_1 = require('../../typeFields');
            const tools_1 = require('../tools');
            const varuint = require('../varint');

            function decode(keyVal) {
                if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
                    throw new Error(
                        'Decode Error: could not decode witnessUtxo with key 0x' +
                        keyVal.key.toString('hex'),
                    );
                }
                const value = tools_1.readUInt64LE(keyVal.value, 0);
                let _offset = 8;
                const scriptLen = varuint.decode(keyVal.value, _offset);
                _offset += varuint.encodingLength(scriptLen);
                const script = keyVal.value.slice(_offset);
                if (script.length !== scriptLen) {
                    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
                }
                return {
                    script,
                    value,
                };
            }

            exports.decode = decode;

            function encode(data) {
                const {script, value} = data;
                const varintLen = varuint.encodingLength(script.length);
                const result = Buffer.allocUnsafe(8 + varintLen + script.length);
                tools_1.writeUInt64LE(result, value, 0);
                varuint.encode(script.length, result, 8);
                script.copy(result, 8 + varintLen);
                return {
                    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
                    value: result,
                };
            }

            exports.encode = encode;
            exports.expected = '{ script: Buffer; value: number; }';

            function check(data) {
                return Buffer.isBuffer(data.script) && typeof data.value === 'number';
            }

            exports.check = check;

            function canAdd(currentData, newData) {
                return (
                    !!currentData &&
                    !!newData &&
                    currentData.witnessUtxo === undefined &&
                    currentData.nonWitnessUtxo === undefined
                );
            }

            exports.canAdd = canAdd;

        }).call(this, require("buffer").Buffer)

    }, {"../../typeFields": 56, "../tools": 50, "../varint": 51, "buffer": 3}],
    46: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const range = n => [...Array(n).keys()];

            function makeConverter(TYPE_BYTE) {
                function decode(keyVal) {
                    if (keyVal.key[0] !== TYPE_BYTE) {
                        throw new Error(
                            'Decode Error: could not decode bip32Derivation with key 0x' +
                            keyVal.key.toString('hex'),
                        );
                    }
                    if (
                        !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
                        ![2, 3, 4].includes(keyVal.key[1])
                    ) {
                        throw new Error(
                            'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
                            keyVal.key.toString('hex'),
                        );
                    }
                    if ((keyVal.value.length / 4) % 1 !== 0) {
                        throw new Error(
                            'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
                        );
                    }
                    const pubkey = keyVal.key.slice(1);
                    const data = {
                        masterFingerprint: keyVal.value.slice(0, 4),
                        pubkey,
                        path: 'm',
                    };
                    for (const i of range(keyVal.value.length / 4 - 1)) {
                        const val = keyVal.value.readUInt32LE(i * 4 + 4);
                        const isHard = !!(val & 0x80000000);
                        const idx = val & 0x7fffffff;
                        data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
                    }
                    return data;
                }

                function encode(data) {
                    const head = Buffer.from([TYPE_BYTE]);
                    const key = Buffer.concat([head, data.pubkey]);
                    const splitPath = data.path.split('/');
                    const value = Buffer.allocUnsafe(splitPath.length * 4);
                    data.masterFingerprint.copy(value, 0);
                    let offset = 4;
                    splitPath.slice(1).forEach(level => {
                        const isHard = level.slice(-1) === "'";
                        let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
                        if (isHard) num += 0x80000000;
                        value.writeUInt32LE(num, offset);
                        offset += 4;
                    });
                    return {
                        key,
                        value,
                    };
                }

                const expected =
                    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';

                function check(data) {
                    return (
                        Buffer.isBuffer(data.pubkey) &&
                        Buffer.isBuffer(data.masterFingerprint) &&
                        typeof data.path === 'string' &&
                        [33, 65].includes(data.pubkey.length) &&
                        [2, 3, 4].includes(data.pubkey[0]) &&
                        data.masterFingerprint.length === 4
                    );
                }

                function canAddToArray(array, item, dupeSet) {
                    const dupeString = item.pubkey.toString('hex');
                    if (dupeSet.has(dupeString)) return false;
                    dupeSet.add(dupeString);
                    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
                }

                return {
                    decode,
                    encode,
                    check,
                    expected,
                    canAddToArray,
                };
            }

            exports.makeConverter = makeConverter;

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    47: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});

        function makeChecker(pubkeyTypes) {
            return checkPubkey;

            function checkPubkey(keyVal) {
                let pubkey;
                if (pubkeyTypes.includes(keyVal.key[0])) {
                    pubkey = keyVal.key.slice(1);
                    if (
                        !(pubkey.length === 33 || pubkey.length === 65) ||
                        ![2, 3, 4].includes(pubkey[0])
                    ) {
                        throw new Error(
                            'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
                        );
                    }
                }
                return pubkey;
            }
        }

        exports.makeChecker = makeChecker;

    }, {}],
    48: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});

            function makeConverter(TYPE_BYTE) {
                function decode(keyVal) {
                    if (keyVal.key[0] !== TYPE_BYTE) {
                        throw new Error(
                            'Decode Error: could not decode redeemScript with key 0x' +
                            keyVal.key.toString('hex'),
                        );
                    }
                    return keyVal.value;
                }

                function encode(data) {
                    const key = Buffer.from([TYPE_BYTE]);
                    return {
                        key,
                        value: data,
                    };
                }

                const expected = 'Buffer';

                function check(data) {
                    return Buffer.isBuffer(data);
                }

                function canAdd(currentData, newData) {
                    return !!currentData && !!newData && currentData.redeemScript === undefined;
                }

                return {
                    decode,
                    encode,
                    check,
                    expected,
                    canAdd,
                };
            }

            exports.makeConverter = makeConverter;

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    49: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});

            function makeConverter(TYPE_BYTE) {
                function decode(keyVal) {
                    if (keyVal.key[0] !== TYPE_BYTE) {
                        throw new Error(
                            'Decode Error: could not decode witnessScript with key 0x' +
                            keyVal.key.toString('hex'),
                        );
                    }
                    return keyVal.value;
                }

                function encode(data) {
                    const key = Buffer.from([TYPE_BYTE]);
                    return {
                        key,
                        value: data,
                    };
                }

                const expected = 'Buffer';

                function check(data) {
                    return Buffer.isBuffer(data);
                }

                function canAdd(currentData, newData) {
                    return (
                        !!currentData && !!newData && currentData.witnessScript === undefined
                    );
                }

                return {
                    decode,
                    encode,
                    check,
                    expected,
                    canAdd,
                };
            }

            exports.makeConverter = makeConverter;

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    50: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const varuint = require('./varint');
            exports.range = n => [...Array(n).keys()];

            function reverseBuffer(buffer) {
                if (buffer.length < 1) return buffer;
                let j = buffer.length - 1;
                let tmp = 0;
                for (let i = 0; i < buffer.length / 2; i++) {
                    tmp = buffer[i];
                    buffer[i] = buffer[j];
                    buffer[j] = tmp;
                    j--;
                }
                return buffer;
            }

            exports.reverseBuffer = reverseBuffer;

            function keyValsToBuffer(keyVals) {
                const buffers = keyVals.map(keyValToBuffer);
                buffers.push(Buffer.from([0]));
                return Buffer.concat(buffers);
            }

            exports.keyValsToBuffer = keyValsToBuffer;

            function keyValToBuffer(keyVal) {
                const keyLen = keyVal.key.length;
                const valLen = keyVal.value.length;
                const keyVarIntLen = varuint.encodingLength(keyLen);
                const valVarIntLen = varuint.encodingLength(valLen);
                const buffer = Buffer.allocUnsafe(
                    keyVarIntLen + keyLen + valVarIntLen + valLen,
                );
                varuint.encode(keyLen, buffer, 0);
                keyVal.key.copy(buffer, keyVarIntLen);
                varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
                keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
                return buffer;
            }

            exports.keyValToBuffer = keyValToBuffer;

// https://github.com/feross/buffer/blob/master/index.js#L1127
            function verifuint(value, max) {
                if (typeof value !== 'number')
                    throw new Error('cannot write a non-number as a number');
                if (value < 0)
                    throw new Error('specified a negative value for writing an unsigned value');
                if (value > max) throw new Error('RangeError: value out of range');
                if (Math.floor(value) !== value)
                    throw new Error('value has a fractional component');
            }

            function readUInt64LE(buffer, offset) {
                const a = buffer.readUInt32LE(offset);
                let b = buffer.readUInt32LE(offset + 4);
                b *= 0x100000000;
                verifuint(b + a, 0x001fffffffffffff);
                return b + a;
            }

            exports.readUInt64LE = readUInt64LE;

            function writeUInt64LE(buffer, value, offset) {
                verifuint(value, 0x001fffffffffffff);
                buffer.writeInt32LE(value & -1, offset);
                buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
                return offset + 8;
            }

            exports.writeUInt64LE = writeUInt64LE;

        }).call(this, require("buffer").Buffer)

    }, {"./varint": 51, "buffer": 3}],
    51: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
// Number.MAX_SAFE_INTEGER
            const MAX_SAFE_INTEGER = 9007199254740991;

            function checkUInt53(n) {
                if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
                    throw new RangeError('value out of range');
            }

            function encode(_number, buffer, offset) {
                checkUInt53(_number);
                if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
                if (!Buffer.isBuffer(buffer))
                    throw new TypeError('buffer must be a Buffer instance');
                if (!offset) offset = 0;
                // 8 bit
                if (_number < 0xfd) {
                    buffer.writeUInt8(_number, offset);
                    Object.assign(encode, {bytes: 1});
                    // 16 bit
                } else if (_number <= 0xffff) {
                    buffer.writeUInt8(0xfd, offset);
                    buffer.writeUInt16LE(_number, offset + 1);
                    Object.assign(encode, {bytes: 3});
                    // 32 bit
                } else if (_number <= 0xffffffff) {
                    buffer.writeUInt8(0xfe, offset);
                    buffer.writeUInt32LE(_number, offset + 1);
                    Object.assign(encode, {bytes: 5});
                    // 64 bit
                } else {
                    buffer.writeUInt8(0xff, offset);
                    buffer.writeUInt32LE(_number >>> 0, offset + 1);
                    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
                    Object.assign(encode, {bytes: 9});
                }
                return buffer;
            }

            exports.encode = encode;

            function decode(buffer, offset) {
                if (!Buffer.isBuffer(buffer))
                    throw new TypeError('buffer must be a Buffer instance');
                if (!offset) offset = 0;
                const first = buffer.readUInt8(offset);
                // 8 bit
                if (first < 0xfd) {
                    Object.assign(decode, {bytes: 1});
                    return first;
                    // 16 bit
                } else if (first === 0xfd) {
                    Object.assign(decode, {bytes: 3});
                    return buffer.readUInt16LE(offset + 1);
                    // 32 bit
                } else if (first === 0xfe) {
                    Object.assign(decode, {bytes: 5});
                    return buffer.readUInt32LE(offset + 1);
                    // 64 bit
                } else {
                    Object.assign(decode, {bytes: 9});
                    const lo = buffer.readUInt32LE(offset + 1);
                    const hi = buffer.readUInt32LE(offset + 5);
                    const _number = hi * 0x0100000000 + lo;
                    checkUInt53(_number);
                    return _number;
                }
            }

            exports.decode = decode;

            function encodingLength(_number) {
                checkUInt53(_number);
                return _number < 0xfd
                    ? 1
                    : _number <= 0xffff
                        ? 3
                        : _number <= 0xffffffff
                            ? 5
                            : 9;
            }

            exports.encodingLength = encodingLength;

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    52: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const convert = require('../converter');
            const tools_1 = require('../converter/tools');
            const varuint = require('../converter/varint');
            const typeFields_1 = require('../typeFields');

            function psbtFromBuffer(buffer, txGetter) {
                let offset = 0;

                function varSlice() {
                    const keyLen = varuint.decode(buffer, offset);
                    offset += varuint.encodingLength(keyLen);
                    const key = buffer.slice(offset, offset + keyLen);
                    offset += keyLen;
                    return key;
                }

                function readUInt32BE() {
                    const num = buffer.readUInt32BE(offset);
                    offset += 4;
                    return num;
                }

                function readUInt8() {
                    const num = buffer.readUInt8(offset);
                    offset += 1;
                    return num;
                }

                function getKeyValue() {
                    const key = varSlice();
                    const value = varSlice();
                    return {
                        key,
                        value,
                    };
                }

                function checkEndOfKeyValPairs() {
                    if (offset >= buffer.length) {
                        throw new Error('Format Error: Unexpected End of PSBT');
                    }
                    const isEnd = buffer.readUInt8(offset) === 0;
                    if (isEnd) {
                        offset++;
                    }
                    return isEnd;
                }

                if (readUInt32BE() !== 0x70736274) {
                    throw new Error('Format Error: Invalid Magic Number');
                }
                if (readUInt8() !== 0xff) {
                    throw new Error(
                        'Format Error: Magic Number must be followed by 0xff separator',
                    );
                }
                const globalMapKeyVals = [];
                const globalKeyIndex = {};
                while (!checkEndOfKeyValPairs()) {
                    const keyVal = getKeyValue();
                    const hexKey = keyVal.key.toString('hex');
                    if (globalKeyIndex[hexKey]) {
                        throw new Error(
                            'Format Error: Keys must be unique for global keymap: key ' + hexKey,
                        );
                    }
                    globalKeyIndex[hexKey] = 1;
                    globalMapKeyVals.push(keyVal);
                }
                const unsignedTxMaps = globalMapKeyVals.filter(
                    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
                );
                if (unsignedTxMaps.length !== 1) {
                    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
                }
                const unsignedTx = txGetter(unsignedTxMaps[0].value);
                // Get input and output counts to loop the respective fields
                const {inputCount, outputCount} = unsignedTx.getInputOutputCounts();
                const inputKeyVals = [];
                const outputKeyVals = [];
                // Get input fields
                for (const index of tools_1.range(inputCount)) {
                    const inputKeyIndex = {};
                    const input = [];
                    while (!checkEndOfKeyValPairs()) {
                        const keyVal = getKeyValue();
                        const hexKey = keyVal.key.toString('hex');
                        if (inputKeyIndex[hexKey]) {
                            throw new Error(
                                'Format Error: Keys must be unique for each input: ' +
                                'input index ' +
                                index +
                                ' key ' +
                                hexKey,
                            );
                        }
                        inputKeyIndex[hexKey] = 1;
                        input.push(keyVal);
                    }
                    inputKeyVals.push(input);
                }
                for (const index of tools_1.range(outputCount)) {
                    const outputKeyIndex = {};
                    const output = [];
                    while (!checkEndOfKeyValPairs()) {
                        const keyVal = getKeyValue();
                        const hexKey = keyVal.key.toString('hex');
                        if (outputKeyIndex[hexKey]) {
                            throw new Error(
                                'Format Error: Keys must be unique for each output: ' +
                                'output index ' +
                                index +
                                ' key ' +
                                hexKey,
                            );
                        }
                        outputKeyIndex[hexKey] = 1;
                        output.push(keyVal);
                    }
                    outputKeyVals.push(output);
                }
                return psbtFromKeyVals(unsignedTx, {
                    globalMapKeyVals,
                    inputKeyVals,
                    outputKeyVals,
                });
            }

            exports.psbtFromBuffer = psbtFromBuffer;

            function checkKeyBuffer(type, keyBuf, keyNum) {
                if (!keyBuf.equals(Buffer.from([keyNum]))) {
                    throw new Error(
                        `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
                    );
                }
            }

            exports.checkKeyBuffer = checkKeyBuffer;

            function psbtFromKeyVals(
                unsignedTx,
                {globalMapKeyVals, inputKeyVals, outputKeyVals},
            ) {
                // That was easy :-)
                const globalMap = {
                    unsignedTx,
                };
                let txCount = 0;
                for (const keyVal of globalMapKeyVals) {
                    // If a globalMap item needs pubkey, uncomment
                    // const pubkey = convert.globals.checkPubkey(keyVal);
                    switch (keyVal.key[0]) {
                        case typeFields_1.GlobalTypes.UNSIGNED_TX:
                            checkKeyBuffer(
                                'global',
                                keyVal.key,
                                typeFields_1.GlobalTypes.UNSIGNED_TX,
                            );
                            if (txCount > 0) {
                                throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
                            }
                            txCount++;
                            break;
                        case typeFields_1.GlobalTypes.GLOBAL_XPUB:
                            if (globalMap.globalXpub === undefined) {
                                globalMap.globalXpub = [];
                            }
                            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
                            break;
                        default:
                            // This will allow inclusion during serialization.
                            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
                            globalMap.unknownKeyVals.push(keyVal);
                    }
                }
                // Get input and output counts to loop the respective fields
                const inputCount = inputKeyVals.length;
                const outputCount = outputKeyVals.length;
                const inputs = [];
                const outputs = [];
                // Get input fields
                for (const index of tools_1.range(inputCount)) {
                    const input = {};
                    for (const keyVal of inputKeyVals[index]) {
                        convert.inputs.checkPubkey(keyVal);
                        switch (keyVal.key[0]) {
                            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.NON_WITNESS_UTXO,
                                );
                                if (
                                    input.nonWitnessUtxo !== undefined ||
                                    input.witnessUtxo !== undefined
                                ) {
                                    throw new Error(
                                        'Format Error: Input has multiple [NON_]WITNESS_UTXO',
                                    );
                                }
                                input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.WITNESS_UTXO:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.WITNESS_UTXO,
                                );
                                if (
                                    input.nonWitnessUtxo !== undefined ||
                                    input.witnessUtxo !== undefined
                                ) {
                                    throw new Error(
                                        'Format Error: Input has multiple [NON_]WITNESS_UTXO',
                                    );
                                }
                                input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.PARTIAL_SIG:
                                if (input.partialSig === undefined) {
                                    input.partialSig = [];
                                }
                                input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
                                break;
                            case typeFields_1.InputTypes.SIGHASH_TYPE:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.SIGHASH_TYPE,
                                );
                                if (input.sighashType !== undefined) {
                                    throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
                                }
                                input.sighashType = convert.inputs.sighashType.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.REDEEM_SCRIPT:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.REDEEM_SCRIPT,
                                );
                                if (input.redeemScript !== undefined) {
                                    throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
                                }
                                input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.WITNESS_SCRIPT:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.WITNESS_SCRIPT,
                                );
                                if (input.witnessScript !== undefined) {
                                    throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
                                }
                                input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.BIP32_DERIVATION:
                                if (input.bip32Derivation === undefined) {
                                    input.bip32Derivation = [];
                                }
                                input.bip32Derivation.push(
                                    convert.inputs.bip32Derivation.decode(keyVal),
                                );
                                break;
                            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.FINAL_SCRIPTSIG,
                                );
                                input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
                                break;
                            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
                                );
                                input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                                    keyVal,
                                );
                                break;
                            case typeFields_1.InputTypes.POR_COMMITMENT:
                                checkKeyBuffer(
                                    'input',
                                    keyVal.key,
                                    typeFields_1.InputTypes.POR_COMMITMENT,
                                );
                                input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
                                break;
                            default:
                                // This will allow inclusion during serialization.
                                if (!input.unknownKeyVals) input.unknownKeyVals = [];
                                input.unknownKeyVals.push(keyVal);
                        }
                    }
                    inputs.push(input);
                }
                for (const index of tools_1.range(outputCount)) {
                    const output = {};
                    for (const keyVal of outputKeyVals[index]) {
                        convert.outputs.checkPubkey(keyVal);
                        switch (keyVal.key[0]) {
                            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
                                checkKeyBuffer(
                                    'output',
                                    keyVal.key,
                                    typeFields_1.OutputTypes.REDEEM_SCRIPT,
                                );
                                if (output.redeemScript !== undefined) {
                                    throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
                                }
                                output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
                                break;
                            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
                                checkKeyBuffer(
                                    'output',
                                    keyVal.key,
                                    typeFields_1.OutputTypes.WITNESS_SCRIPT,
                                );
                                if (output.witnessScript !== undefined) {
                                    throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
                                }
                                output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
                                break;
                            case typeFields_1.OutputTypes.BIP32_DERIVATION:
                                if (output.bip32Derivation === undefined) {
                                    output.bip32Derivation = [];
                                }
                                output.bip32Derivation.push(
                                    convert.outputs.bip32Derivation.decode(keyVal),
                                );
                                break;
                            default:
                                if (!output.unknownKeyVals) output.unknownKeyVals = [];
                                output.unknownKeyVals.push(keyVal);
                        }
                    }
                    outputs.push(output);
                }
                return {globalMap, inputs, outputs};
            }

            exports.psbtFromKeyVals = psbtFromKeyVals;

        }).call(this, require("buffer").Buffer)

    }, {"../converter": 38, "../converter/tools": 50, "../converter/varint": 51, "../typeFields": 56, "buffer": 3}],
    53: [function (require, module, exports) {
        'use strict';

        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }

        Object.defineProperty(exports, '__esModule', {value: true});
        __export(require('./fromBuffer'));
        __export(require('./toBuffer'));

    }, {"./fromBuffer": 52, "./toBuffer": 54}],
    54: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const convert = require('../converter');
            const tools_1 = require('../converter/tools');

            function psbtToBuffer({globalMap, inputs, outputs}) {
                const {globalKeyVals, inputKeyVals, outputKeyVals} = psbtToKeyVals({
                    globalMap,
                    inputs,
                    outputs,
                });
                const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
                const keyValsOrEmptyToBuffer = keyVals =>
                    keyVals.length === 0
                        ? [Buffer.from([0])]
                        : keyVals.map(tools_1.keyValsToBuffer);
                const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
                const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
                const header = Buffer.allocUnsafe(5);
                header.writeUIntBE(0x70736274ff, 0, 5);
                return Buffer.concat(
                    [header, globalBuffer].concat(inputBuffers, outputBuffers),
                );
            }

            exports.psbtToBuffer = psbtToBuffer;
            const sortKeyVals = (a, b) => {
                return a.key.compare(b.key);
            };

            function keyValsFromMap(keyValMap, converterFactory) {
                const keyHexSet = new Set();
                const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
                    if (key === 'unknownKeyVals') return result;
                    // We are checking for undefined anyways. So ignore TS error
                    // @ts-ignore
                    const converter = converterFactory[key];
                    if (converter === undefined) return result;
                    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
                        converter.encode,
                    );
                    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
                    keyHexes.forEach(hex => {
                        if (keyHexSet.has(hex))
                            throw new Error('Serialize Error: Duplicate key: ' + hex);
                        keyHexSet.add(hex);
                    });
                    return result.concat(encodedKeyVals);
                }, []);
                // Get other keyVals that have not yet been gotten
                const otherKeyVals = keyValMap.unknownKeyVals
                    ? keyValMap.unknownKeyVals.filter(keyVal => {
                        return !keyHexSet.has(keyVal.key.toString('hex'));
                    })
                    : [];
                return keyVals.concat(otherKeyVals).sort(sortKeyVals);
            }

            function psbtToKeyVals({globalMap, inputs, outputs}) {
                // First parse the global keyVals
                // Get any extra keyvals to pass along
                return {
                    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
                    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
                    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
                };
            }

            exports.psbtToKeyVals = psbtToKeyVals;

        }).call(this, require("buffer").Buffer)

    }, {"../converter": 38, "../converter/tools": 50, "buffer": 3}],
    55: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const combiner_1 = require('./combiner');
            const parser_1 = require('./parser');
            const typeFields_1 = require('./typeFields');
            const utils_1 = require('./utils');

            class Psbt {
                constructor(tx) {
                    this.inputs = [];
                    this.outputs = [];
                    this.globalMap = {
                        unsignedTx: tx,
                    };
                }

                static fromBase64(data, txFromBuffer) {
                    const buffer = Buffer.from(data, 'base64');
                    return this.fromBuffer(buffer, txFromBuffer);
                }

                static fromHex(data, txFromBuffer) {
                    const buffer = Buffer.from(data, 'hex');
                    return this.fromBuffer(buffer, txFromBuffer);
                }

                static fromBuffer(buffer, txFromBuffer) {
                    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
                    const psbt = new this(results.globalMap.unsignedTx);
                    Object.assign(psbt, results);
                    return psbt;
                }

                toBase64() {
                    const buffer = this.toBuffer();
                    return buffer.toString('base64');
                }

                toHex() {
                    const buffer = this.toBuffer();
                    return buffer.toString('hex');
                }

                toBuffer() {
                    return parser_1.psbtToBuffer(this);
                }

                updateGlobal(updateData) {
                    utils_1.updateGlobal(updateData, this.globalMap);
                    return this;
                }

                updateInput(inputIndex, updateData) {
                    const input = utils_1.checkForInput(this.inputs, inputIndex);
                    utils_1.updateInput(updateData, input);
                    return this;
                }

                updateOutput(outputIndex, updateData) {
                    const output = utils_1.checkForOutput(this.outputs, outputIndex);
                    utils_1.updateOutput(updateData, output);
                    return this;
                }

                addUnknownKeyValToGlobal(keyVal) {
                    utils_1.checkHasKey(
                        keyVal,
                        this.globalMap.unknownKeyVals,
                        utils_1.getEnumLength(typeFields_1.GlobalTypes),
                    );
                    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
                    this.globalMap.unknownKeyVals.push(keyVal);
                    return this;
                }

                addUnknownKeyValToInput(inputIndex, keyVal) {
                    const input = utils_1.checkForInput(this.inputs, inputIndex);
                    utils_1.checkHasKey(
                        keyVal,
                        input.unknownKeyVals,
                        utils_1.getEnumLength(typeFields_1.InputTypes),
                    );
                    if (!input.unknownKeyVals) input.unknownKeyVals = [];
                    input.unknownKeyVals.push(keyVal);
                    return this;
                }

                addUnknownKeyValToOutput(outputIndex, keyVal) {
                    const output = utils_1.checkForOutput(this.outputs, outputIndex);
                    utils_1.checkHasKey(
                        keyVal,
                        output.unknownKeyVals,
                        utils_1.getEnumLength(typeFields_1.OutputTypes),
                    );
                    if (!output.unknownKeyVals) output.unknownKeyVals = [];
                    output.unknownKeyVals.push(keyVal);
                    return this;
                }

                addInput(inputData) {
                    this.globalMap.unsignedTx.addInput(inputData);
                    this.inputs.push({
                        unknownKeyVals: [],
                    });
                    const addKeyVals = inputData.unknownKeyVals || [];
                    const inputIndex = this.inputs.length - 1;
                    if (!Array.isArray(addKeyVals)) {
                        throw new Error('unknownKeyVals must be an Array');
                    }
                    addKeyVals.forEach(keyVal =>
                        this.addUnknownKeyValToInput(inputIndex, keyVal),
                    );
                    utils_1.addInputAttributes(this.inputs, inputData);
                    return this;
                }

                addOutput(outputData) {
                    this.globalMap.unsignedTx.addOutput(outputData);
                    this.outputs.push({
                        unknownKeyVals: [],
                    });
                    const addKeyVals = outputData.unknownKeyVals || [];
                    const outputIndex = this.outputs.length - 1;
                    if (!Array.isArray(addKeyVals)) {
                        throw new Error('unknownKeyVals must be an Array');
                    }
                    addKeyVals.forEach(keyVal =>
                        this.addUnknownKeyValToInput(outputIndex, keyVal),
                    );
                    utils_1.addOutputAttributes(this.outputs, outputData);
                    return this;
                }

                clearFinalizedInput(inputIndex) {
                    const input = utils_1.checkForInput(this.inputs, inputIndex);
                    utils_1.inputCheckUncleanFinalized(inputIndex, input);
                    for (const key of Object.keys(input)) {
                        if (
                            ![
                                'witnessUtxo',
                                'nonWitnessUtxo',
                                'finalScriptSig',
                                'finalScriptWitness',
                                'unknownKeyVals',
                            ].includes(key)
                        ) {
                            // @ts-ignore
                            delete input[key];
                        }
                    }
                    return this;
                }

                combine(...those) {
                    // Combine this with those.
                    // Return self for chaining.
                    const result = combiner_1.combine([this].concat(those));
                    Object.assign(this, result);
                    return this;
                }

                getTransaction() {
                    return this.globalMap.unsignedTx.toBuffer();
                }
            }

            exports.Psbt = Psbt;

        }).call(this, require("buffer").Buffer)

    }, {"./combiner": 35, "./parser": 53, "./typeFields": 56, "./utils": 57, "buffer": 3}],
    56: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        var GlobalTypes;
        (function (GlobalTypes) {
            GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
            GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
        })((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
        exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
        var InputTypes;
        (function (InputTypes) {
            InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
            InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
            InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
            InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
            InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
            InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
            InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
            InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
            InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
            InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
        })((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
        exports.INPUT_TYPE_NAMES = [
            'nonWitnessUtxo',
            'witnessUtxo',
            'partialSig',
            'sighashType',
            'redeemScript',
            'witnessScript',
            'bip32Derivation',
            'finalScriptSig',
            'finalScriptWitness',
            'porCommitment',
        ];
        var OutputTypes;
        (function (OutputTypes) {
            OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
            OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
            OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
        })((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
        exports.OUTPUT_TYPE_NAMES = [
            'redeemScript',
            'witnessScript',
            'bip32Derivation',
        ];

    }, {}],
    57: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const converter = require('./converter');

            function checkForInput(inputs, inputIndex) {
                const input = inputs[inputIndex];
                if (input === undefined) throw new Error(`No input #${inputIndex}`);
                return input;
            }

            exports.checkForInput = checkForInput;

            function checkForOutput(outputs, outputIndex) {
                const output = outputs[outputIndex];
                if (output === undefined) throw new Error(`No output #${outputIndex}`);
                return output;
            }

            exports.checkForOutput = checkForOutput;

            function checkHasKey(checkKeyVal, keyVals, enumLength) {
                if (checkKeyVal.key[0] < enumLength) {
                    throw new Error(
                        `Use the method for your specific key instead of addUnknownKeyVal*`,
                    );
                }
                if (
                    keyVals &&
                    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
                ) {
                    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
                }
            }

            exports.checkHasKey = checkHasKey;

            function getEnumLength(myenum) {
                let count = 0;
                Object.keys(myenum).forEach(val => {
                    if (Number(isNaN(Number(val)))) {
                        count++;
                    }
                });
                return count;
            }

            exports.getEnumLength = getEnumLength;

            function inputCheckUncleanFinalized(inputIndex, input) {
                let result = false;
                if (!input.nonWitnessUtxo !== !input.witnessUtxo) {
                    const needScriptSig = !!input.redeemScript;
                    const needWitnessScript = !!input.witnessScript;
                    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
                    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
                    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
                    result = scriptSigOK && witnessScriptOK && hasOneFinal;
                }
                if (result === false) {
                    throw new Error(
                        `Input #${inputIndex} has too much or too little data to clean`,
                    );
                }
            }

            exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;

            function throwForUpdateMaker(typeName, name, expected, data) {
                throw new Error(
                    `Data for ${typeName} key ${name} is incorrect: Expected ` +
                    `${expected} and got ${JSON.stringify(data)}`,
                );
            }

            function updateMaker(typeName) {
                return (updateData, mainData) => {
                    for (const name of Object.keys(updateData)) {
                        // @ts-ignore
                        const data = updateData[name];
                        // @ts-ignore
                        const {canAdd, canAddToArray, check, expected} =
                            // @ts-ignore
                        converter[typeName + 's'][name] || {};
                        const isArray = !!canAddToArray;
                        // If unknown data. ignore and do not add
                        if (check) {
                            if (isArray) {
                                if (
                                    !Array.isArray(data) ||
                                    // @ts-ignore
                                    (mainData[name] && !Array.isArray(mainData[name]))
                                ) {
                                    throw new Error(`Key type ${name} must be an array`);
                                }
                                if (!data.every(check)) {
                                    throwForUpdateMaker(typeName, name, expected, data);
                                }
                                // @ts-ignore
                                const arr = mainData[name] || [];
                                const dupeCheckSet = new Set();
                                if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
                                    throw new Error('Can not add duplicate data to array');
                                }
                                // @ts-ignore
                                mainData[name] = arr.concat(data);
                            } else {
                                if (!check(data)) {
                                    throwForUpdateMaker(typeName, name, expected, data);
                                }
                                if (!canAdd(mainData, data)) {
                                    throw new Error(`Can not add duplicate data to ${typeName}`);
                                }
                                // @ts-ignore
                                mainData[name] = data;
                            }
                        }
                    }
                };
            }

            exports.updateGlobal = updateMaker('global');
            exports.updateInput = updateMaker('input');
            exports.updateOutput = updateMaker('output');

            function addInputAttributes(inputs, data) {
                const index = inputs.length - 1;
                const input = checkForInput(inputs, index);
                exports.updateInput(data, input);
            }

            exports.addInputAttributes = addInputAttributes;

            function addOutputAttributes(outputs, data) {
                const index = outputs.length - 1;
                const output = checkForInput(outputs, index);
                exports.updateOutput(data, output);
            }

            exports.addOutputAttributes = addOutputAttributes;

            function defaultVersionSetter(version, txBuf) {
                if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
                    throw new Error('Set Version: Invalid Transaction');
                }
                txBuf.writeUInt32LE(version, 0);
                return txBuf;
            }

            exports.defaultVersionSetter = defaultVersionSetter;

            function defaultLocktimeSetter(locktime, txBuf) {
                if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
                    throw new Error('Set Locktime: Invalid Transaction');
                }
                txBuf.writeUInt32LE(locktime, txBuf.length - 4);
                return txBuf;
            }

            exports.defaultLocktimeSetter = defaultLocktimeSetter;

        }).call(this, {"isBuffer": require("../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})

    }, {
        "../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js": 8,
        "./converter": 38
    }],
    58: [function (require, module, exports) {
        (function (Buffer) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            const crypto = require("./crypto");
            const bs58check = require('bs58check');
            const ecc = require('tiny-secp256k1');
            const typeforce = require('typeforce');
            const wif = require('wif');
            const UINT256_TYPE = typeforce.BufferN(32);
            const NETWORK_TYPE = typeforce.compile({
                wif: typeforce.UInt8,
                bip32: {
                    public: typeforce.UInt32,
                    private: typeforce.UInt32,
                },
            });
            const BITCOIN = {
                messagePrefix: '\x18Bitcoin Signed Message:\n',
                bech32: 'bc',
                bip32: {
                    public: 0x0488b21e,
                    private: 0x0488ade4,
                },
                pubKeyHash: 0x00,
                scriptHash: 0x05,
                wif: 0x80,
            };
            const HIGHEST_BIT = 0x80000000;
            const UINT31_MAX = Math.pow(2, 31) - 1;

            function BIP32Path(value) {
                return (typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null);
            }

            function UInt31(value) {
                return typeforce.UInt32(value) && value <= UINT31_MAX;
            }

            class BIP32 {
                constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
                    this.__D = __D;
                    this.__Q = __Q;
                    this.chainCode = chainCode;
                    this.network = network;
                    this.__DEPTH = __DEPTH;
                    this.__INDEX = __INDEX;
                    this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
                    typeforce(NETWORK_TYPE, network);
                    this.lowR = false;
                }

                get depth() {
                    return this.__DEPTH;
                }

                get index() {
                    return this.__INDEX;
                }

                get parentFingerprint() {
                    return this.__PARENT_FINGERPRINT;
                }

                get publicKey() {
                    if (this.__Q === undefined)
                        this.__Q = ecc.pointFromScalar(this.__D, true);
                    return this.__Q;
                }

                get privateKey() {
                    return this.__D;
                }

                get identifier() {
                    return crypto.hash160(this.publicKey);
                }

                get fingerprint() {
                    return this.identifier.slice(0, 4);
                }

                // Private === not neutered
                // Public === neutered
                isNeutered() {
                    return this.__D === undefined;
                }

                neutered() {
                    return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
                }

                toBase58() {
                    const network = this.network;
                    const version = !this.isNeutered()
                        ? network.bip32.private
                        : network.bip32.public;
                    const buffer = Buffer.allocUnsafe(78);
                    // 4 bytes: version bytes
                    buffer.writeUInt32BE(version, 0);
                    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
                    buffer.writeUInt8(this.depth, 4);
                    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
                    buffer.writeUInt32BE(this.parentFingerprint, 5);
                    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
                    // This is encoded in big endian. (0x00000000 if master key)
                    buffer.writeUInt32BE(this.index, 9);
                    // 32 bytes: the chain code
                    this.chainCode.copy(buffer, 13);
                    // 33 bytes: the public key or private key data
                    if (!this.isNeutered()) {
                        // 0x00 + k for private keys
                        buffer.writeUInt8(0, 45);
                        this.privateKey.copy(buffer, 46);
                        // 33 bytes: the public key
                    } else {
                        // X9.62 encoding for public keys
                        this.publicKey.copy(buffer, 45);
                    }
                    return bs58check.encode(buffer);
                }

                toWIF() {
                    if (!this.privateKey)
                        throw new TypeError('Missing private key');
                    return wif.encode(this.network.wif, this.privateKey, true);
                }

                // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
                derive(index) {
                    typeforce(typeforce.UInt32, index);
                    const isHardened = index >= HIGHEST_BIT;
                    const data = Buffer.allocUnsafe(37);
                    // Hardened child
                    if (isHardened) {
                        if (this.isNeutered())
                            throw new TypeError('Missing private key for hardened child key');
                        // data = 0x00 || ser256(kpar) || ser32(index)
                        data[0] = 0x00;
                        this.privateKey.copy(data, 1);
                        data.writeUInt32BE(index, 33);
                        // Normal child
                    } else {
                        // data = serP(point(kpar)) || ser32(index)
                        //      = serP(Kpar) || ser32(index)
                        this.publicKey.copy(data, 0);
                        data.writeUInt32BE(index, 33);
                    }
                    const I = crypto.hmacSHA512(this.chainCode, data);
                    const IL = I.slice(0, 32);
                    const IR = I.slice(32);
                    // if parse256(IL) >= n, proceed with the next value for i
                    if (!ecc.isPrivate(IL))
                        return this.derive(index + 1);
                    // Private parent key -> private child key
                    let hd;
                    if (!this.isNeutered()) {
                        // ki = parse256(IL) + kpar (mod n)
                        const ki = ecc.privateAdd(this.privateKey, IL);
                        // In case ki == 0, proceed with the next value for i
                        if (ki == null)
                            return this.derive(index + 1);
                        hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
                        // Public parent key -> public child key
                    } else {
                        // Ki = point(parse256(IL)) + Kpar
                        //    = G*IL + Kpar
                        const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
                        // In case Ki is the point at infinity, proceed with the next value for i
                        if (Ki === null)
                            return this.derive(index + 1);
                        hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
                    }
                    return hd;
                }

                deriveHardened(index) {
                    typeforce(UInt31, index);
                    // Only derives hardened private keys by default
                    return this.derive(index + HIGHEST_BIT);
                }

                derivePath(path) {
                    typeforce(BIP32Path, path);
                    let splitPath = path.split('/');
                    if (splitPath[0] === 'm') {
                        if (this.parentFingerprint)
                            throw new TypeError('Expected master, got child');
                        splitPath = splitPath.slice(1);
                    }
                    return splitPath.reduce((prevHd, indexStr) => {
                        let index;
                        if (indexStr.slice(-1) === `'`) {
                            index = parseInt(indexStr.slice(0, -1), 10);
                            return prevHd.deriveHardened(index);
                        } else {
                            index = parseInt(indexStr, 10);
                            return prevHd.derive(index);
                        }
                    }, this);
                }

                sign(hash, lowR) {
                    if (!this.privateKey)
                        throw new Error('Missing private key');
                    if (lowR === undefined)
                        lowR = this.lowR;
                    if (lowR === false) {
                        return ecc.sign(hash, this.privateKey);
                    } else {
                        let sig = ecc.sign(hash, this.privateKey);
                        const extraData = Buffer.alloc(32, 0);
                        let counter = 0;
                        // if first try is lowR, skip the loop
                        // for second try and on, add extra entropy counting up
                        while (sig[0] > 0x7f) {
                            counter++;
                            extraData.writeUIntLE(counter, 0, 6);
                            sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
                        }
                        return sig;
                    }
                }

                verify(hash, signature) {
                    return ecc.verify(hash, this.publicKey, signature);
                }
            }

            function fromBase58(inString, network) {
                const buffer = bs58check.decode(inString);
                if (buffer.length !== 78)
                    throw new TypeError('Invalid buffer length');
                network = network || BITCOIN;
                // 4 bytes: version bytes
                const version = buffer.readUInt32BE(0);
                if (version !== network.bip32.private && version !== network.bip32.public)
                    throw new TypeError('Invalid network version');
                // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
                const depth = buffer[4];
                // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
                const parentFingerprint = buffer.readUInt32BE(5);
                if (depth === 0) {
                    if (parentFingerprint !== 0x00000000)
                        throw new TypeError('Invalid parent fingerprint');
                }
                // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
                // This is encoded in MSB order. (0x00000000 if master key)
                const index = buffer.readUInt32BE(9);
                if (depth === 0 && index !== 0)
                    throw new TypeError('Invalid index');
                // 32 bytes: the chain code
                const chainCode = buffer.slice(13, 45);
                let hd;
                // 33 bytes: private key data (0x00 + k)
                if (version === network.bip32.private) {
                    if (buffer.readUInt8(45) !== 0x00)
                        throw new TypeError('Invalid private key');
                    const k = buffer.slice(46, 78);
                    hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
                    // 33 bytes: public key data (0x02 + X or 0x03 + X)
                } else {
                    const X = buffer.slice(45, 78);
                    hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
                }
                return hd;
            }

            exports.fromBase58 = fromBase58;

            function fromPrivateKey(privateKey, chainCode, network) {
                return fromPrivateKeyLocal(privateKey, chainCode, network);
            }

            exports.fromPrivateKey = fromPrivateKey;

            function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
                typeforce({
                    privateKey: UINT256_TYPE,
                    chainCode: UINT256_TYPE,
                }, {privateKey, chainCode});
                network = network || BITCOIN;
                if (!ecc.isPrivate(privateKey))
                    throw new TypeError('Private key not in range [1, n)');
                return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
            }

            function fromPublicKey(publicKey, chainCode, network) {
                return fromPublicKeyLocal(publicKey, chainCode, network);
            }

            exports.fromPublicKey = fromPublicKey;

            function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
                typeforce({
                    publicKey: typeforce.BufferN(33),
                    chainCode: UINT256_TYPE,
                }, {publicKey, chainCode});
                network = network || BITCOIN;
                // verify the X coordinate is a point on the curve
                if (!ecc.isPoint(publicKey))
                    throw new TypeError('Point is not on the curve');
                return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
            }

            function fromSeed(seed, network) {
                typeforce(typeforce.Buffer, seed);
                if (seed.length < 16)
                    throw new TypeError('Seed should be at least 128 bits');
                if (seed.length > 64)
                    throw new TypeError('Seed should be at most 512 bits');
                network = network || BITCOIN;
                const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
                const IL = I.slice(0, 32);
                const IR = I.slice(32);
                return fromPrivateKey(IL, IR, network);
            }

            exports.fromSeed = fromSeed;

        }).call(this, require("buffer").Buffer)

    }, {"./crypto": 59, "bs58check": 123, "buffer": 3, "tiny-secp256k1": 181, "typeforce": 185, "wif": 188}],
    59: [function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: true});
        const createHash = require('create-hash');
        const createHmac = require('create-hmac');

        function hash160(buffer) {
            const sha256Hash = createHash('sha256')
                .update(buffer)
                .digest();
            try {
                return createHash('rmd160')
                    .update(sha256Hash)
                    .digest();
            } catch (err) {
                return createHash('ripemd160')
                    .update(sha256Hash)
                    .digest();
            }
        }

        exports.hash160 = hash160;

        function hmacSHA512(key, data) {
            return createHmac('sha512', key)
                .update(data)
                .digest();
        }

        exports.hmacSHA512 = hmacSHA512;

    }, {"create-hash": 125, "create-hmac": 127}],
    60: [function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: true});
        var bip32_1 = require("./bip32");
        exports.fromSeed = bip32_1.fromSeed;
        exports.fromBase58 = bip32_1.fromBase58;
        exports.fromPublicKey = bip32_1.fromPublicKey;
        exports.fromPrivateKey = bip32_1.fromPrivateKey;

    }, {"./bip32": 58}],
    61: [function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: true});
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
        const wordlists = {};
        exports.wordlists = wordlists;
        let _default;
        exports._default = _default;
        try {
            exports._default = _default = require('./wordlists/chinese_simplified.json');
            wordlists.chinese_simplified = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/chinese_traditional.json');
            wordlists.chinese_traditional = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/korean.json');
            wordlists.korean = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/french.json');
            wordlists.french = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/italian.json');
            wordlists.italian = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/spanish.json');
            wordlists.spanish = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/japanese.json');
            wordlists.japanese = _default;
            wordlists.JA = _default;
        } catch (err) {
        }
        try {
            exports._default = _default = require('./wordlists/english.json');
            wordlists.english = _default;
            wordlists.EN = _default;
        } catch (err) {
        }

    }, {
        "./wordlists/chinese_simplified.json": 63,
        "./wordlists/chinese_traditional.json": 64,
        "./wordlists/english.json": 65,
        "./wordlists/french.json": 66,
        "./wordlists/italian.json": 67,
        "./wordlists/japanese.json": 68,
        "./wordlists/korean.json": 69,
        "./wordlists/spanish.json": 70
    }],
    62: [function (require, module, exports) {
        (function (Buffer) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            const createHash = require("create-hash");
            const pbkdf2_1 = require("pbkdf2");
            const randomBytes = require("randombytes");
            const _wordlists_1 = require("./_wordlists");
            let DEFAULT_WORDLIST = _wordlists_1._default;
            const INVALID_MNEMONIC = 'Invalid mnemonic';
            const INVALID_ENTROPY = 'Invalid entropy';
            const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
            const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
                'Please explicitly pass a 2048 word array explicitly.';

            function lpad(str, padString, length) {
                while (str.length < length)
                    str = padString + str;
                return str;
            }

            function binaryToByte(bin) {
                return parseInt(bin, 2);
            }

            function bytesToBinary(bytes) {
                return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');
            }

            function deriveChecksumBits(entropyBuffer) {
                const ENT = entropyBuffer.length * 8;
                const CS = ENT / 32;
                const hash = createHash('sha256')
                    .update(entropyBuffer)
                    .digest();
                return bytesToBinary([...hash]).slice(0, CS);
            }

            function salt(password) {
                return 'mnemonic' + (password || '');
            }

            function mnemonicToSeedSync(mnemonic, password) {
                const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
                const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
                return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
            }

            exports.mnemonicToSeedSync = mnemonicToSeedSync;

            function mnemonicToSeed(mnemonic, password) {
                return new Promise((resolve, reject) => {
                    try {
                        const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
                        const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
                        pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {
                            if (err)
                                return reject(err);
                            else
                                return resolve(data);
                        });
                    } catch (error) {
                        return reject(error);
                    }
                });
            }

            exports.mnemonicToSeed = mnemonicToSeed;

            function mnemonicToEntropy(mnemonic, wordlist) {
                wordlist = wordlist || DEFAULT_WORDLIST;
                if (!wordlist) {
                    throw new Error(WORDLIST_REQUIRED);
                }
                const words = (mnemonic || '').normalize('NFKD').split(' ');
                if (words.length % 3 !== 0)
                    throw new Error(INVALID_MNEMONIC);
                // convert word indices to 11 bit binary strings
                const bits = words
                    .map(word => {
                        const index = wordlist.indexOf(word);
                        if (index === -1)
                            throw new Error(INVALID_MNEMONIC);
                        return lpad(index.toString(2), '0', 11);
                    })
                    .join('');
                // split the binary string into ENT/CS
                const dividerIndex = Math.floor(bits.length / 33) * 32;
                const entropyBits = bits.slice(0, dividerIndex);
                const checksumBits = bits.slice(dividerIndex);
                // calculate the checksum and compare
                const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
                if (entropyBytes.length < 16)
                    throw new Error(INVALID_ENTROPY);
                if (entropyBytes.length > 32)
                    throw new Error(INVALID_ENTROPY);
                if (entropyBytes.length % 4 !== 0)
                    throw new Error(INVALID_ENTROPY);
                const entropy = Buffer.from(entropyBytes);
                const newChecksum = deriveChecksumBits(entropy);
                if (newChecksum !== checksumBits)
                    throw new Error(INVALID_CHECKSUM);
                return entropy.toString('hex');
            }

            exports.mnemonicToEntropy = mnemonicToEntropy;

            function entropyToMnemonic(entropy, wordlist) {
                if (!Buffer.isBuffer(entropy))
                    entropy = Buffer.from(entropy, 'hex');
                wordlist = wordlist || DEFAULT_WORDLIST;
                if (!wordlist) {
                    throw new Error(WORDLIST_REQUIRED);
                }
                // 128 <= ENT <= 256
                if (entropy.length < 16)
                    throw new TypeError(INVALID_ENTROPY);
                if (entropy.length > 32)
                    throw new TypeError(INVALID_ENTROPY);
                if (entropy.length % 4 !== 0)
                    throw new TypeError(INVALID_ENTROPY);
                const entropyBits = bytesToBinary([...entropy]);
                const checksumBits = deriveChecksumBits(entropy);
                const bits = entropyBits + checksumBits;
                const chunks = bits.match(/(.{1,11})/g);
                const words = chunks.map(binary => {
                    const index = binaryToByte(binary);
                    return wordlist[index];
                });
                return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
                    ? words.join('\u3000')
                    : words.join(' ');
            }

            exports.entropyToMnemonic = entropyToMnemonic;

            function generateMnemonic(strength, rng, wordlist) {
                strength = strength || 128;
                if (strength % 32 !== 0)
                    throw new TypeError(INVALID_ENTROPY);
                rng = rng || randomBytes;
                return entropyToMnemonic(rng(strength / 8), wordlist);
            }

            exports.generateMnemonic = generateMnemonic;

            function validateMnemonic(mnemonic, wordlist) {
                try {
                    mnemonicToEntropy(mnemonic, wordlist);
                } catch (e) {
                    return false;
                }
                return true;
            }

            exports.validateMnemonic = validateMnemonic;

            function setDefaultWordlist(language) {
                const result = _wordlists_1.wordlists[language];
                if (result)
                    DEFAULT_WORDLIST = result;
                else
                    throw new Error('Could not find wordlist for language "' + language + '"');
            }

            exports.setDefaultWordlist = setDefaultWordlist;

            function getDefaultWordlist() {
                if (!DEFAULT_WORDLIST)
                    throw new Error('No Default Wordlist set');
                return Object.keys(_wordlists_1.wordlists).filter(lang => {
                    if (lang === 'JA' || lang === 'EN')
                        return false;
                    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
                })[0];
            }

            exports.getDefaultWordlist = getDefaultWordlist;
            var _wordlists_2 = require("./_wordlists");
            exports.wordlists = _wordlists_2.wordlists;

        }).call(this, require("buffer").Buffer)

    }, {"./_wordlists": 61, "buffer": 3, "create-hash": 125, "pbkdf2": 164, "randombytes": 170}],
    63: [function (require, module, exports) {
        module.exports = [
            "的",
            "一",
            "是",
            "在",
            "不",
            "了",
            "有",
            "和",
            "人",
            "这",
            "中",
            "大",
            "为",
            "上",
            "个",
            "国",
            "我",
            "以",
            "要",
            "他",
            "时",
            "来",
            "用",
            "们",
            "生",
            "到",
            "作",
            "地",
            "于",
            "出",
            "就",
            "分",
            "对",
            "成",
            "会",
            "可",
            "主",
            "发",
            "年",
            "动",
            "同",
            "工",
            "也",
            "能",
            "下",
            "过",
            "子",
            "说",
            "产",
            "种",
            "面",
            "而",
            "方",
            "后",
            "多",
            "定",
            "行",
            "学",
            "法",
            "所",
            "民",
            "得",
            "经",
            "十",
            "三",
            "之",
            "进",
            "着",
            "等",
            "部",
            "度",
            "家",
            "电",
            "力",
            "里",
            "如",
            "水",
            "化",
            "高",
            "自",
            "二",
            "理",
            "起",
            "小",
            "物",
            "现",
            "实",
            "加",
            "量",
            "都",
            "两",
            "体",
            "制",
            "机",
            "当",
            "使",
            "点",
            "从",
            "业",
            "本",
            "去",
            "把",
            "性",
            "好",
            "应",
            "开",
            "它",
            "合",
            "还",
            "因",
            "由",
            "其",
            "些",
            "然",
            "前",
            "外",
            "天",
            "政",
            "四",
            "日",
            "那",
            "社",
            "义",
            "事",
            "平",
            "形",
            "相",
            "全",
            "表",
            "间",
            "样",
            "与",
            "关",
            "各",
            "重",
            "新",
            "线",
            "内",
            "数",
            "正",
            "心",
            "反",
            "你",
            "明",
            "看",
            "原",
            "又",
            "么",
            "利",
            "比",
            "或",
            "但",
            "质",
            "气",
            "第",
            "向",
            "道",
            "命",
            "此",
            "变",
            "条",
            "只",
            "没",
            "结",
            "解",
            "问",
            "意",
            "建",
            "月",
            "公",
            "无",
            "系",
            "军",
            "很",
            "情",
            "者",
            "最",
            "立",
            "代",
            "想",
            "已",
            "通",
            "并",
            "提",
            "直",
            "题",
            "党",
            "程",
            "展",
            "五",
            "果",
            "料",
            "象",
            "员",
            "革",
            "位",
            "入",
            "常",
            "文",
            "总",
            "次",
            "品",
            "式",
            "活",
            "设",
            "及",
            "管",
            "特",
            "件",
            "长",
            "求",
            "老",
            "头",
            "基",
            "资",
            "边",
            "流",
            "路",
            "级",
            "少",
            "图",
            "山",
            "统",
            "接",
            "知",
            "较",
            "将",
            "组",
            "见",
            "计",
            "别",
            "她",
            "手",
            "角",
            "期",
            "根",
            "论",
            "运",
            "农",
            "指",
            "几",
            "九",
            "区",
            "强",
            "放",
            "决",
            "西",
            "被",
            "干",
            "做",
            "必",
            "战",
            "先",
            "回",
            "则",
            "任",
            "取",
            "据",
            "处",
            "队",
            "南",
            "给",
            "色",
            "光",
            "门",
            "即",
            "保",
            "治",
            "北",
            "造",
            "百",
            "规",
            "热",
            "领",
            "七",
            "海",
            "口",
            "东",
            "导",
            "器",
            "压",
            "志",
            "世",
            "金",
            "增",
            "争",
            "济",
            "阶",
            "油",
            "思",
            "术",
            "极",
            "交",
            "受",
            "联",
            "什",
            "认",
            "六",
            "共",
            "权",
            "收",
            "证",
            "改",
            "清",
            "美",
            "再",
            "采",
            "转",
            "更",
            "单",
            "风",
            "切",
            "打",
            "白",
            "教",
            "速",
            "花",
            "带",
            "安",
            "场",
            "身",
            "车",
            "例",
            "真",
            "务",
            "具",
            "万",
            "每",
            "目",
            "至",
            "达",
            "走",
            "积",
            "示",
            "议",
            "声",
            "报",
            "斗",
            "完",
            "类",
            "八",
            "离",
            "华",
            "名",
            "确",
            "才",
            "科",
            "张",
            "信",
            "马",
            "节",
            "话",
            "米",
            "整",
            "空",
            "元",
            "况",
            "今",
            "集",
            "温",
            "传",
            "土",
            "许",
            "步",
            "群",
            "广",
            "石",
            "记",
            "需",
            "段",
            "研",
            "界",
            "拉",
            "林",
            "律",
            "叫",
            "且",
            "究",
            "观",
            "越",
            "织",
            "装",
            "影",
            "算",
            "低",
            "持",
            "音",
            "众",
            "书",
            "布",
            "复",
            "容",
            "儿",
            "须",
            "际",
            "商",
            "非",
            "验",
            "连",
            "断",
            "深",
            "难",
            "近",
            "矿",
            "千",
            "周",
            "委",
            "素",
            "技",
            "备",
            "半",
            "办",
            "青",
            "省",
            "列",
            "习",
            "响",
            "约",
            "支",
            "般",
            "史",
            "感",
            "劳",
            "便",
            "团",
            "往",
            "酸",
            "历",
            "市",
            "克",
            "何",
            "除",
            "消",
            "构",
            "府",
            "称",
            "太",
            "准",
            "精",
            "值",
            "号",
            "率",
            "族",
            "维",
            "划",
            "选",
            "标",
            "写",
            "存",
            "候",
            "毛",
            "亲",
            "快",
            "效",
            "斯",
            "院",
            "查",
            "江",
            "型",
            "眼",
            "王",
            "按",
            "格",
            "养",
            "易",
            "置",
            "派",
            "层",
            "片",
            "始",
            "却",
            "专",
            "状",
            "育",
            "厂",
            "京",
            "识",
            "适",
            "属",
            "圆",
            "包",
            "火",
            "住",
            "调",
            "满",
            "县",
            "局",
            "照",
            "参",
            "红",
            "细",
            "引",
            "听",
            "该",
            "铁",
            "价",
            "严",
            "首",
            "底",
            "液",
            "官",
            "德",
            "随",
            "病",
            "苏",
            "失",
            "尔",
            "死",
            "讲",
            "配",
            "女",
            "黄",
            "推",
            "显",
            "谈",
            "罪",
            "神",
            "艺",
            "呢",
            "席",
            "含",
            "企",
            "望",
            "密",
            "批",
            "营",
            "项",
            "防",
            "举",
            "球",
            "英",
            "氧",
            "势",
            "告",
            "李",
            "台",
            "落",
            "木",
            "帮",
            "轮",
            "破",
            "亚",
            "师",
            "围",
            "注",
            "远",
            "字",
            "材",
            "排",
            "供",
            "河",
            "态",
            "封",
            "另",
            "施",
            "减",
            "树",
            "溶",
            "怎",
            "止",
            "案",
            "言",
            "士",
            "均",
            "武",
            "固",
            "叶",
            "鱼",
            "波",
            "视",
            "仅",
            "费",
            "紧",
            "爱",
            "左",
            "章",
            "早",
            "朝",
            "害",
            "续",
            "轻",
            "服",
            "试",
            "食",
            "充",
            "兵",
            "源",
            "判",
            "护",
            "司",
            "足",
            "某",
            "练",
            "差",
            "致",
            "板",
            "田",
            "降",
            "黑",
            "犯",
            "负",
            "击",
            "范",
            "继",
            "兴",
            "似",
            "余",
            "坚",
            "曲",
            "输",
            "修",
            "故",
            "城",
            "夫",
            "够",
            "送",
            "笔",
            "船",
            "占",
            "右",
            "财",
            "吃",
            "富",
            "春",
            "职",
            "觉",
            "汉",
            "画",
            "功",
            "巴",
            "跟",
            "虽",
            "杂",
            "飞",
            "检",
            "吸",
            "助",
            "升",
            "阳",
            "互",
            "初",
            "创",
            "抗",
            "考",
            "投",
            "坏",
            "策",
            "古",
            "径",
            "换",
            "未",
            "跑",
            "留",
            "钢",
            "曾",
            "端",
            "责",
            "站",
            "简",
            "述",
            "钱",
            "副",
            "尽",
            "帝",
            "射",
            "草",
            "冲",
            "承",
            "独",
            "令",
            "限",
            "阿",
            "宣",
            "环",
            "双",
            "请",
            "超",
            "微",
            "让",
            "控",
            "州",
            "良",
            "轴",
            "找",
            "否",
            "纪",
            "益",
            "依",
            "优",
            "顶",
            "础",
            "载",
            "倒",
            "房",
            "突",
            "坐",
            "粉",
            "敌",
            "略",
            "客",
            "袁",
            "冷",
            "胜",
            "绝",
            "析",
            "块",
            "剂",
            "测",
            "丝",
            "协",
            "诉",
            "念",
            "陈",
            "仍",
            "罗",
            "盐",
            "友",
            "洋",
            "错",
            "苦",
            "夜",
            "刑",
            "移",
            "频",
            "逐",
            "靠",
            "混",
            "母",
            "短",
            "皮",
            "终",
            "聚",
            "汽",
            "村",
            "云",
            "哪",
            "既",
            "距",
            "卫",
            "停",
            "烈",
            "央",
            "察",
            "烧",
            "迅",
            "境",
            "若",
            "印",
            "洲",
            "刻",
            "括",
            "激",
            "孔",
            "搞",
            "甚",
            "室",
            "待",
            "核",
            "校",
            "散",
            "侵",
            "吧",
            "甲",
            "游",
            "久",
            "菜",
            "味",
            "旧",
            "模",
            "湖",
            "货",
            "损",
            "预",
            "阻",
            "毫",
            "普",
            "稳",
            "乙",
            "妈",
            "植",
            "息",
            "扩",
            "银",
            "语",
            "挥",
            "酒",
            "守",
            "拿",
            "序",
            "纸",
            "医",
            "缺",
            "雨",
            "吗",
            "针",
            "刘",
            "啊",
            "急",
            "唱",
            "误",
            "训",
            "愿",
            "审",
            "附",
            "获",
            "茶",
            "鲜",
            "粮",
            "斤",
            "孩",
            "脱",
            "硫",
            "肥",
            "善",
            "龙",
            "演",
            "父",
            "渐",
            "血",
            "欢",
            "械",
            "掌",
            "歌",
            "沙",
            "刚",
            "攻",
            "谓",
            "盾",
            "讨",
            "晚",
            "粒",
            "乱",
            "燃",
            "矛",
            "乎",
            "杀",
            "药",
            "宁",
            "鲁",
            "贵",
            "钟",
            "煤",
            "读",
            "班",
            "伯",
            "香",
            "介",
            "迫",
            "句",
            "丰",
            "培",
            "握",
            "兰",
            "担",
            "弦",
            "蛋",
            "沉",
            "假",
            "穿",
            "执",
            "答",
            "乐",
            "谁",
            "顺",
            "烟",
            "缩",
            "征",
            "脸",
            "喜",
            "松",
            "脚",
            "困",
            "异",
            "免",
            "背",
            "星",
            "福",
            "买",
            "染",
            "井",
            "概",
            "慢",
            "怕",
            "磁",
            "倍",
            "祖",
            "皇",
            "促",
            "静",
            "补",
            "评",
            "翻",
            "肉",
            "践",
            "尼",
            "衣",
            "宽",
            "扬",
            "棉",
            "希",
            "伤",
            "操",
            "垂",
            "秋",
            "宜",
            "氢",
            "套",
            "督",
            "振",
            "架",
            "亮",
            "末",
            "宪",
            "庆",
            "编",
            "牛",
            "触",
            "映",
            "雷",
            "销",
            "诗",
            "座",
            "居",
            "抓",
            "裂",
            "胞",
            "呼",
            "娘",
            "景",
            "威",
            "绿",
            "晶",
            "厚",
            "盟",
            "衡",
            "鸡",
            "孙",
            "延",
            "危",
            "胶",
            "屋",
            "乡",
            "临",
            "陆",
            "顾",
            "掉",
            "呀",
            "灯",
            "岁",
            "措",
            "束",
            "耐",
            "剧",
            "玉",
            "赵",
            "跳",
            "哥",
            "季",
            "课",
            "凯",
            "胡",
            "额",
            "款",
            "绍",
            "卷",
            "齐",
            "伟",
            "蒸",
            "殖",
            "永",
            "宗",
            "苗",
            "川",
            "炉",
            "岩",
            "弱",
            "零",
            "杨",
            "奏",
            "沿",
            "露",
            "杆",
            "探",
            "滑",
            "镇",
            "饭",
            "浓",
            "航",
            "怀",
            "赶",
            "库",
            "夺",
            "伊",
            "灵",
            "税",
            "途",
            "灭",
            "赛",
            "归",
            "召",
            "鼓",
            "播",
            "盘",
            "裁",
            "险",
            "康",
            "唯",
            "录",
            "菌",
            "纯",
            "借",
            "糖",
            "盖",
            "横",
            "符",
            "私",
            "努",
            "堂",
            "域",
            "枪",
            "润",
            "幅",
            "哈",
            "竟",
            "熟",
            "虫",
            "泽",
            "脑",
            "壤",
            "碳",
            "欧",
            "遍",
            "侧",
            "寨",
            "敢",
            "彻",
            "虑",
            "斜",
            "薄",
            "庭",
            "纳",
            "弹",
            "饲",
            "伸",
            "折",
            "麦",
            "湿",
            "暗",
            "荷",
            "瓦",
            "塞",
            "床",
            "筑",
            "恶",
            "户",
            "访",
            "塔",
            "奇",
            "透",
            "梁",
            "刀",
            "旋",
            "迹",
            "卡",
            "氯",
            "遇",
            "份",
            "毒",
            "泥",
            "退",
            "洗",
            "摆",
            "灰",
            "彩",
            "卖",
            "耗",
            "夏",
            "择",
            "忙",
            "铜",
            "献",
            "硬",
            "予",
            "繁",
            "圈",
            "雪",
            "函",
            "亦",
            "抽",
            "篇",
            "阵",
            "阴",
            "丁",
            "尺",
            "追",
            "堆",
            "雄",
            "迎",
            "泛",
            "爸",
            "楼",
            "避",
            "谋",
            "吨",
            "野",
            "猪",
            "旗",
            "累",
            "偏",
            "典",
            "馆",
            "索",
            "秦",
            "脂",
            "潮",
            "爷",
            "豆",
            "忽",
            "托",
            "惊",
            "塑",
            "遗",
            "愈",
            "朱",
            "替",
            "纤",
            "粗",
            "倾",
            "尚",
            "痛",
            "楚",
            "谢",
            "奋",
            "购",
            "磨",
            "君",
            "池",
            "旁",
            "碎",
            "骨",
            "监",
            "捕",
            "弟",
            "暴",
            "割",
            "贯",
            "殊",
            "释",
            "词",
            "亡",
            "壁",
            "顿",
            "宝",
            "午",
            "尘",
            "闻",
            "揭",
            "炮",
            "残",
            "冬",
            "桥",
            "妇",
            "警",
            "综",
            "招",
            "吴",
            "付",
            "浮",
            "遭",
            "徐",
            "您",
            "摇",
            "谷",
            "赞",
            "箱",
            "隔",
            "订",
            "男",
            "吹",
            "园",
            "纷",
            "唐",
            "败",
            "宋",
            "玻",
            "巨",
            "耕",
            "坦",
            "荣",
            "闭",
            "湾",
            "键",
            "凡",
            "驻",
            "锅",
            "救",
            "恩",
            "剥",
            "凝",
            "碱",
            "齿",
            "截",
            "炼",
            "麻",
            "纺",
            "禁",
            "废",
            "盛",
            "版",
            "缓",
            "净",
            "睛",
            "昌",
            "婚",
            "涉",
            "筒",
            "嘴",
            "插",
            "岸",
            "朗",
            "庄",
            "街",
            "藏",
            "姑",
            "贸",
            "腐",
            "奴",
            "啦",
            "惯",
            "乘",
            "伙",
            "恢",
            "匀",
            "纱",
            "扎",
            "辩",
            "耳",
            "彪",
            "臣",
            "亿",
            "璃",
            "抵",
            "脉",
            "秀",
            "萨",
            "俄",
            "网",
            "舞",
            "店",
            "喷",
            "纵",
            "寸",
            "汗",
            "挂",
            "洪",
            "贺",
            "闪",
            "柬",
            "爆",
            "烯",
            "津",
            "稻",
            "墙",
            "软",
            "勇",
            "像",
            "滚",
            "厘",
            "蒙",
            "芳",
            "肯",
            "坡",
            "柱",
            "荡",
            "腿",
            "仪",
            "旅",
            "尾",
            "轧",
            "冰",
            "贡",
            "登",
            "黎",
            "削",
            "钻",
            "勒",
            "逃",
            "障",
            "氨",
            "郭",
            "峰",
            "币",
            "港",
            "伏",
            "轨",
            "亩",
            "毕",
            "擦",
            "莫",
            "刺",
            "浪",
            "秘",
            "援",
            "株",
            "健",
            "售",
            "股",
            "岛",
            "甘",
            "泡",
            "睡",
            "童",
            "铸",
            "汤",
            "阀",
            "休",
            "汇",
            "舍",
            "牧",
            "绕",
            "炸",
            "哲",
            "磷",
            "绩",
            "朋",
            "淡",
            "尖",
            "启",
            "陷",
            "柴",
            "呈",
            "徒",
            "颜",
            "泪",
            "稍",
            "忘",
            "泵",
            "蓝",
            "拖",
            "洞",
            "授",
            "镜",
            "辛",
            "壮",
            "锋",
            "贫",
            "虚",
            "弯",
            "摩",
            "泰",
            "幼",
            "廷",
            "尊",
            "窗",
            "纲",
            "弄",
            "隶",
            "疑",
            "氏",
            "宫",
            "姐",
            "震",
            "瑞",
            "怪",
            "尤",
            "琴",
            "循",
            "描",
            "膜",
            "违",
            "夹",
            "腰",
            "缘",
            "珠",
            "穷",
            "森",
            "枝",
            "竹",
            "沟",
            "催",
            "绳",
            "忆",
            "邦",
            "剩",
            "幸",
            "浆",
            "栏",
            "拥",
            "牙",
            "贮",
            "礼",
            "滤",
            "钠",
            "纹",
            "罢",
            "拍",
            "咱",
            "喊",
            "袖",
            "埃",
            "勤",
            "罚",
            "焦",
            "潜",
            "伍",
            "墨",
            "欲",
            "缝",
            "姓",
            "刊",
            "饱",
            "仿",
            "奖",
            "铝",
            "鬼",
            "丽",
            "跨",
            "默",
            "挖",
            "链",
            "扫",
            "喝",
            "袋",
            "炭",
            "污",
            "幕",
            "诸",
            "弧",
            "励",
            "梅",
            "奶",
            "洁",
            "灾",
            "舟",
            "鉴",
            "苯",
            "讼",
            "抱",
            "毁",
            "懂",
            "寒",
            "智",
            "埔",
            "寄",
            "届",
            "跃",
            "渡",
            "挑",
            "丹",
            "艰",
            "贝",
            "碰",
            "拔",
            "爹",
            "戴",
            "码",
            "梦",
            "芽",
            "熔",
            "赤",
            "渔",
            "哭",
            "敬",
            "颗",
            "奔",
            "铅",
            "仲",
            "虎",
            "稀",
            "妹",
            "乏",
            "珍",
            "申",
            "桌",
            "遵",
            "允",
            "隆",
            "螺",
            "仓",
            "魏",
            "锐",
            "晓",
            "氮",
            "兼",
            "隐",
            "碍",
            "赫",
            "拨",
            "忠",
            "肃",
            "缸",
            "牵",
            "抢",
            "博",
            "巧",
            "壳",
            "兄",
            "杜",
            "讯",
            "诚",
            "碧",
            "祥",
            "柯",
            "页",
            "巡",
            "矩",
            "悲",
            "灌",
            "龄",
            "伦",
            "票",
            "寻",
            "桂",
            "铺",
            "圣",
            "恐",
            "恰",
            "郑",
            "趣",
            "抬",
            "荒",
            "腾",
            "贴",
            "柔",
            "滴",
            "猛",
            "阔",
            "辆",
            "妻",
            "填",
            "撤",
            "储",
            "签",
            "闹",
            "扰",
            "紫",
            "砂",
            "递",
            "戏",
            "吊",
            "陶",
            "伐",
            "喂",
            "疗",
            "瓶",
            "婆",
            "抚",
            "臂",
            "摸",
            "忍",
            "虾",
            "蜡",
            "邻",
            "胸",
            "巩",
            "挤",
            "偶",
            "弃",
            "槽",
            "劲",
            "乳",
            "邓",
            "吉",
            "仁",
            "烂",
            "砖",
            "租",
            "乌",
            "舰",
            "伴",
            "瓜",
            "浅",
            "丙",
            "暂",
            "燥",
            "橡",
            "柳",
            "迷",
            "暖",
            "牌",
            "秧",
            "胆",
            "详",
            "簧",
            "踏",
            "瓷",
            "谱",
            "呆",
            "宾",
            "糊",
            "洛",
            "辉",
            "愤",
            "竞",
            "隙",
            "怒",
            "粘",
            "乃",
            "绪",
            "肩",
            "籍",
            "敏",
            "涂",
            "熙",
            "皆",
            "侦",
            "悬",
            "掘",
            "享",
            "纠",
            "醒",
            "狂",
            "锁",
            "淀",
            "恨",
            "牲",
            "霸",
            "爬",
            "赏",
            "逆",
            "玩",
            "陵",
            "祝",
            "秒",
            "浙",
            "貌",
            "役",
            "彼",
            "悉",
            "鸭",
            "趋",
            "凤",
            "晨",
            "畜",
            "辈",
            "秩",
            "卵",
            "署",
            "梯",
            "炎",
            "滩",
            "棋",
            "驱",
            "筛",
            "峡",
            "冒",
            "啥",
            "寿",
            "译",
            "浸",
            "泉",
            "帽",
            "迟",
            "硅",
            "疆",
            "贷",
            "漏",
            "稿",
            "冠",
            "嫩",
            "胁",
            "芯",
            "牢",
            "叛",
            "蚀",
            "奥",
            "鸣",
            "岭",
            "羊",
            "凭",
            "串",
            "塘",
            "绘",
            "酵",
            "融",
            "盆",
            "锡",
            "庙",
            "筹",
            "冻",
            "辅",
            "摄",
            "袭",
            "筋",
            "拒",
            "僚",
            "旱",
            "钾",
            "鸟",
            "漆",
            "沈",
            "眉",
            "疏",
            "添",
            "棒",
            "穗",
            "硝",
            "韩",
            "逼",
            "扭",
            "侨",
            "凉",
            "挺",
            "碗",
            "栽",
            "炒",
            "杯",
            "患",
            "馏",
            "劝",
            "豪",
            "辽",
            "勃",
            "鸿",
            "旦",
            "吏",
            "拜",
            "狗",
            "埋",
            "辊",
            "掩",
            "饮",
            "搬",
            "骂",
            "辞",
            "勾",
            "扣",
            "估",
            "蒋",
            "绒",
            "雾",
            "丈",
            "朵",
            "姆",
            "拟",
            "宇",
            "辑",
            "陕",
            "雕",
            "偿",
            "蓄",
            "崇",
            "剪",
            "倡",
            "厅",
            "咬",
            "驶",
            "薯",
            "刷",
            "斥",
            "番",
            "赋",
            "奉",
            "佛",
            "浇",
            "漫",
            "曼",
            "扇",
            "钙",
            "桃",
            "扶",
            "仔",
            "返",
            "俗",
            "亏",
            "腔",
            "鞋",
            "棱",
            "覆",
            "框",
            "悄",
            "叔",
            "撞",
            "骗",
            "勘",
            "旺",
            "沸",
            "孤",
            "吐",
            "孟",
            "渠",
            "屈",
            "疾",
            "妙",
            "惜",
            "仰",
            "狠",
            "胀",
            "谐",
            "抛",
            "霉",
            "桑",
            "岗",
            "嘛",
            "衰",
            "盗",
            "渗",
            "脏",
            "赖",
            "涌",
            "甜",
            "曹",
            "阅",
            "肌",
            "哩",
            "厉",
            "烃",
            "纬",
            "毅",
            "昨",
            "伪",
            "症",
            "煮",
            "叹",
            "钉",
            "搭",
            "茎",
            "笼",
            "酷",
            "偷",
            "弓",
            "锥",
            "恒",
            "杰",
            "坑",
            "鼻",
            "翼",
            "纶",
            "叙",
            "狱",
            "逮",
            "罐",
            "络",
            "棚",
            "抑",
            "膨",
            "蔬",
            "寺",
            "骤",
            "穆",
            "冶",
            "枯",
            "册",
            "尸",
            "凸",
            "绅",
            "坯",
            "牺",
            "焰",
            "轰",
            "欣",
            "晋",
            "瘦",
            "御",
            "锭",
            "锦",
            "丧",
            "旬",
            "锻",
            "垄",
            "搜",
            "扑",
            "邀",
            "亭",
            "酯",
            "迈",
            "舒",
            "脆",
            "酶",
            "闲",
            "忧",
            "酚",
            "顽",
            "羽",
            "涨",
            "卸",
            "仗",
            "陪",
            "辟",
            "惩",
            "杭",
            "姚",
            "肚",
            "捉",
            "飘",
            "漂",
            "昆",
            "欺",
            "吾",
            "郎",
            "烷",
            "汁",
            "呵",
            "饰",
            "萧",
            "雅",
            "邮",
            "迁",
            "燕",
            "撒",
            "姻",
            "赴",
            "宴",
            "烦",
            "债",
            "帐",
            "斑",
            "铃",
            "旨",
            "醇",
            "董",
            "饼",
            "雏",
            "姿",
            "拌",
            "傅",
            "腹",
            "妥",
            "揉",
            "贤",
            "拆",
            "歪",
            "葡",
            "胺",
            "丢",
            "浩",
            "徽",
            "昂",
            "垫",
            "挡",
            "览",
            "贪",
            "慰",
            "缴",
            "汪",
            "慌",
            "冯",
            "诺",
            "姜",
            "谊",
            "凶",
            "劣",
            "诬",
            "耀",
            "昏",
            "躺",
            "盈",
            "骑",
            "乔",
            "溪",
            "丛",
            "卢",
            "抹",
            "闷",
            "咨",
            "刮",
            "驾",
            "缆",
            "悟",
            "摘",
            "铒",
            "掷",
            "颇",
            "幻",
            "柄",
            "惠",
            "惨",
            "佳",
            "仇",
            "腊",
            "窝",
            "涤",
            "剑",
            "瞧",
            "堡",
            "泼",
            "葱",
            "罩",
            "霍",
            "捞",
            "胎",
            "苍",
            "滨",
            "俩",
            "捅",
            "湘",
            "砍",
            "霞",
            "邵",
            "萄",
            "疯",
            "淮",
            "遂",
            "熊",
            "粪",
            "烘",
            "宿",
            "档",
            "戈",
            "驳",
            "嫂",
            "裕",
            "徙",
            "箭",
            "捐",
            "肠",
            "撑",
            "晒",
            "辨",
            "殿",
            "莲",
            "摊",
            "搅",
            "酱",
            "屏",
            "疫",
            "哀",
            "蔡",
            "堵",
            "沫",
            "皱",
            "畅",
            "叠",
            "阁",
            "莱",
            "敲",
            "辖",
            "钩",
            "痕",
            "坝",
            "巷",
            "饿",
            "祸",
            "丘",
            "玄",
            "溜",
            "曰",
            "逻",
            "彭",
            "尝",
            "卿",
            "妨",
            "艇",
            "吞",
            "韦",
            "怨",
            "矮",
            "歇"
        ]

    }, {}],
    64: [function (require, module, exports) {
        module.exports = [
            "的",
            "一",
            "是",
            "在",
            "不",
            "了",
            "有",
            "和",
            "人",
            "這",
            "中",
            "大",
            "為",
            "上",
            "個",
            "國",
            "我",
            "以",
            "要",
            "他",
            "時",
            "來",
            "用",
            "們",
            "生",
            "到",
            "作",
            "地",
            "於",
            "出",
            "就",
            "分",
            "對",
            "成",
            "會",
            "可",
            "主",
            "發",
            "年",
            "動",
            "同",
            "工",
            "也",
            "能",
            "下",
            "過",
            "子",
            "說",
            "產",
            "種",
            "面",
            "而",
            "方",
            "後",
            "多",
            "定",
            "行",
            "學",
            "法",
            "所",
            "民",
            "得",
            "經",
            "十",
            "三",
            "之",
            "進",
            "著",
            "等",
            "部",
            "度",
            "家",
            "電",
            "力",
            "裡",
            "如",
            "水",
            "化",
            "高",
            "自",
            "二",
            "理",
            "起",
            "小",
            "物",
            "現",
            "實",
            "加",
            "量",
            "都",
            "兩",
            "體",
            "制",
            "機",
            "當",
            "使",
            "點",
            "從",
            "業",
            "本",
            "去",
            "把",
            "性",
            "好",
            "應",
            "開",
            "它",
            "合",
            "還",
            "因",
            "由",
            "其",
            "些",
            "然",
            "前",
            "外",
            "天",
            "政",
            "四",
            "日",
            "那",
            "社",
            "義",
            "事",
            "平",
            "形",
            "相",
            "全",
            "表",
            "間",
            "樣",
            "與",
            "關",
            "各",
            "重",
            "新",
            "線",
            "內",
            "數",
            "正",
            "心",
            "反",
            "你",
            "明",
            "看",
            "原",
            "又",
            "麼",
            "利",
            "比",
            "或",
            "但",
            "質",
            "氣",
            "第",
            "向",
            "道",
            "命",
            "此",
            "變",
            "條",
            "只",
            "沒",
            "結",
            "解",
            "問",
            "意",
            "建",
            "月",
            "公",
            "無",
            "系",
            "軍",
            "很",
            "情",
            "者",
            "最",
            "立",
            "代",
            "想",
            "已",
            "通",
            "並",
            "提",
            "直",
            "題",
            "黨",
            "程",
            "展",
            "五",
            "果",
            "料",
            "象",
            "員",
            "革",
            "位",
            "入",
            "常",
            "文",
            "總",
            "次",
            "品",
            "式",
            "活",
            "設",
            "及",
            "管",
            "特",
            "件",
            "長",
            "求",
            "老",
            "頭",
            "基",
            "資",
            "邊",
            "流",
            "路",
            "級",
            "少",
            "圖",
            "山",
            "統",
            "接",
            "知",
            "較",
            "將",
            "組",
            "見",
            "計",
            "別",
            "她",
            "手",
            "角",
            "期",
            "根",
            "論",
            "運",
            "農",
            "指",
            "幾",
            "九",
            "區",
            "強",
            "放",
            "決",
            "西",
            "被",
            "幹",
            "做",
            "必",
            "戰",
            "先",
            "回",
            "則",
            "任",
            "取",
            "據",
            "處",
            "隊",
            "南",
            "給",
            "色",
            "光",
            "門",
            "即",
            "保",
            "治",
            "北",
            "造",
            "百",
            "規",
            "熱",
            "領",
            "七",
            "海",
            "口",
            "東",
            "導",
            "器",
            "壓",
            "志",
            "世",
            "金",
            "增",
            "爭",
            "濟",
            "階",
            "油",
            "思",
            "術",
            "極",
            "交",
            "受",
            "聯",
            "什",
            "認",
            "六",
            "共",
            "權",
            "收",
            "證",
            "改",
            "清",
            "美",
            "再",
            "採",
            "轉",
            "更",
            "單",
            "風",
            "切",
            "打",
            "白",
            "教",
            "速",
            "花",
            "帶",
            "安",
            "場",
            "身",
            "車",
            "例",
            "真",
            "務",
            "具",
            "萬",
            "每",
            "目",
            "至",
            "達",
            "走",
            "積",
            "示",
            "議",
            "聲",
            "報",
            "鬥",
            "完",
            "類",
            "八",
            "離",
            "華",
            "名",
            "確",
            "才",
            "科",
            "張",
            "信",
            "馬",
            "節",
            "話",
            "米",
            "整",
            "空",
            "元",
            "況",
            "今",
            "集",
            "溫",
            "傳",
            "土",
            "許",
            "步",
            "群",
            "廣",
            "石",
            "記",
            "需",
            "段",
            "研",
            "界",
            "拉",
            "林",
            "律",
            "叫",
            "且",
            "究",
            "觀",
            "越",
            "織",
            "裝",
            "影",
            "算",
            "低",
            "持",
            "音",
            "眾",
            "書",
            "布",
            "复",
            "容",
            "兒",
            "須",
            "際",
            "商",
            "非",
            "驗",
            "連",
            "斷",
            "深",
            "難",
            "近",
            "礦",
            "千",
            "週",
            "委",
            "素",
            "技",
            "備",
            "半",
            "辦",
            "青",
            "省",
            "列",
            "習",
            "響",
            "約",
            "支",
            "般",
            "史",
            "感",
            "勞",
            "便",
            "團",
            "往",
            "酸",
            "歷",
            "市",
            "克",
            "何",
            "除",
            "消",
            "構",
            "府",
            "稱",
            "太",
            "準",
            "精",
            "值",
            "號",
            "率",
            "族",
            "維",
            "劃",
            "選",
            "標",
            "寫",
            "存",
            "候",
            "毛",
            "親",
            "快",
            "效",
            "斯",
            "院",
            "查",
            "江",
            "型",
            "眼",
            "王",
            "按",
            "格",
            "養",
            "易",
            "置",
            "派",
            "層",
            "片",
            "始",
            "卻",
            "專",
            "狀",
            "育",
            "廠",
            "京",
            "識",
            "適",
            "屬",
            "圓",
            "包",
            "火",
            "住",
            "調",
            "滿",
            "縣",
            "局",
            "照",
            "參",
            "紅",
            "細",
            "引",
            "聽",
            "該",
            "鐵",
            "價",
            "嚴",
            "首",
            "底",
            "液",
            "官",
            "德",
            "隨",
            "病",
            "蘇",
            "失",
            "爾",
            "死",
            "講",
            "配",
            "女",
            "黃",
            "推",
            "顯",
            "談",
            "罪",
            "神",
            "藝",
            "呢",
            "席",
            "含",
            "企",
            "望",
            "密",
            "批",
            "營",
            "項",
            "防",
            "舉",
            "球",
            "英",
            "氧",
            "勢",
            "告",
            "李",
            "台",
            "落",
            "木",
            "幫",
            "輪",
            "破",
            "亞",
            "師",
            "圍",
            "注",
            "遠",
            "字",
            "材",
            "排",
            "供",
            "河",
            "態",
            "封",
            "另",
            "施",
            "減",
            "樹",
            "溶",
            "怎",
            "止",
            "案",
            "言",
            "士",
            "均",
            "武",
            "固",
            "葉",
            "魚",
            "波",
            "視",
            "僅",
            "費",
            "緊",
            "愛",
            "左",
            "章",
            "早",
            "朝",
            "害",
            "續",
            "輕",
            "服",
            "試",
            "食",
            "充",
            "兵",
            "源",
            "判",
            "護",
            "司",
            "足",
            "某",
            "練",
            "差",
            "致",
            "板",
            "田",
            "降",
            "黑",
            "犯",
            "負",
            "擊",
            "范",
            "繼",
            "興",
            "似",
            "餘",
            "堅",
            "曲",
            "輸",
            "修",
            "故",
            "城",
            "夫",
            "夠",
            "送",
            "筆",
            "船",
            "佔",
            "右",
            "財",
            "吃",
            "富",
            "春",
            "職",
            "覺",
            "漢",
            "畫",
            "功",
            "巴",
            "跟",
            "雖",
            "雜",
            "飛",
            "檢",
            "吸",
            "助",
            "昇",
            "陽",
            "互",
            "初",
            "創",
            "抗",
            "考",
            "投",
            "壞",
            "策",
            "古",
            "徑",
            "換",
            "未",
            "跑",
            "留",
            "鋼",
            "曾",
            "端",
            "責",
            "站",
            "簡",
            "述",
            "錢",
            "副",
            "盡",
            "帝",
            "射",
            "草",
            "衝",
            "承",
            "獨",
            "令",
            "限",
            "阿",
            "宣",
            "環",
            "雙",
            "請",
            "超",
            "微",
            "讓",
            "控",
            "州",
            "良",
            "軸",
            "找",
            "否",
            "紀",
            "益",
            "依",
            "優",
            "頂",
            "礎",
            "載",
            "倒",
            "房",
            "突",
            "坐",
            "粉",
            "敵",
            "略",
            "客",
            "袁",
            "冷",
            "勝",
            "絕",
            "析",
            "塊",
            "劑",
            "測",
            "絲",
            "協",
            "訴",
            "念",
            "陳",
            "仍",
            "羅",
            "鹽",
            "友",
            "洋",
            "錯",
            "苦",
            "夜",
            "刑",
            "移",
            "頻",
            "逐",
            "靠",
            "混",
            "母",
            "短",
            "皮",
            "終",
            "聚",
            "汽",
            "村",
            "雲",
            "哪",
            "既",
            "距",
            "衛",
            "停",
            "烈",
            "央",
            "察",
            "燒",
            "迅",
            "境",
            "若",
            "印",
            "洲",
            "刻",
            "括",
            "激",
            "孔",
            "搞",
            "甚",
            "室",
            "待",
            "核",
            "校",
            "散",
            "侵",
            "吧",
            "甲",
            "遊",
            "久",
            "菜",
            "味",
            "舊",
            "模",
            "湖",
            "貨",
            "損",
            "預",
            "阻",
            "毫",
            "普",
            "穩",
            "乙",
            "媽",
            "植",
            "息",
            "擴",
            "銀",
            "語",
            "揮",
            "酒",
            "守",
            "拿",
            "序",
            "紙",
            "醫",
            "缺",
            "雨",
            "嗎",
            "針",
            "劉",
            "啊",
            "急",
            "唱",
            "誤",
            "訓",
            "願",
            "審",
            "附",
            "獲",
            "茶",
            "鮮",
            "糧",
            "斤",
            "孩",
            "脫",
            "硫",
            "肥",
            "善",
            "龍",
            "演",
            "父",
            "漸",
            "血",
            "歡",
            "械",
            "掌",
            "歌",
            "沙",
            "剛",
            "攻",
            "謂",
            "盾",
            "討",
            "晚",
            "粒",
            "亂",
            "燃",
            "矛",
            "乎",
            "殺",
            "藥",
            "寧",
            "魯",
            "貴",
            "鐘",
            "煤",
            "讀",
            "班",
            "伯",
            "香",
            "介",
            "迫",
            "句",
            "豐",
            "培",
            "握",
            "蘭",
            "擔",
            "弦",
            "蛋",
            "沉",
            "假",
            "穿",
            "執",
            "答",
            "樂",
            "誰",
            "順",
            "煙",
            "縮",
            "徵",
            "臉",
            "喜",
            "松",
            "腳",
            "困",
            "異",
            "免",
            "背",
            "星",
            "福",
            "買",
            "染",
            "井",
            "概",
            "慢",
            "怕",
            "磁",
            "倍",
            "祖",
            "皇",
            "促",
            "靜",
            "補",
            "評",
            "翻",
            "肉",
            "踐",
            "尼",
            "衣",
            "寬",
            "揚",
            "棉",
            "希",
            "傷",
            "操",
            "垂",
            "秋",
            "宜",
            "氫",
            "套",
            "督",
            "振",
            "架",
            "亮",
            "末",
            "憲",
            "慶",
            "編",
            "牛",
            "觸",
            "映",
            "雷",
            "銷",
            "詩",
            "座",
            "居",
            "抓",
            "裂",
            "胞",
            "呼",
            "娘",
            "景",
            "威",
            "綠",
            "晶",
            "厚",
            "盟",
            "衡",
            "雞",
            "孫",
            "延",
            "危",
            "膠",
            "屋",
            "鄉",
            "臨",
            "陸",
            "顧",
            "掉",
            "呀",
            "燈",
            "歲",
            "措",
            "束",
            "耐",
            "劇",
            "玉",
            "趙",
            "跳",
            "哥",
            "季",
            "課",
            "凱",
            "胡",
            "額",
            "款",
            "紹",
            "卷",
            "齊",
            "偉",
            "蒸",
            "殖",
            "永",
            "宗",
            "苗",
            "川",
            "爐",
            "岩",
            "弱",
            "零",
            "楊",
            "奏",
            "沿",
            "露",
            "桿",
            "探",
            "滑",
            "鎮",
            "飯",
            "濃",
            "航",
            "懷",
            "趕",
            "庫",
            "奪",
            "伊",
            "靈",
            "稅",
            "途",
            "滅",
            "賽",
            "歸",
            "召",
            "鼓",
            "播",
            "盤",
            "裁",
            "險",
            "康",
            "唯",
            "錄",
            "菌",
            "純",
            "借",
            "糖",
            "蓋",
            "橫",
            "符",
            "私",
            "努",
            "堂",
            "域",
            "槍",
            "潤",
            "幅",
            "哈",
            "竟",
            "熟",
            "蟲",
            "澤",
            "腦",
            "壤",
            "碳",
            "歐",
            "遍",
            "側",
            "寨",
            "敢",
            "徹",
            "慮",
            "斜",
            "薄",
            "庭",
            "納",
            "彈",
            "飼",
            "伸",
            "折",
            "麥",
            "濕",
            "暗",
            "荷",
            "瓦",
            "塞",
            "床",
            "築",
            "惡",
            "戶",
            "訪",
            "塔",
            "奇",
            "透",
            "梁",
            "刀",
            "旋",
            "跡",
            "卡",
            "氯",
            "遇",
            "份",
            "毒",
            "泥",
            "退",
            "洗",
            "擺",
            "灰",
            "彩",
            "賣",
            "耗",
            "夏",
            "擇",
            "忙",
            "銅",
            "獻",
            "硬",
            "予",
            "繁",
            "圈",
            "雪",
            "函",
            "亦",
            "抽",
            "篇",
            "陣",
            "陰",
            "丁",
            "尺",
            "追",
            "堆",
            "雄",
            "迎",
            "泛",
            "爸",
            "樓",
            "避",
            "謀",
            "噸",
            "野",
            "豬",
            "旗",
            "累",
            "偏",
            "典",
            "館",
            "索",
            "秦",
            "脂",
            "潮",
            "爺",
            "豆",
            "忽",
            "托",
            "驚",
            "塑",
            "遺",
            "愈",
            "朱",
            "替",
            "纖",
            "粗",
            "傾",
            "尚",
            "痛",
            "楚",
            "謝",
            "奮",
            "購",
            "磨",
            "君",
            "池",
            "旁",
            "碎",
            "骨",
            "監",
            "捕",
            "弟",
            "暴",
            "割",
            "貫",
            "殊",
            "釋",
            "詞",
            "亡",
            "壁",
            "頓",
            "寶",
            "午",
            "塵",
            "聞",
            "揭",
            "炮",
            "殘",
            "冬",
            "橋",
            "婦",
            "警",
            "綜",
            "招",
            "吳",
            "付",
            "浮",
            "遭",
            "徐",
            "您",
            "搖",
            "谷",
            "贊",
            "箱",
            "隔",
            "訂",
            "男",
            "吹",
            "園",
            "紛",
            "唐",
            "敗",
            "宋",
            "玻",
            "巨",
            "耕",
            "坦",
            "榮",
            "閉",
            "灣",
            "鍵",
            "凡",
            "駐",
            "鍋",
            "救",
            "恩",
            "剝",
            "凝",
            "鹼",
            "齒",
            "截",
            "煉",
            "麻",
            "紡",
            "禁",
            "廢",
            "盛",
            "版",
            "緩",
            "淨",
            "睛",
            "昌",
            "婚",
            "涉",
            "筒",
            "嘴",
            "插",
            "岸",
            "朗",
            "莊",
            "街",
            "藏",
            "姑",
            "貿",
            "腐",
            "奴",
            "啦",
            "慣",
            "乘",
            "夥",
            "恢",
            "勻",
            "紗",
            "扎",
            "辯",
            "耳",
            "彪",
            "臣",
            "億",
            "璃",
            "抵",
            "脈",
            "秀",
            "薩",
            "俄",
            "網",
            "舞",
            "店",
            "噴",
            "縱",
            "寸",
            "汗",
            "掛",
            "洪",
            "賀",
            "閃",
            "柬",
            "爆",
            "烯",
            "津",
            "稻",
            "牆",
            "軟",
            "勇",
            "像",
            "滾",
            "厘",
            "蒙",
            "芳",
            "肯",
            "坡",
            "柱",
            "盪",
            "腿",
            "儀",
            "旅",
            "尾",
            "軋",
            "冰",
            "貢",
            "登",
            "黎",
            "削",
            "鑽",
            "勒",
            "逃",
            "障",
            "氨",
            "郭",
            "峰",
            "幣",
            "港",
            "伏",
            "軌",
            "畝",
            "畢",
            "擦",
            "莫",
            "刺",
            "浪",
            "秘",
            "援",
            "株",
            "健",
            "售",
            "股",
            "島",
            "甘",
            "泡",
            "睡",
            "童",
            "鑄",
            "湯",
            "閥",
            "休",
            "匯",
            "舍",
            "牧",
            "繞",
            "炸",
            "哲",
            "磷",
            "績",
            "朋",
            "淡",
            "尖",
            "啟",
            "陷",
            "柴",
            "呈",
            "徒",
            "顏",
            "淚",
            "稍",
            "忘",
            "泵",
            "藍",
            "拖",
            "洞",
            "授",
            "鏡",
            "辛",
            "壯",
            "鋒",
            "貧",
            "虛",
            "彎",
            "摩",
            "泰",
            "幼",
            "廷",
            "尊",
            "窗",
            "綱",
            "弄",
            "隸",
            "疑",
            "氏",
            "宮",
            "姐",
            "震",
            "瑞",
            "怪",
            "尤",
            "琴",
            "循",
            "描",
            "膜",
            "違",
            "夾",
            "腰",
            "緣",
            "珠",
            "窮",
            "森",
            "枝",
            "竹",
            "溝",
            "催",
            "繩",
            "憶",
            "邦",
            "剩",
            "幸",
            "漿",
            "欄",
            "擁",
            "牙",
            "貯",
            "禮",
            "濾",
            "鈉",
            "紋",
            "罷",
            "拍",
            "咱",
            "喊",
            "袖",
            "埃",
            "勤",
            "罰",
            "焦",
            "潛",
            "伍",
            "墨",
            "欲",
            "縫",
            "姓",
            "刊",
            "飽",
            "仿",
            "獎",
            "鋁",
            "鬼",
            "麗",
            "跨",
            "默",
            "挖",
            "鏈",
            "掃",
            "喝",
            "袋",
            "炭",
            "污",
            "幕",
            "諸",
            "弧",
            "勵",
            "梅",
            "奶",
            "潔",
            "災",
            "舟",
            "鑑",
            "苯",
            "訟",
            "抱",
            "毀",
            "懂",
            "寒",
            "智",
            "埔",
            "寄",
            "屆",
            "躍",
            "渡",
            "挑",
            "丹",
            "艱",
            "貝",
            "碰",
            "拔",
            "爹",
            "戴",
            "碼",
            "夢",
            "芽",
            "熔",
            "赤",
            "漁",
            "哭",
            "敬",
            "顆",
            "奔",
            "鉛",
            "仲",
            "虎",
            "稀",
            "妹",
            "乏",
            "珍",
            "申",
            "桌",
            "遵",
            "允",
            "隆",
            "螺",
            "倉",
            "魏",
            "銳",
            "曉",
            "氮",
            "兼",
            "隱",
            "礙",
            "赫",
            "撥",
            "忠",
            "肅",
            "缸",
            "牽",
            "搶",
            "博",
            "巧",
            "殼",
            "兄",
            "杜",
            "訊",
            "誠",
            "碧",
            "祥",
            "柯",
            "頁",
            "巡",
            "矩",
            "悲",
            "灌",
            "齡",
            "倫",
            "票",
            "尋",
            "桂",
            "鋪",
            "聖",
            "恐",
            "恰",
            "鄭",
            "趣",
            "抬",
            "荒",
            "騰",
            "貼",
            "柔",
            "滴",
            "猛",
            "闊",
            "輛",
            "妻",
            "填",
            "撤",
            "儲",
            "簽",
            "鬧",
            "擾",
            "紫",
            "砂",
            "遞",
            "戲",
            "吊",
            "陶",
            "伐",
            "餵",
            "療",
            "瓶",
            "婆",
            "撫",
            "臂",
            "摸",
            "忍",
            "蝦",
            "蠟",
            "鄰",
            "胸",
            "鞏",
            "擠",
            "偶",
            "棄",
            "槽",
            "勁",
            "乳",
            "鄧",
            "吉",
            "仁",
            "爛",
            "磚",
            "租",
            "烏",
            "艦",
            "伴",
            "瓜",
            "淺",
            "丙",
            "暫",
            "燥",
            "橡",
            "柳",
            "迷",
            "暖",
            "牌",
            "秧",
            "膽",
            "詳",
            "簧",
            "踏",
            "瓷",
            "譜",
            "呆",
            "賓",
            "糊",
            "洛",
            "輝",
            "憤",
            "競",
            "隙",
            "怒",
            "粘",
            "乃",
            "緒",
            "肩",
            "籍",
            "敏",
            "塗",
            "熙",
            "皆",
            "偵",
            "懸",
            "掘",
            "享",
            "糾",
            "醒",
            "狂",
            "鎖",
            "淀",
            "恨",
            "牲",
            "霸",
            "爬",
            "賞",
            "逆",
            "玩",
            "陵",
            "祝",
            "秒",
            "浙",
            "貌",
            "役",
            "彼",
            "悉",
            "鴨",
            "趨",
            "鳳",
            "晨",
            "畜",
            "輩",
            "秩",
            "卵",
            "署",
            "梯",
            "炎",
            "灘",
            "棋",
            "驅",
            "篩",
            "峽",
            "冒",
            "啥",
            "壽",
            "譯",
            "浸",
            "泉",
            "帽",
            "遲",
            "矽",
            "疆",
            "貸",
            "漏",
            "稿",
            "冠",
            "嫩",
            "脅",
            "芯",
            "牢",
            "叛",
            "蝕",
            "奧",
            "鳴",
            "嶺",
            "羊",
            "憑",
            "串",
            "塘",
            "繪",
            "酵",
            "融",
            "盆",
            "錫",
            "廟",
            "籌",
            "凍",
            "輔",
            "攝",
            "襲",
            "筋",
            "拒",
            "僚",
            "旱",
            "鉀",
            "鳥",
            "漆",
            "沈",
            "眉",
            "疏",
            "添",
            "棒",
            "穗",
            "硝",
            "韓",
            "逼",
            "扭",
            "僑",
            "涼",
            "挺",
            "碗",
            "栽",
            "炒",
            "杯",
            "患",
            "餾",
            "勸",
            "豪",
            "遼",
            "勃",
            "鴻",
            "旦",
            "吏",
            "拜",
            "狗",
            "埋",
            "輥",
            "掩",
            "飲",
            "搬",
            "罵",
            "辭",
            "勾",
            "扣",
            "估",
            "蔣",
            "絨",
            "霧",
            "丈",
            "朵",
            "姆",
            "擬",
            "宇",
            "輯",
            "陝",
            "雕",
            "償",
            "蓄",
            "崇",
            "剪",
            "倡",
            "廳",
            "咬",
            "駛",
            "薯",
            "刷",
            "斥",
            "番",
            "賦",
            "奉",
            "佛",
            "澆",
            "漫",
            "曼",
            "扇",
            "鈣",
            "桃",
            "扶",
            "仔",
            "返",
            "俗",
            "虧",
            "腔",
            "鞋",
            "棱",
            "覆",
            "框",
            "悄",
            "叔",
            "撞",
            "騙",
            "勘",
            "旺",
            "沸",
            "孤",
            "吐",
            "孟",
            "渠",
            "屈",
            "疾",
            "妙",
            "惜",
            "仰",
            "狠",
            "脹",
            "諧",
            "拋",
            "黴",
            "桑",
            "崗",
            "嘛",
            "衰",
            "盜",
            "滲",
            "臟",
            "賴",
            "湧",
            "甜",
            "曹",
            "閱",
            "肌",
            "哩",
            "厲",
            "烴",
            "緯",
            "毅",
            "昨",
            "偽",
            "症",
            "煮",
            "嘆",
            "釘",
            "搭",
            "莖",
            "籠",
            "酷",
            "偷",
            "弓",
            "錐",
            "恆",
            "傑",
            "坑",
            "鼻",
            "翼",
            "綸",
            "敘",
            "獄",
            "逮",
            "罐",
            "絡",
            "棚",
            "抑",
            "膨",
            "蔬",
            "寺",
            "驟",
            "穆",
            "冶",
            "枯",
            "冊",
            "屍",
            "凸",
            "紳",
            "坯",
            "犧",
            "焰",
            "轟",
            "欣",
            "晉",
            "瘦",
            "禦",
            "錠",
            "錦",
            "喪",
            "旬",
            "鍛",
            "壟",
            "搜",
            "撲",
            "邀",
            "亭",
            "酯",
            "邁",
            "舒",
            "脆",
            "酶",
            "閒",
            "憂",
            "酚",
            "頑",
            "羽",
            "漲",
            "卸",
            "仗",
            "陪",
            "闢",
            "懲",
            "杭",
            "姚",
            "肚",
            "捉",
            "飄",
            "漂",
            "昆",
            "欺",
            "吾",
            "郎",
            "烷",
            "汁",
            "呵",
            "飾",
            "蕭",
            "雅",
            "郵",
            "遷",
            "燕",
            "撒",
            "姻",
            "赴",
            "宴",
            "煩",
            "債",
            "帳",
            "斑",
            "鈴",
            "旨",
            "醇",
            "董",
            "餅",
            "雛",
            "姿",
            "拌",
            "傅",
            "腹",
            "妥",
            "揉",
            "賢",
            "拆",
            "歪",
            "葡",
            "胺",
            "丟",
            "浩",
            "徽",
            "昂",
            "墊",
            "擋",
            "覽",
            "貪",
            "慰",
            "繳",
            "汪",
            "慌",
            "馮",
            "諾",
            "姜",
            "誼",
            "兇",
            "劣",
            "誣",
            "耀",
            "昏",
            "躺",
            "盈",
            "騎",
            "喬",
            "溪",
            "叢",
            "盧",
            "抹",
            "悶",
            "諮",
            "刮",
            "駕",
            "纜",
            "悟",
            "摘",
            "鉺",
            "擲",
            "頗",
            "幻",
            "柄",
            "惠",
            "慘",
            "佳",
            "仇",
            "臘",
            "窩",
            "滌",
            "劍",
            "瞧",
            "堡",
            "潑",
            "蔥",
            "罩",
            "霍",
            "撈",
            "胎",
            "蒼",
            "濱",
            "倆",
            "捅",
            "湘",
            "砍",
            "霞",
            "邵",
            "萄",
            "瘋",
            "淮",
            "遂",
            "熊",
            "糞",
            "烘",
            "宿",
            "檔",
            "戈",
            "駁",
            "嫂",
            "裕",
            "徙",
            "箭",
            "捐",
            "腸",
            "撐",
            "曬",
            "辨",
            "殿",
            "蓮",
            "攤",
            "攪",
            "醬",
            "屏",
            "疫",
            "哀",
            "蔡",
            "堵",
            "沫",
            "皺",
            "暢",
            "疊",
            "閣",
            "萊",
            "敲",
            "轄",
            "鉤",
            "痕",
            "壩",
            "巷",
            "餓",
            "禍",
            "丘",
            "玄",
            "溜",
            "曰",
            "邏",
            "彭",
            "嘗",
            "卿",
            "妨",
            "艇",
            "吞",
            "韋",
            "怨",
            "矮",
            "歇"
        ]

    }, {}],
    65: [function (require, module, exports) {
        module.exports = [
            "abandon",
            "ability",
            "able",
            "about",
            "above",
            "absent",
            "absorb",
            "abstract",
            "absurd",
            "abuse",
            "access",
            "accident",
            "account",
            "accuse",
            "achieve",
            "acid",
            "acoustic",
            "acquire",
            "across",
            "act",
            "action",
            "actor",
            "actress",
            "actual",
            "adapt",
            "add",
            "addict",
            "address",
            "adjust",
            "admit",
            "adult",
            "advance",
            "advice",
            "aerobic",
            "affair",
            "afford",
            "afraid",
            "again",
            "age",
            "agent",
            "agree",
            "ahead",
            "aim",
            "air",
            "airport",
            "aisle",
            "alarm",
            "album",
            "alcohol",
            "alert",
            "alien",
            "all",
            "alley",
            "allow",
            "almost",
            "alone",
            "alpha",
            "already",
            "also",
            "alter",
            "always",
            "amateur",
            "amazing",
            "among",
            "amount",
            "amused",
            "analyst",
            "anchor",
            "ancient",
            "anger",
            "angle",
            "angry",
            "animal",
            "ankle",
            "announce",
            "annual",
            "another",
            "answer",
            "antenna",
            "antique",
            "anxiety",
            "any",
            "apart",
            "apology",
            "appear",
            "apple",
            "approve",
            "april",
            "arch",
            "arctic",
            "area",
            "arena",
            "argue",
            "arm",
            "armed",
            "armor",
            "army",
            "around",
            "arrange",
            "arrest",
            "arrive",
            "arrow",
            "art",
            "artefact",
            "artist",
            "artwork",
            "ask",
            "aspect",
            "assault",
            "asset",
            "assist",
            "assume",
            "asthma",
            "athlete",
            "atom",
            "attack",
            "attend",
            "attitude",
            "attract",
            "auction",
            "audit",
            "august",
            "aunt",
            "author",
            "auto",
            "autumn",
            "average",
            "avocado",
            "avoid",
            "awake",
            "aware",
            "away",
            "awesome",
            "awful",
            "awkward",
            "axis",
            "baby",
            "bachelor",
            "bacon",
            "badge",
            "bag",
            "balance",
            "balcony",
            "ball",
            "bamboo",
            "banana",
            "banner",
            "bar",
            "barely",
            "bargain",
            "barrel",
            "base",
            "basic",
            "basket",
            "battle",
            "beach",
            "bean",
            "beauty",
            "because",
            "become",
            "beef",
            "before",
            "begin",
            "behave",
            "behind",
            "believe",
            "below",
            "belt",
            "bench",
            "benefit",
            "best",
            "betray",
            "better",
            "between",
            "beyond",
            "bicycle",
            "bid",
            "bike",
            "bind",
            "biology",
            "bird",
            "birth",
            "bitter",
            "black",
            "blade",
            "blame",
            "blanket",
            "blast",
            "bleak",
            "bless",
            "blind",
            "blood",
            "blossom",
            "blouse",
            "blue",
            "blur",
            "blush",
            "board",
            "boat",
            "body",
            "boil",
            "bomb",
            "bone",
            "bonus",
            "book",
            "boost",
            "border",
            "boring",
            "borrow",
            "boss",
            "bottom",
            "bounce",
            "box",
            "boy",
            "bracket",
            "brain",
            "brand",
            "brass",
            "brave",
            "bread",
            "breeze",
            "brick",
            "bridge",
            "brief",
            "bright",
            "bring",
            "brisk",
            "broccoli",
            "broken",
            "bronze",
            "broom",
            "brother",
            "brown",
            "brush",
            "bubble",
            "buddy",
            "budget",
            "buffalo",
            "build",
            "bulb",
            "bulk",
            "bullet",
            "bundle",
            "bunker",
            "burden",
            "burger",
            "burst",
            "bus",
            "business",
            "busy",
            "butter",
            "buyer",
            "buzz",
            "cabbage",
            "cabin",
            "cable",
            "cactus",
            "cage",
            "cake",
            "call",
            "calm",
            "camera",
            "camp",
            "can",
            "canal",
            "cancel",
            "candy",
            "cannon",
            "canoe",
            "canvas",
            "canyon",
            "capable",
            "capital",
            "captain",
            "car",
            "carbon",
            "card",
            "cargo",
            "carpet",
            "carry",
            "cart",
            "case",
            "cash",
            "casino",
            "castle",
            "casual",
            "cat",
            "catalog",
            "catch",
            "category",
            "cattle",
            "caught",
            "cause",
            "caution",
            "cave",
            "ceiling",
            "celery",
            "cement",
            "census",
            "century",
            "cereal",
            "certain",
            "chair",
            "chalk",
            "champion",
            "change",
            "chaos",
            "chapter",
            "charge",
            "chase",
            "chat",
            "cheap",
            "check",
            "cheese",
            "chef",
            "cherry",
            "chest",
            "chicken",
            "chief",
            "child",
            "chimney",
            "choice",
            "choose",
            "chronic",
            "chuckle",
            "chunk",
            "churn",
            "cigar",
            "cinnamon",
            "circle",
            "citizen",
            "city",
            "civil",
            "claim",
            "clap",
            "clarify",
            "claw",
            "clay",
            "clean",
            "clerk",
            "clever",
            "click",
            "client",
            "cliff",
            "climb",
            "clinic",
            "clip",
            "clock",
            "clog",
            "close",
            "cloth",
            "cloud",
            "clown",
            "club",
            "clump",
            "cluster",
            "clutch",
            "coach",
            "coast",
            "coconut",
            "code",
            "coffee",
            "coil",
            "coin",
            "collect",
            "color",
            "column",
            "combine",
            "come",
            "comfort",
            "comic",
            "common",
            "company",
            "concert",
            "conduct",
            "confirm",
            "congress",
            "connect",
            "consider",
            "control",
            "convince",
            "cook",
            "cool",
            "copper",
            "copy",
            "coral",
            "core",
            "corn",
            "correct",
            "cost",
            "cotton",
            "couch",
            "country",
            "couple",
            "course",
            "cousin",
            "cover",
            "coyote",
            "crack",
            "cradle",
            "craft",
            "cram",
            "crane",
            "crash",
            "crater",
            "crawl",
            "crazy",
            "cream",
            "credit",
            "creek",
            "crew",
            "cricket",
            "crime",
            "crisp",
            "critic",
            "crop",
            "cross",
            "crouch",
            "crowd",
            "crucial",
            "cruel",
            "cruise",
            "crumble",
            "crunch",
            "crush",
            "cry",
            "crystal",
            "cube",
            "culture",
            "cup",
            "cupboard",
            "curious",
            "current",
            "curtain",
            "curve",
            "cushion",
            "custom",
            "cute",
            "cycle",
            "dad",
            "damage",
            "damp",
            "dance",
            "danger",
            "daring",
            "dash",
            "daughter",
            "dawn",
            "day",
            "deal",
            "debate",
            "debris",
            "decade",
            "december",
            "decide",
            "decline",
            "decorate",
            "decrease",
            "deer",
            "defense",
            "define",
            "defy",
            "degree",
            "delay",
            "deliver",
            "demand",
            "demise",
            "denial",
            "dentist",
            "deny",
            "depart",
            "depend",
            "deposit",
            "depth",
            "deputy",
            "derive",
            "describe",
            "desert",
            "design",
            "desk",
            "despair",
            "destroy",
            "detail",
            "detect",
            "develop",
            "device",
            "devote",
            "diagram",
            "dial",
            "diamond",
            "diary",
            "dice",
            "diesel",
            "diet",
            "differ",
            "digital",
            "dignity",
            "dilemma",
            "dinner",
            "dinosaur",
            "direct",
            "dirt",
            "disagree",
            "discover",
            "disease",
            "dish",
            "dismiss",
            "disorder",
            "display",
            "distance",
            "divert",
            "divide",
            "divorce",
            "dizzy",
            "doctor",
            "document",
            "dog",
            "doll",
            "dolphin",
            "domain",
            "donate",
            "donkey",
            "donor",
            "door",
            "dose",
            "double",
            "dove",
            "draft",
            "dragon",
            "drama",
            "drastic",
            "draw",
            "dream",
            "dress",
            "drift",
            "drill",
            "drink",
            "drip",
            "drive",
            "drop",
            "drum",
            "dry",
            "duck",
            "dumb",
            "dune",
            "during",
            "dust",
            "dutch",
            "duty",
            "dwarf",
            "dynamic",
            "eager",
            "eagle",
            "early",
            "earn",
            "earth",
            "easily",
            "east",
            "easy",
            "echo",
            "ecology",
            "economy",
            "edge",
            "edit",
            "educate",
            "effort",
            "egg",
            "eight",
            "either",
            "elbow",
            "elder",
            "electric",
            "elegant",
            "element",
            "elephant",
            "elevator",
            "elite",
            "else",
            "embark",
            "embody",
            "embrace",
            "emerge",
            "emotion",
            "employ",
            "empower",
            "empty",
            "enable",
            "enact",
            "end",
            "endless",
            "endorse",
            "enemy",
            "energy",
            "enforce",
            "engage",
            "engine",
            "enhance",
            "enjoy",
            "enlist",
            "enough",
            "enrich",
            "enroll",
            "ensure",
            "enter",
            "entire",
            "entry",
            "envelope",
            "episode",
            "equal",
            "equip",
            "era",
            "erase",
            "erode",
            "erosion",
            "error",
            "erupt",
            "escape",
            "essay",
            "essence",
            "estate",
            "eternal",
            "ethics",
            "evidence",
            "evil",
            "evoke",
            "evolve",
            "exact",
            "example",
            "excess",
            "exchange",
            "excite",
            "exclude",
            "excuse",
            "execute",
            "exercise",
            "exhaust",
            "exhibit",
            "exile",
            "exist",
            "exit",
            "exotic",
            "expand",
            "expect",
            "expire",
            "explain",
            "expose",
            "express",
            "extend",
            "extra",
            "eye",
            "eyebrow",
            "fabric",
            "face",
            "faculty",
            "fade",
            "faint",
            "faith",
            "fall",
            "false",
            "fame",
            "family",
            "famous",
            "fan",
            "fancy",
            "fantasy",
            "farm",
            "fashion",
            "fat",
            "fatal",
            "father",
            "fatigue",
            "fault",
            "favorite",
            "feature",
            "february",
            "federal",
            "fee",
            "feed",
            "feel",
            "female",
            "fence",
            "festival",
            "fetch",
            "fever",
            "few",
            "fiber",
            "fiction",
            "field",
            "figure",
            "file",
            "film",
            "filter",
            "final",
            "find",
            "fine",
            "finger",
            "finish",
            "fire",
            "firm",
            "first",
            "fiscal",
            "fish",
            "fit",
            "fitness",
            "fix",
            "flag",
            "flame",
            "flash",
            "flat",
            "flavor",
            "flee",
            "flight",
            "flip",
            "float",
            "flock",
            "floor",
            "flower",
            "fluid",
            "flush",
            "fly",
            "foam",
            "focus",
            "fog",
            "foil",
            "fold",
            "follow",
            "food",
            "foot",
            "force",
            "forest",
            "forget",
            "fork",
            "fortune",
            "forum",
            "forward",
            "fossil",
            "foster",
            "found",
            "fox",
            "fragile",
            "frame",
            "frequent",
            "fresh",
            "friend",
            "fringe",
            "frog",
            "front",
            "frost",
            "frown",
            "frozen",
            "fruit",
            "fuel",
            "fun",
            "funny",
            "furnace",
            "fury",
            "future",
            "gadget",
            "gain",
            "galaxy",
            "gallery",
            "game",
            "gap",
            "garage",
            "garbage",
            "garden",
            "garlic",
            "garment",
            "gas",
            "gasp",
            "gate",
            "gather",
            "gauge",
            "gaze",
            "general",
            "genius",
            "genre",
            "gentle",
            "genuine",
            "gesture",
            "ghost",
            "giant",
            "gift",
            "giggle",
            "ginger",
            "giraffe",
            "girl",
            "give",
            "glad",
            "glance",
            "glare",
            "glass",
            "glide",
            "glimpse",
            "globe",
            "gloom",
            "glory",
            "glove",
            "glow",
            "glue",
            "goat",
            "goddess",
            "gold",
            "good",
            "goose",
            "gorilla",
            "gospel",
            "gossip",
            "govern",
            "gown",
            "grab",
            "grace",
            "grain",
            "grant",
            "grape",
            "grass",
            "gravity",
            "great",
            "green",
            "grid",
            "grief",
            "grit",
            "grocery",
            "group",
            "grow",
            "grunt",
            "guard",
            "guess",
            "guide",
            "guilt",
            "guitar",
            "gun",
            "gym",
            "habit",
            "hair",
            "half",
            "hammer",
            "hamster",
            "hand",
            "happy",
            "harbor",
            "hard",
            "harsh",
            "harvest",
            "hat",
            "have",
            "hawk",
            "hazard",
            "head",
            "health",
            "heart",
            "heavy",
            "hedgehog",
            "height",
            "hello",
            "helmet",
            "help",
            "hen",
            "hero",
            "hidden",
            "high",
            "hill",
            "hint",
            "hip",
            "hire",
            "history",
            "hobby",
            "hockey",
            "hold",
            "hole",
            "holiday",
            "hollow",
            "home",
            "honey",
            "hood",
            "hope",
            "horn",
            "horror",
            "horse",
            "hospital",
            "host",
            "hotel",
            "hour",
            "hover",
            "hub",
            "huge",
            "human",
            "humble",
            "humor",
            "hundred",
            "hungry",
            "hunt",
            "hurdle",
            "hurry",
            "hurt",
            "husband",
            "hybrid",
            "ice",
            "icon",
            "idea",
            "identify",
            "idle",
            "ignore",
            "ill",
            "illegal",
            "illness",
            "image",
            "imitate",
            "immense",
            "immune",
            "impact",
            "impose",
            "improve",
            "impulse",
            "inch",
            "include",
            "income",
            "increase",
            "index",
            "indicate",
            "indoor",
            "industry",
            "infant",
            "inflict",
            "inform",
            "inhale",
            "inherit",
            "initial",
            "inject",
            "injury",
            "inmate",
            "inner",
            "innocent",
            "input",
            "inquiry",
            "insane",
            "insect",
            "inside",
            "inspire",
            "install",
            "intact",
            "interest",
            "into",
            "invest",
            "invite",
            "involve",
            "iron",
            "island",
            "isolate",
            "issue",
            "item",
            "ivory",
            "jacket",
            "jaguar",
            "jar",
            "jazz",
            "jealous",
            "jeans",
            "jelly",
            "jewel",
            "job",
            "join",
            "joke",
            "journey",
            "joy",
            "judge",
            "juice",
            "jump",
            "jungle",
            "junior",
            "junk",
            "just",
            "kangaroo",
            "keen",
            "keep",
            "ketchup",
            "key",
            "kick",
            "kid",
            "kidney",
            "kind",
            "kingdom",
            "kiss",
            "kit",
            "kitchen",
            "kite",
            "kitten",
            "kiwi",
            "knee",
            "knife",
            "knock",
            "know",
            "lab",
            "label",
            "labor",
            "ladder",
            "lady",
            "lake",
            "lamp",
            "language",
            "laptop",
            "large",
            "later",
            "latin",
            "laugh",
            "laundry",
            "lava",
            "law",
            "lawn",
            "lawsuit",
            "layer",
            "lazy",
            "leader",
            "leaf",
            "learn",
            "leave",
            "lecture",
            "left",
            "leg",
            "legal",
            "legend",
            "leisure",
            "lemon",
            "lend",
            "length",
            "lens",
            "leopard",
            "lesson",
            "letter",
            "level",
            "liar",
            "liberty",
            "library",
            "license",
            "life",
            "lift",
            "light",
            "like",
            "limb",
            "limit",
            "link",
            "lion",
            "liquid",
            "list",
            "little",
            "live",
            "lizard",
            "load",
            "loan",
            "lobster",
            "local",
            "lock",
            "logic",
            "lonely",
            "long",
            "loop",
            "lottery",
            "loud",
            "lounge",
            "love",
            "loyal",
            "lucky",
            "luggage",
            "lumber",
            "lunar",
            "lunch",
            "luxury",
            "lyrics",
            "machine",
            "mad",
            "magic",
            "magnet",
            "maid",
            "mail",
            "main",
            "major",
            "make",
            "mammal",
            "man",
            "manage",
            "mandate",
            "mango",
            "mansion",
            "manual",
            "maple",
            "marble",
            "march",
            "margin",
            "marine",
            "market",
            "marriage",
            "mask",
            "mass",
            "master",
            "match",
            "material",
            "math",
            "matrix",
            "matter",
            "maximum",
            "maze",
            "meadow",
            "mean",
            "measure",
            "meat",
            "mechanic",
            "medal",
            "media",
            "melody",
            "melt",
            "member",
            "memory",
            "mention",
            "menu",
            "mercy",
            "merge",
            "merit",
            "merry",
            "mesh",
            "message",
            "metal",
            "method",
            "middle",
            "midnight",
            "milk",
            "million",
            "mimic",
            "mind",
            "minimum",
            "minor",
            "minute",
            "miracle",
            "mirror",
            "misery",
            "miss",
            "mistake",
            "mix",
            "mixed",
            "mixture",
            "mobile",
            "model",
            "modify",
            "mom",
            "moment",
            "monitor",
            "monkey",
            "monster",
            "month",
            "moon",
            "moral",
            "more",
            "morning",
            "mosquito",
            "mother",
            "motion",
            "motor",
            "mountain",
            "mouse",
            "move",
            "movie",
            "much",
            "muffin",
            "mule",
            "multiply",
            "muscle",
            "museum",
            "mushroom",
            "music",
            "must",
            "mutual",
            "myself",
            "mystery",
            "myth",
            "naive",
            "name",
            "napkin",
            "narrow",
            "nasty",
            "nation",
            "nature",
            "near",
            "neck",
            "need",
            "negative",
            "neglect",
            "neither",
            "nephew",
            "nerve",
            "nest",
            "net",
            "network",
            "neutral",
            "never",
            "news",
            "next",
            "nice",
            "night",
            "noble",
            "noise",
            "nominee",
            "noodle",
            "normal",
            "north",
            "nose",
            "notable",
            "note",
            "nothing",
            "notice",
            "novel",
            "now",
            "nuclear",
            "number",
            "nurse",
            "nut",
            "oak",
            "obey",
            "object",
            "oblige",
            "obscure",
            "observe",
            "obtain",
            "obvious",
            "occur",
            "ocean",
            "october",
            "odor",
            "off",
            "offer",
            "office",
            "often",
            "oil",
            "okay",
            "old",
            "olive",
            "olympic",
            "omit",
            "once",
            "one",
            "onion",
            "online",
            "only",
            "open",
            "opera",
            "opinion",
            "oppose",
            "option",
            "orange",
            "orbit",
            "orchard",
            "order",
            "ordinary",
            "organ",
            "orient",
            "original",
            "orphan",
            "ostrich",
            "other",
            "outdoor",
            "outer",
            "output",
            "outside",
            "oval",
            "oven",
            "over",
            "own",
            "owner",
            "oxygen",
            "oyster",
            "ozone",
            "pact",
            "paddle",
            "page",
            "pair",
            "palace",
            "palm",
            "panda",
            "panel",
            "panic",
            "panther",
            "paper",
            "parade",
            "parent",
            "park",
            "parrot",
            "party",
            "pass",
            "patch",
            "path",
            "patient",
            "patrol",
            "pattern",
            "pause",
            "pave",
            "payment",
            "peace",
            "peanut",
            "pear",
            "peasant",
            "pelican",
            "pen",
            "penalty",
            "pencil",
            "people",
            "pepper",
            "perfect",
            "permit",
            "person",
            "pet",
            "phone",
            "photo",
            "phrase",
            "physical",
            "piano",
            "picnic",
            "picture",
            "piece",
            "pig",
            "pigeon",
            "pill",
            "pilot",
            "pink",
            "pioneer",
            "pipe",
            "pistol",
            "pitch",
            "pizza",
            "place",
            "planet",
            "plastic",
            "plate",
            "play",
            "please",
            "pledge",
            "pluck",
            "plug",
            "plunge",
            "poem",
            "poet",
            "point",
            "polar",
            "pole",
            "police",
            "pond",
            "pony",
            "pool",
            "popular",
            "portion",
            "position",
            "possible",
            "post",
            "potato",
            "pottery",
            "poverty",
            "powder",
            "power",
            "practice",
            "praise",
            "predict",
            "prefer",
            "prepare",
            "present",
            "pretty",
            "prevent",
            "price",
            "pride",
            "primary",
            "print",
            "priority",
            "prison",
            "private",
            "prize",
            "problem",
            "process",
            "produce",
            "profit",
            "program",
            "project",
            "promote",
            "proof",
            "property",
            "prosper",
            "protect",
            "proud",
            "provide",
            "public",
            "pudding",
            "pull",
            "pulp",
            "pulse",
            "pumpkin",
            "punch",
            "pupil",
            "puppy",
            "purchase",
            "purity",
            "purpose",
            "purse",
            "push",
            "put",
            "puzzle",
            "pyramid",
            "quality",
            "quantum",
            "quarter",
            "question",
            "quick",
            "quit",
            "quiz",
            "quote",
            "rabbit",
            "raccoon",
            "race",
            "rack",
            "radar",
            "radio",
            "rail",
            "rain",
            "raise",
            "rally",
            "ramp",
            "ranch",
            "random",
            "range",
            "rapid",
            "rare",
            "rate",
            "rather",
            "raven",
            "raw",
            "razor",
            "ready",
            "real",
            "reason",
            "rebel",
            "rebuild",
            "recall",
            "receive",
            "recipe",
            "record",
            "recycle",
            "reduce",
            "reflect",
            "reform",
            "refuse",
            "region",
            "regret",
            "regular",
            "reject",
            "relax",
            "release",
            "relief",
            "rely",
            "remain",
            "remember",
            "remind",
            "remove",
            "render",
            "renew",
            "rent",
            "reopen",
            "repair",
            "repeat",
            "replace",
            "report",
            "require",
            "rescue",
            "resemble",
            "resist",
            "resource",
            "response",
            "result",
            "retire",
            "retreat",
            "return",
            "reunion",
            "reveal",
            "review",
            "reward",
            "rhythm",
            "rib",
            "ribbon",
            "rice",
            "rich",
            "ride",
            "ridge",
            "rifle",
            "right",
            "rigid",
            "ring",
            "riot",
            "ripple",
            "risk",
            "ritual",
            "rival",
            "river",
            "road",
            "roast",
            "robot",
            "robust",
            "rocket",
            "romance",
            "roof",
            "rookie",
            "room",
            "rose",
            "rotate",
            "rough",
            "round",
            "route",
            "royal",
            "rubber",
            "rude",
            "rug",
            "rule",
            "run",
            "runway",
            "rural",
            "sad",
            "saddle",
            "sadness",
            "safe",
            "sail",
            "salad",
            "salmon",
            "salon",
            "salt",
            "salute",
            "same",
            "sample",
            "sand",
            "satisfy",
            "satoshi",
            "sauce",
            "sausage",
            "save",
            "say",
            "scale",
            "scan",
            "scare",
            "scatter",
            "scene",
            "scheme",
            "school",
            "science",
            "scissors",
            "scorpion",
            "scout",
            "scrap",
            "screen",
            "script",
            "scrub",
            "sea",
            "search",
            "season",
            "seat",
            "second",
            "secret",
            "section",
            "security",
            "seed",
            "seek",
            "segment",
            "select",
            "sell",
            "seminar",
            "senior",
            "sense",
            "sentence",
            "series",
            "service",
            "session",
            "settle",
            "setup",
            "seven",
            "shadow",
            "shaft",
            "shallow",
            "share",
            "shed",
            "shell",
            "sheriff",
            "shield",
            "shift",
            "shine",
            "ship",
            "shiver",
            "shock",
            "shoe",
            "shoot",
            "shop",
            "short",
            "shoulder",
            "shove",
            "shrimp",
            "shrug",
            "shuffle",
            "shy",
            "sibling",
            "sick",
            "side",
            "siege",
            "sight",
            "sign",
            "silent",
            "silk",
            "silly",
            "silver",
            "similar",
            "simple",
            "since",
            "sing",
            "siren",
            "sister",
            "situate",
            "six",
            "size",
            "skate",
            "sketch",
            "ski",
            "skill",
            "skin",
            "skirt",
            "skull",
            "slab",
            "slam",
            "sleep",
            "slender",
            "slice",
            "slide",
            "slight",
            "slim",
            "slogan",
            "slot",
            "slow",
            "slush",
            "small",
            "smart",
            "smile",
            "smoke",
            "smooth",
            "snack",
            "snake",
            "snap",
            "sniff",
            "snow",
            "soap",
            "soccer",
            "social",
            "sock",
            "soda",
            "soft",
            "solar",
            "soldier",
            "solid",
            "solution",
            "solve",
            "someone",
            "song",
            "soon",
            "sorry",
            "sort",
            "soul",
            "sound",
            "soup",
            "source",
            "south",
            "space",
            "spare",
            "spatial",
            "spawn",
            "speak",
            "special",
            "speed",
            "spell",
            "spend",
            "sphere",
            "spice",
            "spider",
            "spike",
            "spin",
            "spirit",
            "split",
            "spoil",
            "sponsor",
            "spoon",
            "sport",
            "spot",
            "spray",
            "spread",
            "spring",
            "spy",
            "square",
            "squeeze",
            "squirrel",
            "stable",
            "stadium",
            "staff",
            "stage",
            "stairs",
            "stamp",
            "stand",
            "start",
            "state",
            "stay",
            "steak",
            "steel",
            "stem",
            "step",
            "stereo",
            "stick",
            "still",
            "sting",
            "stock",
            "stomach",
            "stone",
            "stool",
            "story",
            "stove",
            "strategy",
            "street",
            "strike",
            "strong",
            "struggle",
            "student",
            "stuff",
            "stumble",
            "style",
            "subject",
            "submit",
            "subway",
            "success",
            "such",
            "sudden",
            "suffer",
            "sugar",
            "suggest",
            "suit",
            "summer",
            "sun",
            "sunny",
            "sunset",
            "super",
            "supply",
            "supreme",
            "sure",
            "surface",
            "surge",
            "surprise",
            "surround",
            "survey",
            "suspect",
            "sustain",
            "swallow",
            "swamp",
            "swap",
            "swarm",
            "swear",
            "sweet",
            "swift",
            "swim",
            "swing",
            "switch",
            "sword",
            "symbol",
            "symptom",
            "syrup",
            "system",
            "table",
            "tackle",
            "tag",
            "tail",
            "talent",
            "talk",
            "tank",
            "tape",
            "target",
            "task",
            "taste",
            "tattoo",
            "taxi",
            "teach",
            "team",
            "tell",
            "ten",
            "tenant",
            "tennis",
            "tent",
            "term",
            "test",
            "text",
            "thank",
            "that",
            "theme",
            "then",
            "theory",
            "there",
            "they",
            "thing",
            "this",
            "thought",
            "three",
            "thrive",
            "throw",
            "thumb",
            "thunder",
            "ticket",
            "tide",
            "tiger",
            "tilt",
            "timber",
            "time",
            "tiny",
            "tip",
            "tired",
            "tissue",
            "title",
            "toast",
            "tobacco",
            "today",
            "toddler",
            "toe",
            "together",
            "toilet",
            "token",
            "tomato",
            "tomorrow",
            "tone",
            "tongue",
            "tonight",
            "tool",
            "tooth",
            "top",
            "topic",
            "topple",
            "torch",
            "tornado",
            "tortoise",
            "toss",
            "total",
            "tourist",
            "toward",
            "tower",
            "town",
            "toy",
            "track",
            "trade",
            "traffic",
            "tragic",
            "train",
            "transfer",
            "trap",
            "trash",
            "travel",
            "tray",
            "treat",
            "tree",
            "trend",
            "trial",
            "tribe",
            "trick",
            "trigger",
            "trim",
            "trip",
            "trophy",
            "trouble",
            "truck",
            "true",
            "truly",
            "trumpet",
            "trust",
            "truth",
            "try",
            "tube",
            "tuition",
            "tumble",
            "tuna",
            "tunnel",
            "turkey",
            "turn",
            "turtle",
            "twelve",
            "twenty",
            "twice",
            "twin",
            "twist",
            "two",
            "type",
            "typical",
            "ugly",
            "umbrella",
            "unable",
            "unaware",
            "uncle",
            "uncover",
            "under",
            "undo",
            "unfair",
            "unfold",
            "unhappy",
            "uniform",
            "unique",
            "unit",
            "universe",
            "unknown",
            "unlock",
            "until",
            "unusual",
            "unveil",
            "update",
            "upgrade",
            "uphold",
            "upon",
            "upper",
            "upset",
            "urban",
            "urge",
            "usage",
            "use",
            "used",
            "useful",
            "useless",
            "usual",
            "utility",
            "vacant",
            "vacuum",
            "vague",
            "valid",
            "valley",
            "valve",
            "van",
            "vanish",
            "vapor",
            "various",
            "vast",
            "vault",
            "vehicle",
            "velvet",
            "vendor",
            "venture",
            "venue",
            "verb",
            "verify",
            "version",
            "very",
            "vessel",
            "veteran",
            "viable",
            "vibrant",
            "vicious",
            "victory",
            "video",
            "view",
            "village",
            "vintage",
            "violin",
            "virtual",
            "virus",
            "visa",
            "visit",
            "visual",
            "vital",
            "vivid",
            "vocal",
            "voice",
            "void",
            "volcano",
            "volume",
            "vote",
            "voyage",
            "wage",
            "wagon",
            "wait",
            "walk",
            "wall",
            "walnut",
            "want",
            "warfare",
            "warm",
            "warrior",
            "wash",
            "wasp",
            "waste",
            "water",
            "wave",
            "way",
            "wealth",
            "weapon",
            "wear",
            "weasel",
            "weather",
            "web",
            "wedding",
            "weekend",
            "weird",
            "welcome",
            "west",
            "wet",
            "whale",
            "what",
            "wheat",
            "wheel",
            "when",
            "where",
            "whip",
            "whisper",
            "wide",
            "width",
            "wife",
            "wild",
            "will",
            "win",
            "window",
            "wine",
            "wing",
            "wink",
            "winner",
            "winter",
            "wire",
            "wisdom",
            "wise",
            "wish",
            "witness",
            "wolf",
            "woman",
            "wonder",
            "wood",
            "wool",
            "word",
            "work",
            "world",
            "worry",
            "worth",
            "wrap",
            "wreck",
            "wrestle",
            "wrist",
            "write",
            "wrong",
            "yard",
            "year",
            "yellow",
            "you",
            "young",
            "youth",
            "zebra",
            "zero",
            "zone",
            "zoo"
        ]

    }, {}],
    66: [function (require, module, exports) {
        module.exports = [
            "abaisser",
            "abandon",
            "abdiquer",
            "abeille",
            "abolir",
            "aborder",
            "aboutir",
            "aboyer",
            "abrasif",
            "abreuver",
            "abriter",
            "abroger",
            "abrupt",
            "absence",
            "absolu",
            "absurde",
            "abusif",
            "abyssal",
            "académie",
            "acajou",
            "acarien",
            "accabler",
            "accepter",
            "acclamer",
            "accolade",
            "accroche",
            "accuser",
            "acerbe",
            "achat",
            "acheter",
            "aciduler",
            "acier",
            "acompte",
            "acquérir",
            "acronyme",
            "acteur",
            "actif",
            "actuel",
            "adepte",
            "adéquat",
            "adhésif",
            "adjectif",
            "adjuger",
            "admettre",
            "admirer",
            "adopter",
            "adorer",
            "adoucir",
            "adresse",
            "adroit",
            "adulte",
            "adverbe",
            "aérer",
            "aéronef",
            "affaire",
            "affecter",
            "affiche",
            "affreux",
            "affubler",
            "agacer",
            "agencer",
            "agile",
            "agiter",
            "agrafer",
            "agréable",
            "agrume",
            "aider",
            "aiguille",
            "ailier",
            "aimable",
            "aisance",
            "ajouter",
            "ajuster",
            "alarmer",
            "alchimie",
            "alerte",
            "algèbre",
            "algue",
            "aliéner",
            "aliment",
            "alléger",
            "alliage",
            "allouer",
            "allumer",
            "alourdir",
            "alpaga",
            "altesse",
            "alvéole",
            "amateur",
            "ambigu",
            "ambre",
            "aménager",
            "amertume",
            "amidon",
            "amiral",
            "amorcer",
            "amour",
            "amovible",
            "amphibie",
            "ampleur",
            "amusant",
            "analyse",
            "anaphore",
            "anarchie",
            "anatomie",
            "ancien",
            "anéantir",
            "angle",
            "angoisse",
            "anguleux",
            "animal",
            "annexer",
            "annonce",
            "annuel",
            "anodin",
            "anomalie",
            "anonyme",
            "anormal",
            "antenne",
            "antidote",
            "anxieux",
            "apaiser",
            "apéritif",
            "aplanir",
            "apologie",
            "appareil",
            "appeler",
            "apporter",
            "appuyer",
            "aquarium",
            "aqueduc",
            "arbitre",
            "arbuste",
            "ardeur",
            "ardoise",
            "argent",
            "arlequin",
            "armature",
            "armement",
            "armoire",
            "armure",
            "arpenter",
            "arracher",
            "arriver",
            "arroser",
            "arsenic",
            "artériel",
            "article",
            "aspect",
            "asphalte",
            "aspirer",
            "assaut",
            "asservir",
            "assiette",
            "associer",
            "assurer",
            "asticot",
            "astre",
            "astuce",
            "atelier",
            "atome",
            "atrium",
            "atroce",
            "attaque",
            "attentif",
            "attirer",
            "attraper",
            "aubaine",
            "auberge",
            "audace",
            "audible",
            "augurer",
            "aurore",
            "automne",
            "autruche",
            "avaler",
            "avancer",
            "avarice",
            "avenir",
            "averse",
            "aveugle",
            "aviateur",
            "avide",
            "avion",
            "aviser",
            "avoine",
            "avouer",
            "avril",
            "axial",
            "axiome",
            "badge",
            "bafouer",
            "bagage",
            "baguette",
            "baignade",
            "balancer",
            "balcon",
            "baleine",
            "balisage",
            "bambin",
            "bancaire",
            "bandage",
            "banlieue",
            "bannière",
            "banquier",
            "barbier",
            "baril",
            "baron",
            "barque",
            "barrage",
            "bassin",
            "bastion",
            "bataille",
            "bateau",
            "batterie",
            "baudrier",
            "bavarder",
            "belette",
            "bélier",
            "belote",
            "bénéfice",
            "berceau",
            "berger",
            "berline",
            "bermuda",
            "besace",
            "besogne",
            "bétail",
            "beurre",
            "biberon",
            "bicycle",
            "bidule",
            "bijou",
            "bilan",
            "bilingue",
            "billard",
            "binaire",
            "biologie",
            "biopsie",
            "biotype",
            "biscuit",
            "bison",
            "bistouri",
            "bitume",
            "bizarre",
            "blafard",
            "blague",
            "blanchir",
            "blessant",
            "blinder",
            "blond",
            "bloquer",
            "blouson",
            "bobard",
            "bobine",
            "boire",
            "boiser",
            "bolide",
            "bonbon",
            "bondir",
            "bonheur",
            "bonifier",
            "bonus",
            "bordure",
            "borne",
            "botte",
            "boucle",
            "boueux",
            "bougie",
            "boulon",
            "bouquin",
            "bourse",
            "boussole",
            "boutique",
            "boxeur",
            "branche",
            "brasier",
            "brave",
            "brebis",
            "brèche",
            "breuvage",
            "bricoler",
            "brigade",
            "brillant",
            "brioche",
            "brique",
            "brochure",
            "broder",
            "bronzer",
            "brousse",
            "broyeur",
            "brume",
            "brusque",
            "brutal",
            "bruyant",
            "buffle",
            "buisson",
            "bulletin",
            "bureau",
            "burin",
            "bustier",
            "butiner",
            "butoir",
            "buvable",
            "buvette",
            "cabanon",
            "cabine",
            "cachette",
            "cadeau",
            "cadre",
            "caféine",
            "caillou",
            "caisson",
            "calculer",
            "calepin",
            "calibre",
            "calmer",
            "calomnie",
            "calvaire",
            "camarade",
            "caméra",
            "camion",
            "campagne",
            "canal",
            "caneton",
            "canon",
            "cantine",
            "canular",
            "capable",
            "caporal",
            "caprice",
            "capsule",
            "capter",
            "capuche",
            "carabine",
            "carbone",
            "caresser",
            "caribou",
            "carnage",
            "carotte",
            "carreau",
            "carton",
            "cascade",
            "casier",
            "casque",
            "cassure",
            "causer",
            "caution",
            "cavalier",
            "caverne",
            "caviar",
            "cédille",
            "ceinture",
            "céleste",
            "cellule",
            "cendrier",
            "censurer",
            "central",
            "cercle",
            "cérébral",
            "cerise",
            "cerner",
            "cerveau",
            "cesser",
            "chagrin",
            "chaise",
            "chaleur",
            "chambre",
            "chance",
            "chapitre",
            "charbon",
            "chasseur",
            "chaton",
            "chausson",
            "chavirer",
            "chemise",
            "chenille",
            "chéquier",
            "chercher",
            "cheval",
            "chien",
            "chiffre",
            "chignon",
            "chimère",
            "chiot",
            "chlorure",
            "chocolat",
            "choisir",
            "chose",
            "chouette",
            "chrome",
            "chute",
            "cigare",
            "cigogne",
            "cimenter",
            "cinéma",
            "cintrer",
            "circuler",
            "cirer",
            "cirque",
            "citerne",
            "citoyen",
            "citron",
            "civil",
            "clairon",
            "clameur",
            "claquer",
            "classe",
            "clavier",
            "client",
            "cligner",
            "climat",
            "clivage",
            "cloche",
            "clonage",
            "cloporte",
            "cobalt",
            "cobra",
            "cocasse",
            "cocotier",
            "coder",
            "codifier",
            "coffre",
            "cogner",
            "cohésion",
            "coiffer",
            "coincer",
            "colère",
            "colibri",
            "colline",
            "colmater",
            "colonel",
            "combat",
            "comédie",
            "commande",
            "compact",
            "concert",
            "conduire",
            "confier",
            "congeler",
            "connoter",
            "consonne",
            "contact",
            "convexe",
            "copain",
            "copie",
            "corail",
            "corbeau",
            "cordage",
            "corniche",
            "corpus",
            "correct",
            "cortège",
            "cosmique",
            "costume",
            "coton",
            "coude",
            "coupure",
            "courage",
            "couteau",
            "couvrir",
            "coyote",
            "crabe",
            "crainte",
            "cravate",
            "crayon",
            "créature",
            "créditer",
            "crémeux",
            "creuser",
            "crevette",
            "cribler",
            "crier",
            "cristal",
            "critère",
            "croire",
            "croquer",
            "crotale",
            "crucial",
            "cruel",
            "crypter",
            "cubique",
            "cueillir",
            "cuillère",
            "cuisine",
            "cuivre",
            "culminer",
            "cultiver",
            "cumuler",
            "cupide",
            "curatif",
            "curseur",
            "cyanure",
            "cycle",
            "cylindre",
            "cynique",
            "daigner",
            "damier",
            "danger",
            "danseur",
            "dauphin",
            "débattre",
            "débiter",
            "déborder",
            "débrider",
            "débutant",
            "décaler",
            "décembre",
            "déchirer",
            "décider",
            "déclarer",
            "décorer",
            "décrire",
            "décupler",
            "dédale",
            "déductif",
            "déesse",
            "défensif",
            "défiler",
            "défrayer",
            "dégager",
            "dégivrer",
            "déglutir",
            "dégrafer",
            "déjeuner",
            "délice",
            "déloger",
            "demander",
            "demeurer",
            "démolir",
            "dénicher",
            "dénouer",
            "dentelle",
            "dénuder",
            "départ",
            "dépenser",
            "déphaser",
            "déplacer",
            "déposer",
            "déranger",
            "dérober",
            "désastre",
            "descente",
            "désert",
            "désigner",
            "désobéir",
            "dessiner",
            "destrier",
            "détacher",
            "détester",
            "détourer",
            "détresse",
            "devancer",
            "devenir",
            "deviner",
            "devoir",
            "diable",
            "dialogue",
            "diamant",
            "dicter",
            "différer",
            "digérer",
            "digital",
            "digne",
            "diluer",
            "dimanche",
            "diminuer",
            "dioxyde",
            "directif",
            "diriger",
            "discuter",
            "disposer",
            "dissiper",
            "distance",
            "divertir",
            "diviser",
            "docile",
            "docteur",
            "dogme",
            "doigt",
            "domaine",
            "domicile",
            "dompter",
            "donateur",
            "donjon",
            "donner",
            "dopamine",
            "dortoir",
            "dorure",
            "dosage",
            "doseur",
            "dossier",
            "dotation",
            "douanier",
            "double",
            "douceur",
            "douter",
            "doyen",
            "dragon",
            "draper",
            "dresser",
            "dribbler",
            "droiture",
            "duperie",
            "duplexe",
            "durable",
            "durcir",
            "dynastie",
            "éblouir",
            "écarter",
            "écharpe",
            "échelle",
            "éclairer",
            "éclipse",
            "éclore",
            "écluse",
            "école",
            "économie",
            "écorce",
            "écouter",
            "écraser",
            "écrémer",
            "écrivain",
            "écrou",
            "écume",
            "écureuil",
            "édifier",
            "éduquer",
            "effacer",
            "effectif",
            "effigie",
            "effort",
            "effrayer",
            "effusion",
            "égaliser",
            "égarer",
            "éjecter",
            "élaborer",
            "élargir",
            "électron",
            "élégant",
            "éléphant",
            "élève",
            "éligible",
            "élitisme",
            "éloge",
            "élucider",
            "éluder",
            "emballer",
            "embellir",
            "embryon",
            "émeraude",
            "émission",
            "emmener",
            "émotion",
            "émouvoir",
            "empereur",
            "employer",
            "emporter",
            "emprise",
            "émulsion",
            "encadrer",
            "enchère",
            "enclave",
            "encoche",
            "endiguer",
            "endosser",
            "endroit",
            "enduire",
            "énergie",
            "enfance",
            "enfermer",
            "enfouir",
            "engager",
            "engin",
            "englober",
            "énigme",
            "enjamber",
            "enjeu",
            "enlever",
            "ennemi",
            "ennuyeux",
            "enrichir",
            "enrobage",
            "enseigne",
            "entasser",
            "entendre",
            "entier",
            "entourer",
            "entraver",
            "énumérer",
            "envahir",
            "enviable",
            "envoyer",
            "enzyme",
            "éolien",
            "épaissir",
            "épargne",
            "épatant",
            "épaule",
            "épicerie",
            "épidémie",
            "épier",
            "épilogue",
            "épine",
            "épisode",
            "épitaphe",
            "époque",
            "épreuve",
            "éprouver",
            "épuisant",
            "équerre",
            "équipe",
            "ériger",
            "érosion",
            "erreur",
            "éruption",
            "escalier",
            "espadon",
            "espèce",
            "espiègle",
            "espoir",
            "esprit",
            "esquiver",
            "essayer",
            "essence",
            "essieu",
            "essorer",
            "estime",
            "estomac",
            "estrade",
            "étagère",
            "étaler",
            "étanche",
            "étatique",
            "éteindre",
            "étendoir",
            "éternel",
            "éthanol",
            "éthique",
            "ethnie",
            "étirer",
            "étoffer",
            "étoile",
            "étonnant",
            "étourdir",
            "étrange",
            "étroit",
            "étude",
            "euphorie",
            "évaluer",
            "évasion",
            "éventail",
            "évidence",
            "éviter",
            "évolutif",
            "évoquer",
            "exact",
            "exagérer",
            "exaucer",
            "exceller",
            "excitant",
            "exclusif",
            "excuse",
            "exécuter",
            "exemple",
            "exercer",
            "exhaler",
            "exhorter",
            "exigence",
            "exiler",
            "exister",
            "exotique",
            "expédier",
            "explorer",
            "exposer",
            "exprimer",
            "exquis",
            "extensif",
            "extraire",
            "exulter",
            "fable",
            "fabuleux",
            "facette",
            "facile",
            "facture",
            "faiblir",
            "falaise",
            "fameux",
            "famille",
            "farceur",
            "farfelu",
            "farine",
            "farouche",
            "fasciner",
            "fatal",
            "fatigue",
            "faucon",
            "fautif",
            "faveur",
            "favori",
            "fébrile",
            "féconder",
            "fédérer",
            "félin",
            "femme",
            "fémur",
            "fendoir",
            "féodal",
            "fermer",
            "féroce",
            "ferveur",
            "festival",
            "feuille",
            "feutre",
            "février",
            "fiasco",
            "ficeler",
            "fictif",
            "fidèle",
            "figure",
            "filature",
            "filetage",
            "filière",
            "filleul",
            "filmer",
            "filou",
            "filtrer",
            "financer",
            "finir",
            "fiole",
            "firme",
            "fissure",
            "fixer",
            "flairer",
            "flamme",
            "flasque",
            "flatteur",
            "fléau",
            "flèche",
            "fleur",
            "flexion",
            "flocon",
            "flore",
            "fluctuer",
            "fluide",
            "fluvial",
            "folie",
            "fonderie",
            "fongible",
            "fontaine",
            "forcer",
            "forgeron",
            "formuler",
            "fortune",
            "fossile",
            "foudre",
            "fougère",
            "fouiller",
            "foulure",
            "fourmi",
            "fragile",
            "fraise",
            "franchir",
            "frapper",
            "frayeur",
            "frégate",
            "freiner",
            "frelon",
            "frémir",
            "frénésie",
            "frère",
            "friable",
            "friction",
            "frisson",
            "frivole",
            "froid",
            "fromage",
            "frontal",
            "frotter",
            "fruit",
            "fugitif",
            "fuite",
            "fureur",
            "furieux",
            "furtif",
            "fusion",
            "futur",
            "gagner",
            "galaxie",
            "galerie",
            "gambader",
            "garantir",
            "gardien",
            "garnir",
            "garrigue",
            "gazelle",
            "gazon",
            "géant",
            "gélatine",
            "gélule",
            "gendarme",
            "général",
            "génie",
            "genou",
            "gentil",
            "géologie",
            "géomètre",
            "géranium",
            "germe",
            "gestuel",
            "geyser",
            "gibier",
            "gicler",
            "girafe",
            "givre",
            "glace",
            "glaive",
            "glisser",
            "globe",
            "gloire",
            "glorieux",
            "golfeur",
            "gomme",
            "gonfler",
            "gorge",
            "gorille",
            "goudron",
            "gouffre",
            "goulot",
            "goupille",
            "gourmand",
            "goutte",
            "graduel",
            "graffiti",
            "graine",
            "grand",
            "grappin",
            "gratuit",
            "gravir",
            "grenat",
            "griffure",
            "griller",
            "grimper",
            "grogner",
            "gronder",
            "grotte",
            "groupe",
            "gruger",
            "grutier",
            "gruyère",
            "guépard",
            "guerrier",
            "guide",
            "guimauve",
            "guitare",
            "gustatif",
            "gymnaste",
            "gyrostat",
            "habitude",
            "hachoir",
            "halte",
            "hameau",
            "hangar",
            "hanneton",
            "haricot",
            "harmonie",
            "harpon",
            "hasard",
            "hélium",
            "hématome",
            "herbe",
            "hérisson",
            "hermine",
            "héron",
            "hésiter",
            "heureux",
            "hiberner",
            "hibou",
            "hilarant",
            "histoire",
            "hiver",
            "homard",
            "hommage",
            "homogène",
            "honneur",
            "honorer",
            "honteux",
            "horde",
            "horizon",
            "horloge",
            "hormone",
            "horrible",
            "houleux",
            "housse",
            "hublot",
            "huileux",
            "humain",
            "humble",
            "humide",
            "humour",
            "hurler",
            "hydromel",
            "hygiène",
            "hymne",
            "hypnose",
            "idylle",
            "ignorer",
            "iguane",
            "illicite",
            "illusion",
            "image",
            "imbiber",
            "imiter",
            "immense",
            "immobile",
            "immuable",
            "impact",
            "impérial",
            "implorer",
            "imposer",
            "imprimer",
            "imputer",
            "incarner",
            "incendie",
            "incident",
            "incliner",
            "incolore",
            "indexer",
            "indice",
            "inductif",
            "inédit",
            "ineptie",
            "inexact",
            "infini",
            "infliger",
            "informer",
            "infusion",
            "ingérer",
            "inhaler",
            "inhiber",
            "injecter",
            "injure",
            "innocent",
            "inoculer",
            "inonder",
            "inscrire",
            "insecte",
            "insigne",
            "insolite",
            "inspirer",
            "instinct",
            "insulter",
            "intact",
            "intense",
            "intime",
            "intrigue",
            "intuitif",
            "inutile",
            "invasion",
            "inventer",
            "inviter",
            "invoquer",
            "ironique",
            "irradier",
            "irréel",
            "irriter",
            "isoler",
            "ivoire",
            "ivresse",
            "jaguar",
            "jaillir",
            "jambe",
            "janvier",
            "jardin",
            "jauger",
            "jaune",
            "javelot",
            "jetable",
            "jeton",
            "jeudi",
            "jeunesse",
            "joindre",
            "joncher",
            "jongler",
            "joueur",
            "jouissif",
            "journal",
            "jovial",
            "joyau",
            "joyeux",
            "jubiler",
            "jugement",
            "junior",
            "jupon",
            "juriste",
            "justice",
            "juteux",
            "juvénile",
            "kayak",
            "kimono",
            "kiosque",
            "label",
            "labial",
            "labourer",
            "lacérer",
            "lactose",
            "lagune",
            "laine",
            "laisser",
            "laitier",
            "lambeau",
            "lamelle",
            "lampe",
            "lanceur",
            "langage",
            "lanterne",
            "lapin",
            "largeur",
            "larme",
            "laurier",
            "lavabo",
            "lavoir",
            "lecture",
            "légal",
            "léger",
            "légume",
            "lessive",
            "lettre",
            "levier",
            "lexique",
            "lézard",
            "liasse",
            "libérer",
            "libre",
            "licence",
            "licorne",
            "liège",
            "lièvre",
            "ligature",
            "ligoter",
            "ligue",
            "limer",
            "limite",
            "limonade",
            "limpide",
            "linéaire",
            "lingot",
            "lionceau",
            "liquide",
            "lisière",
            "lister",
            "lithium",
            "litige",
            "littoral",
            "livreur",
            "logique",
            "lointain",
            "loisir",
            "lombric",
            "loterie",
            "louer",
            "lourd",
            "loutre",
            "louve",
            "loyal",
            "lubie",
            "lucide",
            "lucratif",
            "lueur",
            "lugubre",
            "luisant",
            "lumière",
            "lunaire",
            "lundi",
            "luron",
            "lutter",
            "luxueux",
            "machine",
            "magasin",
            "magenta",
            "magique",
            "maigre",
            "maillon",
            "maintien",
            "mairie",
            "maison",
            "majorer",
            "malaxer",
            "maléfice",
            "malheur",
            "malice",
            "mallette",
            "mammouth",
            "mandater",
            "maniable",
            "manquant",
            "manteau",
            "manuel",
            "marathon",
            "marbre",
            "marchand",
            "mardi",
            "maritime",
            "marqueur",
            "marron",
            "marteler",
            "mascotte",
            "massif",
            "matériel",
            "matière",
            "matraque",
            "maudire",
            "maussade",
            "mauve",
            "maximal",
            "méchant",
            "méconnu",
            "médaille",
            "médecin",
            "méditer",
            "méduse",
            "meilleur",
            "mélange",
            "mélodie",
            "membre",
            "mémoire",
            "menacer",
            "mener",
            "menhir",
            "mensonge",
            "mentor",
            "mercredi",
            "mérite",
            "merle",
            "messager",
            "mesure",
            "métal",
            "météore",
            "méthode",
            "métier",
            "meuble",
            "miauler",
            "microbe",
            "miette",
            "mignon",
            "migrer",
            "milieu",
            "million",
            "mimique",
            "mince",
            "minéral",
            "minimal",
            "minorer",
            "minute",
            "miracle",
            "miroiter",
            "missile",
            "mixte",
            "mobile",
            "moderne",
            "moelleux",
            "mondial",
            "moniteur",
            "monnaie",
            "monotone",
            "monstre",
            "montagne",
            "monument",
            "moqueur",
            "morceau",
            "morsure",
            "mortier",
            "moteur",
            "motif",
            "mouche",
            "moufle",
            "moulin",
            "mousson",
            "mouton",
            "mouvant",
            "multiple",
            "munition",
            "muraille",
            "murène",
            "murmure",
            "muscle",
            "muséum",
            "musicien",
            "mutation",
            "muter",
            "mutuel",
            "myriade",
            "myrtille",
            "mystère",
            "mythique",
            "nageur",
            "nappe",
            "narquois",
            "narrer",
            "natation",
            "nation",
            "nature",
            "naufrage",
            "nautique",
            "navire",
            "nébuleux",
            "nectar",
            "néfaste",
            "négation",
            "négliger",
            "négocier",
            "neige",
            "nerveux",
            "nettoyer",
            "neurone",
            "neutron",
            "neveu",
            "niche",
            "nickel",
            "nitrate",
            "niveau",
            "noble",
            "nocif",
            "nocturne",
            "noirceur",
            "noisette",
            "nomade",
            "nombreux",
            "nommer",
            "normatif",
            "notable",
            "notifier",
            "notoire",
            "nourrir",
            "nouveau",
            "novateur",
            "novembre",
            "novice",
            "nuage",
            "nuancer",
            "nuire",
            "nuisible",
            "numéro",
            "nuptial",
            "nuque",
            "nutritif",
            "obéir",
            "objectif",
            "obliger",
            "obscur",
            "observer",
            "obstacle",
            "obtenir",
            "obturer",
            "occasion",
            "occuper",
            "océan",
            "octobre",
            "octroyer",
            "octupler",
            "oculaire",
            "odeur",
            "odorant",
            "offenser",
            "officier",
            "offrir",
            "ogive",
            "oiseau",
            "oisillon",
            "olfactif",
            "olivier",
            "ombrage",
            "omettre",
            "onctueux",
            "onduler",
            "onéreux",
            "onirique",
            "opale",
            "opaque",
            "opérer",
            "opinion",
            "opportun",
            "opprimer",
            "opter",
            "optique",
            "orageux",
            "orange",
            "orbite",
            "ordonner",
            "oreille",
            "organe",
            "orgueil",
            "orifice",
            "ornement",
            "orque",
            "ortie",
            "osciller",
            "osmose",
            "ossature",
            "otarie",
            "ouragan",
            "ourson",
            "outil",
            "outrager",
            "ouvrage",
            "ovation",
            "oxyde",
            "oxygène",
            "ozone",
            "paisible",
            "palace",
            "palmarès",
            "palourde",
            "palper",
            "panache",
            "panda",
            "pangolin",
            "paniquer",
            "panneau",
            "panorama",
            "pantalon",
            "papaye",
            "papier",
            "papoter",
            "papyrus",
            "paradoxe",
            "parcelle",
            "paresse",
            "parfumer",
            "parler",
            "parole",
            "parrain",
            "parsemer",
            "partager",
            "parure",
            "parvenir",
            "passion",
            "pastèque",
            "paternel",
            "patience",
            "patron",
            "pavillon",
            "pavoiser",
            "payer",
            "paysage",
            "peigne",
            "peintre",
            "pelage",
            "pélican",
            "pelle",
            "pelouse",
            "peluche",
            "pendule",
            "pénétrer",
            "pénible",
            "pensif",
            "pénurie",
            "pépite",
            "péplum",
            "perdrix",
            "perforer",
            "période",
            "permuter",
            "perplexe",
            "persil",
            "perte",
            "peser",
            "pétale",
            "petit",
            "pétrir",
            "peuple",
            "pharaon",
            "phobie",
            "phoque",
            "photon",
            "phrase",
            "physique",
            "piano",
            "pictural",
            "pièce",
            "pierre",
            "pieuvre",
            "pilote",
            "pinceau",
            "pipette",
            "piquer",
            "pirogue",
            "piscine",
            "piston",
            "pivoter",
            "pixel",
            "pizza",
            "placard",
            "plafond",
            "plaisir",
            "planer",
            "plaque",
            "plastron",
            "plateau",
            "pleurer",
            "plexus",
            "pliage",
            "plomb",
            "plonger",
            "pluie",
            "plumage",
            "pochette",
            "poésie",
            "poète",
            "pointe",
            "poirier",
            "poisson",
            "poivre",
            "polaire",
            "policier",
            "pollen",
            "polygone",
            "pommade",
            "pompier",
            "ponctuel",
            "pondérer",
            "poney",
            "portique",
            "position",
            "posséder",
            "posture",
            "potager",
            "poteau",
            "potion",
            "pouce",
            "poulain",
            "poumon",
            "pourpre",
            "poussin",
            "pouvoir",
            "prairie",
            "pratique",
            "précieux",
            "prédire",
            "préfixe",
            "prélude",
            "prénom",
            "présence",
            "prétexte",
            "prévoir",
            "primitif",
            "prince",
            "prison",
            "priver",
            "problème",
            "procéder",
            "prodige",
            "profond",
            "progrès",
            "proie",
            "projeter",
            "prologue",
            "promener",
            "propre",
            "prospère",
            "protéger",
            "prouesse",
            "proverbe",
            "prudence",
            "pruneau",
            "psychose",
            "public",
            "puceron",
            "puiser",
            "pulpe",
            "pulsar",
            "punaise",
            "punitif",
            "pupitre",
            "purifier",
            "puzzle",
            "pyramide",
            "quasar",
            "querelle",
            "question",
            "quiétude",
            "quitter",
            "quotient",
            "racine",
            "raconter",
            "radieux",
            "ragondin",
            "raideur",
            "raisin",
            "ralentir",
            "rallonge",
            "ramasser",
            "rapide",
            "rasage",
            "ratisser",
            "ravager",
            "ravin",
            "rayonner",
            "réactif",
            "réagir",
            "réaliser",
            "réanimer",
            "recevoir",
            "réciter",
            "réclamer",
            "récolter",
            "recruter",
            "reculer",
            "recycler",
            "rédiger",
            "redouter",
            "refaire",
            "réflexe",
            "réformer",
            "refrain",
            "refuge",
            "régalien",
            "région",
            "réglage",
            "régulier",
            "réitérer",
            "rejeter",
            "rejouer",
            "relatif",
            "relever",
            "relief",
            "remarque",
            "remède",
            "remise",
            "remonter",
            "remplir",
            "remuer",
            "renard",
            "renfort",
            "renifler",
            "renoncer",
            "rentrer",
            "renvoi",
            "replier",
            "reporter",
            "reprise",
            "reptile",
            "requin",
            "réserve",
            "résineux",
            "résoudre",
            "respect",
            "rester",
            "résultat",
            "rétablir",
            "retenir",
            "réticule",
            "retomber",
            "retracer",
            "réunion",
            "réussir",
            "revanche",
            "revivre",
            "révolte",
            "révulsif",
            "richesse",
            "rideau",
            "rieur",
            "rigide",
            "rigoler",
            "rincer",
            "riposter",
            "risible",
            "risque",
            "rituel",
            "rival",
            "rivière",
            "rocheux",
            "romance",
            "rompre",
            "ronce",
            "rondin",
            "roseau",
            "rosier",
            "rotatif",
            "rotor",
            "rotule",
            "rouge",
            "rouille",
            "rouleau",
            "routine",
            "royaume",
            "ruban",
            "rubis",
            "ruche",
            "ruelle",
            "rugueux",
            "ruiner",
            "ruisseau",
            "ruser",
            "rustique",
            "rythme",
            "sabler",
            "saboter",
            "sabre",
            "sacoche",
            "safari",
            "sagesse",
            "saisir",
            "salade",
            "salive",
            "salon",
            "saluer",
            "samedi",
            "sanction",
            "sanglier",
            "sarcasme",
            "sardine",
            "saturer",
            "saugrenu",
            "saumon",
            "sauter",
            "sauvage",
            "savant",
            "savonner",
            "scalpel",
            "scandale",
            "scélérat",
            "scénario",
            "sceptre",
            "schéma",
            "science",
            "scinder",
            "score",
            "scrutin",
            "sculpter",
            "séance",
            "sécable",
            "sécher",
            "secouer",
            "sécréter",
            "sédatif",
            "séduire",
            "seigneur",
            "séjour",
            "sélectif",
            "semaine",
            "sembler",
            "semence",
            "séminal",
            "sénateur",
            "sensible",
            "sentence",
            "séparer",
            "séquence",
            "serein",
            "sergent",
            "sérieux",
            "serrure",
            "sérum",
            "service",
            "sésame",
            "sévir",
            "sevrage",
            "sextuple",
            "sidéral",
            "siècle",
            "siéger",
            "siffler",
            "sigle",
            "signal",
            "silence",
            "silicium",
            "simple",
            "sincère",
            "sinistre",
            "siphon",
            "sirop",
            "sismique",
            "situer",
            "skier",
            "social",
            "socle",
            "sodium",
            "soigneux",
            "soldat",
            "soleil",
            "solitude",
            "soluble",
            "sombre",
            "sommeil",
            "somnoler",
            "sonde",
            "songeur",
            "sonnette",
            "sonore",
            "sorcier",
            "sortir",
            "sosie",
            "sottise",
            "soucieux",
            "soudure",
            "souffle",
            "soulever",
            "soupape",
            "source",
            "soutirer",
            "souvenir",
            "spacieux",
            "spatial",
            "spécial",
            "sphère",
            "spiral",
            "stable",
            "station",
            "sternum",
            "stimulus",
            "stipuler",
            "strict",
            "studieux",
            "stupeur",
            "styliste",
            "sublime",
            "substrat",
            "subtil",
            "subvenir",
            "succès",
            "sucre",
            "suffixe",
            "suggérer",
            "suiveur",
            "sulfate",
            "superbe",
            "supplier",
            "surface",
            "suricate",
            "surmener",
            "surprise",
            "sursaut",
            "survie",
            "suspect",
            "syllabe",
            "symbole",
            "symétrie",
            "synapse",
            "syntaxe",
            "système",
            "tabac",
            "tablier",
            "tactile",
            "tailler",
            "talent",
            "talisman",
            "talonner",
            "tambour",
            "tamiser",
            "tangible",
            "tapis",
            "taquiner",
            "tarder",
            "tarif",
            "tartine",
            "tasse",
            "tatami",
            "tatouage",
            "taupe",
            "taureau",
            "taxer",
            "témoin",
            "temporel",
            "tenaille",
            "tendre",
            "teneur",
            "tenir",
            "tension",
            "terminer",
            "terne",
            "terrible",
            "tétine",
            "texte",
            "thème",
            "théorie",
            "thérapie",
            "thorax",
            "tibia",
            "tiède",
            "timide",
            "tirelire",
            "tiroir",
            "tissu",
            "titane",
            "titre",
            "tituber",
            "toboggan",
            "tolérant",
            "tomate",
            "tonique",
            "tonneau",
            "toponyme",
            "torche",
            "tordre",
            "tornade",
            "torpille",
            "torrent",
            "torse",
            "tortue",
            "totem",
            "toucher",
            "tournage",
            "tousser",
            "toxine",
            "traction",
            "trafic",
            "tragique",
            "trahir",
            "train",
            "trancher",
            "travail",
            "trèfle",
            "tremper",
            "trésor",
            "treuil",
            "triage",
            "tribunal",
            "tricoter",
            "trilogie",
            "triomphe",
            "tripler",
            "triturer",
            "trivial",
            "trombone",
            "tronc",
            "tropical",
            "troupeau",
            "tuile",
            "tulipe",
            "tumulte",
            "tunnel",
            "turbine",
            "tuteur",
            "tutoyer",
            "tuyau",
            "tympan",
            "typhon",
            "typique",
            "tyran",
            "ubuesque",
            "ultime",
            "ultrason",
            "unanime",
            "unifier",
            "union",
            "unique",
            "unitaire",
            "univers",
            "uranium",
            "urbain",
            "urticant",
            "usage",
            "usine",
            "usuel",
            "usure",
            "utile",
            "utopie",
            "vacarme",
            "vaccin",
            "vagabond",
            "vague",
            "vaillant",
            "vaincre",
            "vaisseau",
            "valable",
            "valise",
            "vallon",
            "valve",
            "vampire",
            "vanille",
            "vapeur",
            "varier",
            "vaseux",
            "vassal",
            "vaste",
            "vecteur",
            "vedette",
            "végétal",
            "véhicule",
            "veinard",
            "véloce",
            "vendredi",
            "vénérer",
            "venger",
            "venimeux",
            "ventouse",
            "verdure",
            "vérin",
            "vernir",
            "verrou",
            "verser",
            "vertu",
            "veston",
            "vétéran",
            "vétuste",
            "vexant",
            "vexer",
            "viaduc",
            "viande",
            "victoire",
            "vidange",
            "vidéo",
            "vignette",
            "vigueur",
            "vilain",
            "village",
            "vinaigre",
            "violon",
            "vipère",
            "virement",
            "virtuose",
            "virus",
            "visage",
            "viseur",
            "vision",
            "visqueux",
            "visuel",
            "vital",
            "vitesse",
            "viticole",
            "vitrine",
            "vivace",
            "vivipare",
            "vocation",
            "voguer",
            "voile",
            "voisin",
            "voiture",
            "volaille",
            "volcan",
            "voltiger",
            "volume",
            "vorace",
            "vortex",
            "voter",
            "vouloir",
            "voyage",
            "voyelle",
            "wagon",
            "xénon",
            "yacht",
            "zèbre",
            "zénith",
            "zeste",
            "zoologie"
        ]

    }, {}],
    67: [function (require, module, exports) {
        module.exports = [
            "abaco",
            "abbaglio",
            "abbinato",
            "abete",
            "abisso",
            "abolire",
            "abrasivo",
            "abrogato",
            "accadere",
            "accenno",
            "accusato",
            "acetone",
            "achille",
            "acido",
            "acqua",
            "acre",
            "acrilico",
            "acrobata",
            "acuto",
            "adagio",
            "addebito",
            "addome",
            "adeguato",
            "aderire",
            "adipe",
            "adottare",
            "adulare",
            "affabile",
            "affetto",
            "affisso",
            "affranto",
            "aforisma",
            "afoso",
            "africano",
            "agave",
            "agente",
            "agevole",
            "aggancio",
            "agire",
            "agitare",
            "agonismo",
            "agricolo",
            "agrumeto",
            "aguzzo",
            "alabarda",
            "alato",
            "albatro",
            "alberato",
            "albo",
            "albume",
            "alce",
            "alcolico",
            "alettone",
            "alfa",
            "algebra",
            "aliante",
            "alibi",
            "alimento",
            "allagato",
            "allegro",
            "allievo",
            "allodola",
            "allusivo",
            "almeno",
            "alogeno",
            "alpaca",
            "alpestre",
            "altalena",
            "alterno",
            "alticcio",
            "altrove",
            "alunno",
            "alveolo",
            "alzare",
            "amalgama",
            "amanita",
            "amarena",
            "ambito",
            "ambrato",
            "ameba",
            "america",
            "ametista",
            "amico",
            "ammasso",
            "ammenda",
            "ammirare",
            "ammonito",
            "amore",
            "ampio",
            "ampliare",
            "amuleto",
            "anacardo",
            "anagrafe",
            "analista",
            "anarchia",
            "anatra",
            "anca",
            "ancella",
            "ancora",
            "andare",
            "andrea",
            "anello",
            "angelo",
            "angolare",
            "angusto",
            "anima",
            "annegare",
            "annidato",
            "anno",
            "annuncio",
            "anonimo",
            "anticipo",
            "anzi",
            "apatico",
            "apertura",
            "apode",
            "apparire",
            "appetito",
            "appoggio",
            "approdo",
            "appunto",
            "aprile",
            "arabica",
            "arachide",
            "aragosta",
            "araldica",
            "arancio",
            "aratura",
            "arazzo",
            "arbitro",
            "archivio",
            "ardito",
            "arenile",
            "argento",
            "argine",
            "arguto",
            "aria",
            "armonia",
            "arnese",
            "arredato",
            "arringa",
            "arrosto",
            "arsenico",
            "arso",
            "artefice",
            "arzillo",
            "asciutto",
            "ascolto",
            "asepsi",
            "asettico",
            "asfalto",
            "asino",
            "asola",
            "aspirato",
            "aspro",
            "assaggio",
            "asse",
            "assoluto",
            "assurdo",
            "asta",
            "astenuto",
            "astice",
            "astratto",
            "atavico",
            "ateismo",
            "atomico",
            "atono",
            "attesa",
            "attivare",
            "attorno",
            "attrito",
            "attuale",
            "ausilio",
            "austria",
            "autista",
            "autonomo",
            "autunno",
            "avanzato",
            "avere",
            "avvenire",
            "avviso",
            "avvolgere",
            "azione",
            "azoto",
            "azzimo",
            "azzurro",
            "babele",
            "baccano",
            "bacino",
            "baco",
            "badessa",
            "badilata",
            "bagnato",
            "baita",
            "balcone",
            "baldo",
            "balena",
            "ballata",
            "balzano",
            "bambino",
            "bandire",
            "baraonda",
            "barbaro",
            "barca",
            "baritono",
            "barlume",
            "barocco",
            "basilico",
            "basso",
            "batosta",
            "battuto",
            "baule",
            "bava",
            "bavosa",
            "becco",
            "beffa",
            "belgio",
            "belva",
            "benda",
            "benevole",
            "benigno",
            "benzina",
            "bere",
            "berlina",
            "beta",
            "bibita",
            "bici",
            "bidone",
            "bifido",
            "biga",
            "bilancia",
            "bimbo",
            "binocolo",
            "biologo",
            "bipede",
            "bipolare",
            "birbante",
            "birra",
            "biscotto",
            "bisesto",
            "bisnonno",
            "bisonte",
            "bisturi",
            "bizzarro",
            "blando",
            "blatta",
            "bollito",
            "bonifico",
            "bordo",
            "bosco",
            "botanico",
            "bottino",
            "bozzolo",
            "braccio",
            "bradipo",
            "brama",
            "branca",
            "bravura",
            "bretella",
            "brevetto",
            "brezza",
            "briglia",
            "brillante",
            "brindare",
            "broccolo",
            "brodo",
            "bronzina",
            "brullo",
            "bruno",
            "bubbone",
            "buca",
            "budino",
            "buffone",
            "buio",
            "bulbo",
            "buono",
            "burlone",
            "burrasca",
            "bussola",
            "busta",
            "cadetto",
            "caduco",
            "calamaro",
            "calcolo",
            "calesse",
            "calibro",
            "calmo",
            "caloria",
            "cambusa",
            "camerata",
            "camicia",
            "cammino",
            "camola",
            "campale",
            "canapa",
            "candela",
            "cane",
            "canino",
            "canotto",
            "cantina",
            "capace",
            "capello",
            "capitolo",
            "capogiro",
            "cappero",
            "capra",
            "capsula",
            "carapace",
            "carcassa",
            "cardo",
            "carisma",
            "carovana",
            "carretto",
            "cartolina",
            "casaccio",
            "cascata",
            "caserma",
            "caso",
            "cassone",
            "castello",
            "casuale",
            "catasta",
            "catena",
            "catrame",
            "cauto",
            "cavillo",
            "cedibile",
            "cedrata",
            "cefalo",
            "celebre",
            "cellulare",
            "cena",
            "cenone",
            "centesimo",
            "ceramica",
            "cercare",
            "certo",
            "cerume",
            "cervello",
            "cesoia",
            "cespo",
            "ceto",
            "chela",
            "chiaro",
            "chicca",
            "chiedere",
            "chimera",
            "china",
            "chirurgo",
            "chitarra",
            "ciao",
            "ciclismo",
            "cifrare",
            "cigno",
            "cilindro",
            "ciottolo",
            "circa",
            "cirrosi",
            "citrico",
            "cittadino",
            "ciuffo",
            "civetta",
            "civile",
            "classico",
            "clinica",
            "cloro",
            "cocco",
            "codardo",
            "codice",
            "coerente",
            "cognome",
            "collare",
            "colmato",
            "colore",
            "colposo",
            "coltivato",
            "colza",
            "coma",
            "cometa",
            "commando",
            "comodo",
            "computer",
            "comune",
            "conciso",
            "condurre",
            "conferma",
            "congelare",
            "coniuge",
            "connesso",
            "conoscere",
            "consumo",
            "continuo",
            "convegno",
            "coperto",
            "copione",
            "coppia",
            "copricapo",
            "corazza",
            "cordata",
            "coricato",
            "cornice",
            "corolla",
            "corpo",
            "corredo",
            "corsia",
            "cortese",
            "cosmico",
            "costante",
            "cottura",
            "covato",
            "cratere",
            "cravatta",
            "creato",
            "credere",
            "cremoso",
            "crescita",
            "creta",
            "criceto",
            "crinale",
            "crisi",
            "critico",
            "croce",
            "cronaca",
            "crostata",
            "cruciale",
            "crusca",
            "cucire",
            "cuculo",
            "cugino",
            "cullato",
            "cupola",
            "curatore",
            "cursore",
            "curvo",
            "cuscino",
            "custode",
            "dado",
            "daino",
            "dalmata",
            "damerino",
            "daniela",
            "dannoso",
            "danzare",
            "datato",
            "davanti",
            "davvero",
            "debutto",
            "decennio",
            "deciso",
            "declino",
            "decollo",
            "decreto",
            "dedicato",
            "definito",
            "deforme",
            "degno",
            "delegare",
            "delfino",
            "delirio",
            "delta",
            "demenza",
            "denotato",
            "dentro",
            "deposito",
            "derapata",
            "derivare",
            "deroga",
            "descritto",
            "deserto",
            "desiderio",
            "desumere",
            "detersivo",
            "devoto",
            "diametro",
            "dicembre",
            "diedro",
            "difeso",
            "diffuso",
            "digerire",
            "digitale",
            "diluvio",
            "dinamico",
            "dinnanzi",
            "dipinto",
            "diploma",
            "dipolo",
            "diradare",
            "dire",
            "dirotto",
            "dirupo",
            "disagio",
            "discreto",
            "disfare",
            "disgelo",
            "disposto",
            "distanza",
            "disumano",
            "dito",
            "divano",
            "divelto",
            "dividere",
            "divorato",
            "doblone",
            "docente",
            "doganale",
            "dogma",
            "dolce",
            "domato",
            "domenica",
            "dominare",
            "dondolo",
            "dono",
            "dormire",
            "dote",
            "dottore",
            "dovuto",
            "dozzina",
            "drago",
            "druido",
            "dubbio",
            "dubitare",
            "ducale",
            "duna",
            "duomo",
            "duplice",
            "duraturo",
            "ebano",
            "eccesso",
            "ecco",
            "eclissi",
            "economia",
            "edera",
            "edicola",
            "edile",
            "editoria",
            "educare",
            "egemonia",
            "egli",
            "egoismo",
            "egregio",
            "elaborato",
            "elargire",
            "elegante",
            "elencato",
            "eletto",
            "elevare",
            "elfico",
            "elica",
            "elmo",
            "elsa",
            "eluso",
            "emanato",
            "emblema",
            "emesso",
            "emiro",
            "emotivo",
            "emozione",
            "empirico",
            "emulo",
            "endemico",
            "enduro",
            "energia",
            "enfasi",
            "enoteca",
            "entrare",
            "enzima",
            "epatite",
            "epilogo",
            "episodio",
            "epocale",
            "eppure",
            "equatore",
            "erario",
            "erba",
            "erboso",
            "erede",
            "eremita",
            "erigere",
            "ermetico",
            "eroe",
            "erosivo",
            "errante",
            "esagono",
            "esame",
            "esanime",
            "esaudire",
            "esca",
            "esempio",
            "esercito",
            "esibito",
            "esigente",
            "esistere",
            "esito",
            "esofago",
            "esortato",
            "esoso",
            "espanso",
            "espresso",
            "essenza",
            "esso",
            "esteso",
            "estimare",
            "estonia",
            "estroso",
            "esultare",
            "etilico",
            "etnico",
            "etrusco",
            "etto",
            "euclideo",
            "europa",
            "evaso",
            "evidenza",
            "evitato",
            "evoluto",
            "evviva",
            "fabbrica",
            "faccenda",
            "fachiro",
            "falco",
            "famiglia",
            "fanale",
            "fanfara",
            "fango",
            "fantasma",
            "fare",
            "farfalla",
            "farinoso",
            "farmaco",
            "fascia",
            "fastoso",
            "fasullo",
            "faticare",
            "fato",
            "favoloso",
            "febbre",
            "fecola",
            "fede",
            "fegato",
            "felpa",
            "feltro",
            "femmina",
            "fendere",
            "fenomeno",
            "fermento",
            "ferro",
            "fertile",
            "fessura",
            "festivo",
            "fetta",
            "feudo",
            "fiaba",
            "fiducia",
            "fifa",
            "figurato",
            "filo",
            "finanza",
            "finestra",
            "finire",
            "fiore",
            "fiscale",
            "fisico",
            "fiume",
            "flacone",
            "flamenco",
            "flebo",
            "flemma",
            "florido",
            "fluente",
            "fluoro",
            "fobico",
            "focaccia",
            "focoso",
            "foderato",
            "foglio",
            "folata",
            "folclore",
            "folgore",
            "fondente",
            "fonetico",
            "fonia",
            "fontana",
            "forbito",
            "forchetta",
            "foresta",
            "formica",
            "fornaio",
            "foro",
            "fortezza",
            "forzare",
            "fosfato",
            "fosso",
            "fracasso",
            "frana",
            "frassino",
            "fratello",
            "freccetta",
            "frenata",
            "fresco",
            "frigo",
            "frollino",
            "fronde",
            "frugale",
            "frutta",
            "fucilata",
            "fucsia",
            "fuggente",
            "fulmine",
            "fulvo",
            "fumante",
            "fumetto",
            "fumoso",
            "fune",
            "funzione",
            "fuoco",
            "furbo",
            "furgone",
            "furore",
            "fuso",
            "futile",
            "gabbiano",
            "gaffe",
            "galateo",
            "gallina",
            "galoppo",
            "gambero",
            "gamma",
            "garanzia",
            "garbo",
            "garofano",
            "garzone",
            "gasdotto",
            "gasolio",
            "gastrico",
            "gatto",
            "gaudio",
            "gazebo",
            "gazzella",
            "geco",
            "gelatina",
            "gelso",
            "gemello",
            "gemmato",
            "gene",
            "genitore",
            "gennaio",
            "genotipo",
            "gergo",
            "ghepardo",
            "ghiaccio",
            "ghisa",
            "giallo",
            "gilda",
            "ginepro",
            "giocare",
            "gioiello",
            "giorno",
            "giove",
            "girato",
            "girone",
            "gittata",
            "giudizio",
            "giurato",
            "giusto",
            "globulo",
            "glutine",
            "gnomo",
            "gobba",
            "golf",
            "gomito",
            "gommone",
            "gonfio",
            "gonna",
            "governo",
            "gracile",
            "grado",
            "grafico",
            "grammo",
            "grande",
            "grattare",
            "gravoso",
            "grazia",
            "greca",
            "gregge",
            "grifone",
            "grigio",
            "grinza",
            "grotta",
            "gruppo",
            "guadagno",
            "guaio",
            "guanto",
            "guardare",
            "gufo",
            "guidare",
            "ibernato",
            "icona",
            "identico",
            "idillio",
            "idolo",
            "idra",
            "idrico",
            "idrogeno",
            "igiene",
            "ignaro",
            "ignorato",
            "ilare",
            "illeso",
            "illogico",
            "illudere",
            "imballo",
            "imbevuto",
            "imbocco",
            "imbuto",
            "immane",
            "immerso",
            "immolato",
            "impacco",
            "impeto",
            "impiego",
            "importo",
            "impronta",
            "inalare",
            "inarcare",
            "inattivo",
            "incanto",
            "incendio",
            "inchino",
            "incisivo",
            "incluso",
            "incontro",
            "incrocio",
            "incubo",
            "indagine",
            "india",
            "indole",
            "inedito",
            "infatti",
            "infilare",
            "inflitto",
            "ingaggio",
            "ingegno",
            "inglese",
            "ingordo",
            "ingrosso",
            "innesco",
            "inodore",
            "inoltrare",
            "inondato",
            "insano",
            "insetto",
            "insieme",
            "insonnia",
            "insulina",
            "intasato",
            "intero",
            "intonaco",
            "intuito",
            "inumidire",
            "invalido",
            "invece",
            "invito",
            "iperbole",
            "ipnotico",
            "ipotesi",
            "ippica",
            "iride",
            "irlanda",
            "ironico",
            "irrigato",
            "irrorare",
            "isolato",
            "isotopo",
            "isterico",
            "istituto",
            "istrice",
            "italia",
            "iterare",
            "labbro",
            "labirinto",
            "lacca",
            "lacerato",
            "lacrima",
            "lacuna",
            "laddove",
            "lago",
            "lampo",
            "lancetta",
            "lanterna",
            "lardoso",
            "larga",
            "laringe",
            "lastra",
            "latenza",
            "latino",
            "lattuga",
            "lavagna",
            "lavoro",
            "legale",
            "leggero",
            "lembo",
            "lentezza",
            "lenza",
            "leone",
            "lepre",
            "lesivo",
            "lessato",
            "lesto",
            "letterale",
            "leva",
            "levigato",
            "libero",
            "lido",
            "lievito",
            "lilla",
            "limatura",
            "limitare",
            "limpido",
            "lineare",
            "lingua",
            "liquido",
            "lira",
            "lirica",
            "lisca",
            "lite",
            "litigio",
            "livrea",
            "locanda",
            "lode",
            "logica",
            "lombare",
            "londra",
            "longevo",
            "loquace",
            "lorenzo",
            "loto",
            "lotteria",
            "luce",
            "lucidato",
            "lumaca",
            "luminoso",
            "lungo",
            "lupo",
            "luppolo",
            "lusinga",
            "lusso",
            "lutto",
            "macabro",
            "macchina",
            "macero",
            "macinato",
            "madama",
            "magico",
            "maglia",
            "magnete",
            "magro",
            "maiolica",
            "malafede",
            "malgrado",
            "malinteso",
            "malsano",
            "malto",
            "malumore",
            "mana",
            "mancia",
            "mandorla",
            "mangiare",
            "manifesto",
            "mannaro",
            "manovra",
            "mansarda",
            "mantide",
            "manubrio",
            "mappa",
            "maratona",
            "marcire",
            "maretta",
            "marmo",
            "marsupio",
            "maschera",
            "massaia",
            "mastino",
            "materasso",
            "matricola",
            "mattone",
            "maturo",
            "mazurca",
            "meandro",
            "meccanico",
            "mecenate",
            "medesimo",
            "meditare",
            "mega",
            "melassa",
            "melis",
            "melodia",
            "meninge",
            "meno",
            "mensola",
            "mercurio",
            "merenda",
            "merlo",
            "meschino",
            "mese",
            "messere",
            "mestolo",
            "metallo",
            "metodo",
            "mettere",
            "miagolare",
            "mica",
            "micelio",
            "michele",
            "microbo",
            "midollo",
            "miele",
            "migliore",
            "milano",
            "milite",
            "mimosa",
            "minerale",
            "mini",
            "minore",
            "mirino",
            "mirtillo",
            "miscela",
            "missiva",
            "misto",
            "misurare",
            "mitezza",
            "mitigare",
            "mitra",
            "mittente",
            "mnemonico",
            "modello",
            "modifica",
            "modulo",
            "mogano",
            "mogio",
            "mole",
            "molosso",
            "monastero",
            "monco",
            "mondina",
            "monetario",
            "monile",
            "monotono",
            "monsone",
            "montato",
            "monviso",
            "mora",
            "mordere",
            "morsicato",
            "mostro",
            "motivato",
            "motosega",
            "motto",
            "movenza",
            "movimento",
            "mozzo",
            "mucca",
            "mucosa",
            "muffa",
            "mughetto",
            "mugnaio",
            "mulatto",
            "mulinello",
            "multiplo",
            "mummia",
            "munto",
            "muovere",
            "murale",
            "musa",
            "muscolo",
            "musica",
            "mutevole",
            "muto",
            "nababbo",
            "nafta",
            "nanometro",
            "narciso",
            "narice",
            "narrato",
            "nascere",
            "nastrare",
            "naturale",
            "nautica",
            "naviglio",
            "nebulosa",
            "necrosi",
            "negativo",
            "negozio",
            "nemmeno",
            "neofita",
            "neretto",
            "nervo",
            "nessuno",
            "nettuno",
            "neutrale",
            "neve",
            "nevrotico",
            "nicchia",
            "ninfa",
            "nitido",
            "nobile",
            "nocivo",
            "nodo",
            "nome",
            "nomina",
            "nordico",
            "normale",
            "norvegese",
            "nostrano",
            "notare",
            "notizia",
            "notturno",
            "novella",
            "nucleo",
            "nulla",
            "numero",
            "nuovo",
            "nutrire",
            "nuvola",
            "nuziale",
            "oasi",
            "obbedire",
            "obbligo",
            "obelisco",
            "oblio",
            "obolo",
            "obsoleto",
            "occasione",
            "occhio",
            "occidente",
            "occorrere",
            "occultare",
            "ocra",
            "oculato",
            "odierno",
            "odorare",
            "offerta",
            "offrire",
            "offuscato",
            "oggetto",
            "oggi",
            "ognuno",
            "olandese",
            "olfatto",
            "oliato",
            "oliva",
            "ologramma",
            "oltre",
            "omaggio",
            "ombelico",
            "ombra",
            "omega",
            "omissione",
            "ondoso",
            "onere",
            "onice",
            "onnivoro",
            "onorevole",
            "onta",
            "operato",
            "opinione",
            "opposto",
            "oracolo",
            "orafo",
            "ordine",
            "orecchino",
            "orefice",
            "orfano",
            "organico",
            "origine",
            "orizzonte",
            "orma",
            "ormeggio",
            "ornativo",
            "orologio",
            "orrendo",
            "orribile",
            "ortensia",
            "ortica",
            "orzata",
            "orzo",
            "osare",
            "oscurare",
            "osmosi",
            "ospedale",
            "ospite",
            "ossa",
            "ossidare",
            "ostacolo",
            "oste",
            "otite",
            "otre",
            "ottagono",
            "ottimo",
            "ottobre",
            "ovale",
            "ovest",
            "ovino",
            "oviparo",
            "ovocito",
            "ovunque",
            "ovviare",
            "ozio",
            "pacchetto",
            "pace",
            "pacifico",
            "padella",
            "padrone",
            "paese",
            "paga",
            "pagina",
            "palazzina",
            "palesare",
            "pallido",
            "palo",
            "palude",
            "pandoro",
            "pannello",
            "paolo",
            "paonazzo",
            "paprica",
            "parabola",
            "parcella",
            "parere",
            "pargolo",
            "pari",
            "parlato",
            "parola",
            "partire",
            "parvenza",
            "parziale",
            "passivo",
            "pasticca",
            "patacca",
            "patologia",
            "pattume",
            "pavone",
            "peccato",
            "pedalare",
            "pedonale",
            "peggio",
            "peloso",
            "penare",
            "pendice",
            "penisola",
            "pennuto",
            "penombra",
            "pensare",
            "pentola",
            "pepe",
            "pepita",
            "perbene",
            "percorso",
            "perdonato",
            "perforare",
            "pergamena",
            "periodo",
            "permesso",
            "perno",
            "perplesso",
            "persuaso",
            "pertugio",
            "pervaso",
            "pesatore",
            "pesista",
            "peso",
            "pestifero",
            "petalo",
            "pettine",
            "petulante",
            "pezzo",
            "piacere",
            "pianta",
            "piattino",
            "piccino",
            "picozza",
            "piega",
            "pietra",
            "piffero",
            "pigiama",
            "pigolio",
            "pigro",
            "pila",
            "pilifero",
            "pillola",
            "pilota",
            "pimpante",
            "pineta",
            "pinna",
            "pinolo",
            "pioggia",
            "piombo",
            "piramide",
            "piretico",
            "pirite",
            "pirolisi",
            "pitone",
            "pizzico",
            "placebo",
            "planare",
            "plasma",
            "platano",
            "plenario",
            "pochezza",
            "poderoso",
            "podismo",
            "poesia",
            "poggiare",
            "polenta",
            "poligono",
            "pollice",
            "polmonite",
            "polpetta",
            "polso",
            "poltrona",
            "polvere",
            "pomice",
            "pomodoro",
            "ponte",
            "popoloso",
            "porfido",
            "poroso",
            "porpora",
            "porre",
            "portata",
            "posa",
            "positivo",
            "possesso",
            "postulato",
            "potassio",
            "potere",
            "pranzo",
            "prassi",
            "pratica",
            "precluso",
            "predica",
            "prefisso",
            "pregiato",
            "prelievo",
            "premere",
            "prenotare",
            "preparato",
            "presenza",
            "pretesto",
            "prevalso",
            "prima",
            "principe",
            "privato",
            "problema",
            "procura",
            "produrre",
            "profumo",
            "progetto",
            "prolunga",
            "promessa",
            "pronome",
            "proposta",
            "proroga",
            "proteso",
            "prova",
            "prudente",
            "prugna",
            "prurito",
            "psiche",
            "pubblico",
            "pudica",
            "pugilato",
            "pugno",
            "pulce",
            "pulito",
            "pulsante",
            "puntare",
            "pupazzo",
            "pupilla",
            "puro",
            "quadro",
            "qualcosa",
            "quasi",
            "querela",
            "quota",
            "raccolto",
            "raddoppio",
            "radicale",
            "radunato",
            "raffica",
            "ragazzo",
            "ragione",
            "ragno",
            "ramarro",
            "ramingo",
            "ramo",
            "randagio",
            "rantolare",
            "rapato",
            "rapina",
            "rappreso",
            "rasatura",
            "raschiato",
            "rasente",
            "rassegna",
            "rastrello",
            "rata",
            "ravveduto",
            "reale",
            "recepire",
            "recinto",
            "recluta",
            "recondito",
            "recupero",
            "reddito",
            "redimere",
            "regalato",
            "registro",
            "regola",
            "regresso",
            "relazione",
            "remare",
            "remoto",
            "renna",
            "replica",
            "reprimere",
            "reputare",
            "resa",
            "residente",
            "responso",
            "restauro",
            "rete",
            "retina",
            "retorica",
            "rettifica",
            "revocato",
            "riassunto",
            "ribadire",
            "ribelle",
            "ribrezzo",
            "ricarica",
            "ricco",
            "ricevere",
            "riciclato",
            "ricordo",
            "ricreduto",
            "ridicolo",
            "ridurre",
            "rifasare",
            "riflesso",
            "riforma",
            "rifugio",
            "rigare",
            "rigettato",
            "righello",
            "rilassato",
            "rilevato",
            "rimanere",
            "rimbalzo",
            "rimedio",
            "rimorchio",
            "rinascita",
            "rincaro",
            "rinforzo",
            "rinnovo",
            "rinomato",
            "rinsavito",
            "rintocco",
            "rinuncia",
            "rinvenire",
            "riparato",
            "ripetuto",
            "ripieno",
            "riportare",
            "ripresa",
            "ripulire",
            "risata",
            "rischio",
            "riserva",
            "risibile",
            "riso",
            "rispetto",
            "ristoro",
            "risultato",
            "risvolto",
            "ritardo",
            "ritegno",
            "ritmico",
            "ritrovo",
            "riunione",
            "riva",
            "riverso",
            "rivincita",
            "rivolto",
            "rizoma",
            "roba",
            "robotico",
            "robusto",
            "roccia",
            "roco",
            "rodaggio",
            "rodere",
            "roditore",
            "rogito",
            "rollio",
            "romantico",
            "rompere",
            "ronzio",
            "rosolare",
            "rospo",
            "rotante",
            "rotondo",
            "rotula",
            "rovescio",
            "rubizzo",
            "rubrica",
            "ruga",
            "rullino",
            "rumine",
            "rumoroso",
            "ruolo",
            "rupe",
            "russare",
            "rustico",
            "sabato",
            "sabbiare",
            "sabotato",
            "sagoma",
            "salasso",
            "saldatura",
            "salgemma",
            "salivare",
            "salmone",
            "salone",
            "saltare",
            "saluto",
            "salvo",
            "sapere",
            "sapido",
            "saporito",
            "saraceno",
            "sarcasmo",
            "sarto",
            "sassoso",
            "satellite",
            "satira",
            "satollo",
            "saturno",
            "savana",
            "savio",
            "saziato",
            "sbadiglio",
            "sbalzo",
            "sbancato",
            "sbarra",
            "sbattere",
            "sbavare",
            "sbendare",
            "sbirciare",
            "sbloccato",
            "sbocciato",
            "sbrinare",
            "sbruffone",
            "sbuffare",
            "scabroso",
            "scadenza",
            "scala",
            "scambiare",
            "scandalo",
            "scapola",
            "scarso",
            "scatenare",
            "scavato",
            "scelto",
            "scenico",
            "scettro",
            "scheda",
            "schiena",
            "sciarpa",
            "scienza",
            "scindere",
            "scippo",
            "sciroppo",
            "scivolo",
            "sclerare",
            "scodella",
            "scolpito",
            "scomparto",
            "sconforto",
            "scoprire",
            "scorta",
            "scossone",
            "scozzese",
            "scriba",
            "scrollare",
            "scrutinio",
            "scuderia",
            "scultore",
            "scuola",
            "scuro",
            "scusare",
            "sdebitare",
            "sdoganare",
            "seccatura",
            "secondo",
            "sedano",
            "seggiola",
            "segnalato",
            "segregato",
            "seguito",
            "selciato",
            "selettivo",
            "sella",
            "selvaggio",
            "semaforo",
            "sembrare",
            "seme",
            "seminato",
            "sempre",
            "senso",
            "sentire",
            "sepolto",
            "sequenza",
            "serata",
            "serbato",
            "sereno",
            "serio",
            "serpente",
            "serraglio",
            "servire",
            "sestina",
            "setola",
            "settimana",
            "sfacelo",
            "sfaldare",
            "sfamato",
            "sfarzoso",
            "sfaticato",
            "sfera",
            "sfida",
            "sfilato",
            "sfinge",
            "sfocato",
            "sfoderare",
            "sfogo",
            "sfoltire",
            "sforzato",
            "sfratto",
            "sfruttato",
            "sfuggito",
            "sfumare",
            "sfuso",
            "sgabello",
            "sgarbato",
            "sgonfiare",
            "sgorbio",
            "sgrassato",
            "sguardo",
            "sibilo",
            "siccome",
            "sierra",
            "sigla",
            "signore",
            "silenzio",
            "sillaba",
            "simbolo",
            "simpatico",
            "simulato",
            "sinfonia",
            "singolo",
            "sinistro",
            "sino",
            "sintesi",
            "sinusoide",
            "sipario",
            "sisma",
            "sistole",
            "situato",
            "slitta",
            "slogatura",
            "sloveno",
            "smarrito",
            "smemorato",
            "smentito",
            "smeraldo",
            "smilzo",
            "smontare",
            "smottato",
            "smussato",
            "snellire",
            "snervato",
            "snodo",
            "sobbalzo",
            "sobrio",
            "soccorso",
            "sociale",
            "sodale",
            "soffitto",
            "sogno",
            "soldato",
            "solenne",
            "solido",
            "sollazzo",
            "solo",
            "solubile",
            "solvente",
            "somatico",
            "somma",
            "sonda",
            "sonetto",
            "sonnifero",
            "sopire",
            "soppeso",
            "sopra",
            "sorgere",
            "sorpasso",
            "sorriso",
            "sorso",
            "sorteggio",
            "sorvolato",
            "sospiro",
            "sosta",
            "sottile",
            "spada",
            "spalla",
            "spargere",
            "spatola",
            "spavento",
            "spazzola",
            "specie",
            "spedire",
            "spegnere",
            "spelatura",
            "speranza",
            "spessore",
            "spettrale",
            "spezzato",
            "spia",
            "spigoloso",
            "spillato",
            "spinoso",
            "spirale",
            "splendido",
            "sportivo",
            "sposo",
            "spranga",
            "sprecare",
            "spronato",
            "spruzzo",
            "spuntino",
            "squillo",
            "sradicare",
            "srotolato",
            "stabile",
            "stacco",
            "staffa",
            "stagnare",
            "stampato",
            "stantio",
            "starnuto",
            "stasera",
            "statuto",
            "stelo",
            "steppa",
            "sterzo",
            "stiletto",
            "stima",
            "stirpe",
            "stivale",
            "stizzoso",
            "stonato",
            "storico",
            "strappo",
            "stregato",
            "stridulo",
            "strozzare",
            "strutto",
            "stuccare",
            "stufo",
            "stupendo",
            "subentro",
            "succoso",
            "sudore",
            "suggerito",
            "sugo",
            "sultano",
            "suonare",
            "superbo",
            "supporto",
            "surgelato",
            "surrogato",
            "sussurro",
            "sutura",
            "svagare",
            "svedese",
            "sveglio",
            "svelare",
            "svenuto",
            "svezia",
            "sviluppo",
            "svista",
            "svizzera",
            "svolta",
            "svuotare",
            "tabacco",
            "tabulato",
            "tacciare",
            "taciturno",
            "tale",
            "talismano",
            "tampone",
            "tannino",
            "tara",
            "tardivo",
            "targato",
            "tariffa",
            "tarpare",
            "tartaruga",
            "tasto",
            "tattico",
            "taverna",
            "tavolata",
            "tazza",
            "teca",
            "tecnico",
            "telefono",
            "temerario",
            "tempo",
            "temuto",
            "tendone",
            "tenero",
            "tensione",
            "tentacolo",
            "teorema",
            "terme",
            "terrazzo",
            "terzetto",
            "tesi",
            "tesserato",
            "testato",
            "tetro",
            "tettoia",
            "tifare",
            "tigella",
            "timbro",
            "tinto",
            "tipico",
            "tipografo",
            "tiraggio",
            "tiro",
            "titanio",
            "titolo",
            "titubante",
            "tizio",
            "tizzone",
            "toccare",
            "tollerare",
            "tolto",
            "tombola",
            "tomo",
            "tonfo",
            "tonsilla",
            "topazio",
            "topologia",
            "toppa",
            "torba",
            "tornare",
            "torrone",
            "tortora",
            "toscano",
            "tossire",
            "tostatura",
            "totano",
            "trabocco",
            "trachea",
            "trafila",
            "tragedia",
            "tralcio",
            "tramonto",
            "transito",
            "trapano",
            "trarre",
            "trasloco",
            "trattato",
            "trave",
            "treccia",
            "tremolio",
            "trespolo",
            "tributo",
            "tricheco",
            "trifoglio",
            "trillo",
            "trincea",
            "trio",
            "tristezza",
            "triturato",
            "trivella",
            "tromba",
            "trono",
            "troppo",
            "trottola",
            "trovare",
            "truccato",
            "tubatura",
            "tuffato",
            "tulipano",
            "tumulto",
            "tunisia",
            "turbare",
            "turchino",
            "tuta",
            "tutela",
            "ubicato",
            "uccello",
            "uccisore",
            "udire",
            "uditivo",
            "uffa",
            "ufficio",
            "uguale",
            "ulisse",
            "ultimato",
            "umano",
            "umile",
            "umorismo",
            "uncinetto",
            "ungere",
            "ungherese",
            "unicorno",
            "unificato",
            "unisono",
            "unitario",
            "unte",
            "uovo",
            "upupa",
            "uragano",
            "urgenza",
            "urlo",
            "usanza",
            "usato",
            "uscito",
            "usignolo",
            "usuraio",
            "utensile",
            "utilizzo",
            "utopia",
            "vacante",
            "vaccinato",
            "vagabondo",
            "vagliato",
            "valanga",
            "valgo",
            "valico",
            "valletta",
            "valoroso",
            "valutare",
            "valvola",
            "vampata",
            "vangare",
            "vanitoso",
            "vano",
            "vantaggio",
            "vanvera",
            "vapore",
            "varano",
            "varcato",
            "variante",
            "vasca",
            "vedetta",
            "vedova",
            "veduto",
            "vegetale",
            "veicolo",
            "velcro",
            "velina",
            "velluto",
            "veloce",
            "venato",
            "vendemmia",
            "vento",
            "verace",
            "verbale",
            "vergogna",
            "verifica",
            "vero",
            "verruca",
            "verticale",
            "vescica",
            "vessillo",
            "vestale",
            "veterano",
            "vetrina",
            "vetusto",
            "viandante",
            "vibrante",
            "vicenda",
            "vichingo",
            "vicinanza",
            "vidimare",
            "vigilia",
            "vigneto",
            "vigore",
            "vile",
            "villano",
            "vimini",
            "vincitore",
            "viola",
            "vipera",
            "virgola",
            "virologo",
            "virulento",
            "viscoso",
            "visione",
            "vispo",
            "vissuto",
            "visura",
            "vita",
            "vitello",
            "vittima",
            "vivanda",
            "vivido",
            "viziare",
            "voce",
            "voga",
            "volatile",
            "volere",
            "volpe",
            "voragine",
            "vulcano",
            "zampogna",
            "zanna",
            "zappato",
            "zattera",
            "zavorra",
            "zefiro",
            "zelante",
            "zelo",
            "zenzero",
            "zerbino",
            "zibetto",
            "zinco",
            "zircone",
            "zitto",
            "zolla",
            "zotico",
            "zucchero",
            "zufolo",
            "zulu",
            "zuppa"
        ]

    }, {}],
    68: [function (require, module, exports) {
        module.exports = [
            "あいこくしん",
            "あいさつ",
            "あいだ",
            "あおぞら",
            "あかちゃん",
            "あきる",
            "あけがた",
            "あける",
            "あこがれる",
            "あさい",
            "あさひ",
            "あしあと",
            "あじわう",
            "あずかる",
            "あずき",
            "あそぶ",
            "あたえる",
            "あたためる",
            "あたりまえ",
            "あたる",
            "あつい",
            "あつかう",
            "あっしゅく",
            "あつまり",
            "あつめる",
            "あてな",
            "あてはまる",
            "あひる",
            "あぶら",
            "あぶる",
            "あふれる",
            "あまい",
            "あまど",
            "あまやかす",
            "あまり",
            "あみもの",
            "あめりか",
            "あやまる",
            "あゆむ",
            "あらいぐま",
            "あらし",
            "あらすじ",
            "あらためる",
            "あらゆる",
            "あらわす",
            "ありがとう",
            "あわせる",
            "あわてる",
            "あんい",
            "あんがい",
            "あんこ",
            "あんぜん",
            "あんてい",
            "あんない",
            "あんまり",
            "いいだす",
            "いおん",
            "いがい",
            "いがく",
            "いきおい",
            "いきなり",
            "いきもの",
            "いきる",
            "いくじ",
            "いくぶん",
            "いけばな",
            "いけん",
            "いこう",
            "いこく",
            "いこつ",
            "いさましい",
            "いさん",
            "いしき",
            "いじゅう",
            "いじょう",
            "いじわる",
            "いずみ",
            "いずれ",
            "いせい",
            "いせえび",
            "いせかい",
            "いせき",
            "いぜん",
            "いそうろう",
            "いそがしい",
            "いだい",
            "いだく",
            "いたずら",
            "いたみ",
            "いたりあ",
            "いちおう",
            "いちじ",
            "いちど",
            "いちば",
            "いちぶ",
            "いちりゅう",
            "いつか",
            "いっしゅん",
            "いっせい",
            "いっそう",
            "いったん",
            "いっち",
            "いってい",
            "いっぽう",
            "いてざ",
            "いてん",
            "いどう",
            "いとこ",
            "いない",
            "いなか",
            "いねむり",
            "いのち",
            "いのる",
            "いはつ",
            "いばる",
            "いはん",
            "いびき",
            "いひん",
            "いふく",
            "いへん",
            "いほう",
            "いみん",
            "いもうと",
            "いもたれ",
            "いもり",
            "いやがる",
            "いやす",
            "いよかん",
            "いよく",
            "いらい",
            "いらすと",
            "いりぐち",
            "いりょう",
            "いれい",
            "いれもの",
            "いれる",
            "いろえんぴつ",
            "いわい",
            "いわう",
            "いわかん",
            "いわば",
            "いわゆる",
            "いんげんまめ",
            "いんさつ",
            "いんしょう",
            "いんよう",
            "うえき",
            "うえる",
            "うおざ",
            "うがい",
            "うかぶ",
            "うかべる",
            "うきわ",
            "うくらいな",
            "うくれれ",
            "うけたまわる",
            "うけつけ",
            "うけとる",
            "うけもつ",
            "うける",
            "うごかす",
            "うごく",
            "うこん",
            "うさぎ",
            "うしなう",
            "うしろがみ",
            "うすい",
            "うすぎ",
            "うすぐらい",
            "うすめる",
            "うせつ",
            "うちあわせ",
            "うちがわ",
            "うちき",
            "うちゅう",
            "うっかり",
            "うつくしい",
            "うったえる",
            "うつる",
            "うどん",
            "うなぎ",
            "うなじ",
            "うなずく",
            "うなる",
            "うねる",
            "うのう",
            "うぶげ",
            "うぶごえ",
            "うまれる",
            "うめる",
            "うもう",
            "うやまう",
            "うよく",
            "うらがえす",
            "うらぐち",
            "うらない",
            "うりあげ",
            "うりきれ",
            "うるさい",
            "うれしい",
            "うれゆき",
            "うれる",
            "うろこ",
            "うわき",
            "うわさ",
            "うんこう",
            "うんちん",
            "うんてん",
            "うんどう",
            "えいえん",
            "えいが",
            "えいきょう",
            "えいご",
            "えいせい",
            "えいぶん",
            "えいよう",
            "えいわ",
            "えおり",
            "えがお",
            "えがく",
            "えきたい",
            "えくせる",
            "えしゃく",
            "えすて",
            "えつらん",
            "えのぐ",
            "えほうまき",
            "えほん",
            "えまき",
            "えもじ",
            "えもの",
            "えらい",
            "えらぶ",
            "えりあ",
            "えんえん",
            "えんかい",
            "えんぎ",
            "えんげき",
            "えんしゅう",
            "えんぜつ",
            "えんそく",
            "えんちょう",
            "えんとつ",
            "おいかける",
            "おいこす",
            "おいしい",
            "おいつく",
            "おうえん",
            "おうさま",
            "おうじ",
            "おうせつ",
            "おうたい",
            "おうふく",
            "おうべい",
            "おうよう",
            "おえる",
            "おおい",
            "おおう",
            "おおどおり",
            "おおや",
            "おおよそ",
            "おかえり",
            "おかず",
            "おがむ",
            "おかわり",
            "おぎなう",
            "おきる",
            "おくさま",
            "おくじょう",
            "おくりがな",
            "おくる",
            "おくれる",
            "おこす",
            "おこなう",
            "おこる",
            "おさえる",
            "おさない",
            "おさめる",
            "おしいれ",
            "おしえる",
            "おじぎ",
            "おじさん",
            "おしゃれ",
            "おそらく",
            "おそわる",
            "おたがい",
            "おたく",
            "おだやか",
            "おちつく",
            "おっと",
            "おつり",
            "おでかけ",
            "おとしもの",
            "おとなしい",
            "おどり",
            "おどろかす",
            "おばさん",
            "おまいり",
            "おめでとう",
            "おもいで",
            "おもう",
            "おもたい",
            "おもちゃ",
            "おやつ",
            "おやゆび",
            "およぼす",
            "おらんだ",
            "おろす",
            "おんがく",
            "おんけい",
            "おんしゃ",
            "おんせん",
            "おんだん",
            "おんちゅう",
            "おんどけい",
            "かあつ",
            "かいが",
            "がいき",
            "がいけん",
            "がいこう",
            "かいさつ",
            "かいしゃ",
            "かいすいよく",
            "かいぜん",
            "かいぞうど",
            "かいつう",
            "かいてん",
            "かいとう",
            "かいふく",
            "がいへき",
            "かいほう",
            "かいよう",
            "がいらい",
            "かいわ",
            "かえる",
            "かおり",
            "かかえる",
            "かがく",
            "かがし",
            "かがみ",
            "かくご",
            "かくとく",
            "かざる",
            "がぞう",
            "かたい",
            "かたち",
            "がちょう",
            "がっきゅう",
            "がっこう",
            "がっさん",
            "がっしょう",
            "かなざわし",
            "かのう",
            "がはく",
            "かぶか",
            "かほう",
            "かほご",
            "かまう",
            "かまぼこ",
            "かめれおん",
            "かゆい",
            "かようび",
            "からい",
            "かるい",
            "かろう",
            "かわく",
            "かわら",
            "がんか",
            "かんけい",
            "かんこう",
            "かんしゃ",
            "かんそう",
            "かんたん",
            "かんち",
            "がんばる",
            "きあい",
            "きあつ",
            "きいろ",
            "ぎいん",
            "きうい",
            "きうん",
            "きえる",
            "きおう",
            "きおく",
            "きおち",
            "きおん",
            "きかい",
            "きかく",
            "きかんしゃ",
            "ききて",
            "きくばり",
            "きくらげ",
            "きけんせい",
            "きこう",
            "きこえる",
            "きこく",
            "きさい",
            "きさく",
            "きさま",
            "きさらぎ",
            "ぎじかがく",
            "ぎしき",
            "ぎじたいけん",
            "ぎじにってい",
            "ぎじゅつしゃ",
            "きすう",
            "きせい",
            "きせき",
            "きせつ",
            "きそう",
            "きぞく",
            "きぞん",
            "きたえる",
            "きちょう",
            "きつえん",
            "ぎっちり",
            "きつつき",
            "きつね",
            "きてい",
            "きどう",
            "きどく",
            "きない",
            "きなが",
            "きなこ",
            "きぬごし",
            "きねん",
            "きのう",
            "きのした",
            "きはく",
            "きびしい",
            "きひん",
            "きふく",
            "きぶん",
            "きぼう",
            "きほん",
            "きまる",
            "きみつ",
            "きむずかしい",
            "きめる",
            "きもだめし",
            "きもち",
            "きもの",
            "きゃく",
            "きやく",
            "ぎゅうにく",
            "きよう",
            "きょうりゅう",
            "きらい",
            "きらく",
            "きりん",
            "きれい",
            "きれつ",
            "きろく",
            "ぎろん",
            "きわめる",
            "ぎんいろ",
            "きんかくじ",
            "きんじょ",
            "きんようび",
            "ぐあい",
            "くいず",
            "くうかん",
            "くうき",
            "くうぐん",
            "くうこう",
            "ぐうせい",
            "くうそう",
            "ぐうたら",
            "くうふく",
            "くうぼ",
            "くかん",
            "くきょう",
            "くげん",
            "ぐこう",
            "くさい",
            "くさき",
            "くさばな",
            "くさる",
            "くしゃみ",
            "くしょう",
            "くすのき",
            "くすりゆび",
            "くせげ",
            "くせん",
            "ぐたいてき",
            "くださる",
            "くたびれる",
            "くちこみ",
            "くちさき",
            "くつした",
            "ぐっすり",
            "くつろぐ",
            "くとうてん",
            "くどく",
            "くなん",
            "くねくね",
            "くのう",
            "くふう",
            "くみあわせ",
            "くみたてる",
            "くめる",
            "くやくしょ",
            "くらす",
            "くらべる",
            "くるま",
            "くれる",
            "くろう",
            "くわしい",
            "ぐんかん",
            "ぐんしょく",
            "ぐんたい",
            "ぐんて",
            "けあな",
            "けいかく",
            "けいけん",
            "けいこ",
            "けいさつ",
            "げいじゅつ",
            "けいたい",
            "げいのうじん",
            "けいれき",
            "けいろ",
            "けおとす",
            "けおりもの",
            "げきか",
            "げきげん",
            "げきだん",
            "げきちん",
            "げきとつ",
            "げきは",
            "げきやく",
            "げこう",
            "げこくじょう",
            "げざい",
            "けさき",
            "げざん",
            "けしき",
            "けしごむ",
            "けしょう",
            "げすと",
            "けたば",
            "けちゃっぷ",
            "けちらす",
            "けつあつ",
            "けつい",
            "けつえき",
            "けっこん",
            "けつじょ",
            "けっせき",
            "けってい",
            "けつまつ",
            "げつようび",
            "げつれい",
            "けつろん",
            "げどく",
            "けとばす",
            "けとる",
            "けなげ",
            "けなす",
            "けなみ",
            "けぬき",
            "げねつ",
            "けねん",
            "けはい",
            "げひん",
            "けぶかい",
            "げぼく",
            "けまり",
            "けみかる",
            "けむし",
            "けむり",
            "けもの",
            "けらい",
            "けろけろ",
            "けわしい",
            "けんい",
            "けんえつ",
            "けんお",
            "けんか",
            "げんき",
            "けんげん",
            "けんこう",
            "けんさく",
            "けんしゅう",
            "けんすう",
            "げんそう",
            "けんちく",
            "けんてい",
            "けんとう",
            "けんない",
            "けんにん",
            "げんぶつ",
            "けんま",
            "けんみん",
            "けんめい",
            "けんらん",
            "けんり",
            "こあくま",
            "こいぬ",
            "こいびと",
            "ごうい",
            "こうえん",
            "こうおん",
            "こうかん",
            "ごうきゅう",
            "ごうけい",
            "こうこう",
            "こうさい",
            "こうじ",
            "こうすい",
            "ごうせい",
            "こうそく",
            "こうたい",
            "こうちゃ",
            "こうつう",
            "こうてい",
            "こうどう",
            "こうない",
            "こうはい",
            "ごうほう",
            "ごうまん",
            "こうもく",
            "こうりつ",
            "こえる",
            "こおり",
            "ごかい",
            "ごがつ",
            "ごかん",
            "こくご",
            "こくさい",
            "こくとう",
            "こくない",
            "こくはく",
            "こぐま",
            "こけい",
            "こける",
            "ここのか",
            "こころ",
            "こさめ",
            "こしつ",
            "こすう",
            "こせい",
            "こせき",
            "こぜん",
            "こそだて",
            "こたい",
            "こたえる",
            "こたつ",
            "こちょう",
            "こっか",
            "こつこつ",
            "こつばん",
            "こつぶ",
            "こてい",
            "こてん",
            "ことがら",
            "ことし",
            "ことば",
            "ことり",
            "こなごな",
            "こねこね",
            "このまま",
            "このみ",
            "このよ",
            "ごはん",
            "こひつじ",
            "こふう",
            "こふん",
            "こぼれる",
            "ごまあぶら",
            "こまかい",
            "ごますり",
            "こまつな",
            "こまる",
            "こむぎこ",
            "こもじ",
            "こもち",
            "こもの",
            "こもん",
            "こやく",
            "こやま",
            "こゆう",
            "こゆび",
            "こよい",
            "こよう",
            "こりる",
            "これくしょん",
            "ころっけ",
            "こわもて",
            "こわれる",
            "こんいん",
            "こんかい",
            "こんき",
            "こんしゅう",
            "こんすい",
            "こんだて",
            "こんとん",
            "こんなん",
            "こんびに",
            "こんぽん",
            "こんまけ",
            "こんや",
            "こんれい",
            "こんわく",
            "ざいえき",
            "さいかい",
            "さいきん",
            "ざいげん",
            "ざいこ",
            "さいしょ",
            "さいせい",
            "ざいたく",
            "ざいちゅう",
            "さいてき",
            "ざいりょう",
            "さうな",
            "さかいし",
            "さがす",
            "さかな",
            "さかみち",
            "さがる",
            "さぎょう",
            "さくし",
            "さくひん",
            "さくら",
            "さこく",
            "さこつ",
            "さずかる",
            "ざせき",
            "さたん",
            "さつえい",
            "ざつおん",
            "ざっか",
            "ざつがく",
            "さっきょく",
            "ざっし",
            "さつじん",
            "ざっそう",
            "さつたば",
            "さつまいも",
            "さてい",
            "さといも",
            "さとう",
            "さとおや",
            "さとし",
            "さとる",
            "さのう",
            "さばく",
            "さびしい",
            "さべつ",
            "さほう",
            "さほど",
            "さます",
            "さみしい",
            "さみだれ",
            "さむけ",
            "さめる",
            "さやえんどう",
            "さゆう",
            "さよう",
            "さよく",
            "さらだ",
            "ざるそば",
            "さわやか",
            "さわる",
            "さんいん",
            "さんか",
            "さんきゃく",
            "さんこう",
            "さんさい",
            "ざんしょ",
            "さんすう",
            "さんせい",
            "さんそ",
            "さんち",
            "さんま",
            "さんみ",
            "さんらん",
            "しあい",
            "しあげ",
            "しあさって",
            "しあわせ",
            "しいく",
            "しいん",
            "しうち",
            "しえい",
            "しおけ",
            "しかい",
            "しかく",
            "じかん",
            "しごと",
            "しすう",
            "じだい",
            "したうけ",
            "したぎ",
            "したて",
            "したみ",
            "しちょう",
            "しちりん",
            "しっかり",
            "しつじ",
            "しつもん",
            "してい",
            "してき",
            "してつ",
            "じてん",
            "じどう",
            "しなぎれ",
            "しなもの",
            "しなん",
            "しねま",
            "しねん",
            "しのぐ",
            "しのぶ",
            "しはい",
            "しばかり",
            "しはつ",
            "しはらい",
            "しはん",
            "しひょう",
            "しふく",
            "じぶん",
            "しへい",
            "しほう",
            "しほん",
            "しまう",
            "しまる",
            "しみん",
            "しむける",
            "じむしょ",
            "しめい",
            "しめる",
            "しもん",
            "しゃいん",
            "しゃうん",
            "しゃおん",
            "じゃがいも",
            "しやくしょ",
            "しゃくほう",
            "しゃけん",
            "しゃこ",
            "しゃざい",
            "しゃしん",
            "しゃせん",
            "しゃそう",
            "しゃたい",
            "しゃちょう",
            "しゃっきん",
            "じゃま",
            "しゃりん",
            "しゃれい",
            "じゆう",
            "じゅうしょ",
            "しゅくはく",
            "じゅしん",
            "しゅっせき",
            "しゅみ",
            "しゅらば",
            "じゅんばん",
            "しょうかい",
            "しょくたく",
            "しょっけん",
            "しょどう",
            "しょもつ",
            "しらせる",
            "しらべる",
            "しんか",
            "しんこう",
            "じんじゃ",
            "しんせいじ",
            "しんちく",
            "しんりん",
            "すあげ",
            "すあし",
            "すあな",
            "ずあん",
            "すいえい",
            "すいか",
            "すいとう",
            "ずいぶん",
            "すいようび",
            "すうがく",
            "すうじつ",
            "すうせん",
            "すおどり",
            "すきま",
            "すくう",
            "すくない",
            "すける",
            "すごい",
            "すこし",
            "ずさん",
            "すずしい",
            "すすむ",
            "すすめる",
            "すっかり",
            "ずっしり",
            "ずっと",
            "すてき",
            "すてる",
            "すねる",
            "すのこ",
            "すはだ",
            "すばらしい",
            "ずひょう",
            "ずぶぬれ",
            "すぶり",
            "すふれ",
            "すべて",
            "すべる",
            "ずほう",
            "すぼん",
            "すまい",
            "すめし",
            "すもう",
            "すやき",
            "すらすら",
            "するめ",
            "すれちがう",
            "すろっと",
            "すわる",
            "すんぜん",
            "すんぽう",
            "せあぶら",
            "せいかつ",
            "せいげん",
            "せいじ",
            "せいよう",
            "せおう",
            "せかいかん",
            "せきにん",
            "せきむ",
            "せきゆ",
            "せきらんうん",
            "せけん",
            "せこう",
            "せすじ",
            "せたい",
            "せたけ",
            "せっかく",
            "せっきゃく",
            "ぜっく",
            "せっけん",
            "せっこつ",
            "せっさたくま",
            "せつぞく",
            "せつだん",
            "せつでん",
            "せっぱん",
            "せつび",
            "せつぶん",
            "せつめい",
            "せつりつ",
            "せなか",
            "せのび",
            "せはば",
            "せびろ",
            "せぼね",
            "せまい",
            "せまる",
            "せめる",
            "せもたれ",
            "せりふ",
            "ぜんあく",
            "せんい",
            "せんえい",
            "せんか",
            "せんきょ",
            "せんく",
            "せんげん",
            "ぜんご",
            "せんさい",
            "せんしゅ",
            "せんすい",
            "せんせい",
            "せんぞ",
            "せんたく",
            "せんちょう",
            "せんてい",
            "せんとう",
            "せんぬき",
            "せんねん",
            "せんぱい",
            "ぜんぶ",
            "ぜんぽう",
            "せんむ",
            "せんめんじょ",
            "せんもん",
            "せんやく",
            "せんゆう",
            "せんよう",
            "ぜんら",
            "ぜんりゃく",
            "せんれい",
            "せんろ",
            "そあく",
            "そいとげる",
            "そいね",
            "そうがんきょう",
            "そうき",
            "そうご",
            "そうしん",
            "そうだん",
            "そうなん",
            "そうび",
            "そうめん",
            "そうり",
            "そえもの",
            "そえん",
            "そがい",
            "そげき",
            "そこう",
            "そこそこ",
            "そざい",
            "そしな",
            "そせい",
            "そせん",
            "そそぐ",
            "そだてる",
            "そつう",
            "そつえん",
            "そっかん",
            "そつぎょう",
            "そっけつ",
            "そっこう",
            "そっせん",
            "そっと",
            "そとがわ",
            "そとづら",
            "そなえる",
            "そなた",
            "そふぼ",
            "そぼく",
            "そぼろ",
            "そまつ",
            "そまる",
            "そむく",
            "そむりえ",
            "そめる",
            "そもそも",
            "そよかぜ",
            "そらまめ",
            "そろう",
            "そんかい",
            "そんけい",
            "そんざい",
            "そんしつ",
            "そんぞく",
            "そんちょう",
            "ぞんび",
            "ぞんぶん",
            "そんみん",
            "たあい",
            "たいいん",
            "たいうん",
            "たいえき",
            "たいおう",
            "だいがく",
            "たいき",
            "たいぐう",
            "たいけん",
            "たいこ",
            "たいざい",
            "だいじょうぶ",
            "だいすき",
            "たいせつ",
            "たいそう",
            "だいたい",
            "たいちょう",
            "たいてい",
            "だいどころ",
            "たいない",
            "たいねつ",
            "たいのう",
            "たいはん",
            "だいひょう",
            "たいふう",
            "たいへん",
            "たいほ",
            "たいまつばな",
            "たいみんぐ",
            "たいむ",
            "たいめん",
            "たいやき",
            "たいよう",
            "たいら",
            "たいりょく",
            "たいる",
            "たいわん",
            "たうえ",
            "たえる",
            "たおす",
            "たおる",
            "たおれる",
            "たかい",
            "たかね",
            "たきび",
            "たくさん",
            "たこく",
            "たこやき",
            "たさい",
            "たしざん",
            "だじゃれ",
            "たすける",
            "たずさわる",
            "たそがれ",
            "たたかう",
            "たたく",
            "ただしい",
            "たたみ",
            "たちばな",
            "だっかい",
            "だっきゃく",
            "だっこ",
            "だっしゅつ",
            "だったい",
            "たてる",
            "たとえる",
            "たなばた",
            "たにん",
            "たぬき",
            "たのしみ",
            "たはつ",
            "たぶん",
            "たべる",
            "たぼう",
            "たまご",
            "たまる",
            "だむる",
            "ためいき",
            "ためす",
            "ためる",
            "たもつ",
            "たやすい",
            "たよる",
            "たらす",
            "たりきほんがん",
            "たりょう",
            "たりる",
            "たると",
            "たれる",
            "たれんと",
            "たろっと",
            "たわむれる",
            "だんあつ",
            "たんい",
            "たんおん",
            "たんか",
            "たんき",
            "たんけん",
            "たんご",
            "たんさん",
            "たんじょうび",
            "だんせい",
            "たんそく",
            "たんたい",
            "だんち",
            "たんてい",
            "たんとう",
            "だんな",
            "たんにん",
            "だんねつ",
            "たんのう",
            "たんぴん",
            "だんぼう",
            "たんまつ",
            "たんめい",
            "だんれつ",
            "だんろ",
            "だんわ",
            "ちあい",
            "ちあん",
            "ちいき",
            "ちいさい",
            "ちえん",
            "ちかい",
            "ちから",
            "ちきゅう",
            "ちきん",
            "ちけいず",
            "ちけん",
            "ちこく",
            "ちさい",
            "ちしき",
            "ちしりょう",
            "ちせい",
            "ちそう",
            "ちたい",
            "ちたん",
            "ちちおや",
            "ちつじょ",
            "ちてき",
            "ちてん",
            "ちぬき",
            "ちぬり",
            "ちのう",
            "ちひょう",
            "ちへいせん",
            "ちほう",
            "ちまた",
            "ちみつ",
            "ちみどろ",
            "ちめいど",
            "ちゃんこなべ",
            "ちゅうい",
            "ちゆりょく",
            "ちょうし",
            "ちょさくけん",
            "ちらし",
            "ちらみ",
            "ちりがみ",
            "ちりょう",
            "ちるど",
            "ちわわ",
            "ちんたい",
            "ちんもく",
            "ついか",
            "ついたち",
            "つうか",
            "つうじょう",
            "つうはん",
            "つうわ",
            "つかう",
            "つかれる",
            "つくね",
            "つくる",
            "つけね",
            "つける",
            "つごう",
            "つたえる",
            "つづく",
            "つつじ",
            "つつむ",
            "つとめる",
            "つながる",
            "つなみ",
            "つねづね",
            "つのる",
            "つぶす",
            "つまらない",
            "つまる",
            "つみき",
            "つめたい",
            "つもり",
            "つもる",
            "つよい",
            "つるぼ",
            "つるみく",
            "つわもの",
            "つわり",
            "てあし",
            "てあて",
            "てあみ",
            "ていおん",
            "ていか",
            "ていき",
            "ていけい",
            "ていこく",
            "ていさつ",
            "ていし",
            "ていせい",
            "ていたい",
            "ていど",
            "ていねい",
            "ていひょう",
            "ていへん",
            "ていぼう",
            "てうち",
            "ておくれ",
            "てきとう",
            "てくび",
            "でこぼこ",
            "てさぎょう",
            "てさげ",
            "てすり",
            "てそう",
            "てちがい",
            "てちょう",
            "てつがく",
            "てつづき",
            "でっぱ",
            "てつぼう",
            "てつや",
            "でぬかえ",
            "てぬき",
            "てぬぐい",
            "てのひら",
            "てはい",
            "てぶくろ",
            "てふだ",
            "てほどき",
            "てほん",
            "てまえ",
            "てまきずし",
            "てみじか",
            "てみやげ",
            "てらす",
            "てれび",
            "てわけ",
            "てわたし",
            "でんあつ",
            "てんいん",
            "てんかい",
            "てんき",
            "てんぐ",
            "てんけん",
            "てんごく",
            "てんさい",
            "てんし",
            "てんすう",
            "でんち",
            "てんてき",
            "てんとう",
            "てんない",
            "てんぷら",
            "てんぼうだい",
            "てんめつ",
            "てんらんかい",
            "でんりょく",
            "でんわ",
            "どあい",
            "といれ",
            "どうかん",
            "とうきゅう",
            "どうぐ",
            "とうし",
            "とうむぎ",
            "とおい",
            "とおか",
            "とおく",
            "とおす",
            "とおる",
            "とかい",
            "とかす",
            "ときおり",
            "ときどき",
            "とくい",
            "とくしゅう",
            "とくてん",
            "とくに",
            "とくべつ",
            "とけい",
            "とける",
            "とこや",
            "とさか",
            "としょかん",
            "とそう",
            "とたん",
            "とちゅう",
            "とっきゅう",
            "とっくん",
            "とつぜん",
            "とつにゅう",
            "とどける",
            "ととのえる",
            "とない",
            "となえる",
            "となり",
            "とのさま",
            "とばす",
            "どぶがわ",
            "とほう",
            "とまる",
            "とめる",
            "ともだち",
            "ともる",
            "どようび",
            "とらえる",
            "とんかつ",
            "どんぶり",
            "ないかく",
            "ないこう",
            "ないしょ",
            "ないす",
            "ないせん",
            "ないそう",
            "なおす",
            "ながい",
            "なくす",
            "なげる",
            "なこうど",
            "なさけ",
            "なたでここ",
            "なっとう",
            "なつやすみ",
            "ななおし",
            "なにごと",
            "なにもの",
            "なにわ",
            "なのか",
            "なふだ",
            "なまいき",
            "なまえ",
            "なまみ",
            "なみだ",
            "なめらか",
            "なめる",
            "なやむ",
            "ならう",
            "ならび",
            "ならぶ",
            "なれる",
            "なわとび",
            "なわばり",
            "にあう",
            "にいがた",
            "にうけ",
            "におい",
            "にかい",
            "にがて",
            "にきび",
            "にくしみ",
            "にくまん",
            "にげる",
            "にさんかたんそ",
            "にしき",
            "にせもの",
            "にちじょう",
            "にちようび",
            "にっか",
            "にっき",
            "にっけい",
            "にっこう",
            "にっさん",
            "にっしょく",
            "にっすう",
            "にっせき",
            "にってい",
            "になう",
            "にほん",
            "にまめ",
            "にもつ",
            "にやり",
            "にゅういん",
            "にりんしゃ",
            "にわとり",
            "にんい",
            "にんか",
            "にんき",
            "にんげん",
            "にんしき",
            "にんずう",
            "にんそう",
            "にんたい",
            "にんち",
            "にんてい",
            "にんにく",
            "にんぷ",
            "にんまり",
            "にんむ",
            "にんめい",
            "にんよう",
            "ぬいくぎ",
            "ぬかす",
            "ぬぐいとる",
            "ぬぐう",
            "ぬくもり",
            "ぬすむ",
            "ぬまえび",
            "ぬめり",
            "ぬらす",
            "ぬんちゃく",
            "ねあげ",
            "ねいき",
            "ねいる",
            "ねいろ",
            "ねぐせ",
            "ねくたい",
            "ねくら",
            "ねこぜ",
            "ねこむ",
            "ねさげ",
            "ねすごす",
            "ねそべる",
            "ねだん",
            "ねつい",
            "ねっしん",
            "ねつぞう",
            "ねったいぎょ",
            "ねぶそく",
            "ねふだ",
            "ねぼう",
            "ねほりはほり",
            "ねまき",
            "ねまわし",
            "ねみみ",
            "ねむい",
            "ねむたい",
            "ねもと",
            "ねらう",
            "ねわざ",
            "ねんいり",
            "ねんおし",
            "ねんかん",
            "ねんきん",
            "ねんぐ",
            "ねんざ",
            "ねんし",
            "ねんちゃく",
            "ねんど",
            "ねんぴ",
            "ねんぶつ",
            "ねんまつ",
            "ねんりょう",
            "ねんれい",
            "のいず",
            "のおづま",
            "のがす",
            "のきなみ",
            "のこぎり",
            "のこす",
            "のこる",
            "のせる",
            "のぞく",
            "のぞむ",
            "のたまう",
            "のちほど",
            "のっく",
            "のばす",
            "のはら",
            "のべる",
            "のぼる",
            "のみもの",
            "のやま",
            "のらいぬ",
            "のらねこ",
            "のりもの",
            "のりゆき",
            "のれん",
            "のんき",
            "ばあい",
            "はあく",
            "ばあさん",
            "ばいか",
            "ばいく",
            "はいけん",
            "はいご",
            "はいしん",
            "はいすい",
            "はいせん",
            "はいそう",
            "はいち",
            "ばいばい",
            "はいれつ",
            "はえる",
            "はおる",
            "はかい",
            "ばかり",
            "はかる",
            "はくしゅ",
            "はけん",
            "はこぶ",
            "はさみ",
            "はさん",
            "はしご",
            "ばしょ",
            "はしる",
            "はせる",
            "ぱそこん",
            "はそん",
            "はたん",
            "はちみつ",
            "はつおん",
            "はっかく",
            "はづき",
            "はっきり",
            "はっくつ",
            "はっけん",
            "はっこう",
            "はっさん",
            "はっしん",
            "はったつ",
            "はっちゅう",
            "はってん",
            "はっぴょう",
            "はっぽう",
            "はなす",
            "はなび",
            "はにかむ",
            "はぶらし",
            "はみがき",
            "はむかう",
            "はめつ",
            "はやい",
            "はやし",
            "はらう",
            "はろうぃん",
            "はわい",
            "はんい",
            "はんえい",
            "はんおん",
            "はんかく",
            "はんきょう",
            "ばんぐみ",
            "はんこ",
            "はんしゃ",
            "はんすう",
            "はんだん",
            "ぱんち",
            "ぱんつ",
            "はんてい",
            "はんとし",
            "はんのう",
            "はんぱ",
            "はんぶん",
            "はんぺん",
            "はんぼうき",
            "はんめい",
            "はんらん",
            "はんろん",
            "ひいき",
            "ひうん",
            "ひえる",
            "ひかく",
            "ひかり",
            "ひかる",
            "ひかん",
            "ひくい",
            "ひけつ",
            "ひこうき",
            "ひこく",
            "ひさい",
            "ひさしぶり",
            "ひさん",
            "びじゅつかん",
            "ひしょ",
            "ひそか",
            "ひそむ",
            "ひたむき",
            "ひだり",
            "ひたる",
            "ひつぎ",
            "ひっこし",
            "ひっし",
            "ひつじゅひん",
            "ひっす",
            "ひつぜん",
            "ぴったり",
            "ぴっちり",
            "ひつよう",
            "ひてい",
            "ひとごみ",
            "ひなまつり",
            "ひなん",
            "ひねる",
            "ひはん",
            "ひびく",
            "ひひょう",
            "ひほう",
            "ひまわり",
            "ひまん",
            "ひみつ",
            "ひめい",
            "ひめじし",
            "ひやけ",
            "ひやす",
            "ひよう",
            "びょうき",
            "ひらがな",
            "ひらく",
            "ひりつ",
            "ひりょう",
            "ひるま",
            "ひるやすみ",
            "ひれい",
            "ひろい",
            "ひろう",
            "ひろき",
            "ひろゆき",
            "ひんかく",
            "ひんけつ",
            "ひんこん",
            "ひんしゅ",
            "ひんそう",
            "ぴんち",
            "ひんぱん",
            "びんぼう",
            "ふあん",
            "ふいうち",
            "ふうけい",
            "ふうせん",
            "ぷうたろう",
            "ふうとう",
            "ふうふ",
            "ふえる",
            "ふおん",
            "ふかい",
            "ふきん",
            "ふくざつ",
            "ふくぶくろ",
            "ふこう",
            "ふさい",
            "ふしぎ",
            "ふじみ",
            "ふすま",
            "ふせい",
            "ふせぐ",
            "ふそく",
            "ぶたにく",
            "ふたん",
            "ふちょう",
            "ふつう",
            "ふつか",
            "ふっかつ",
            "ふっき",
            "ふっこく",
            "ぶどう",
            "ふとる",
            "ふとん",
            "ふのう",
            "ふはい",
            "ふひょう",
            "ふへん",
            "ふまん",
            "ふみん",
            "ふめつ",
            "ふめん",
            "ふよう",
            "ふりこ",
            "ふりる",
            "ふるい",
            "ふんいき",
            "ぶんがく",
            "ぶんぐ",
            "ふんしつ",
            "ぶんせき",
            "ふんそう",
            "ぶんぽう",
            "へいあん",
            "へいおん",
            "へいがい",
            "へいき",
            "へいげん",
            "へいこう",
            "へいさ",
            "へいしゃ",
            "へいせつ",
            "へいそ",
            "へいたく",
            "へいてん",
            "へいねつ",
            "へいわ",
            "へきが",
            "へこむ",
            "べにいろ",
            "べにしょうが",
            "へらす",
            "へんかん",
            "べんきょう",
            "べんごし",
            "へんさい",
            "へんたい",
            "べんり",
            "ほあん",
            "ほいく",
            "ぼうぎょ",
            "ほうこく",
            "ほうそう",
            "ほうほう",
            "ほうもん",
            "ほうりつ",
            "ほえる",
            "ほおん",
            "ほかん",
            "ほきょう",
            "ぼきん",
            "ほくろ",
            "ほけつ",
            "ほけん",
            "ほこう",
            "ほこる",
            "ほしい",
            "ほしつ",
            "ほしゅ",
            "ほしょう",
            "ほせい",
            "ほそい",
            "ほそく",
            "ほたて",
            "ほたる",
            "ぽちぶくろ",
            "ほっきょく",
            "ほっさ",
            "ほったん",
            "ほとんど",
            "ほめる",
            "ほんい",
            "ほんき",
            "ほんけ",
            "ほんしつ",
            "ほんやく",
            "まいにち",
            "まかい",
            "まかせる",
            "まがる",
            "まける",
            "まこと",
            "まさつ",
            "まじめ",
            "ますく",
            "まぜる",
            "まつり",
            "まとめ",
            "まなぶ",
            "まぬけ",
            "まねく",
            "まほう",
            "まもる",
            "まゆげ",
            "まよう",
            "まろやか",
            "まわす",
            "まわり",
            "まわる",
            "まんが",
            "まんきつ",
            "まんぞく",
            "まんなか",
            "みいら",
            "みうち",
            "みえる",
            "みがく",
            "みかた",
            "みかん",
            "みけん",
            "みこん",
            "みじかい",
            "みすい",
            "みすえる",
            "みせる",
            "みっか",
            "みつかる",
            "みつける",
            "みてい",
            "みとめる",
            "みなと",
            "みなみかさい",
            "みねらる",
            "みのう",
            "みのがす",
            "みほん",
            "みもと",
            "みやげ",
            "みらい",
            "みりょく",
            "みわく",
            "みんか",
            "みんぞく",
            "むいか",
            "むえき",
            "むえん",
            "むかい",
            "むかう",
            "むかえ",
            "むかし",
            "むぎちゃ",
            "むける",
            "むげん",
            "むさぼる",
            "むしあつい",
            "むしば",
            "むじゅん",
            "むしろ",
            "むすう",
            "むすこ",
            "むすぶ",
            "むすめ",
            "むせる",
            "むせん",
            "むちゅう",
            "むなしい",
            "むのう",
            "むやみ",
            "むよう",
            "むらさき",
            "むりょう",
            "むろん",
            "めいあん",
            "めいうん",
            "めいえん",
            "めいかく",
            "めいきょく",
            "めいさい",
            "めいし",
            "めいそう",
            "めいぶつ",
            "めいれい",
            "めいわく",
            "めぐまれる",
            "めざす",
            "めした",
            "めずらしい",
            "めだつ",
            "めまい",
            "めやす",
            "めんきょ",
            "めんせき",
            "めんどう",
            "もうしあげる",
            "もうどうけん",
            "もえる",
            "もくし",
            "もくてき",
            "もくようび",
            "もちろん",
            "もどる",
            "もらう",
            "もんく",
            "もんだい",
            "やおや",
            "やける",
            "やさい",
            "やさしい",
            "やすい",
            "やすたろう",
            "やすみ",
            "やせる",
            "やそう",
            "やたい",
            "やちん",
            "やっと",
            "やっぱり",
            "やぶる",
            "やめる",
            "ややこしい",
            "やよい",
            "やわらかい",
            "ゆうき",
            "ゆうびんきょく",
            "ゆうべ",
            "ゆうめい",
            "ゆけつ",
            "ゆしゅつ",
            "ゆせん",
            "ゆそう",
            "ゆたか",
            "ゆちゃく",
            "ゆでる",
            "ゆにゅう",
            "ゆびわ",
            "ゆらい",
            "ゆれる",
            "ようい",
            "ようか",
            "ようきゅう",
            "ようじ",
            "ようす",
            "ようちえん",
            "よかぜ",
            "よかん",
            "よきん",
            "よくせい",
            "よくぼう",
            "よけい",
            "よごれる",
            "よさん",
            "よしゅう",
            "よそう",
            "よそく",
            "よっか",
            "よてい",
            "よどがわく",
            "よねつ",
            "よやく",
            "よゆう",
            "よろこぶ",
            "よろしい",
            "らいう",
            "らくがき",
            "らくご",
            "らくさつ",
            "らくだ",
            "らしんばん",
            "らせん",
            "らぞく",
            "らたい",
            "らっか",
            "られつ",
            "りえき",
            "りかい",
            "りきさく",
            "りきせつ",
            "りくぐん",
            "りくつ",
            "りけん",
            "りこう",
            "りせい",
            "りそう",
            "りそく",
            "りてん",
            "りねん",
            "りゆう",
            "りゅうがく",
            "りよう",
            "りょうり",
            "りょかん",
            "りょくちゃ",
            "りょこう",
            "りりく",
            "りれき",
            "りろん",
            "りんご",
            "るいけい",
            "るいさい",
            "るいじ",
            "るいせき",
            "るすばん",
            "るりがわら",
            "れいかん",
            "れいぎ",
            "れいせい",
            "れいぞうこ",
            "れいとう",
            "れいぼう",
            "れきし",
            "れきだい",
            "れんあい",
            "れんけい",
            "れんこん",
            "れんさい",
            "れんしゅう",
            "れんぞく",
            "れんらく",
            "ろうか",
            "ろうご",
            "ろうじん",
            "ろうそく",
            "ろくが",
            "ろこつ",
            "ろじうら",
            "ろしゅつ",
            "ろせん",
            "ろてん",
            "ろめん",
            "ろれつ",
            "ろんぎ",
            "ろんぱ",
            "ろんぶん",
            "ろんり",
            "わかす",
            "わかめ",
            "わかやま",
            "わかれる",
            "わしつ",
            "わじまし",
            "わすれもの",
            "わらう",
            "われる"
        ]

    }, {}],
    69: [function (require, module, exports) {
        module.exports = [
            "가격",
            "가끔",
            "가난",
            "가능",
            "가득",
            "가르침",
            "가뭄",
            "가방",
            "가상",
            "가슴",
            "가운데",
            "가을",
            "가이드",
            "가입",
            "가장",
            "가정",
            "가족",
            "가죽",
            "각오",
            "각자",
            "간격",
            "간부",
            "간섭",
            "간장",
            "간접",
            "간판",
            "갈등",
            "갈비",
            "갈색",
            "갈증",
            "감각",
            "감기",
            "감소",
            "감수성",
            "감자",
            "감정",
            "갑자기",
            "강남",
            "강당",
            "강도",
            "강력히",
            "강변",
            "강북",
            "강사",
            "강수량",
            "강아지",
            "강원도",
            "강의",
            "강제",
            "강조",
            "같이",
            "개구리",
            "개나리",
            "개방",
            "개별",
            "개선",
            "개성",
            "개인",
            "객관적",
            "거실",
            "거액",
            "거울",
            "거짓",
            "거품",
            "걱정",
            "건강",
            "건물",
            "건설",
            "건조",
            "건축",
            "걸음",
            "검사",
            "검토",
            "게시판",
            "게임",
            "겨울",
            "견해",
            "결과",
            "결국",
            "결론",
            "결석",
            "결승",
            "결심",
            "결정",
            "결혼",
            "경계",
            "경고",
            "경기",
            "경력",
            "경복궁",
            "경비",
            "경상도",
            "경영",
            "경우",
            "경쟁",
            "경제",
            "경주",
            "경찰",
            "경치",
            "경향",
            "경험",
            "계곡",
            "계단",
            "계란",
            "계산",
            "계속",
            "계약",
            "계절",
            "계층",
            "계획",
            "고객",
            "고구려",
            "고궁",
            "고급",
            "고등학생",
            "고무신",
            "고민",
            "고양이",
            "고장",
            "고전",
            "고집",
            "고춧가루",
            "고통",
            "고향",
            "곡식",
            "골목",
            "골짜기",
            "골프",
            "공간",
            "공개",
            "공격",
            "공군",
            "공급",
            "공기",
            "공동",
            "공무원",
            "공부",
            "공사",
            "공식",
            "공업",
            "공연",
            "공원",
            "공장",
            "공짜",
            "공책",
            "공통",
            "공포",
            "공항",
            "공휴일",
            "과목",
            "과일",
            "과장",
            "과정",
            "과학",
            "관객",
            "관계",
            "관광",
            "관념",
            "관람",
            "관련",
            "관리",
            "관습",
            "관심",
            "관점",
            "관찰",
            "광경",
            "광고",
            "광장",
            "광주",
            "괴로움",
            "굉장히",
            "교과서",
            "교문",
            "교복",
            "교실",
            "교양",
            "교육",
            "교장",
            "교직",
            "교통",
            "교환",
            "교훈",
            "구경",
            "구름",
            "구멍",
            "구별",
            "구분",
            "구석",
            "구성",
            "구속",
            "구역",
            "구입",
            "구청",
            "구체적",
            "국가",
            "국기",
            "국내",
            "국립",
            "국물",
            "국민",
            "국수",
            "국어",
            "국왕",
            "국적",
            "국제",
            "국회",
            "군대",
            "군사",
            "군인",
            "궁극적",
            "권리",
            "권위",
            "권투",
            "귀국",
            "귀신",
            "규정",
            "규칙",
            "균형",
            "그날",
            "그냥",
            "그늘",
            "그러나",
            "그룹",
            "그릇",
            "그림",
            "그제서야",
            "그토록",
            "극복",
            "극히",
            "근거",
            "근교",
            "근래",
            "근로",
            "근무",
            "근본",
            "근원",
            "근육",
            "근처",
            "글씨",
            "글자",
            "금강산",
            "금고",
            "금년",
            "금메달",
            "금액",
            "금연",
            "금요일",
            "금지",
            "긍정적",
            "기간",
            "기관",
            "기념",
            "기능",
            "기독교",
            "기둥",
            "기록",
            "기름",
            "기법",
            "기본",
            "기분",
            "기쁨",
            "기숙사",
            "기술",
            "기억",
            "기업",
            "기온",
            "기운",
            "기원",
            "기적",
            "기준",
            "기침",
            "기혼",
            "기획",
            "긴급",
            "긴장",
            "길이",
            "김밥",
            "김치",
            "김포공항",
            "깍두기",
            "깜빡",
            "깨달음",
            "깨소금",
            "껍질",
            "꼭대기",
            "꽃잎",
            "나들이",
            "나란히",
            "나머지",
            "나물",
            "나침반",
            "나흘",
            "낙엽",
            "난방",
            "날개",
            "날씨",
            "날짜",
            "남녀",
            "남대문",
            "남매",
            "남산",
            "남자",
            "남편",
            "남학생",
            "낭비",
            "낱말",
            "내년",
            "내용",
            "내일",
            "냄비",
            "냄새",
            "냇물",
            "냉동",
            "냉면",
            "냉방",
            "냉장고",
            "넥타이",
            "넷째",
            "노동",
            "노란색",
            "노력",
            "노인",
            "녹음",
            "녹차",
            "녹화",
            "논리",
            "논문",
            "논쟁",
            "놀이",
            "농구",
            "농담",
            "농민",
            "농부",
            "농업",
            "농장",
            "농촌",
            "높이",
            "눈동자",
            "눈물",
            "눈썹",
            "뉴욕",
            "느낌",
            "늑대",
            "능동적",
            "능력",
            "다방",
            "다양성",
            "다음",
            "다이어트",
            "다행",
            "단계",
            "단골",
            "단독",
            "단맛",
            "단순",
            "단어",
            "단위",
            "단점",
            "단체",
            "단추",
            "단편",
            "단풍",
            "달걀",
            "달러",
            "달력",
            "달리",
            "닭고기",
            "담당",
            "담배",
            "담요",
            "담임",
            "답변",
            "답장",
            "당근",
            "당분간",
            "당연히",
            "당장",
            "대규모",
            "대낮",
            "대단히",
            "대답",
            "대도시",
            "대략",
            "대량",
            "대륙",
            "대문",
            "대부분",
            "대신",
            "대응",
            "대장",
            "대전",
            "대접",
            "대중",
            "대책",
            "대출",
            "대충",
            "대통령",
            "대학",
            "대한민국",
            "대합실",
            "대형",
            "덩어리",
            "데이트",
            "도대체",
            "도덕",
            "도둑",
            "도망",
            "도서관",
            "도심",
            "도움",
            "도입",
            "도자기",
            "도저히",
            "도전",
            "도중",
            "도착",
            "독감",
            "독립",
            "독서",
            "독일",
            "독창적",
            "동화책",
            "뒷모습",
            "뒷산",
            "딸아이",
            "마누라",
            "마늘",
            "마당",
            "마라톤",
            "마련",
            "마무리",
            "마사지",
            "마약",
            "마요네즈",
            "마을",
            "마음",
            "마이크",
            "마중",
            "마지막",
            "마찬가지",
            "마찰",
            "마흔",
            "막걸리",
            "막내",
            "막상",
            "만남",
            "만두",
            "만세",
            "만약",
            "만일",
            "만점",
            "만족",
            "만화",
            "많이",
            "말기",
            "말씀",
            "말투",
            "맘대로",
            "망원경",
            "매년",
            "매달",
            "매력",
            "매번",
            "매스컴",
            "매일",
            "매장",
            "맥주",
            "먹이",
            "먼저",
            "먼지",
            "멀리",
            "메일",
            "며느리",
            "며칠",
            "면담",
            "멸치",
            "명단",
            "명령",
            "명예",
            "명의",
            "명절",
            "명칭",
            "명함",
            "모금",
            "모니터",
            "모델",
            "모든",
            "모범",
            "모습",
            "모양",
            "모임",
            "모조리",
            "모집",
            "모퉁이",
            "목걸이",
            "목록",
            "목사",
            "목소리",
            "목숨",
            "목적",
            "목표",
            "몰래",
            "몸매",
            "몸무게",
            "몸살",
            "몸속",
            "몸짓",
            "몸통",
            "몹시",
            "무관심",
            "무궁화",
            "무더위",
            "무덤",
            "무릎",
            "무슨",
            "무엇",
            "무역",
            "무용",
            "무조건",
            "무지개",
            "무척",
            "문구",
            "문득",
            "문법",
            "문서",
            "문제",
            "문학",
            "문화",
            "물가",
            "물건",
            "물결",
            "물고기",
            "물론",
            "물리학",
            "물음",
            "물질",
            "물체",
            "미국",
            "미디어",
            "미사일",
            "미술",
            "미역",
            "미용실",
            "미움",
            "미인",
            "미팅",
            "미혼",
            "민간",
            "민족",
            "민주",
            "믿음",
            "밀가루",
            "밀리미터",
            "밑바닥",
            "바가지",
            "바구니",
            "바나나",
            "바늘",
            "바닥",
            "바닷가",
            "바람",
            "바이러스",
            "바탕",
            "박물관",
            "박사",
            "박수",
            "반대",
            "반드시",
            "반말",
            "반발",
            "반성",
            "반응",
            "반장",
            "반죽",
            "반지",
            "반찬",
            "받침",
            "발가락",
            "발걸음",
            "발견",
            "발달",
            "발레",
            "발목",
            "발바닥",
            "발생",
            "발음",
            "발자국",
            "발전",
            "발톱",
            "발표",
            "밤하늘",
            "밥그릇",
            "밥맛",
            "밥상",
            "밥솥",
            "방금",
            "방면",
            "방문",
            "방바닥",
            "방법",
            "방송",
            "방식",
            "방안",
            "방울",
            "방지",
            "방학",
            "방해",
            "방향",
            "배경",
            "배꼽",
            "배달",
            "배드민턴",
            "백두산",
            "백색",
            "백성",
            "백인",
            "백제",
            "백화점",
            "버릇",
            "버섯",
            "버튼",
            "번개",
            "번역",
            "번지",
            "번호",
            "벌금",
            "벌레",
            "벌써",
            "범위",
            "범인",
            "범죄",
            "법률",
            "법원",
            "법적",
            "법칙",
            "베이징",
            "벨트",
            "변경",
            "변동",
            "변명",
            "변신",
            "변호사",
            "변화",
            "별도",
            "별명",
            "별일",
            "병실",
            "병아리",
            "병원",
            "보관",
            "보너스",
            "보라색",
            "보람",
            "보름",
            "보상",
            "보안",
            "보자기",
            "보장",
            "보전",
            "보존",
            "보통",
            "보편적",
            "보험",
            "복도",
            "복사",
            "복숭아",
            "복습",
            "볶음",
            "본격적",
            "본래",
            "본부",
            "본사",
            "본성",
            "본인",
            "본질",
            "볼펜",
            "봉사",
            "봉지",
            "봉투",
            "부근",
            "부끄러움",
            "부담",
            "부동산",
            "부문",
            "부분",
            "부산",
            "부상",
            "부엌",
            "부인",
            "부작용",
            "부장",
            "부정",
            "부족",
            "부지런히",
            "부친",
            "부탁",
            "부품",
            "부회장",
            "북부",
            "북한",
            "분노",
            "분량",
            "분리",
            "분명",
            "분석",
            "분야",
            "분위기",
            "분필",
            "분홍색",
            "불고기",
            "불과",
            "불교",
            "불꽃",
            "불만",
            "불법",
            "불빛",
            "불안",
            "불이익",
            "불행",
            "브랜드",
            "비극",
            "비난",
            "비닐",
            "비둘기",
            "비디오",
            "비로소",
            "비만",
            "비명",
            "비밀",
            "비바람",
            "비빔밥",
            "비상",
            "비용",
            "비율",
            "비중",
            "비타민",
            "비판",
            "빌딩",
            "빗물",
            "빗방울",
            "빗줄기",
            "빛깔",
            "빨간색",
            "빨래",
            "빨리",
            "사건",
            "사계절",
            "사나이",
            "사냥",
            "사람",
            "사랑",
            "사립",
            "사모님",
            "사물",
            "사방",
            "사상",
            "사생활",
            "사설",
            "사슴",
            "사실",
            "사업",
            "사용",
            "사월",
            "사장",
            "사전",
            "사진",
            "사촌",
            "사춘기",
            "사탕",
            "사투리",
            "사흘",
            "산길",
            "산부인과",
            "산업",
            "산책",
            "살림",
            "살인",
            "살짝",
            "삼계탕",
            "삼국",
            "삼십",
            "삼월",
            "삼촌",
            "상관",
            "상금",
            "상대",
            "상류",
            "상반기",
            "상상",
            "상식",
            "상업",
            "상인",
            "상자",
            "상점",
            "상처",
            "상추",
            "상태",
            "상표",
            "상품",
            "상황",
            "새벽",
            "색깔",
            "색연필",
            "생각",
            "생명",
            "생물",
            "생방송",
            "생산",
            "생선",
            "생신",
            "생일",
            "생활",
            "서랍",
            "서른",
            "서명",
            "서민",
            "서비스",
            "서양",
            "서울",
            "서적",
            "서점",
            "서쪽",
            "서클",
            "석사",
            "석유",
            "선거",
            "선물",
            "선배",
            "선생",
            "선수",
            "선원",
            "선장",
            "선전",
            "선택",
            "선풍기",
            "설거지",
            "설날",
            "설렁탕",
            "설명",
            "설문",
            "설사",
            "설악산",
            "설치",
            "설탕",
            "섭씨",
            "성공",
            "성당",
            "성명",
            "성별",
            "성인",
            "성장",
            "성적",
            "성질",
            "성함",
            "세금",
            "세미나",
            "세상",
            "세월",
            "세종대왕",
            "세탁",
            "센터",
            "센티미터",
            "셋째",
            "소규모",
            "소극적",
            "소금",
            "소나기",
            "소년",
            "소득",
            "소망",
            "소문",
            "소설",
            "소속",
            "소아과",
            "소용",
            "소원",
            "소음",
            "소중히",
            "소지품",
            "소질",
            "소풍",
            "소형",
            "속담",
            "속도",
            "속옷",
            "손가락",
            "손길",
            "손녀",
            "손님",
            "손등",
            "손목",
            "손뼉",
            "손실",
            "손질",
            "손톱",
            "손해",
            "솔직히",
            "솜씨",
            "송아지",
            "송이",
            "송편",
            "쇠고기",
            "쇼핑",
            "수건",
            "수년",
            "수단",
            "수돗물",
            "수동적",
            "수면",
            "수명",
            "수박",
            "수상",
            "수석",
            "수술",
            "수시로",
            "수업",
            "수염",
            "수영",
            "수입",
            "수준",
            "수집",
            "수출",
            "수컷",
            "수필",
            "수학",
            "수험생",
            "수화기",
            "숙녀",
            "숙소",
            "숙제",
            "순간",
            "순서",
            "순수",
            "순식간",
            "순위",
            "숟가락",
            "술병",
            "술집",
            "숫자",
            "스님",
            "스물",
            "스스로",
            "스승",
            "스웨터",
            "스위치",
            "스케이트",
            "스튜디오",
            "스트레스",
            "스포츠",
            "슬쩍",
            "슬픔",
            "습관",
            "습기",
            "승객",
            "승리",
            "승부",
            "승용차",
            "승진",
            "시각",
            "시간",
            "시골",
            "시금치",
            "시나리오",
            "시댁",
            "시리즈",
            "시멘트",
            "시민",
            "시부모",
            "시선",
            "시설",
            "시스템",
            "시아버지",
            "시어머니",
            "시월",
            "시인",
            "시일",
            "시작",
            "시장",
            "시절",
            "시점",
            "시중",
            "시즌",
            "시집",
            "시청",
            "시합",
            "시험",
            "식구",
            "식기",
            "식당",
            "식량",
            "식료품",
            "식물",
            "식빵",
            "식사",
            "식생활",
            "식초",
            "식탁",
            "식품",
            "신고",
            "신규",
            "신념",
            "신문",
            "신발",
            "신비",
            "신사",
            "신세",
            "신용",
            "신제품",
            "신청",
            "신체",
            "신화",
            "실감",
            "실내",
            "실력",
            "실례",
            "실망",
            "실수",
            "실습",
            "실시",
            "실장",
            "실정",
            "실질적",
            "실천",
            "실체",
            "실컷",
            "실태",
            "실패",
            "실험",
            "실현",
            "심리",
            "심부름",
            "심사",
            "심장",
            "심정",
            "심판",
            "쌍둥이",
            "씨름",
            "씨앗",
            "아가씨",
            "아나운서",
            "아드님",
            "아들",
            "아쉬움",
            "아스팔트",
            "아시아",
            "아울러",
            "아저씨",
            "아줌마",
            "아직",
            "아침",
            "아파트",
            "아프리카",
            "아픔",
            "아홉",
            "아흔",
            "악기",
            "악몽",
            "악수",
            "안개",
            "안경",
            "안과",
            "안내",
            "안녕",
            "안동",
            "안방",
            "안부",
            "안주",
            "알루미늄",
            "알코올",
            "암시",
            "암컷",
            "압력",
            "앞날",
            "앞문",
            "애인",
            "애정",
            "액수",
            "앨범",
            "야간",
            "야단",
            "야옹",
            "약간",
            "약국",
            "약속",
            "약수",
            "약점",
            "약품",
            "약혼녀",
            "양념",
            "양력",
            "양말",
            "양배추",
            "양주",
            "양파",
            "어둠",
            "어려움",
            "어른",
            "어젯밤",
            "어쨌든",
            "어쩌다가",
            "어쩐지",
            "언니",
            "언덕",
            "언론",
            "언어",
            "얼굴",
            "얼른",
            "얼음",
            "얼핏",
            "엄마",
            "업무",
            "업종",
            "업체",
            "엉덩이",
            "엉망",
            "엉터리",
            "엊그제",
            "에너지",
            "에어컨",
            "엔진",
            "여건",
            "여고생",
            "여관",
            "여군",
            "여권",
            "여대생",
            "여덟",
            "여동생",
            "여든",
            "여론",
            "여름",
            "여섯",
            "여성",
            "여왕",
            "여인",
            "여전히",
            "여직원",
            "여학생",
            "여행",
            "역사",
            "역시",
            "역할",
            "연결",
            "연구",
            "연극",
            "연기",
            "연락",
            "연설",
            "연세",
            "연속",
            "연습",
            "연애",
            "연예인",
            "연인",
            "연장",
            "연주",
            "연출",
            "연필",
            "연합",
            "연휴",
            "열기",
            "열매",
            "열쇠",
            "열심히",
            "열정",
            "열차",
            "열흘",
            "염려",
            "엽서",
            "영국",
            "영남",
            "영상",
            "영양",
            "영역",
            "영웅",
            "영원히",
            "영하",
            "영향",
            "영혼",
            "영화",
            "옆구리",
            "옆방",
            "옆집",
            "예감",
            "예금",
            "예방",
            "예산",
            "예상",
            "예선",
            "예술",
            "예습",
            "예식장",
            "예약",
            "예전",
            "예절",
            "예정",
            "예컨대",
            "옛날",
            "오늘",
            "오락",
            "오랫동안",
            "오렌지",
            "오로지",
            "오른발",
            "오븐",
            "오십",
            "오염",
            "오월",
            "오전",
            "오직",
            "오징어",
            "오페라",
            "오피스텔",
            "오히려",
            "옥상",
            "옥수수",
            "온갖",
            "온라인",
            "온몸",
            "온종일",
            "온통",
            "올가을",
            "올림픽",
            "올해",
            "옷차림",
            "와이셔츠",
            "와인",
            "완성",
            "완전",
            "왕비",
            "왕자",
            "왜냐하면",
            "왠지",
            "외갓집",
            "외국",
            "외로움",
            "외삼촌",
            "외출",
            "외침",
            "외할머니",
            "왼발",
            "왼손",
            "왼쪽",
            "요금",
            "요일",
            "요즘",
            "요청",
            "용기",
            "용서",
            "용어",
            "우산",
            "우선",
            "우승",
            "우연히",
            "우정",
            "우체국",
            "우편",
            "운동",
            "운명",
            "운반",
            "운전",
            "운행",
            "울산",
            "울음",
            "움직임",
            "웃어른",
            "웃음",
            "워낙",
            "원고",
            "원래",
            "원서",
            "원숭이",
            "원인",
            "원장",
            "원피스",
            "월급",
            "월드컵",
            "월세",
            "월요일",
            "웨이터",
            "위반",
            "위법",
            "위성",
            "위원",
            "위험",
            "위협",
            "윗사람",
            "유난히",
            "유럽",
            "유명",
            "유물",
            "유산",
            "유적",
            "유치원",
            "유학",
            "유행",
            "유형",
            "육군",
            "육상",
            "육십",
            "육체",
            "은행",
            "음력",
            "음료",
            "음반",
            "음성",
            "음식",
            "음악",
            "음주",
            "의견",
            "의논",
            "의문",
            "의복",
            "의식",
            "의심",
            "의외로",
            "의욕",
            "의원",
            "의학",
            "이것",
            "이곳",
            "이념",
            "이놈",
            "이달",
            "이대로",
            "이동",
            "이렇게",
            "이력서",
            "이론적",
            "이름",
            "이민",
            "이발소",
            "이별",
            "이불",
            "이빨",
            "이상",
            "이성",
            "이슬",
            "이야기",
            "이용",
            "이웃",
            "이월",
            "이윽고",
            "이익",
            "이전",
            "이중",
            "이튿날",
            "이틀",
            "이혼",
            "인간",
            "인격",
            "인공",
            "인구",
            "인근",
            "인기",
            "인도",
            "인류",
            "인물",
            "인생",
            "인쇄",
            "인연",
            "인원",
            "인재",
            "인종",
            "인천",
            "인체",
            "인터넷",
            "인하",
            "인형",
            "일곱",
            "일기",
            "일단",
            "일대",
            "일등",
            "일반",
            "일본",
            "일부",
            "일상",
            "일생",
            "일손",
            "일요일",
            "일월",
            "일정",
            "일종",
            "일주일",
            "일찍",
            "일체",
            "일치",
            "일행",
            "일회용",
            "임금",
            "임무",
            "입대",
            "입력",
            "입맛",
            "입사",
            "입술",
            "입시",
            "입원",
            "입장",
            "입학",
            "자가용",
            "자격",
            "자극",
            "자동",
            "자랑",
            "자부심",
            "자식",
            "자신",
            "자연",
            "자원",
            "자율",
            "자전거",
            "자정",
            "자존심",
            "자판",
            "작가",
            "작년",
            "작성",
            "작업",
            "작용",
            "작은딸",
            "작품",
            "잔디",
            "잔뜩",
            "잔치",
            "잘못",
            "잠깐",
            "잠수함",
            "잠시",
            "잠옷",
            "잠자리",
            "잡지",
            "장관",
            "장군",
            "장기간",
            "장래",
            "장례",
            "장르",
            "장마",
            "장면",
            "장모",
            "장미",
            "장비",
            "장사",
            "장소",
            "장식",
            "장애인",
            "장인",
            "장점",
            "장차",
            "장학금",
            "재능",
            "재빨리",
            "재산",
            "재생",
            "재작년",
            "재정",
            "재채기",
            "재판",
            "재학",
            "재활용",
            "저것",
            "저고리",
            "저곳",
            "저녁",
            "저런",
            "저렇게",
            "저번",
            "저울",
            "저절로",
            "저축",
            "적극",
            "적당히",
            "적성",
            "적용",
            "적응",
            "전개",
            "전공",
            "전기",
            "전달",
            "전라도",
            "전망",
            "전문",
            "전반",
            "전부",
            "전세",
            "전시",
            "전용",
            "전자",
            "전쟁",
            "전주",
            "전철",
            "전체",
            "전통",
            "전혀",
            "전후",
            "절대",
            "절망",
            "절반",
            "절약",
            "절차",
            "점검",
            "점수",
            "점심",
            "점원",
            "점점",
            "점차",
            "접근",
            "접시",
            "접촉",
            "젓가락",
            "정거장",
            "정도",
            "정류장",
            "정리",
            "정말",
            "정면",
            "정문",
            "정반대",
            "정보",
            "정부",
            "정비",
            "정상",
            "정성",
            "정오",
            "정원",
            "정장",
            "정지",
            "정치",
            "정확히",
            "제공",
            "제과점",
            "제대로",
            "제목",
            "제발",
            "제법",
            "제삿날",
            "제안",
            "제일",
            "제작",
            "제주도",
            "제출",
            "제품",
            "제한",
            "조각",
            "조건",
            "조금",
            "조깅",
            "조명",
            "조미료",
            "조상",
            "조선",
            "조용히",
            "조절",
            "조정",
            "조직",
            "존댓말",
            "존재",
            "졸업",
            "졸음",
            "종교",
            "종로",
            "종류",
            "종소리",
            "종업원",
            "종종",
            "종합",
            "좌석",
            "죄인",
            "주관적",
            "주름",
            "주말",
            "주머니",
            "주먹",
            "주문",
            "주민",
            "주방",
            "주변",
            "주식",
            "주인",
            "주일",
            "주장",
            "주전자",
            "주택",
            "준비",
            "줄거리",
            "줄기",
            "줄무늬",
            "중간",
            "중계방송",
            "중국",
            "중년",
            "중단",
            "중독",
            "중반",
            "중부",
            "중세",
            "중소기업",
            "중순",
            "중앙",
            "중요",
            "중학교",
            "즉석",
            "즉시",
            "즐거움",
            "증가",
            "증거",
            "증권",
            "증상",
            "증세",
            "지각",
            "지갑",
            "지경",
            "지극히",
            "지금",
            "지급",
            "지능",
            "지름길",
            "지리산",
            "지방",
            "지붕",
            "지식",
            "지역",
            "지우개",
            "지원",
            "지적",
            "지점",
            "지진",
            "지출",
            "직선",
            "직업",
            "직원",
            "직장",
            "진급",
            "진동",
            "진로",
            "진료",
            "진리",
            "진짜",
            "진찰",
            "진출",
            "진통",
            "진행",
            "질문",
            "질병",
            "질서",
            "짐작",
            "집단",
            "집안",
            "집중",
            "짜증",
            "찌꺼기",
            "차남",
            "차라리",
            "차량",
            "차림",
            "차별",
            "차선",
            "차츰",
            "착각",
            "찬물",
            "찬성",
            "참가",
            "참기름",
            "참새",
            "참석",
            "참여",
            "참외",
            "참조",
            "찻잔",
            "창가",
            "창고",
            "창구",
            "창문",
            "창밖",
            "창작",
            "창조",
            "채널",
            "채점",
            "책가방",
            "책방",
            "책상",
            "책임",
            "챔피언",
            "처벌",
            "처음",
            "천국",
            "천둥",
            "천장",
            "천재",
            "천천히",
            "철도",
            "철저히",
            "철학",
            "첫날",
            "첫째",
            "청년",
            "청바지",
            "청소",
            "청춘",
            "체계",
            "체력",
            "체온",
            "체육",
            "체중",
            "체험",
            "초등학생",
            "초반",
            "초밥",
            "초상화",
            "초순",
            "초여름",
            "초원",
            "초저녁",
            "초점",
            "초청",
            "초콜릿",
            "촛불",
            "총각",
            "총리",
            "총장",
            "촬영",
            "최근",
            "최상",
            "최선",
            "최신",
            "최악",
            "최종",
            "추석",
            "추억",
            "추진",
            "추천",
            "추측",
            "축구",
            "축소",
            "축제",
            "축하",
            "출근",
            "출발",
            "출산",
            "출신",
            "출연",
            "출입",
            "출장",
            "출판",
            "충격",
            "충고",
            "충돌",
            "충분히",
            "충청도",
            "취업",
            "취직",
            "취향",
            "치약",
            "친구",
            "친척",
            "칠십",
            "칠월",
            "칠판",
            "침대",
            "침묵",
            "침실",
            "칫솔",
            "칭찬",
            "카메라",
            "카운터",
            "칼국수",
            "캐릭터",
            "캠퍼스",
            "캠페인",
            "커튼",
            "컨디션",
            "컬러",
            "컴퓨터",
            "코끼리",
            "코미디",
            "콘서트",
            "콜라",
            "콤플렉스",
            "콩나물",
            "쾌감",
            "쿠데타",
            "크림",
            "큰길",
            "큰딸",
            "큰소리",
            "큰아들",
            "큰어머니",
            "큰일",
            "큰절",
            "클래식",
            "클럽",
            "킬로",
            "타입",
            "타자기",
            "탁구",
            "탁자",
            "탄생",
            "태권도",
            "태양",
            "태풍",
            "택시",
            "탤런트",
            "터널",
            "터미널",
            "테니스",
            "테스트",
            "테이블",
            "텔레비전",
            "토론",
            "토마토",
            "토요일",
            "통계",
            "통과",
            "통로",
            "통신",
            "통역",
            "통일",
            "통장",
            "통제",
            "통증",
            "통합",
            "통화",
            "퇴근",
            "퇴원",
            "퇴직금",
            "튀김",
            "트럭",
            "특급",
            "특별",
            "특성",
            "특수",
            "특징",
            "특히",
            "튼튼히",
            "티셔츠",
            "파란색",
            "파일",
            "파출소",
            "판결",
            "판단",
            "판매",
            "판사",
            "팔십",
            "팔월",
            "팝송",
            "패션",
            "팩스",
            "팩시밀리",
            "팬티",
            "퍼센트",
            "페인트",
            "편견",
            "편의",
            "편지",
            "편히",
            "평가",
            "평균",
            "평생",
            "평소",
            "평양",
            "평일",
            "평화",
            "포스터",
            "포인트",
            "포장",
            "포함",
            "표면",
            "표정",
            "표준",
            "표현",
            "품목",
            "품질",
            "풍경",
            "풍속",
            "풍습",
            "프랑스",
            "프린터",
            "플라스틱",
            "피곤",
            "피망",
            "피아노",
            "필름",
            "필수",
            "필요",
            "필자",
            "필통",
            "핑계",
            "하느님",
            "하늘",
            "하드웨어",
            "하룻밤",
            "하반기",
            "하숙집",
            "하순",
            "하여튼",
            "하지만",
            "하천",
            "하품",
            "하필",
            "학과",
            "학교",
            "학급",
            "학기",
            "학년",
            "학력",
            "학번",
            "학부모",
            "학비",
            "학생",
            "학술",
            "학습",
            "학용품",
            "학원",
            "학위",
            "학자",
            "학점",
            "한계",
            "한글",
            "한꺼번에",
            "한낮",
            "한눈",
            "한동안",
            "한때",
            "한라산",
            "한마디",
            "한문",
            "한번",
            "한복",
            "한식",
            "한여름",
            "한쪽",
            "할머니",
            "할아버지",
            "할인",
            "함께",
            "함부로",
            "합격",
            "합리적",
            "항공",
            "항구",
            "항상",
            "항의",
            "해결",
            "해군",
            "해답",
            "해당",
            "해물",
            "해석",
            "해설",
            "해수욕장",
            "해안",
            "핵심",
            "핸드백",
            "햄버거",
            "햇볕",
            "햇살",
            "행동",
            "행복",
            "행사",
            "행운",
            "행위",
            "향기",
            "향상",
            "향수",
            "허락",
            "허용",
            "헬기",
            "현관",
            "현금",
            "현대",
            "현상",
            "현실",
            "현장",
            "현재",
            "현지",
            "혈액",
            "협력",
            "형부",
            "형사",
            "형수",
            "형식",
            "형제",
            "형태",
            "형편",
            "혜택",
            "호기심",
            "호남",
            "호랑이",
            "호박",
            "호텔",
            "호흡",
            "혹시",
            "홀로",
            "홈페이지",
            "홍보",
            "홍수",
            "홍차",
            "화면",
            "화분",
            "화살",
            "화요일",
            "화장",
            "화학",
            "확보",
            "확인",
            "확장",
            "확정",
            "환갑",
            "환경",
            "환영",
            "환율",
            "환자",
            "활기",
            "활동",
            "활발히",
            "활용",
            "활짝",
            "회견",
            "회관",
            "회복",
            "회색",
            "회원",
            "회장",
            "회전",
            "횟수",
            "횡단보도",
            "효율적",
            "후반",
            "후춧가루",
            "훈련",
            "훨씬",
            "휴식",
            "휴일",
            "흉내",
            "흐름",
            "흑백",
            "흑인",
            "흔적",
            "흔히",
            "흥미",
            "흥분",
            "희곡",
            "희망",
            "희생",
            "흰색",
            "힘껏"
        ]

    }, {}],
    70: [function (require, module, exports) {
        module.exports = [
            "ábaco",
            "abdomen",
            "abeja",
            "abierto",
            "abogado",
            "abono",
            "aborto",
            "abrazo",
            "abrir",
            "abuelo",
            "abuso",
            "acabar",
            "academia",
            "acceso",
            "acción",
            "aceite",
            "acelga",
            "acento",
            "aceptar",
            "ácido",
            "aclarar",
            "acné",
            "acoger",
            "acoso",
            "activo",
            "acto",
            "actriz",
            "actuar",
            "acudir",
            "acuerdo",
            "acusar",
            "adicto",
            "admitir",
            "adoptar",
            "adorno",
            "aduana",
            "adulto",
            "aéreo",
            "afectar",
            "afición",
            "afinar",
            "afirmar",
            "ágil",
            "agitar",
            "agonía",
            "agosto",
            "agotar",
            "agregar",
            "agrio",
            "agua",
            "agudo",
            "águila",
            "aguja",
            "ahogo",
            "ahorro",
            "aire",
            "aislar",
            "ajedrez",
            "ajeno",
            "ajuste",
            "alacrán",
            "alambre",
            "alarma",
            "alba",
            "álbum",
            "alcalde",
            "aldea",
            "alegre",
            "alejar",
            "alerta",
            "aleta",
            "alfiler",
            "alga",
            "algodón",
            "aliado",
            "aliento",
            "alivio",
            "alma",
            "almeja",
            "almíbar",
            "altar",
            "alteza",
            "altivo",
            "alto",
            "altura",
            "alumno",
            "alzar",
            "amable",
            "amante",
            "amapola",
            "amargo",
            "amasar",
            "ámbar",
            "ámbito",
            "ameno",
            "amigo",
            "amistad",
            "amor",
            "amparo",
            "amplio",
            "ancho",
            "anciano",
            "ancla",
            "andar",
            "andén",
            "anemia",
            "ángulo",
            "anillo",
            "ánimo",
            "anís",
            "anotar",
            "antena",
            "antiguo",
            "antojo",
            "anual",
            "anular",
            "anuncio",
            "añadir",
            "añejo",
            "año",
            "apagar",
            "aparato",
            "apetito",
            "apio",
            "aplicar",
            "apodo",
            "aporte",
            "apoyo",
            "aprender",
            "aprobar",
            "apuesta",
            "apuro",
            "arado",
            "araña",
            "arar",
            "árbitro",
            "árbol",
            "arbusto",
            "archivo",
            "arco",
            "arder",
            "ardilla",
            "arduo",
            "área",
            "árido",
            "aries",
            "armonía",
            "arnés",
            "aroma",
            "arpa",
            "arpón",
            "arreglo",
            "arroz",
            "arruga",
            "arte",
            "artista",
            "asa",
            "asado",
            "asalto",
            "ascenso",
            "asegurar",
            "aseo",
            "asesor",
            "asiento",
            "asilo",
            "asistir",
            "asno",
            "asombro",
            "áspero",
            "astilla",
            "astro",
            "astuto",
            "asumir",
            "asunto",
            "atajo",
            "ataque",
            "atar",
            "atento",
            "ateo",
            "ático",
            "atleta",
            "átomo",
            "atraer",
            "atroz",
            "atún",
            "audaz",
            "audio",
            "auge",
            "aula",
            "aumento",
            "ausente",
            "autor",
            "aval",
            "avance",
            "avaro",
            "ave",
            "avellana",
            "avena",
            "avestruz",
            "avión",
            "aviso",
            "ayer",
            "ayuda",
            "ayuno",
            "azafrán",
            "azar",
            "azote",
            "azúcar",
            "azufre",
            "azul",
            "baba",
            "babor",
            "bache",
            "bahía",
            "baile",
            "bajar",
            "balanza",
            "balcón",
            "balde",
            "bambú",
            "banco",
            "banda",
            "baño",
            "barba",
            "barco",
            "barniz",
            "barro",
            "báscula",
            "bastón",
            "basura",
            "batalla",
            "batería",
            "batir",
            "batuta",
            "baúl",
            "bazar",
            "bebé",
            "bebida",
            "bello",
            "besar",
            "beso",
            "bestia",
            "bicho",
            "bien",
            "bingo",
            "blanco",
            "bloque",
            "blusa",
            "boa",
            "bobina",
            "bobo",
            "boca",
            "bocina",
            "boda",
            "bodega",
            "boina",
            "bola",
            "bolero",
            "bolsa",
            "bomba",
            "bondad",
            "bonito",
            "bono",
            "bonsái",
            "borde",
            "borrar",
            "bosque",
            "bote",
            "botín",
            "bóveda",
            "bozal",
            "bravo",
            "brazo",
            "brecha",
            "breve",
            "brillo",
            "brinco",
            "brisa",
            "broca",
            "broma",
            "bronce",
            "brote",
            "bruja",
            "brusco",
            "bruto",
            "buceo",
            "bucle",
            "bueno",
            "buey",
            "bufanda",
            "bufón",
            "búho",
            "buitre",
            "bulto",
            "burbuja",
            "burla",
            "burro",
            "buscar",
            "butaca",
            "buzón",
            "caballo",
            "cabeza",
            "cabina",
            "cabra",
            "cacao",
            "cadáver",
            "cadena",
            "caer",
            "café",
            "caída",
            "caimán",
            "caja",
            "cajón",
            "cal",
            "calamar",
            "calcio",
            "caldo",
            "calidad",
            "calle",
            "calma",
            "calor",
            "calvo",
            "cama",
            "cambio",
            "camello",
            "camino",
            "campo",
            "cáncer",
            "candil",
            "canela",
            "canguro",
            "canica",
            "canto",
            "caña",
            "cañón",
            "caoba",
            "caos",
            "capaz",
            "capitán",
            "capote",
            "captar",
            "capucha",
            "cara",
            "carbón",
            "cárcel",
            "careta",
            "carga",
            "cariño",
            "carne",
            "carpeta",
            "carro",
            "carta",
            "casa",
            "casco",
            "casero",
            "caspa",
            "castor",
            "catorce",
            "catre",
            "caudal",
            "causa",
            "cazo",
            "cebolla",
            "ceder",
            "cedro",
            "celda",
            "célebre",
            "celoso",
            "célula",
            "cemento",
            "ceniza",
            "centro",
            "cerca",
            "cerdo",
            "cereza",
            "cero",
            "cerrar",
            "certeza",
            "césped",
            "cetro",
            "chacal",
            "chaleco",
            "champú",
            "chancla",
            "chapa",
            "charla",
            "chico",
            "chiste",
            "chivo",
            "choque",
            "choza",
            "chuleta",
            "chupar",
            "ciclón",
            "ciego",
            "cielo",
            "cien",
            "cierto",
            "cifra",
            "cigarro",
            "cima",
            "cinco",
            "cine",
            "cinta",
            "ciprés",
            "circo",
            "ciruela",
            "cisne",
            "cita",
            "ciudad",
            "clamor",
            "clan",
            "claro",
            "clase",
            "clave",
            "cliente",
            "clima",
            "clínica",
            "cobre",
            "cocción",
            "cochino",
            "cocina",
            "coco",
            "código",
            "codo",
            "cofre",
            "coger",
            "cohete",
            "cojín",
            "cojo",
            "cola",
            "colcha",
            "colegio",
            "colgar",
            "colina",
            "collar",
            "colmo",
            "columna",
            "combate",
            "comer",
            "comida",
            "cómodo",
            "compra",
            "conde",
            "conejo",
            "conga",
            "conocer",
            "consejo",
            "contar",
            "copa",
            "copia",
            "corazón",
            "corbata",
            "corcho",
            "cordón",
            "corona",
            "correr",
            "coser",
            "cosmos",
            "costa",
            "cráneo",
            "cráter",
            "crear",
            "crecer",
            "creído",
            "crema",
            "cría",
            "crimen",
            "cripta",
            "crisis",
            "cromo",
            "crónica",
            "croqueta",
            "crudo",
            "cruz",
            "cuadro",
            "cuarto",
            "cuatro",
            "cubo",
            "cubrir",
            "cuchara",
            "cuello",
            "cuento",
            "cuerda",
            "cuesta",
            "cueva",
            "cuidar",
            "culebra",
            "culpa",
            "culto",
            "cumbre",
            "cumplir",
            "cuna",
            "cuneta",
            "cuota",
            "cupón",
            "cúpula",
            "curar",
            "curioso",
            "curso",
            "curva",
            "cutis",
            "dama",
            "danza",
            "dar",
            "dardo",
            "dátil",
            "deber",
            "débil",
            "década",
            "decir",
            "dedo",
            "defensa",
            "definir",
            "dejar",
            "delfín",
            "delgado",
            "delito",
            "demora",
            "denso",
            "dental",
            "deporte",
            "derecho",
            "derrota",
            "desayuno",
            "deseo",
            "desfile",
            "desnudo",
            "destino",
            "desvío",
            "detalle",
            "detener",
            "deuda",
            "día",
            "diablo",
            "diadema",
            "diamante",
            "diana",
            "diario",
            "dibujo",
            "dictar",
            "diente",
            "dieta",
            "diez",
            "difícil",
            "digno",
            "dilema",
            "diluir",
            "dinero",
            "directo",
            "dirigir",
            "disco",
            "diseño",
            "disfraz",
            "diva",
            "divino",
            "doble",
            "doce",
            "dolor",
            "domingo",
            "don",
            "donar",
            "dorado",
            "dormir",
            "dorso",
            "dos",
            "dosis",
            "dragón",
            "droga",
            "ducha",
            "duda",
            "duelo",
            "dueño",
            "dulce",
            "dúo",
            "duque",
            "durar",
            "dureza",
            "duro",
            "ébano",
            "ebrio",
            "echar",
            "eco",
            "ecuador",
            "edad",
            "edición",
            "edificio",
            "editor",
            "educar",
            "efecto",
            "eficaz",
            "eje",
            "ejemplo",
            "elefante",
            "elegir",
            "elemento",
            "elevar",
            "elipse",
            "élite",
            "elixir",
            "elogio",
            "eludir",
            "embudo",
            "emitir",
            "emoción",
            "empate",
            "empeño",
            "empleo",
            "empresa",
            "enano",
            "encargo",
            "enchufe",
            "encía",
            "enemigo",
            "enero",
            "enfado",
            "enfermo",
            "engaño",
            "enigma",
            "enlace",
            "enorme",
            "enredo",
            "ensayo",
            "enseñar",
            "entero",
            "entrar",
            "envase",
            "envío",
            "época",
            "equipo",
            "erizo",
            "escala",
            "escena",
            "escolar",
            "escribir",
            "escudo",
            "esencia",
            "esfera",
            "esfuerzo",
            "espada",
            "espejo",
            "espía",
            "esposa",
            "espuma",
            "esquí",
            "estar",
            "este",
            "estilo",
            "estufa",
            "etapa",
            "eterno",
            "ética",
            "etnia",
            "evadir",
            "evaluar",
            "evento",
            "evitar",
            "exacto",
            "examen",
            "exceso",
            "excusa",
            "exento",
            "exigir",
            "exilio",
            "existir",
            "éxito",
            "experto",
            "explicar",
            "exponer",
            "extremo",
            "fábrica",
            "fábula",
            "fachada",
            "fácil",
            "factor",
            "faena",
            "faja",
            "falda",
            "fallo",
            "falso",
            "faltar",
            "fama",
            "familia",
            "famoso",
            "faraón",
            "farmacia",
            "farol",
            "farsa",
            "fase",
            "fatiga",
            "fauna",
            "favor",
            "fax",
            "febrero",
            "fecha",
            "feliz",
            "feo",
            "feria",
            "feroz",
            "fértil",
            "fervor",
            "festín",
            "fiable",
            "fianza",
            "fiar",
            "fibra",
            "ficción",
            "ficha",
            "fideo",
            "fiebre",
            "fiel",
            "fiera",
            "fiesta",
            "figura",
            "fijar",
            "fijo",
            "fila",
            "filete",
            "filial",
            "filtro",
            "fin",
            "finca",
            "fingir",
            "finito",
            "firma",
            "flaco",
            "flauta",
            "flecha",
            "flor",
            "flota",
            "fluir",
            "flujo",
            "flúor",
            "fobia",
            "foca",
            "fogata",
            "fogón",
            "folio",
            "folleto",
            "fondo",
            "forma",
            "forro",
            "fortuna",
            "forzar",
            "fosa",
            "foto",
            "fracaso",
            "frágil",
            "franja",
            "frase",
            "fraude",
            "freír",
            "freno",
            "fresa",
            "frío",
            "frito",
            "fruta",
            "fuego",
            "fuente",
            "fuerza",
            "fuga",
            "fumar",
            "función",
            "funda",
            "furgón",
            "furia",
            "fusil",
            "fútbol",
            "futuro",
            "gacela",
            "gafas",
            "gaita",
            "gajo",
            "gala",
            "galería",
            "gallo",
            "gamba",
            "ganar",
            "gancho",
            "ganga",
            "ganso",
            "garaje",
            "garza",
            "gasolina",
            "gastar",
            "gato",
            "gavilán",
            "gemelo",
            "gemir",
            "gen",
            "género",
            "genio",
            "gente",
            "geranio",
            "gerente",
            "germen",
            "gesto",
            "gigante",
            "gimnasio",
            "girar",
            "giro",
            "glaciar",
            "globo",
            "gloria",
            "gol",
            "golfo",
            "goloso",
            "golpe",
            "goma",
            "gordo",
            "gorila",
            "gorra",
            "gota",
            "goteo",
            "gozar",
            "grada",
            "gráfico",
            "grano",
            "grasa",
            "gratis",
            "grave",
            "grieta",
            "grillo",
            "gripe",
            "gris",
            "grito",
            "grosor",
            "grúa",
            "grueso",
            "grumo",
            "grupo",
            "guante",
            "guapo",
            "guardia",
            "guerra",
            "guía",
            "guiño",
            "guion",
            "guiso",
            "guitarra",
            "gusano",
            "gustar",
            "haber",
            "hábil",
            "hablar",
            "hacer",
            "hacha",
            "hada",
            "hallar",
            "hamaca",
            "harina",
            "haz",
            "hazaña",
            "hebilla",
            "hebra",
            "hecho",
            "helado",
            "helio",
            "hembra",
            "herir",
            "hermano",
            "héroe",
            "hervir",
            "hielo",
            "hierro",
            "hígado",
            "higiene",
            "hijo",
            "himno",
            "historia",
            "hocico",
            "hogar",
            "hoguera",
            "hoja",
            "hombre",
            "hongo",
            "honor",
            "honra",
            "hora",
            "hormiga",
            "horno",
            "hostil",
            "hoyo",
            "hueco",
            "huelga",
            "huerta",
            "hueso",
            "huevo",
            "huida",
            "huir",
            "humano",
            "húmedo",
            "humilde",
            "humo",
            "hundir",
            "huracán",
            "hurto",
            "icono",
            "ideal",
            "idioma",
            "ídolo",
            "iglesia",
            "iglú",
            "igual",
            "ilegal",
            "ilusión",
            "imagen",
            "imán",
            "imitar",
            "impar",
            "imperio",
            "imponer",
            "impulso",
            "incapaz",
            "índice",
            "inerte",
            "infiel",
            "informe",
            "ingenio",
            "inicio",
            "inmenso",
            "inmune",
            "innato",
            "insecto",
            "instante",
            "interés",
            "íntimo",
            "intuir",
            "inútil",
            "invierno",
            "ira",
            "iris",
            "ironía",
            "isla",
            "islote",
            "jabalí",
            "jabón",
            "jamón",
            "jarabe",
            "jardín",
            "jarra",
            "jaula",
            "jazmín",
            "jefe",
            "jeringa",
            "jinete",
            "jornada",
            "joroba",
            "joven",
            "joya",
            "juerga",
            "jueves",
            "juez",
            "jugador",
            "jugo",
            "juguete",
            "juicio",
            "junco",
            "jungla",
            "junio",
            "juntar",
            "júpiter",
            "jurar",
            "justo",
            "juvenil",
            "juzgar",
            "kilo",
            "koala",
            "labio",
            "lacio",
            "lacra",
            "lado",
            "ladrón",
            "lagarto",
            "lágrima",
            "laguna",
            "laico",
            "lamer",
            "lámina",
            "lámpara",
            "lana",
            "lancha",
            "langosta",
            "lanza",
            "lápiz",
            "largo",
            "larva",
            "lástima",
            "lata",
            "látex",
            "latir",
            "laurel",
            "lavar",
            "lazo",
            "leal",
            "lección",
            "leche",
            "lector",
            "leer",
            "legión",
            "legumbre",
            "lejano",
            "lengua",
            "lento",
            "leña",
            "león",
            "leopardo",
            "lesión",
            "letal",
            "letra",
            "leve",
            "leyenda",
            "libertad",
            "libro",
            "licor",
            "líder",
            "lidiar",
            "lienzo",
            "liga",
            "ligero",
            "lima",
            "límite",
            "limón",
            "limpio",
            "lince",
            "lindo",
            "línea",
            "lingote",
            "lino",
            "linterna",
            "líquido",
            "liso",
            "lista",
            "litera",
            "litio",
            "litro",
            "llaga",
            "llama",
            "llanto",
            "llave",
            "llegar",
            "llenar",
            "llevar",
            "llorar",
            "llover",
            "lluvia",
            "lobo",
            "loción",
            "loco",
            "locura",
            "lógica",
            "logro",
            "lombriz",
            "lomo",
            "lonja",
            "lote",
            "lucha",
            "lucir",
            "lugar",
            "lujo",
            "luna",
            "lunes",
            "lupa",
            "lustro",
            "luto",
            "luz",
            "maceta",
            "macho",
            "madera",
            "madre",
            "maduro",
            "maestro",
            "mafia",
            "magia",
            "mago",
            "maíz",
            "maldad",
            "maleta",
            "malla",
            "malo",
            "mamá",
            "mambo",
            "mamut",
            "manco",
            "mando",
            "manejar",
            "manga",
            "maniquí",
            "manjar",
            "mano",
            "manso",
            "manta",
            "mañana",
            "mapa",
            "máquina",
            "mar",
            "marco",
            "marea",
            "marfil",
            "margen",
            "marido",
            "mármol",
            "marrón",
            "martes",
            "marzo",
            "masa",
            "máscara",
            "masivo",
            "matar",
            "materia",
            "matiz",
            "matriz",
            "máximo",
            "mayor",
            "mazorca",
            "mecha",
            "medalla",
            "medio",
            "médula",
            "mejilla",
            "mejor",
            "melena",
            "melón",
            "memoria",
            "menor",
            "mensaje",
            "mente",
            "menú",
            "mercado",
            "merengue",
            "mérito",
            "mes",
            "mesón",
            "meta",
            "meter",
            "método",
            "metro",
            "mezcla",
            "miedo",
            "miel",
            "miembro",
            "miga",
            "mil",
            "milagro",
            "militar",
            "millón",
            "mimo",
            "mina",
            "minero",
            "mínimo",
            "minuto",
            "miope",
            "mirar",
            "misa",
            "miseria",
            "misil",
            "mismo",
            "mitad",
            "mito",
            "mochila",
            "moción",
            "moda",
            "modelo",
            "moho",
            "mojar",
            "molde",
            "moler",
            "molino",
            "momento",
            "momia",
            "monarca",
            "moneda",
            "monja",
            "monto",
            "moño",
            "morada",
            "morder",
            "moreno",
            "morir",
            "morro",
            "morsa",
            "mortal",
            "mosca",
            "mostrar",
            "motivo",
            "mover",
            "móvil",
            "mozo",
            "mucho",
            "mudar",
            "mueble",
            "muela",
            "muerte",
            "muestra",
            "mugre",
            "mujer",
            "mula",
            "muleta",
            "multa",
            "mundo",
            "muñeca",
            "mural",
            "muro",
            "músculo",
            "museo",
            "musgo",
            "música",
            "muslo",
            "nácar",
            "nación",
            "nadar",
            "naipe",
            "naranja",
            "nariz",
            "narrar",
            "nasal",
            "natal",
            "nativo",
            "natural",
            "náusea",
            "naval",
            "nave",
            "navidad",
            "necio",
            "néctar",
            "negar",
            "negocio",
            "negro",
            "neón",
            "nervio",
            "neto",
            "neutro",
            "nevar",
            "nevera",
            "nicho",
            "nido",
            "niebla",
            "nieto",
            "niñez",
            "niño",
            "nítido",
            "nivel",
            "nobleza",
            "noche",
            "nómina",
            "noria",
            "norma",
            "norte",
            "nota",
            "noticia",
            "novato",
            "novela",
            "novio",
            "nube",
            "nuca",
            "núcleo",
            "nudillo",
            "nudo",
            "nuera",
            "nueve",
            "nuez",
            "nulo",
            "número",
            "nutria",
            "oasis",
            "obeso",
            "obispo",
            "objeto",
            "obra",
            "obrero",
            "observar",
            "obtener",
            "obvio",
            "oca",
            "ocaso",
            "océano",
            "ochenta",
            "ocho",
            "ocio",
            "ocre",
            "octavo",
            "octubre",
            "oculto",
            "ocupar",
            "ocurrir",
            "odiar",
            "odio",
            "odisea",
            "oeste",
            "ofensa",
            "oferta",
            "oficio",
            "ofrecer",
            "ogro",
            "oído",
            "oír",
            "ojo",
            "ola",
            "oleada",
            "olfato",
            "olivo",
            "olla",
            "olmo",
            "olor",
            "olvido",
            "ombligo",
            "onda",
            "onza",
            "opaco",
            "opción",
            "ópera",
            "opinar",
            "oponer",
            "optar",
            "óptica",
            "opuesto",
            "oración",
            "orador",
            "oral",
            "órbita",
            "orca",
            "orden",
            "oreja",
            "órgano",
            "orgía",
            "orgullo",
            "oriente",
            "origen",
            "orilla",
            "oro",
            "orquesta",
            "oruga",
            "osadía",
            "oscuro",
            "osezno",
            "oso",
            "ostra",
            "otoño",
            "otro",
            "oveja",
            "óvulo",
            "óxido",
            "oxígeno",
            "oyente",
            "ozono",
            "pacto",
            "padre",
            "paella",
            "página",
            "pago",
            "país",
            "pájaro",
            "palabra",
            "palco",
            "paleta",
            "pálido",
            "palma",
            "paloma",
            "palpar",
            "pan",
            "panal",
            "pánico",
            "pantera",
            "pañuelo",
            "papá",
            "papel",
            "papilla",
            "paquete",
            "parar",
            "parcela",
            "pared",
            "parir",
            "paro",
            "párpado",
            "parque",
            "párrafo",
            "parte",
            "pasar",
            "paseo",
            "pasión",
            "paso",
            "pasta",
            "pata",
            "patio",
            "patria",
            "pausa",
            "pauta",
            "pavo",
            "payaso",
            "peatón",
            "pecado",
            "pecera",
            "pecho",
            "pedal",
            "pedir",
            "pegar",
            "peine",
            "pelar",
            "peldaño",
            "pelea",
            "peligro",
            "pellejo",
            "pelo",
            "peluca",
            "pena",
            "pensar",
            "peñón",
            "peón",
            "peor",
            "pepino",
            "pequeño",
            "pera",
            "percha",
            "perder",
            "pereza",
            "perfil",
            "perico",
            "perla",
            "permiso",
            "perro",
            "persona",
            "pesa",
            "pesca",
            "pésimo",
            "pestaña",
            "pétalo",
            "petróleo",
            "pez",
            "pezuña",
            "picar",
            "pichón",
            "pie",
            "piedra",
            "pierna",
            "pieza",
            "pijama",
            "pilar",
            "piloto",
            "pimienta",
            "pino",
            "pintor",
            "pinza",
            "piña",
            "piojo",
            "pipa",
            "pirata",
            "pisar",
            "piscina",
            "piso",
            "pista",
            "pitón",
            "pizca",
            "placa",
            "plan",
            "plata",
            "playa",
            "plaza",
            "pleito",
            "pleno",
            "plomo",
            "pluma",
            "plural",
            "pobre",
            "poco",
            "poder",
            "podio",
            "poema",
            "poesía",
            "poeta",
            "polen",
            "policía",
            "pollo",
            "polvo",
            "pomada",
            "pomelo",
            "pomo",
            "pompa",
            "poner",
            "porción",
            "portal",
            "posada",
            "poseer",
            "posible",
            "poste",
            "potencia",
            "potro",
            "pozo",
            "prado",
            "precoz",
            "pregunta",
            "premio",
            "prensa",
            "preso",
            "previo",
            "primo",
            "príncipe",
            "prisión",
            "privar",
            "proa",
            "probar",
            "proceso",
            "producto",
            "proeza",
            "profesor",
            "programa",
            "prole",
            "promesa",
            "pronto",
            "propio",
            "próximo",
            "prueba",
            "público",
            "puchero",
            "pudor",
            "pueblo",
            "puerta",
            "puesto",
            "pulga",
            "pulir",
            "pulmón",
            "pulpo",
            "pulso",
            "puma",
            "punto",
            "puñal",
            "puño",
            "pupa",
            "pupila",
            "puré",
            "quedar",
            "queja",
            "quemar",
            "querer",
            "queso",
            "quieto",
            "química",
            "quince",
            "quitar",
            "rábano",
            "rabia",
            "rabo",
            "ración",
            "radical",
            "raíz",
            "rama",
            "rampa",
            "rancho",
            "rango",
            "rapaz",
            "rápido",
            "rapto",
            "rasgo",
            "raspa",
            "rato",
            "rayo",
            "raza",
            "razón",
            "reacción",
            "realidad",
            "rebaño",
            "rebote",
            "recaer",
            "receta",
            "rechazo",
            "recoger",
            "recreo",
            "recto",
            "recurso",
            "red",
            "redondo",
            "reducir",
            "reflejo",
            "reforma",
            "refrán",
            "refugio",
            "regalo",
            "regir",
            "regla",
            "regreso",
            "rehén",
            "reino",
            "reír",
            "reja",
            "relato",
            "relevo",
            "relieve",
            "relleno",
            "reloj",
            "remar",
            "remedio",
            "remo",
            "rencor",
            "rendir",
            "renta",
            "reparto",
            "repetir",
            "reposo",
            "reptil",
            "res",
            "rescate",
            "resina",
            "respeto",
            "resto",
            "resumen",
            "retiro",
            "retorno",
            "retrato",
            "reunir",
            "revés",
            "revista",
            "rey",
            "rezar",
            "rico",
            "riego",
            "rienda",
            "riesgo",
            "rifa",
            "rígido",
            "rigor",
            "rincón",
            "riñón",
            "río",
            "riqueza",
            "risa",
            "ritmo",
            "rito",
            "rizo",
            "roble",
            "roce",
            "rociar",
            "rodar",
            "rodeo",
            "rodilla",
            "roer",
            "rojizo",
            "rojo",
            "romero",
            "romper",
            "ron",
            "ronco",
            "ronda",
            "ropa",
            "ropero",
            "rosa",
            "rosca",
            "rostro",
            "rotar",
            "rubí",
            "rubor",
            "rudo",
            "rueda",
            "rugir",
            "ruido",
            "ruina",
            "ruleta",
            "rulo",
            "rumbo",
            "rumor",
            "ruptura",
            "ruta",
            "rutina",
            "sábado",
            "saber",
            "sabio",
            "sable",
            "sacar",
            "sagaz",
            "sagrado",
            "sala",
            "saldo",
            "salero",
            "salir",
            "salmón",
            "salón",
            "salsa",
            "salto",
            "salud",
            "salvar",
            "samba",
            "sanción",
            "sandía",
            "sanear",
            "sangre",
            "sanidad",
            "sano",
            "santo",
            "sapo",
            "saque",
            "sardina",
            "sartén",
            "sastre",
            "satán",
            "sauna",
            "saxofón",
            "sección",
            "seco",
            "secreto",
            "secta",
            "sed",
            "seguir",
            "seis",
            "sello",
            "selva",
            "semana",
            "semilla",
            "senda",
            "sensor",
            "señal",
            "señor",
            "separar",
            "sepia",
            "sequía",
            "ser",
            "serie",
            "sermón",
            "servir",
            "sesenta",
            "sesión",
            "seta",
            "setenta",
            "severo",
            "sexo",
            "sexto",
            "sidra",
            "siesta",
            "siete",
            "siglo",
            "signo",
            "sílaba",
            "silbar",
            "silencio",
            "silla",
            "símbolo",
            "simio",
            "sirena",
            "sistema",
            "sitio",
            "situar",
            "sobre",
            "socio",
            "sodio",
            "sol",
            "solapa",
            "soldado",
            "soledad",
            "sólido",
            "soltar",
            "solución",
            "sombra",
            "sondeo",
            "sonido",
            "sonoro",
            "sonrisa",
            "sopa",
            "soplar",
            "soporte",
            "sordo",
            "sorpresa",
            "sorteo",
            "sostén",
            "sótano",
            "suave",
            "subir",
            "suceso",
            "sudor",
            "suegra",
            "suelo",
            "sueño",
            "suerte",
            "sufrir",
            "sujeto",
            "sultán",
            "sumar",
            "superar",
            "suplir",
            "suponer",
            "supremo",
            "sur",
            "surco",
            "sureño",
            "surgir",
            "susto",
            "sutil",
            "tabaco",
            "tabique",
            "tabla",
            "tabú",
            "taco",
            "tacto",
            "tajo",
            "talar",
            "talco",
            "talento",
            "talla",
            "talón",
            "tamaño",
            "tambor",
            "tango",
            "tanque",
            "tapa",
            "tapete",
            "tapia",
            "tapón",
            "taquilla",
            "tarde",
            "tarea",
            "tarifa",
            "tarjeta",
            "tarot",
            "tarro",
            "tarta",
            "tatuaje",
            "tauro",
            "taza",
            "tazón",
            "teatro",
            "techo",
            "tecla",
            "técnica",
            "tejado",
            "tejer",
            "tejido",
            "tela",
            "teléfono",
            "tema",
            "temor",
            "templo",
            "tenaz",
            "tender",
            "tener",
            "tenis",
            "tenso",
            "teoría",
            "terapia",
            "terco",
            "término",
            "ternura",
            "terror",
            "tesis",
            "tesoro",
            "testigo",
            "tetera",
            "texto",
            "tez",
            "tibio",
            "tiburón",
            "tiempo",
            "tienda",
            "tierra",
            "tieso",
            "tigre",
            "tijera",
            "tilde",
            "timbre",
            "tímido",
            "timo",
            "tinta",
            "tío",
            "típico",
            "tipo",
            "tira",
            "tirón",
            "titán",
            "títere",
            "título",
            "tiza",
            "toalla",
            "tobillo",
            "tocar",
            "tocino",
            "todo",
            "toga",
            "toldo",
            "tomar",
            "tono",
            "tonto",
            "topar",
            "tope",
            "toque",
            "tórax",
            "torero",
            "tormenta",
            "torneo",
            "toro",
            "torpedo",
            "torre",
            "torso",
            "tortuga",
            "tos",
            "tosco",
            "toser",
            "tóxico",
            "trabajo",
            "tractor",
            "traer",
            "tráfico",
            "trago",
            "traje",
            "tramo",
            "trance",
            "trato",
            "trauma",
            "trazar",
            "trébol",
            "tregua",
            "treinta",
            "tren",
            "trepar",
            "tres",
            "tribu",
            "trigo",
            "tripa",
            "triste",
            "triunfo",
            "trofeo",
            "trompa",
            "tronco",
            "tropa",
            "trote",
            "trozo",
            "truco",
            "trueno",
            "trufa",
            "tubería",
            "tubo",
            "tuerto",
            "tumba",
            "tumor",
            "túnel",
            "túnica",
            "turbina",
            "turismo",
            "turno",
            "tutor",
            "ubicar",
            "úlcera",
            "umbral",
            "unidad",
            "unir",
            "universo",
            "uno",
            "untar",
            "uña",
            "urbano",
            "urbe",
            "urgente",
            "urna",
            "usar",
            "usuario",
            "útil",
            "utopía",
            "uva",
            "vaca",
            "vacío",
            "vacuna",
            "vagar",
            "vago",
            "vaina",
            "vajilla",
            "vale",
            "válido",
            "valle",
            "valor",
            "válvula",
            "vampiro",
            "vara",
            "variar",
            "varón",
            "vaso",
            "vecino",
            "vector",
            "vehículo",
            "veinte",
            "vejez",
            "vela",
            "velero",
            "veloz",
            "vena",
            "vencer",
            "venda",
            "veneno",
            "vengar",
            "venir",
            "venta",
            "venus",
            "ver",
            "verano",
            "verbo",
            "verde",
            "vereda",
            "verja",
            "verso",
            "verter",
            "vía",
            "viaje",
            "vibrar",
            "vicio",
            "víctima",
            "vida",
            "vídeo",
            "vidrio",
            "viejo",
            "viernes",
            "vigor",
            "vil",
            "villa",
            "vinagre",
            "vino",
            "viñedo",
            "violín",
            "viral",
            "virgo",
            "virtud",
            "visor",
            "víspera",
            "vista",
            "vitamina",
            "viudo",
            "vivaz",
            "vivero",
            "vivir",
            "vivo",
            "volcán",
            "volumen",
            "volver",
            "voraz",
            "votar",
            "voto",
            "voz",
            "vuelo",
            "vulgar",
            "yacer",
            "yate",
            "yegua",
            "yema",
            "yerno",
            "yeso",
            "yodo",
            "yoga",
            "yogur",
            "zafiro",
            "zanja",
            "zapato",
            "zarza",
            "zona",
            "zorro",
            "zumo",
            "zurdo"
        ]

    }, {}],
    71: [function (require, module, exports) {
// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use

        var Buffer = require('safe-buffer').Buffer

        function check(buffer) {
            if (buffer.length < 8) return false
            if (buffer.length > 72) return false
            if (buffer[0] !== 0x30) return false
            if (buffer[1] !== buffer.length - 2) return false
            if (buffer[2] !== 0x02) return false

            var lenR = buffer[3]
            if (lenR === 0) return false
            if (5 + lenR >= buffer.length) return false
            if (buffer[4 + lenR] !== 0x02) return false

            var lenS = buffer[5 + lenR]
            if (lenS === 0) return false
            if ((6 + lenR + lenS) !== buffer.length) return false

            if (buffer[4] & 0x80) return false
            if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) return false

            if (buffer[lenR + 6] & 0x80) return false
            if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) return false
            return true
        }

        function decode(buffer) {
            if (buffer.length < 8) throw new Error('DER sequence length is too short')
            if (buffer.length > 72) throw new Error('DER sequence length is too long')
            if (buffer[0] !== 0x30) throw new Error('Expected DER sequence')
            if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid')
            if (buffer[2] !== 0x02) throw new Error('Expected DER integer')

            var lenR = buffer[3]
            if (lenR === 0) throw new Error('R length is zero')
            if (5 + lenR >= buffer.length) throw new Error('R length is too long')
            if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)')

            var lenS = buffer[5 + lenR]
            if (lenS === 0) throw new Error('S length is zero')
            if ((6 + lenR + lenS) !== buffer.length) throw new Error('S length is invalid')

            if (buffer[4] & 0x80) throw new Error('R value is negative')
            if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) throw new Error('R value excessively padded')

            if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative')
            if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded')

            // non-BIP66 - extract R, S values
            return {
                r: buffer.slice(4, 4 + lenR),
                s: buffer.slice(6 + lenR)
            }
        }

        /*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
        function encode(r, s) {
            var lenR = r.length
            var lenS = s.length
            if (lenR === 0) throw new Error('R length is zero')
            if (lenS === 0) throw new Error('S length is zero')
            if (lenR > 33) throw new Error('R length is too long')
            if (lenS > 33) throw new Error('S length is too long')
            if (r[0] & 0x80) throw new Error('R value is negative')
            if (s[0] & 0x80) throw new Error('S value is negative')
            if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) throw new Error('R value excessively padded')
            if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) throw new Error('S value excessively padded')

            var signature = Buffer.allocUnsafe(6 + lenR + lenS)

            // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
            signature[0] = 0x30
            signature[1] = signature.length - 2
            signature[2] = 0x02
            signature[3] = r.length
            r.copy(signature, 4)
            signature[4 + lenR] = 0x02
            signature[5 + lenR] = s.length
            s.copy(signature, 6 + lenR)

            return signature
        }

        module.exports = {
            check: check,
            decode: decode,
            encode: encode
        }

    }, {"safe-buffer": 172}],
    72: [function (require, module, exports) {
        module.exports = {
            "OP_FALSE": 0,
            "OP_0": 0,
            "OP_PUSHDATA1": 76,
            "OP_PUSHDATA2": 77,
            "OP_PUSHDATA4": 78,
            "OP_1NEGATE": 79,
            "OP_RESERVED": 80,
            "OP_TRUE": 81,
            "OP_1": 81,
            "OP_2": 82,
            "OP_3": 83,
            "OP_4": 84,
            "OP_5": 85,
            "OP_6": 86,
            "OP_7": 87,
            "OP_8": 88,
            "OP_9": 89,
            "OP_10": 90,
            "OP_11": 91,
            "OP_12": 92,
            "OP_13": 93,
            "OP_14": 94,
            "OP_15": 95,
            "OP_16": 96,

            "OP_NOP": 97,
            "OP_VER": 98,
            "OP_IF": 99,
            "OP_NOTIF": 100,
            "OP_VERIF": 101,
            "OP_VERNOTIF": 102,
            "OP_ELSE": 103,
            "OP_ENDIF": 104,
            "OP_VERIFY": 105,
            "OP_RETURN": 106,

            "OP_TOALTSTACK": 107,
            "OP_FROMALTSTACK": 108,
            "OP_2DROP": 109,
            "OP_2DUP": 110,
            "OP_3DUP": 111,
            "OP_2OVER": 112,
            "OP_2ROT": 113,
            "OP_2SWAP": 114,
            "OP_IFDUP": 115,
            "OP_DEPTH": 116,
            "OP_DROP": 117,
            "OP_DUP": 118,
            "OP_NIP": 119,
            "OP_OVER": 120,
            "OP_PICK": 121,
            "OP_ROLL": 122,
            "OP_ROT": 123,
            "OP_SWAP": 124,
            "OP_TUCK": 125,

            "OP_CAT": 126,
            "OP_SUBSTR": 127,
            "OP_LEFT": 128,
            "OP_RIGHT": 129,
            "OP_SIZE": 130,

            "OP_INVERT": 131,
            "OP_AND": 132,
            "OP_OR": 133,
            "OP_XOR": 134,
            "OP_EQUAL": 135,
            "OP_EQUALVERIFY": 136,
            "OP_RESERVED1": 137,
            "OP_RESERVED2": 138,

            "OP_1ADD": 139,
            "OP_1SUB": 140,
            "OP_2MUL": 141,
            "OP_2DIV": 142,
            "OP_NEGATE": 143,
            "OP_ABS": 144,
            "OP_NOT": 145,
            "OP_0NOTEQUAL": 146,
            "OP_ADD": 147,
            "OP_SUB": 148,
            "OP_MUL": 149,
            "OP_DIV": 150,
            "OP_MOD": 151,
            "OP_LSHIFT": 152,
            "OP_RSHIFT": 153,

            "OP_BOOLAND": 154,
            "OP_BOOLOR": 155,
            "OP_NUMEQUAL": 156,
            "OP_NUMEQUALVERIFY": 157,
            "OP_NUMNOTEQUAL": 158,
            "OP_LESSTHAN": 159,
            "OP_GREATERTHAN": 160,
            "OP_LESSTHANOREQUAL": 161,
            "OP_GREATERTHANOREQUAL": 162,
            "OP_MIN": 163,
            "OP_MAX": 164,

            "OP_WITHIN": 165,

            "OP_RIPEMD160": 166,
            "OP_SHA1": 167,
            "OP_SHA256": 168,
            "OP_HASH160": 169,
            "OP_HASH256": 170,
            "OP_CODESEPARATOR": 171,
            "OP_CHECKSIG": 172,
            "OP_CHECKSIGVERIFY": 173,
            "OP_CHECKMULTISIG": 174,
            "OP_CHECKMULTISIGVERIFY": 175,

            "OP_NOP1": 176,

            "OP_NOP2": 177,
            "OP_CHECKLOCKTIMEVERIFY": 177,

            "OP_NOP3": 178,
            "OP_CHECKSEQUENCEVERIFY": 178,

            "OP_NOP4": 179,
            "OP_NOP5": 180,
            "OP_NOP6": 181,
            "OP_NOP7": 182,
            "OP_NOP8": 183,
            "OP_NOP9": 184,
            "OP_NOP10": 185,

            "OP_PUBKEYHASH": 253,
            "OP_PUBKEY": 254,
            "OP_INVALIDOPCODE": 255
        }

    }, {}],
    73: [function (require, module, exports) {
        var OPS = require('./index.json')

        var map = {}
        for (var op in OPS) {
            var code = OPS[op]
            map[code] = op
        }

        module.exports = map

    }, {"./index.json": 72}],
    74: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const networks = require('./networks');
            const payments = require('./payments');
            const bscript = require('./script');
            const types = require('./types');
            const bech32 = require('bech32');
            const bs58check = require('bs58check');
            const typeforce = require('typeforce');

            function fromBase58Check(address) {
                const payload = bs58check.decode(address);
                // TODO: 4.0.0, move to "toOutputScript"
                if (payload.length < 21) throw new TypeError(address + ' is too short');
                if (payload.length > 21) throw new TypeError(address + ' is too long');
                const version = payload.readUInt8(0);
                const hash = payload.slice(1);
                return {version, hash};
            }

            exports.fromBase58Check = fromBase58Check;

            function fromBech32(address) {
                const result = bech32.decode(address);
                const data = bech32.fromWords(result.words.slice(1));
                return {
                    version: result.words[0],
                    prefix: result.prefix,
                    data: Buffer.from(data),
                };
            }

            exports.fromBech32 = fromBech32;

            function toBase58Check(hash, version) {
                typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
                const payload = Buffer.allocUnsafe(21);
                payload.writeUInt8(version, 0);
                hash.copy(payload, 1);
                return bs58check.encode(payload);
            }

            exports.toBase58Check = toBase58Check;

            function toBech32(data, version, prefix) {
                const words = bech32.toWords(data);
                words.unshift(version);
                return bech32.encode(prefix, words);
            }

            exports.toBech32 = toBech32;

            function fromOutputScript(output, network) {
                // TODO: Network
                network = network || networks.bitcoin;
                try {
                    return payments.p2pkh({output, network}).address;
                } catch (e) {
                }
                try {
                    return payments.p2sh({output, network}).address;
                } catch (e) {
                }
                try {
                    return payments.p2wpkh({output, network}).address;
                } catch (e) {
                }
                try {
                    return payments.p2wsh({output, network}).address;
                } catch (e) {
                }
                throw new Error(bscript.toASM(output) + ' has no matching Address');
            }

            exports.fromOutputScript = fromOutputScript;

            function toOutputScript(address, network) {
                network = network || networks.bitcoin;
                let decodeBase58;
                let decodeBech32;
                try {
                    decodeBase58 = fromBase58Check(address);
                } catch (e) {
                }
                if (decodeBase58) {
                    if (decodeBase58.version === network.pubKeyHash)
                        return payments.p2pkh({hash: decodeBase58.hash}).output;
                    if (decodeBase58.version === network.scriptHash)
                        return payments.p2sh({hash: decodeBase58.hash}).output;
                } else {
                    try {
                        decodeBech32 = fromBech32(address);
                    } catch (e) {
                    }
                    if (decodeBech32) {
                        if (decodeBech32.prefix !== network.bech32)
                            throw new Error(address + ' has an invalid prefix');
                        if (decodeBech32.version === 0) {
                            if (decodeBech32.data.length === 20)
                                return payments.p2wpkh({hash: decodeBech32.data}).output;
                            if (decodeBech32.data.length === 32)
                                return payments.p2wsh({hash: decodeBech32.data}).output;
                        }
                    }
                }
                throw new Error(address + ' has no matching Script');
            }

            exports.toOutputScript = toOutputScript;

        }).call(this, require("buffer").Buffer)

    }, {
        "./networks": 81,
        "./payments": 83,
        "./script": 92,
        "./types": 118,
        "bech32": 34,
        "bs58check": 123,
        "buffer": 3,
        "typeforce": 185
    }],
    75: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bufferutils_1 = require('./bufferutils');
            const bcrypto = require('./crypto');
            const transaction_1 = require('./transaction');
            const types = require('./types');
            const fastMerkleRoot = require('merkle-lib/fastRoot');
            const typeforce = require('typeforce');
            const varuint = require('varuint-bitcoin');
            const errorMerkleNoTxes = new TypeError(
                'Cannot compute merkle root for zero transactions',
            );
            const errorWitnessNotSegwit = new TypeError(
                'Cannot compute witness commit for non-segwit block',
            );

            class Block {
                constructor() {
                    this.version = 1;
                    this.prevHash = undefined;
                    this.merkleRoot = undefined;
                    this.timestamp = 0;
                    this.witnessCommit = undefined;
                    this.bits = 0;
                    this.nonce = 0;
                    this.transactions = undefined;
                }

                static fromBuffer(buffer) {
                    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
                    let offset = 0;
                    const readSlice = n => {
                        offset += n;
                        return buffer.slice(offset - n, offset);
                    };
                    const readUInt32 = () => {
                        const i = buffer.readUInt32LE(offset);
                        offset += 4;
                        return i;
                    };
                    const readInt32 = () => {
                        const i = buffer.readInt32LE(offset);
                        offset += 4;
                        return i;
                    };
                    const block = new Block();
                    block.version = readInt32();
                    block.prevHash = readSlice(32);
                    block.merkleRoot = readSlice(32);
                    block.timestamp = readUInt32();
                    block.bits = readUInt32();
                    block.nonce = readUInt32();
                    if (buffer.length === 80) return block;
                    const readVarInt = () => {
                        const vi = varuint.decode(buffer, offset);
                        offset += varuint.decode.bytes;
                        return vi;
                    };
                    const readTransaction = () => {
                        const tx = transaction_1.Transaction.fromBuffer(
                            buffer.slice(offset),
                            true,
                        );
                        offset += tx.byteLength();
                        return tx;
                    };
                    const nTransactions = readVarInt();
                    block.transactions = [];
                    for (let i = 0; i < nTransactions; ++i) {
                        const tx = readTransaction();
                        block.transactions.push(tx);
                    }
                    const witnessCommit = block.getWitnessCommit();
                    // This Block contains a witness commit
                    if (witnessCommit) block.witnessCommit = witnessCommit;
                    return block;
                }

                static fromHex(hex) {
                    return Block.fromBuffer(Buffer.from(hex, 'hex'));
                }

                static calculateTarget(bits) {
                    const exponent = ((bits & 0xff000000) >> 24) - 3;
                    const mantissa = bits & 0x007fffff;
                    const target = Buffer.alloc(32, 0);
                    target.writeUIntBE(mantissa, 29 - exponent, 3);
                    return target;
                }

                static calculateMerkleRoot(transactions, forWitness) {
                    typeforce([{getHash: types.Function}], transactions);
                    if (transactions.length === 0) throw errorMerkleNoTxes;
                    if (forWitness && !txesHaveWitnessCommit(transactions))
                        throw errorWitnessNotSegwit;
                    const hashes = transactions.map(transaction =>
                        transaction.getHash(forWitness),
                    );
                    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);
                    return forWitness
                        ? bcrypto.hash256(
                            Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),
                        )
                        : rootHash;
                }

                getWitnessCommit() {
                    if (!txesHaveWitnessCommit(this.transactions)) return null;
                    // The merkle root for the witness data is in an OP_RETURN output.
                    // There is no rule for the index of the output, so use filter to find it.
                    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
                    // If multiple commits are found, the output with highest index is assumed.
                    const witnessCommits = this.transactions[0].outs
                        .filter(out =>
                            out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),
                        )
                        .map(out => out.script.slice(6, 38));
                    if (witnessCommits.length === 0) return null;
                    // Use the commit with the highest output (should only be one though)
                    const result = witnessCommits[witnessCommits.length - 1];
                    if (!(result instanceof Buffer && result.length === 32)) return null;
                    return result;
                }

                hasWitnessCommit() {
                    if (
                        this.witnessCommit instanceof Buffer &&
                        this.witnessCommit.length === 32
                    )
                        return true;
                    if (this.getWitnessCommit() !== null) return true;
                    return false;
                }

                hasWitness() {
                    return anyTxHasWitness(this.transactions);
                }

                weight() {
                    const base = this.byteLength(false, false);
                    const total = this.byteLength(false, true);
                    return base * 3 + total;
                }

                byteLength(headersOnly, allowWitness = true) {
                    if (headersOnly || !this.transactions) return 80;
                    return (
                        80 +
                        varuint.encodingLength(this.transactions.length) +
                        this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)
                    );
                }

                getHash() {
                    return bcrypto.hash256(this.toBuffer(true));
                }

                getId() {
                    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');
                }

                getUTCDate() {
                    const date = new Date(0); // epoch
                    date.setUTCSeconds(this.timestamp);
                    return date;
                }

                // TODO: buffer, offset compatibility
                toBuffer(headersOnly) {
                    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
                    let offset = 0;
                    const writeSlice = slice => {
                        slice.copy(buffer, offset);
                        offset += slice.length;
                    };
                    const writeInt32 = i => {
                        buffer.writeInt32LE(i, offset);
                        offset += 4;
                    };
                    const writeUInt32 = i => {
                        buffer.writeUInt32LE(i, offset);
                        offset += 4;
                    };
                    writeInt32(this.version);
                    writeSlice(this.prevHash);
                    writeSlice(this.merkleRoot);
                    writeUInt32(this.timestamp);
                    writeUInt32(this.bits);
                    writeUInt32(this.nonce);
                    if (headersOnly || !this.transactions) return buffer;
                    varuint.encode(this.transactions.length, buffer, offset);
                    offset += varuint.encode.bytes;
                    this.transactions.forEach(tx => {
                        const txSize = tx.byteLength(); // TODO: extract from toBuffer?
                        tx.toBuffer(buffer, offset);
                        offset += txSize;
                    });
                    return buffer;
                }

                toHex(headersOnly) {
                    return this.toBuffer(headersOnly).toString('hex');
                }

                checkTxRoots() {
                    // If the Block has segwit transactions but no witness commit,
                    // there's no way it can be valid, so fail the check.
                    const hasWitnessCommit = this.hasWitnessCommit();
                    if (!hasWitnessCommit && this.hasWitness()) return false;
                    return (
                        this.__checkMerkleRoot() &&
                        (hasWitnessCommit ? this.__checkWitnessCommit() : true)
                    );
                }

                checkProofOfWork() {
                    const hash = bufferutils_1.reverseBuffer(this.getHash());
                    const target = Block.calculateTarget(this.bits);
                    return hash.compare(target) <= 0;
                }

                __checkMerkleRoot() {
                    if (!this.transactions) throw errorMerkleNoTxes;
                    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
                    return this.merkleRoot.compare(actualMerkleRoot) === 0;
                }

                __checkWitnessCommit() {
                    if (!this.transactions) throw errorMerkleNoTxes;
                    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
                    const actualWitnessCommit = Block.calculateMerkleRoot(
                        this.transactions,
                        true,
                    );
                    return this.witnessCommit.compare(actualWitnessCommit) === 0;
                }
            }

            exports.Block = Block;

            function txesHaveWitnessCommit(transactions) {
                return (
                    transactions instanceof Array &&
                    transactions[0] &&
                    transactions[0].ins &&
                    transactions[0].ins instanceof Array &&
                    transactions[0].ins[0] &&
                    transactions[0].ins[0].witness &&
                    transactions[0].ins[0].witness instanceof Array &&
                    transactions[0].ins[0].witness.length > 0
                );
            }

            function anyTxHasWitness(transactions) {
                return (
                    transactions instanceof Array &&
                    transactions.some(
                        tx =>
                            typeof tx === 'object' &&
                            tx.ins instanceof Array &&
                            tx.ins.some(
                                input =>
                                    typeof input === 'object' &&
                                    input.witness instanceof Array &&
                                    input.witness.length > 0,
                            ),
                    )
                );
            }

        }).call(this, require("buffer").Buffer)

    }, {
        "./bufferutils": 76,
        "./crypto": 78,
        "./transaction": 116,
        "./types": 118,
        "buffer": 3,
        "merkle-lib/fastRoot": 161,
        "typeforce": 185,
        "varuint-bitcoin": 187
    }],
    76: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});

// https://github.com/feross/buffer/blob/master/index.js#L1127
        function verifuint(value, max) {
            if (typeof value !== 'number')
                throw new Error('cannot write a non-number as a number');
            if (value < 0)
                throw new Error('specified a negative value for writing an unsigned value');
            if (value > max) throw new Error('RangeError: value out of range');
            if (Math.floor(value) !== value)
                throw new Error('value has a fractional component');
        }

        function readUInt64LE(buffer, offset) {
            const a = buffer.readUInt32LE(offset);
            let b = buffer.readUInt32LE(offset + 4);
            b *= 0x100000000;
            verifuint(b + a, 0x001fffffffffffff);
            return b + a;
        }

        exports.readUInt64LE = readUInt64LE;

        function writeUInt64LE(buffer, value, offset) {
            verifuint(value, 0x001fffffffffffff);
            buffer.writeInt32LE(value & -1, offset);
            buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
            return offset + 8;
        }

        exports.writeUInt64LE = writeUInt64LE;

        function reverseBuffer(buffer) {
            if (buffer.length < 1) return buffer;
            let j = buffer.length - 1;
            let tmp = 0;
            for (let i = 0; i < buffer.length / 2; i++) {
                tmp = buffer[i];
                buffer[i] = buffer[j];
                buffer[j] = tmp;
                j--;
            }
            return buffer;
        }

        exports.reverseBuffer = reverseBuffer;

    }, {}],
    77: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const script_1 = require('./script');
        const multisig = require('./templates/multisig');
        const nullData = require('./templates/nulldata');
        const pubKey = require('./templates/pubkey');
        const pubKeyHash = require('./templates/pubkeyhash');
        const scriptHash = require('./templates/scripthash');
        const witnessCommitment = require('./templates/witnesscommitment');
        const witnessPubKeyHash = require('./templates/witnesspubkeyhash');
        const witnessScriptHash = require('./templates/witnessscripthash');
        const types = {
            P2MS: 'multisig',
            NONSTANDARD: 'nonstandard',
            NULLDATA: 'nulldata',
            P2PK: 'pubkey',
            P2PKH: 'pubkeyhash',
            P2SH: 'scripthash',
            P2WPKH: 'witnesspubkeyhash',
            P2WSH: 'witnessscripthash',
            WITNESS_COMMITMENT: 'witnesscommitment',
        };
        exports.types = types;

        function classifyOutput(script) {
            if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;
            if (witnessScriptHash.output.check(script)) return types.P2WSH;
            if (pubKeyHash.output.check(script)) return types.P2PKH;
            if (scriptHash.output.check(script)) return types.P2SH;
            // XXX: optimization, below functions .decompile before use
            const chunks = script_1.decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (multisig.output.check(chunks)) return types.P2MS;
            if (pubKey.output.check(chunks)) return types.P2PK;
            if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;
            if (nullData.output.check(chunks)) return types.NULLDATA;
            return types.NONSTANDARD;
        }

        exports.output = classifyOutput;

        function classifyInput(script, allowIncomplete) {
            // XXX: optimization, below functions .decompile before use
            const chunks = script_1.decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (pubKeyHash.input.check(chunks)) return types.P2PKH;
            if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;
            if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;
            if (pubKey.input.check(chunks)) return types.P2PK;
            return types.NONSTANDARD;
        }

        exports.input = classifyInput;

        function classifyWitness(script, allowIncomplete) {
            // XXX: optimization, below functions .decompile before use
            const chunks = script_1.decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;
            if (witnessScriptHash.input.check(chunks, allowIncomplete))
                return types.P2WSH;
            return types.NONSTANDARD;
        }

        exports.witness = classifyWitness;

    }, {
        "./script": 92,
        "./templates/multisig": 95,
        "./templates/nulldata": 98,
        "./templates/pubkey": 99,
        "./templates/pubkeyhash": 102,
        "./templates/scripthash": 105,
        "./templates/witnesscommitment": 108,
        "./templates/witnesspubkeyhash": 110,
        "./templates/witnessscripthash": 113
    }],
    78: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const createHash = require('create-hash');

        function ripemd160(buffer) {
            try {
                return createHash('rmd160')
                    .update(buffer)
                    .digest();
            } catch (err) {
                return createHash('ripemd160')
                    .update(buffer)
                    .digest();
            }
        }

        exports.ripemd160 = ripemd160;

        function sha1(buffer) {
            return createHash('sha1')
                .update(buffer)
                .digest();
        }

        exports.sha1 = sha1;

        function sha256(buffer) {
            return createHash('sha256')
                .update(buffer)
                .digest();
        }

        exports.sha256 = sha256;

        function hash160(buffer) {
            return ripemd160(sha256(buffer));
        }

        exports.hash160 = hash160;

        function hash256(buffer) {
            return sha256(sha256(buffer));
        }

        exports.hash256 = hash256;

    }, {"create-hash": 125}],
    79: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const NETWORKS = require('./networks');
            const types = require('./types');
            const ecc = require('tiny-secp256k1');
            const randomBytes = require('randombytes');
            const typeforce = require('typeforce');
            const wif = require('wif');
            const isOptions = typeforce.maybe(
                typeforce.compile({
                    compressed: types.maybe(types.Boolean),
                    network: types.maybe(types.Network),
                }),
            );

            class ECPair {
                constructor(__D, __Q, options) {
                    this.__D = __D;
                    this.__Q = __Q;
                    this.lowR = false;
                    if (options === undefined) options = {};
                    this.compressed =
                        options.compressed === undefined ? true : options.compressed;
                    this.network = options.network || NETWORKS.bitcoin;
                    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);
                }

                get privateKey() {
                    return this.__D;
                }

                get publicKey() {
                    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);
                    return this.__Q;
                }

                toWIF() {
                    if (!this.__D) throw new Error('Missing private key');
                    return wif.encode(this.network.wif, this.__D, this.compressed);
                }

                sign(hash, lowR) {
                    if (!this.__D) throw new Error('Missing private key');
                    if (lowR === undefined) lowR = this.lowR;
                    if (lowR === false) {
                        return ecc.sign(hash, this.__D);
                    } else {
                        let sig = ecc.sign(hash, this.__D);
                        const extraData = Buffer.alloc(32, 0);
                        let counter = 0;
                        // if first try is lowR, skip the loop
                        // for second try and on, add extra entropy counting up
                        while (sig[0] > 0x7f) {
                            counter++;
                            extraData.writeUIntLE(counter, 0, 6);
                            sig = ecc.signWithEntropy(hash, this.__D, extraData);
                        }
                        return sig;
                    }
                }

                verify(hash, signature) {
                    return ecc.verify(hash, this.publicKey, signature);
                }
            }

            function fromPrivateKey(buffer, options) {
                typeforce(types.Buffer256bit, buffer);
                if (!ecc.isPrivate(buffer))
                    throw new TypeError('Private key not in range [1, n)');
                typeforce(isOptions, options);
                return new ECPair(buffer, undefined, options);
            }

            exports.fromPrivateKey = fromPrivateKey;

            function fromPublicKey(buffer, options) {
                typeforce(ecc.isPoint, buffer);
                typeforce(isOptions, options);
                return new ECPair(undefined, buffer, options);
            }

            exports.fromPublicKey = fromPublicKey;

            function fromWIF(wifString, network) {
                const decoded = wif.decode(wifString);
                const version = decoded.version;
                // list of networks?
                if (types.Array(network)) {
                    network = network
                        .filter(x => {
                            return version === x.wif;
                        })
                        .pop();
                    if (!network) throw new Error('Unknown network version');
                    // otherwise, assume a network object (or default to bitcoin)
                } else {
                    network = network || NETWORKS.bitcoin;
                    if (version !== network.wif) throw new Error('Invalid network version');
                }
                return fromPrivateKey(decoded.privateKey, {
                    compressed: decoded.compressed,
                    network: network,
                });
            }

            exports.fromWIF = fromWIF;

            function makeRandom(options) {
                typeforce(isOptions, options);
                if (options === undefined) options = {};
                const rng = options.rng || randomBytes;
                let d;
                do {
                    d = rng(32);
                    typeforce(types.Buffer256bit, d);
                } while (!ecc.isPrivate(d));
                return fromPrivateKey(d, options);
            }

            exports.makeRandom = makeRandom;

        }).call(this, require("buffer").Buffer)

    }, {
        "./networks": 81,
        "./types": 118,
        "buffer": 3,
        "randombytes": 170,
        "tiny-secp256k1": 181,
        "typeforce": 185,
        "wif": 188
    }],
    80: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const bip32 = require('bip32');
        exports.bip32 = bip32;
        const address = require('./address');
        exports.address = address;
        const crypto = require('./crypto');
        exports.crypto = crypto;
        const ECPair = require('./ecpair');
        exports.ECPair = ECPair;
        const networks = require('./networks');
        exports.networks = networks;
        const payments = require('./payments');
        exports.payments = payments;
        const script = require('./script');
        exports.script = script;
        var block_1 = require('./block');
        exports.Block = block_1.Block;
        var psbt_1 = require('./psbt');
        exports.Psbt = psbt_1.Psbt;
        var script_1 = require('./script');
        exports.opcodes = script_1.OPS;
        var transaction_1 = require('./transaction');
        exports.Transaction = transaction_1.Transaction;
        var transaction_builder_1 = require('./transaction_builder');
        exports.TransactionBuilder = transaction_builder_1.TransactionBuilder;

    }, {
        "./address": 74,
        "./block": 75,
        "./crypto": 78,
        "./ecpair": 79,
        "./networks": 81,
        "./payments": 83,
        "./psbt": 91,
        "./script": 92,
        "./transaction": 116,
        "./transaction_builder": 117,
        "bip32": 60
    }],
    81: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        exports.bitcoin = {
            messagePrefix: '\x18Bitcoin Signed Message:\n',
            bech32: 'bc',
            bip32: {
                public: 0x0488b21e,
                private: 0x0488ade4,
            },
            pubKeyHash: 0x00,
            scriptHash: 0x05,
            wif: 0x80,
        };
        exports.regtest = {
            messagePrefix: '\x18Bitcoin Signed Message:\n',
            bech32: 'bcrt',
            bip32: {
                public: 0x043587cf,
                private: 0x04358394,
            },
            pubKeyHash: 0x6f,
            scriptHash: 0xc4,
            wif: 0xef,
        };
        exports.testnet = {
            messagePrefix: '\x18Bitcoin Signed Message:\n',
            bech32: 'tb',
            bip32: {
                public: 0x043587cf,
                private: 0x04358394,
            },
            pubKeyHash: 0x6f,
            scriptHash: 0xc4,
            wif: 0xef,
        };

    }, {}],
    82: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const networks_1 = require('../networks');
        const bscript = require('../script');
        const lazy = require('./lazy');
        const typef = require('typeforce');
        const OPS = bscript.OPS;

        function stacksEqual(a, b) {
            if (a.length !== b.length) return false;
            return a.every((x, i) => {
                return x.equals(b[i]);
            });
        }

// output: OP_RETURN ...
        function p2data(a, opts) {
            if (!a.data && !a.output) throw new TypeError('Not enough data');
            opts = Object.assign({validate: true}, opts || {});
            typef(
                {
                    network: typef.maybe(typef.Object),
                    output: typef.maybe(typef.Buffer),
                    data: typef.maybe(typef.arrayOf(typef.Buffer)),
                },
                a,
            );
            const network = a.network || networks_1.bitcoin;
            const o = {name: 'embed', network};
            lazy.prop(o, 'output', () => {
                if (!a.data) return;
                return bscript.compile([OPS.OP_RETURN].concat(a.data));
            });
            lazy.prop(o, 'data', () => {
                if (!a.output) return;
                return bscript.decompile(a.output).slice(1);
            });
            // extended validation
            if (opts.validate) {
                if (a.output) {
                    const chunks = bscript.decompile(a.output);
                    if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
                    if (!chunks.slice(1).every(typef.Buffer))
                        throw new TypeError('Output is invalid');
                    if (a.data && !stacksEqual(a.data, o.data))
                        throw new TypeError('Data mismatch');
                }
            }
            return Object.assign(o, a);
        }

        exports.p2data = p2data;

    }, {"../networks": 81, "../script": 92, "./lazy": 84, "typeforce": 185}],
    83: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const embed_1 = require('./embed');
        exports.embed = embed_1.p2data;
        const p2ms_1 = require('./p2ms');
        exports.p2ms = p2ms_1.p2ms;
        const p2pk_1 = require('./p2pk');
        exports.p2pk = p2pk_1.p2pk;
        const p2pkh_1 = require('./p2pkh');
        exports.p2pkh = p2pkh_1.p2pkh;
        const p2sh_1 = require('./p2sh');
        exports.p2sh = p2sh_1.p2sh;
        const p2wpkh_1 = require('./p2wpkh');
        exports.p2wpkh = p2wpkh_1.p2wpkh;
        const p2wsh_1 = require('./p2wsh');
        exports.p2wsh = p2wsh_1.p2wsh;
// TODO
// witness commitment

    }, {"./embed": 82, "./p2ms": 85, "./p2pk": 86, "./p2pkh": 87, "./p2sh": 88, "./p2wpkh": 89, "./p2wsh": 90}],
    84: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});

        function prop(object, name, f) {
            Object.defineProperty(object, name, {
                configurable: true,
                enumerable: true,
                get() {
                    const _value = f.call(this);
                    this[name] = _value;
                    return _value;
                },
                set(_value) {
                    Object.defineProperty(this, name, {
                        configurable: true,
                        enumerable: true,
                        value: _value,
                        writable: true,
                    });
                },
            });
        }

        exports.prop = prop;

        function value(f) {
            let _value;
            return () => {
                if (_value !== undefined) return _value;
                _value = f();
                return _value;
            };
        }

        exports.value = value;

    }, {}],
    85: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const networks_1 = require('../networks');
        const bscript = require('../script');
        const lazy = require('./lazy');
        const OPS = bscript.OPS;
        const typef = require('typeforce');
        const ecc = require('tiny-secp256k1');
        const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
        function stacksEqual(a, b) {
            if (a.length !== b.length) return false;
            return a.every((x, i) => {
                return x.equals(b[i]);
            });
        }

// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
        function p2ms(a, opts) {
            if (
                !a.input &&
                !a.output &&
                !(a.pubkeys && a.m !== undefined) &&
                !a.signatures
            )
                throw new TypeError('Not enough data');
            opts = Object.assign({validate: true}, opts || {});

            function isAcceptableSignature(x) {
                return (
                    bscript.isCanonicalScriptSignature(x) ||
                    (opts.allowIncomplete && x === OPS.OP_0) !== undefined
                );
            }

            typef(
                {
                    network: typef.maybe(typef.Object),
                    m: typef.maybe(typef.Number),
                    n: typef.maybe(typef.Number),
                    output: typef.maybe(typef.Buffer),
                    pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),
                    signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
                    input: typef.maybe(typef.Buffer),
                },
                a,
            );
            const network = a.network || networks_1.bitcoin;
            const o = {network};
            let chunks = [];
            let decoded = false;

            function decode(output) {
                if (decoded) return;
                decoded = true;
                chunks = bscript.decompile(output);
                o.m = chunks[0] - OP_INT_BASE;
                o.n = chunks[chunks.length - 2] - OP_INT_BASE;
                o.pubkeys = chunks.slice(1, -2);
            }

            lazy.prop(o, 'output', () => {
                if (!a.m) return;
                if (!o.n) return;
                if (!a.pubkeys) return;
                return bscript.compile(
                    [].concat(
                        OP_INT_BASE + a.m,
                        a.pubkeys,
                        OP_INT_BASE + o.n,
                        OPS.OP_CHECKMULTISIG,
                    ),
                );
            });
            lazy.prop(o, 'm', () => {
                if (!o.output) return;
                decode(o.output);
                return o.m;
            });
            lazy.prop(o, 'n', () => {
                if (!o.pubkeys) return;
                return o.pubkeys.length;
            });
            lazy.prop(o, 'pubkeys', () => {
                if (!a.output) return;
                decode(a.output);
                return o.pubkeys;
            });
            lazy.prop(o, 'signatures', () => {
                if (!a.input) return;
                return bscript.decompile(a.input).slice(1);
            });
            lazy.prop(o, 'input', () => {
                if (!a.signatures) return;
                return bscript.compile([OPS.OP_0].concat(a.signatures));
            });
            lazy.prop(o, 'witness', () => {
                if (!o.input) return;
                return [];
            });
            lazy.prop(o, 'name', () => {
                if (!o.m || !o.n) return;
                return `p2ms(${o.m} of ${o.n})`;
            });
            // extended validation
            if (opts.validate) {
                if (a.output) {
                    decode(a.output);
                    if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');
                    if (!typef.Number(chunks[chunks.length - 2]))
                        throw new TypeError('Output is invalid');
                    if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
                        throw new TypeError('Output is invalid');
                    if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
                        throw new TypeError('Output is invalid');
                    if (!o.pubkeys.every(x => ecc.isPoint(x)))
                        throw new TypeError('Output is invalid');
                    if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
                    if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
                    if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
                        throw new TypeError('Pubkeys mismatch');
                }
                if (a.pubkeys) {
                    if (a.n !== undefined && a.n !== a.pubkeys.length)
                        throw new TypeError('Pubkey count mismatch');
                    o.n = a.pubkeys.length;
                    if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
                }
                if (a.signatures) {
                    if (a.signatures.length < o.m)
                        throw new TypeError('Not enough signatures provided');
                    if (a.signatures.length > o.m)
                        throw new TypeError('Too many signatures provided');
                }
                if (a.input) {
                    if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
                    if (
                        o.signatures.length === 0 ||
                        !o.signatures.every(isAcceptableSignature)
                    )
                        throw new TypeError('Input has invalid signature(s)');
                    if (a.signatures && !stacksEqual(a.signatures, o.signatures))
                        throw new TypeError('Signature mismatch');
                    if (a.m !== undefined && a.m !== a.signatures.length)
                        throw new TypeError('Signature count mismatch');
                }
            }
            return Object.assign(o, a);
        }

        exports.p2ms = p2ms;

    }, {"../networks": 81, "../script": 92, "./lazy": 84, "tiny-secp256k1": 181, "typeforce": 185}],
    86: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const networks_1 = require('../networks');
        const bscript = require('../script');
        const lazy = require('./lazy');
        const typef = require('typeforce');
        const OPS = bscript.OPS;
        const ecc = require('tiny-secp256k1');
// input: {signature}
// output: {pubKey} OP_CHECKSIG
        function p2pk(a, opts) {
            if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
                throw new TypeError('Not enough data');
            opts = Object.assign({validate: true}, opts || {});
            typef(
                {
                    network: typef.maybe(typef.Object),
                    output: typef.maybe(typef.Buffer),
                    pubkey: typef.maybe(ecc.isPoint),
                    signature: typef.maybe(bscript.isCanonicalScriptSignature),
                    input: typef.maybe(typef.Buffer),
                },
                a,
            );
            const _chunks = lazy.value(() => {
                return bscript.decompile(a.input);
            });
            const network = a.network || networks_1.bitcoin;
            const o = {name: 'p2pk', network};
            lazy.prop(o, 'output', () => {
                if (!a.pubkey) return;
                return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
            });
            lazy.prop(o, 'pubkey', () => {
                if (!a.output) return;
                return a.output.slice(1, -1);
            });
            lazy.prop(o, 'signature', () => {
                if (!a.input) return;
                return _chunks()[0];
            });
            lazy.prop(o, 'input', () => {
                if (!a.signature) return;
                return bscript.compile([a.signature]);
            });
            lazy.prop(o, 'witness', () => {
                if (!o.input) return;
                return [];
            });
            // extended validation
            if (opts.validate) {
                if (a.output) {
                    if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
                        throw new TypeError('Output is invalid');
                    if (!ecc.isPoint(o.pubkey))
                        throw new TypeError('Output pubkey is invalid');
                    if (a.pubkey && !a.pubkey.equals(o.pubkey))
                        throw new TypeError('Pubkey mismatch');
                }
                if (a.signature) {
                    if (a.input && !a.input.equals(o.input))
                        throw new TypeError('Signature mismatch');
                }
                if (a.input) {
                    if (_chunks().length !== 1) throw new TypeError('Input is invalid');
                    if (!bscript.isCanonicalScriptSignature(o.signature))
                        throw new TypeError('Input has invalid signature');
                }
            }
            return Object.assign(o, a);
        }

        exports.p2pk = p2pk;

    }, {"../networks": 81, "../script": 92, "./lazy": 84, "tiny-secp256k1": 181, "typeforce": 185}],
    87: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bcrypto = require('../crypto');
            const networks_1 = require('../networks');
            const bscript = require('../script');
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = bscript.OPS;
            const ecc = require('tiny-secp256k1');
            const bs58check = require('bs58check');
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
            function p2pkh(a, opts) {
                if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
                    throw new TypeError('Not enough data');
                opts = Object.assign({validate: true}, opts || {});
                typef(
                    {
                        network: typef.maybe(typef.Object),
                        address: typef.maybe(typef.String),
                        hash: typef.maybe(typef.BufferN(20)),
                        output: typef.maybe(typef.BufferN(25)),
                        pubkey: typef.maybe(ecc.isPoint),
                        signature: typef.maybe(bscript.isCanonicalScriptSignature),
                        input: typef.maybe(typef.Buffer),
                    },
                    a,
                );
                const _address = lazy.value(() => {
                    const payload = bs58check.decode(a.address);
                    const version = payload.readUInt8(0);
                    const hash = payload.slice(1);
                    return {version, hash};
                });
                const _chunks = lazy.value(() => {
                    return bscript.decompile(a.input);
                });
                const network = a.network || networks_1.bitcoin;
                const o = {name: 'p2pkh', network};
                lazy.prop(o, 'address', () => {
                    if (!o.hash) return;
                    const payload = Buffer.allocUnsafe(21);
                    payload.writeUInt8(network.pubKeyHash, 0);
                    o.hash.copy(payload, 1);
                    return bs58check.encode(payload);
                });
                lazy.prop(o, 'hash', () => {
                    if (a.output) return a.output.slice(3, 23);
                    if (a.address) return _address().hash;
                    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
                });
                lazy.prop(o, 'output', () => {
                    if (!o.hash) return;
                    return bscript.compile([
                        OPS.OP_DUP,
                        OPS.OP_HASH160,
                        o.hash,
                        OPS.OP_EQUALVERIFY,
                        OPS.OP_CHECKSIG,
                    ]);
                });
                lazy.prop(o, 'pubkey', () => {
                    if (!a.input) return;
                    return _chunks()[1];
                });
                lazy.prop(o, 'signature', () => {
                    if (!a.input) return;
                    return _chunks()[0];
                });
                lazy.prop(o, 'input', () => {
                    if (!a.pubkey) return;
                    if (!a.signature) return;
                    return bscript.compile([a.signature, a.pubkey]);
                });
                lazy.prop(o, 'witness', () => {
                    if (!o.input) return;
                    return [];
                });
                // extended validation
                if (opts.validate) {
                    let hash = Buffer.from([]);
                    if (a.address) {
                        if (_address().version !== network.pubKeyHash)
                            throw new TypeError('Invalid version or Network mismatch');
                        if (_address().hash.length !== 20) throw new TypeError('Invalid address');
                        hash = _address().hash;
                    }
                    if (a.hash) {
                        if (hash.length > 0 && !hash.equals(a.hash))
                            throw new TypeError('Hash mismatch');
                        else hash = a.hash;
                    }
                    if (a.output) {
                        if (
                            a.output.length !== 25 ||
                            a.output[0] !== OPS.OP_DUP ||
                            a.output[1] !== OPS.OP_HASH160 ||
                            a.output[2] !== 0x14 ||
                            a.output[23] !== OPS.OP_EQUALVERIFY ||
                            a.output[24] !== OPS.OP_CHECKSIG
                        )
                            throw new TypeError('Output is invalid');
                        const hash2 = a.output.slice(3, 23);
                        if (hash.length > 0 && !hash.equals(hash2))
                            throw new TypeError('Hash mismatch');
                        else hash = hash2;
                    }
                    if (a.pubkey) {
                        const pkh = bcrypto.hash160(a.pubkey);
                        if (hash.length > 0 && !hash.equals(pkh))
                            throw new TypeError('Hash mismatch');
                        else hash = pkh;
                    }
                    if (a.input) {
                        const chunks = _chunks();
                        if (chunks.length !== 2) throw new TypeError('Input is invalid');
                        if (!bscript.isCanonicalScriptSignature(chunks[0]))
                            throw new TypeError('Input has invalid signature');
                        if (!ecc.isPoint(chunks[1]))
                            throw new TypeError('Input has invalid pubkey');
                        if (a.signature && !a.signature.equals(chunks[0]))
                            throw new TypeError('Signature mismatch');
                        if (a.pubkey && !a.pubkey.equals(chunks[1]))
                            throw new TypeError('Pubkey mismatch');
                        const pkh = bcrypto.hash160(chunks[1]);
                        if (hash.length > 0 && !hash.equals(pkh))
                            throw new TypeError('Hash mismatch');
                    }
                }
                return Object.assign(o, a);
            }

            exports.p2pkh = p2pkh;

        }).call(this, require("buffer").Buffer)

    }, {
        "../crypto": 78,
        "../networks": 81,
        "../script": 92,
        "./lazy": 84,
        "bs58check": 123,
        "buffer": 3,
        "tiny-secp256k1": 181,
        "typeforce": 185
    }],
    88: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bcrypto = require('../crypto');
            const networks_1 = require('../networks');
            const bscript = require('../script');
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = bscript.OPS;
            const bs58check = require('bs58check');

            function stacksEqual(a, b) {
                if (a.length !== b.length) return false;
                return a.every((x, i) => {
                    return x.equals(b[i]);
                });
            }

// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
            function p2sh(a, opts) {
                if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
                    throw new TypeError('Not enough data');
                opts = Object.assign({validate: true}, opts || {});
                typef(
                    {
                        network: typef.maybe(typef.Object),
                        address: typef.maybe(typef.String),
                        hash: typef.maybe(typef.BufferN(20)),
                        output: typef.maybe(typef.BufferN(23)),
                        redeem: typef.maybe({
                            network: typef.maybe(typef.Object),
                            output: typef.maybe(typef.Buffer),
                            input: typef.maybe(typef.Buffer),
                            witness: typef.maybe(typef.arrayOf(typef.Buffer)),
                        }),
                        input: typef.maybe(typef.Buffer),
                        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
                    },
                    a,
                );
                let network = a.network;
                if (!network) {
                    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
                }
                const o = {network};
                const _address = lazy.value(() => {
                    const payload = bs58check.decode(a.address);
                    const version = payload.readUInt8(0);
                    const hash = payload.slice(1);
                    return {version, hash};
                });
                const _chunks = lazy.value(() => {
                    return bscript.decompile(a.input);
                });
                const _redeem = lazy.value(() => {
                    const chunks = _chunks();
                    return {
                        network,
                        output: chunks[chunks.length - 1],
                        input: bscript.compile(chunks.slice(0, -1)),
                        witness: a.witness || [],
                    };
                });
                // output dependents
                lazy.prop(o, 'address', () => {
                    if (!o.hash) return;
                    const payload = Buffer.allocUnsafe(21);
                    payload.writeUInt8(o.network.scriptHash, 0);
                    o.hash.copy(payload, 1);
                    return bs58check.encode(payload);
                });
                lazy.prop(o, 'hash', () => {
                    // in order of least effort
                    if (a.output) return a.output.slice(2, 22);
                    if (a.address) return _address().hash;
                    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
                });
                lazy.prop(o, 'output', () => {
                    if (!o.hash) return;
                    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
                });
                // input dependents
                lazy.prop(o, 'redeem', () => {
                    if (!a.input) return;
                    return _redeem();
                });
                lazy.prop(o, 'input', () => {
                    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
                    return bscript.compile(
                        [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
                    );
                });
                lazy.prop(o, 'witness', () => {
                    if (o.redeem && o.redeem.witness) return o.redeem.witness;
                    if (o.input) return [];
                });
                lazy.prop(o, 'name', () => {
                    const nameParts = ['p2sh'];
                    if (o.redeem !== undefined) nameParts.push(o.redeem.name);
                    return nameParts.join('-');
                });
                if (opts.validate) {
                    let hash = Buffer.from([]);
                    if (a.address) {
                        if (_address().version !== network.scriptHash)
                            throw new TypeError('Invalid version or Network mismatch');
                        if (_address().hash.length !== 20) throw new TypeError('Invalid address');
                        hash = _address().hash;
                    }
                    if (a.hash) {
                        if (hash.length > 0 && !hash.equals(a.hash))
                            throw new TypeError('Hash mismatch');
                        else hash = a.hash;
                    }
                    if (a.output) {
                        if (
                            a.output.length !== 23 ||
                            a.output[0] !== OPS.OP_HASH160 ||
                            a.output[1] !== 0x14 ||
                            a.output[22] !== OPS.OP_EQUAL
                        )
                            throw new TypeError('Output is invalid');
                        const hash2 = a.output.slice(2, 22);
                        if (hash.length > 0 && !hash.equals(hash2))
                            throw new TypeError('Hash mismatch');
                        else hash = hash2;
                    }
                    // inlined to prevent 'no-inner-declarations' failing
                    const checkRedeem = redeem => {
                        // is the redeem output empty/invalid?
                        if (redeem.output) {
                            const decompile = bscript.decompile(redeem.output);
                            if (!decompile || decompile.length < 1)
                                throw new TypeError('Redeem.output too short');
                            // match hash against other sources
                            const hash2 = bcrypto.hash160(redeem.output);
                            if (hash.length > 0 && !hash.equals(hash2))
                                throw new TypeError('Hash mismatch');
                            else hash = hash2;
                        }
                        if (redeem.input) {
                            const hasInput = redeem.input.length > 0;
                            const hasWitness = redeem.witness && redeem.witness.length > 0;
                            if (!hasInput && !hasWitness) throw new TypeError('Empty input');
                            if (hasInput && hasWitness)
                                throw new TypeError('Input and witness provided');
                            if (hasInput) {
                                const richunks = bscript.decompile(redeem.input);
                                if (!bscript.isPushOnly(richunks))
                                    throw new TypeError('Non push-only scriptSig');
                            }
                        }
                    };
                    if (a.input) {
                        const chunks = _chunks();
                        if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
                        if (!Buffer.isBuffer(_redeem().output))
                            throw new TypeError('Input is invalid');
                        checkRedeem(_redeem());
                    }
                    if (a.redeem) {
                        if (a.redeem.network && a.redeem.network !== network)
                            throw new TypeError('Network mismatch');
                        if (a.input) {
                            const redeem = _redeem();
                            if (a.redeem.output && !a.redeem.output.equals(redeem.output))
                                throw new TypeError('Redeem.output mismatch');
                            if (a.redeem.input && !a.redeem.input.equals(redeem.input))
                                throw new TypeError('Redeem.input mismatch');
                        }
                        checkRedeem(a.redeem);
                    }
                    if (a.witness) {
                        if (
                            a.redeem &&
                            a.redeem.witness &&
                            !stacksEqual(a.redeem.witness, a.witness)
                        )
                            throw new TypeError('Witness and redeem.witness mismatch');
                    }
                }
                return Object.assign(o, a);
            }

            exports.p2sh = p2sh;

        }).call(this, require("buffer").Buffer)

    }, {
        "../crypto": 78,
        "../networks": 81,
        "../script": 92,
        "./lazy": 84,
        "bs58check": 123,
        "buffer": 3,
        "typeforce": 185
    }],
    89: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bcrypto = require('../crypto');
            const networks_1 = require('../networks');
            const bscript = require('../script');
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = bscript.OPS;
            const ecc = require('tiny-secp256k1');
            const bech32 = require('bech32');
            const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
            function p2wpkh(a, opts) {
                if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
                    throw new TypeError('Not enough data');
                opts = Object.assign({validate: true}, opts || {});
                typef(
                    {
                        address: typef.maybe(typef.String),
                        hash: typef.maybe(typef.BufferN(20)),
                        input: typef.maybe(typef.BufferN(0)),
                        network: typef.maybe(typef.Object),
                        output: typef.maybe(typef.BufferN(22)),
                        pubkey: typef.maybe(ecc.isPoint),
                        signature: typef.maybe(bscript.isCanonicalScriptSignature),
                        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
                    },
                    a,
                );
                const _address = lazy.value(() => {
                    const result = bech32.decode(a.address);
                    const version = result.words.shift();
                    const data = bech32.fromWords(result.words);
                    return {
                        version,
                        prefix: result.prefix,
                        data: Buffer.from(data),
                    };
                });
                const network = a.network || networks_1.bitcoin;
                const o = {name: 'p2wpkh', network};
                lazy.prop(o, 'address', () => {
                    if (!o.hash) return;
                    const words = bech32.toWords(o.hash);
                    words.unshift(0x00);
                    return bech32.encode(network.bech32, words);
                });
                lazy.prop(o, 'hash', () => {
                    if (a.output) return a.output.slice(2, 22);
                    if (a.address) return _address().data;
                    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
                });
                lazy.prop(o, 'output', () => {
                    if (!o.hash) return;
                    return bscript.compile([OPS.OP_0, o.hash]);
                });
                lazy.prop(o, 'pubkey', () => {
                    if (a.pubkey) return a.pubkey;
                    if (!a.witness) return;
                    return a.witness[1];
                });
                lazy.prop(o, 'signature', () => {
                    if (!a.witness) return;
                    return a.witness[0];
                });
                lazy.prop(o, 'input', () => {
                    if (!o.witness) return;
                    return EMPTY_BUFFER;
                });
                lazy.prop(o, 'witness', () => {
                    if (!a.pubkey) return;
                    if (!a.signature) return;
                    return [a.signature, a.pubkey];
                });
                // extended validation
                if (opts.validate) {
                    let hash = Buffer.from([]);
                    if (a.address) {
                        if (network && network.bech32 !== _address().prefix)
                            throw new TypeError('Invalid prefix or Network mismatch');
                        if (_address().version !== 0x00)
                            throw new TypeError('Invalid address version');
                        if (_address().data.length !== 20)
                            throw new TypeError('Invalid address data');
                        hash = _address().data;
                    }
                    if (a.hash) {
                        if (hash.length > 0 && !hash.equals(a.hash))
                            throw new TypeError('Hash mismatch');
                        else hash = a.hash;
                    }
                    if (a.output) {
                        if (
                            a.output.length !== 22 ||
                            a.output[0] !== OPS.OP_0 ||
                            a.output[1] !== 0x14
                        )
                            throw new TypeError('Output is invalid');
                        if (hash.length > 0 && !hash.equals(a.output.slice(2)))
                            throw new TypeError('Hash mismatch');
                        else hash = a.output.slice(2);
                    }
                    if (a.pubkey) {
                        const pkh = bcrypto.hash160(a.pubkey);
                        if (hash.length > 0 && !hash.equals(pkh))
                            throw new TypeError('Hash mismatch');
                        else hash = pkh;
                    }
                    if (a.witness) {
                        if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
                        if (!bscript.isCanonicalScriptSignature(a.witness[0]))
                            throw new TypeError('Witness has invalid signature');
                        if (!ecc.isPoint(a.witness[1]))
                            throw new TypeError('Witness has invalid pubkey');
                        if (a.signature && !a.signature.equals(a.witness[0]))
                            throw new TypeError('Signature mismatch');
                        if (a.pubkey && !a.pubkey.equals(a.witness[1]))
                            throw new TypeError('Pubkey mismatch');
                        const pkh = bcrypto.hash160(a.witness[1]);
                        if (hash.length > 0 && !hash.equals(pkh))
                            throw new TypeError('Hash mismatch');
                    }
                }
                return Object.assign(o, a);
            }

            exports.p2wpkh = p2wpkh;

        }).call(this, require("buffer").Buffer)

    }, {
        "../crypto": 78,
        "../networks": 81,
        "../script": 92,
        "./lazy": 84,
        "bech32": 34,
        "buffer": 3,
        "tiny-secp256k1": 181,
        "typeforce": 185
    }],
    90: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bcrypto = require('../crypto');
            const networks_1 = require('../networks');
            const bscript = require('../script');
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = bscript.OPS;
            const bech32 = require('bech32');
            const EMPTY_BUFFER = Buffer.alloc(0);

            function stacksEqual(a, b) {
                if (a.length !== b.length) return false;
                return a.every((x, i) => {
                    return x.equals(b[i]);
                });
            }

// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
            function p2wsh(a, opts) {
                if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
                    throw new TypeError('Not enough data');
                opts = Object.assign({validate: true}, opts || {});
                typef(
                    {
                        network: typef.maybe(typef.Object),
                        address: typef.maybe(typef.String),
                        hash: typef.maybe(typef.BufferN(32)),
                        output: typef.maybe(typef.BufferN(34)),
                        redeem: typef.maybe({
                            input: typef.maybe(typef.Buffer),
                            network: typef.maybe(typef.Object),
                            output: typef.maybe(typef.Buffer),
                            witness: typef.maybe(typef.arrayOf(typef.Buffer)),
                        }),
                        input: typef.maybe(typef.BufferN(0)),
                        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
                    },
                    a,
                );
                const _address = lazy.value(() => {
                    const result = bech32.decode(a.address);
                    const version = result.words.shift();
                    const data = bech32.fromWords(result.words);
                    return {
                        version,
                        prefix: result.prefix,
                        data: Buffer.from(data),
                    };
                });
                const _rchunks = lazy.value(() => {
                    return bscript.decompile(a.redeem.input);
                });
                let network = a.network;
                if (!network) {
                    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
                }
                const o = {network};
                lazy.prop(o, 'address', () => {
                    if (!o.hash) return;
                    const words = bech32.toWords(o.hash);
                    words.unshift(0x00);
                    return bech32.encode(network.bech32, words);
                });
                lazy.prop(o, 'hash', () => {
                    if (a.output) return a.output.slice(2);
                    if (a.address) return _address().data;
                    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
                });
                lazy.prop(o, 'output', () => {
                    if (!o.hash) return;
                    return bscript.compile([OPS.OP_0, o.hash]);
                });
                lazy.prop(o, 'redeem', () => {
                    if (!a.witness) return;
                    return {
                        output: a.witness[a.witness.length - 1],
                        input: EMPTY_BUFFER,
                        witness: a.witness.slice(0, -1),
                    };
                });
                lazy.prop(o, 'input', () => {
                    if (!o.witness) return;
                    return EMPTY_BUFFER;
                });
                lazy.prop(o, 'witness', () => {
                    // transform redeem input to witness stack?
                    if (
                        a.redeem &&
                        a.redeem.input &&
                        a.redeem.input.length > 0 &&
                        a.redeem.output &&
                        a.redeem.output.length > 0
                    ) {
                        const stack = bscript.toStack(_rchunks());
                        // assign, and blank the existing input
                        o.redeem = Object.assign({witness: stack}, a.redeem);
                        o.redeem.input = EMPTY_BUFFER;
                        return [].concat(stack, a.redeem.output);
                    }
                    if (!a.redeem) return;
                    if (!a.redeem.output) return;
                    if (!a.redeem.witness) return;
                    return [].concat(a.redeem.witness, a.redeem.output);
                });
                lazy.prop(o, 'name', () => {
                    const nameParts = ['p2wsh'];
                    if (o.redeem !== undefined) nameParts.push(o.redeem.name);
                    return nameParts.join('-');
                });
                // extended validation
                if (opts.validate) {
                    let hash = Buffer.from([]);
                    if (a.address) {
                        if (_address().prefix !== network.bech32)
                            throw new TypeError('Invalid prefix or Network mismatch');
                        if (_address().version !== 0x00)
                            throw new TypeError('Invalid address version');
                        if (_address().data.length !== 32)
                            throw new TypeError('Invalid address data');
                        hash = _address().data;
                    }
                    if (a.hash) {
                        if (hash.length > 0 && !hash.equals(a.hash))
                            throw new TypeError('Hash mismatch');
                        else hash = a.hash;
                    }
                    if (a.output) {
                        if (
                            a.output.length !== 34 ||
                            a.output[0] !== OPS.OP_0 ||
                            a.output[1] !== 0x20
                        )
                            throw new TypeError('Output is invalid');
                        const hash2 = a.output.slice(2);
                        if (hash.length > 0 && !hash.equals(hash2))
                            throw new TypeError('Hash mismatch');
                        else hash = hash2;
                    }
                    if (a.redeem) {
                        if (a.redeem.network && a.redeem.network !== network)
                            throw new TypeError('Network mismatch');
                        // is there two redeem sources?
                        if (
                            a.redeem.input &&
                            a.redeem.input.length > 0 &&
                            a.redeem.witness &&
                            a.redeem.witness.length > 0
                        )
                            throw new TypeError('Ambiguous witness source');
                        // is the redeem output non-empty?
                        if (a.redeem.output) {
                            if (bscript.decompile(a.redeem.output).length === 0)
                                throw new TypeError('Redeem.output is invalid');
                            // match hash against other sources
                            const hash2 = bcrypto.sha256(a.redeem.output);
                            if (hash.length > 0 && !hash.equals(hash2))
                                throw new TypeError('Hash mismatch');
                            else hash = hash2;
                        }
                        if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
                            throw new TypeError('Non push-only scriptSig');
                        if (
                            a.witness &&
                            a.redeem.witness &&
                            !stacksEqual(a.witness, a.redeem.witness)
                        )
                            throw new TypeError('Witness and redeem.witness mismatch');
                    }
                    if (a.witness) {
                        if (
                            a.redeem &&
                            a.redeem.output &&
                            !a.redeem.output.equals(a.witness[a.witness.length - 1])
                        )
                            throw new TypeError('Witness and redeem.output mismatch');
                    }
                }
                return Object.assign(o, a);
            }

            exports.p2wsh = p2wsh;

        }).call(this, require("buffer").Buffer)

    }, {
        "../crypto": 78,
        "../networks": 81,
        "../script": 92,
        "./lazy": 84,
        "bech32": 34,
        "buffer": 3,
        "typeforce": 185
    }],
    91: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bip174_1 = require('bip174');
            const varuint = require('bip174/src/lib/converter/varint');
            const utils_1 = require('bip174/src/lib/utils');
            const address_1 = require('./address');
            const bufferutils_1 = require('./bufferutils');
            const crypto_1 = require('./crypto');
            const ecpair_1 = require('./ecpair');
            const networks_1 = require('./networks');
            const payments = require('./payments');
            const bscript = require('./script');
            const transaction_1 = require('./transaction');
            /**
             * These are the default arguments for a Psbt instance.
             */
            const DEFAULT_OPTS = {
                /**
                 * A bitcoinjs Network object. This is only used if you pass an `address`
                 * parameter to addOutput. Otherwise it is not needed and can be left default.
                 */
                network: networks_1.bitcoin,
                /**
                 * When extractTransaction is called, the fee rate is checked.
                 * THIS IS NOT TO BE RELIED ON.
                 * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
                 */
                maximumFeeRate: 5000,
            };

            /**
             * Psbt class can parse and generate a PSBT binary based off of the BIP174.
             * There are 6 roles that this class fulfills. (Explained in BIP174)
             *
             * Creator: This can be done with `new Psbt()`
             * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
             *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
             *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
             *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
             *   addInput requires hash: Buffer | string; and index: number; as attributes
             *   and can also include any attributes that are used in updateInput method.
             *   addOutput requires script: Buffer; and value: number; and likewise can include
             *   data for updateOutput.
             *   For a list of what attributes should be what types. Check the bip174 library.
             *   Also, check the integration tests for some examples of usage.
             * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
             *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
             *   your info. Or you can explicitly sign a specific input with signInput and
             *   signInputAsync. For the async methods you can create a SignerAsync object
             *   and use something like a hardware wallet to sign with. (You must implement this)
             * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
             *   the psbt calling combine will always have precedence when a conflict occurs.
             *   Combine checks if the internal bitcoin transaction is the same, so be sure that
             *   all sequences, version, locktime, etc. are the same before combining.
             * Input Finalizer: This role is fairly important. Not only does it need to construct
             *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
             *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
             *   Running any finalize method will delete any data in the input(s) that are no longer
             *   needed due to the finalized scripts containing the information.
             * Transaction Extractor: This role will perform some checks before returning a
             *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
             */
            class Psbt {
                constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
                    this.data = data;
                    // set defaults
                    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
                    this.__CACHE = {
                        __NON_WITNESS_UTXO_TX_CACHE: [],
                        __NON_WITNESS_UTXO_BUF_CACHE: [],
                        __TX_IN_CACHE: {},
                        __TX: this.data.globalMap.unsignedTx.tx,
                    };
                    if (this.data.inputs.length === 0) this.setVersion(2);
                    // Make data hidden when enumerating
                    const dpew = (obj, attr, enumerable, writable) =>
                        Object.defineProperty(obj, attr, {
                            enumerable,
                            writable,
                        });
                    dpew(this, '__CACHE', false, true);
                    dpew(this, 'opts', false, true);
                }

                static fromBase64(data, opts = {}) {
                    const buffer = Buffer.from(data, 'base64');
                    return this.fromBuffer(buffer, opts);
                }

                static fromHex(data, opts = {}) {
                    const buffer = Buffer.from(data, 'hex');
                    return this.fromBuffer(buffer, opts);
                }

                static fromBuffer(buffer, opts = {}) {
                    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
                    const psbt = new Psbt(opts, psbtBase);
                    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
                    return psbt;
                }

                get inputCount() {
                    return this.data.inputs.length;
                }

                combine(...those) {
                    this.data.combine(...those.map(o => o.data));
                    return this;
                }

                clone() {
                    // TODO: more efficient cloning
                    const res = Psbt.fromBuffer(this.data.toBuffer());
                    res.opts = JSON.parse(JSON.stringify(this.opts));
                    return res;
                }

                setMaximumFeeRate(satoshiPerByte) {
                    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
                    this.opts.maximumFeeRate = satoshiPerByte;
                }

                setVersion(version) {
                    check32Bit(version);
                    checkInputsForPartialSig(this.data.inputs, 'setVersion');
                    const c = this.__CACHE;
                    c.__TX.version = version;
                    c.__EXTRACTED_TX = undefined;
                    return this;
                }

                setLocktime(locktime) {
                    check32Bit(locktime);
                    checkInputsForPartialSig(this.data.inputs, 'setLocktime');
                    const c = this.__CACHE;
                    c.__TX.locktime = locktime;
                    c.__EXTRACTED_TX = undefined;
                    return this;
                }

                setInputSequence(inputIndex, sequence) {
                    check32Bit(sequence);
                    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
                    const c = this.__CACHE;
                    if (c.__TX.ins.length <= inputIndex) {
                        throw new Error('Input index too high');
                    }
                    c.__TX.ins[inputIndex].sequence = sequence;
                    c.__EXTRACTED_TX = undefined;
                    return this;
                }

                addInputs(inputDatas) {
                    inputDatas.forEach(inputData => this.addInput(inputData));
                    return this;
                }

                addInput(inputData) {
                    if (
                        arguments.length > 1 ||
                        !inputData ||
                        inputData.hash === undefined ||
                        inputData.index === undefined
                    ) {
                        throw new Error(
                            `Invalid arguments for Psbt.addInput. ` +
                            `Requires single object with at least [hash] and [index]`,
                        );
                    }
                    checkInputsForPartialSig(this.data.inputs, 'addInput');
                    const c = this.__CACHE;
                    this.data.addInput(inputData);
                    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
                    checkTxInputCache(c, txIn);
                    const inputIndex = this.data.inputs.length - 1;
                    const input = this.data.inputs[inputIndex];
                    if (input.nonWitnessUtxo) {
                        addNonWitnessTxCache(this.__CACHE, input, inputIndex);
                    }
                    c.__FEE = undefined;
                    c.__FEE_RATE = undefined;
                    c.__EXTRACTED_TX = undefined;
                    return this;
                }

                addOutputs(outputDatas) {
                    outputDatas.forEach(outputData => this.addOutput(outputData));
                    return this;
                }

                addOutput(outputData) {
                    if (
                        arguments.length > 1 ||
                        !outputData ||
                        outputData.value === undefined ||
                        (outputData.address === undefined && outputData.script === undefined)
                    ) {
                        throw new Error(
                            `Invalid arguments for Psbt.addOutput. ` +
                            `Requires single object with at least [script or address] and [value]`,
                        );
                    }
                    checkInputsForPartialSig(this.data.inputs, 'addOutput');
                    const {address} = outputData;
                    if (typeof address === 'string') {
                        const {network} = this.opts;
                        const script = address_1.toOutputScript(address, network);
                        outputData = Object.assign(outputData, {script});
                    }
                    const c = this.__CACHE;
                    this.data.addOutput(outputData);
                    c.__FEE = undefined;
                    c.__FEE_RATE = undefined;
                    c.__EXTRACTED_TX = undefined;
                    return this;
                }

                extractTransaction(disableFeeCheck) {
                    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
                    const c = this.__CACHE;
                    if (!disableFeeCheck) {
                        checkFees(this, c, this.opts);
                    }
                    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
                    const tx = c.__TX.clone();
                    inputFinalizeGetAmts(this.data.inputs, tx, c, true);
                    return tx;
                }

                getFeeRate() {
                    return getTxCacheValue(
                        '__FEE_RATE',
                        'fee rate',
                        this.data.inputs,
                        this.__CACHE,
                    );
                }

                getFee() {
                    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
                }

                finalizeAllInputs() {
                    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
                    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
                    return this;
                }

                finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {
                    const input = utils_1.checkForInput(this.data.inputs, inputIndex);
                    const {script, isP2SH, isP2WSH, isSegwit} = getScriptFromInput(
                        inputIndex,
                        input,
                        this.__CACHE,
                    );
                    if (!script) throw new Error(`No script found for input #${inputIndex}`);
                    checkPartialSigSighashes(input);
                    const {finalScriptSig, finalScriptWitness} = finalScriptsFunc(
                        inputIndex,
                        input,
                        script,
                        isSegwit,
                        isP2SH,
                        isP2WSH,
                    );
                    if (finalScriptSig) this.data.updateInput(inputIndex, {finalScriptSig});
                    if (finalScriptWitness)
                        this.data.updateInput(inputIndex, {finalScriptWitness});
                    if (!finalScriptSig && !finalScriptWitness)
                        throw new Error(`Unknown error finalizing input #${inputIndex}`);
                    this.data.clearFinalizedInput(inputIndex);
                    return this;
                }

                validateSignaturesOfAllInputs() {
                    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
                    const results = range(this.data.inputs.length).map(idx =>
                        this.validateSignaturesOfInput(idx),
                    );
                    return results.reduce((final, res) => res === true && final, true);
                }

                validateSignaturesOfInput(inputIndex, pubkey) {
                    const input = this.data.inputs[inputIndex];
                    const partialSig = (input || {}).partialSig;
                    if (!input || !partialSig || partialSig.length < 1)
                        throw new Error('No signatures to validate');
                    const mySigs = pubkey
                        ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
                        : partialSig;
                    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
                    const results = [];
                    let hashCache;
                    let scriptCache;
                    let sighashCache;
                    for (const pSig of mySigs) {
                        const sig = bscript.signature.decode(pSig.signature);
                        const {hash, script} =
                            sighashCache !== sig.hashType
                                ? getHashForSig(
                                inputIndex,
                                Object.assign({}, input, {sighashType: sig.hashType}),
                                this.__CACHE,
                                )
                                : {hash: hashCache, script: scriptCache};
                        sighashCache = sig.hashType;
                        hashCache = hash;
                        scriptCache = script;
                        checkScriptForPubkey(pSig.pubkey, script, 'verify');
                        const keypair = ecpair_1.fromPublicKey(pSig.pubkey);
                        results.push(keypair.verify(hash, sig.signature));
                    }
                    return results.every(res => res === true);
                }

                signAllInputsHD(
                    hdKeyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
                        throw new Error('Need HDSigner to sign input');
                    }
                    const results = [];
                    for (const i of range(this.data.inputs.length)) {
                        try {
                            this.signInputHD(i, hdKeyPair, sighashTypes);
                            results.push(true);
                        } catch (err) {
                            results.push(false);
                        }
                    }
                    if (results.every(v => v === false)) {
                        throw new Error('No inputs were signed');
                    }
                    return this;
                }

                signAllInputsHDAsync(
                    hdKeyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    return new Promise((resolve, reject) => {
                        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
                            return reject(new Error('Need HDSigner to sign input'));
                        }
                        const results = [];
                        const promises = [];
                        for (const i of range(this.data.inputs.length)) {
                            promises.push(
                                this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
                                    () => {
                                        results.push(true);
                                    },
                                    () => {
                                        results.push(false);
                                    },
                                ),
                            );
                        }
                        return Promise.all(promises).then(() => {
                            if (results.every(v => v === false)) {
                                return reject(new Error('No inputs were signed'));
                            }
                            resolve();
                        });
                    });
                }

                signInputHD(
                    inputIndex,
                    hdKeyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
                        throw new Error('Need HDSigner to sign input');
                    }
                    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
                    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
                    return this;
                }

                signInputHDAsync(
                    inputIndex,
                    hdKeyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    return new Promise((resolve, reject) => {
                        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
                            return reject(new Error('Need HDSigner to sign input'));
                        }
                        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
                        const promises = signers.map(signer =>
                            this.signInputAsync(inputIndex, signer, sighashTypes),
                        );
                        return Promise.all(promises)
                            .then(() => {
                                resolve();
                            })
                            .catch(reject);
                    });
                }

                signAllInputs(
                    keyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    if (!keyPair || !keyPair.publicKey)
                        throw new Error('Need Signer to sign input');
                    // TODO: Add a pubkey/pubkeyhash cache to each input
                    // as input information is added, then eventually
                    // optimize this method.
                    const results = [];
                    for (const i of range(this.data.inputs.length)) {
                        try {
                            this.signInput(i, keyPair, sighashTypes);
                            results.push(true);
                        } catch (err) {
                            results.push(false);
                        }
                    }
                    if (results.every(v => v === false)) {
                        throw new Error('No inputs were signed');
                    }
                    return this;
                }

                signAllInputsAsync(
                    keyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    return new Promise((resolve, reject) => {
                        if (!keyPair || !keyPair.publicKey)
                            return reject(new Error('Need Signer to sign input'));
                        // TODO: Add a pubkey/pubkeyhash cache to each input
                        // as input information is added, then eventually
                        // optimize this method.
                        const results = [];
                        const promises = [];
                        for (const [i] of this.data.inputs.entries()) {
                            promises.push(
                                this.signInputAsync(i, keyPair, sighashTypes).then(
                                    () => {
                                        results.push(true);
                                    },
                                    () => {
                                        results.push(false);
                                    },
                                ),
                            );
                        }
                        return Promise.all(promises).then(() => {
                            if (results.every(v => v === false)) {
                                return reject(new Error('No inputs were signed'));
                            }
                            resolve();
                        });
                    });
                }

                signInput(
                    inputIndex,
                    keyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    if (!keyPair || !keyPair.publicKey)
                        throw new Error('Need Signer to sign input');
                    const {hash, sighashType} = getHashAndSighashType(
                        this.data.inputs,
                        inputIndex,
                        keyPair.publicKey,
                        this.__CACHE,
                        sighashTypes,
                    );
                    const partialSig = [
                        {
                            pubkey: keyPair.publicKey,
                            signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
                        },
                    ];
                    this.data.updateInput(inputIndex, {partialSig});
                    return this;
                }

                signInputAsync(
                    inputIndex,
                    keyPair,
                    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
                ) {
                    return new Promise((resolve, reject) => {
                        if (!keyPair || !keyPair.publicKey)
                            return reject(new Error('Need Signer to sign input'));
                        const {hash, sighashType} = getHashAndSighashType(
                            this.data.inputs,
                            inputIndex,
                            keyPair.publicKey,
                            this.__CACHE,
                            sighashTypes,
                        );
                        Promise.resolve(keyPair.sign(hash)).then(signature => {
                            const partialSig = [
                                {
                                    pubkey: keyPair.publicKey,
                                    signature: bscript.signature.encode(signature, sighashType),
                                },
                            ];
                            this.data.updateInput(inputIndex, {partialSig});
                            resolve();
                        });
                    });
                }

                toBuffer() {
                    return this.data.toBuffer();
                }

                toHex() {
                    return this.data.toHex();
                }

                toBase64() {
                    return this.data.toBase64();
                }

                updateGlobal(updateData) {
                    this.data.updateGlobal(updateData);
                    return this;
                }

                updateInput(inputIndex, updateData) {
                    this.data.updateInput(inputIndex, updateData);
                    if (updateData.nonWitnessUtxo) {
                        addNonWitnessTxCache(
                            this.__CACHE,
                            this.data.inputs[inputIndex],
                            inputIndex,
                        );
                    }
                    return this;
                }

                updateOutput(outputIndex, updateData) {
                    this.data.updateOutput(outputIndex, updateData);
                    return this;
                }

                addUnknownKeyValToGlobal(keyVal) {
                    this.data.addUnknownKeyValToGlobal(keyVal);
                    return this;
                }

                addUnknownKeyValToInput(inputIndex, keyVal) {
                    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
                    return this;
                }

                addUnknownKeyValToOutput(outputIndex, keyVal) {
                    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
                    return this;
                }

                clearFinalizedInput(inputIndex) {
                    this.data.clearFinalizedInput(inputIndex);
                    return this;
                }
            }

            exports.Psbt = Psbt;
            /**
             * This function is needed to pass to the bip174 base class's fromBuffer.
             * It takes the "transaction buffer" portion of the psbt buffer and returns a
             * Transaction (From the bip174 library) interface.
             */
            const transactionFromBuffer = buffer => new PsbtTransaction(buffer);

            /**
             * This class implements the Transaction interface from bip174 library.
             * It contains a bitcoinjs-lib Transaction object.
             */
            class PsbtTransaction {
                constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
                    this.tx = transaction_1.Transaction.fromBuffer(buffer);
                    checkTxEmpty(this.tx);
                    Object.defineProperty(this, 'tx', {
                        enumerable: false,
                        writable: true,
                    });
                }

                getInputOutputCounts() {
                    return {
                        inputCount: this.tx.ins.length,
                        outputCount: this.tx.outs.length,
                    };
                }

                addInput(input) {
                    if (
                        input.hash === undefined ||
                        input.index === undefined ||
                        (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
                        typeof input.index !== 'number'
                    ) {
                        throw new Error('Error adding input.');
                    }
                    const hash =
                        typeof input.hash === 'string'
                            ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))
                            : input.hash;
                    this.tx.addInput(hash, input.index, input.sequence);
                }

                addOutput(output) {
                    if (
                        output.script === undefined ||
                        output.value === undefined ||
                        !Buffer.isBuffer(output.script) ||
                        typeof output.value !== 'number'
                    ) {
                        throw new Error('Error adding output.');
                    }
                    this.tx.addOutput(output.script, output.value);
                }

                toBuffer() {
                    return this.tx.toBuffer();
                }
            }

            function canFinalize(input, script, scriptType) {
                switch (scriptType) {
                    case 'pubkey':
                    case 'pubkeyhash':
                    case 'witnesspubkeyhash':
                        return hasSigs(1, input.partialSig);
                    case 'multisig':
                        const p2ms = payments.p2ms({output: script});
                        return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
                    default:
                        return false;
                }
            }

            function hasSigs(neededSigs, partialSig, pubkeys) {
                if (!partialSig) return false;
                let sigs;
                if (pubkeys) {
                    sigs = pubkeys
                        .map(pkey => {
                            const pubkey = ecpair_1.fromPublicKey(pkey, {compressed: true})
                                .publicKey;
                            return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
                        })
                        .filter(v => !!v);
                } else {
                    sigs = partialSig;
                }
                if (sigs.length > neededSigs) throw new Error('Too many signatures');
                return sigs.length === neededSigs;
            }

            function isFinalized(input) {
                return !!input.finalScriptSig || !!input.finalScriptWitness;
            }

            function isPaymentFactory(payment) {
                return script => {
                    try {
                        payment({output: script});
                        return true;
                    } catch (err) {
                        return false;
                    }
                };
            }

            const isP2MS = isPaymentFactory(payments.p2ms);
            const isP2PK = isPaymentFactory(payments.p2pk);
            const isP2PKH = isPaymentFactory(payments.p2pkh);
            const isP2WPKH = isPaymentFactory(payments.p2wpkh);
            const isP2WSHScript = isPaymentFactory(payments.p2wsh);

            function check32Bit(num) {
                if (
                    typeof num !== 'number' ||
                    num !== Math.floor(num) ||
                    num > 0xffffffff ||
                    num < 0
                ) {
                    throw new Error('Invalid 32 bit integer');
                }
            }

            function checkFees(psbt, cache, opts) {
                const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
                const vsize = cache.__EXTRACTED_TX.virtualSize();
                const satoshis = feeRate * vsize;
                if (feeRate >= opts.maximumFeeRate) {
                    throw new Error(
                        `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
                        `fees, which is ${feeRate} satoshi per byte for a transaction ` +
                        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
                        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
                        `pass true to the first arg of extractTransaction.`,
                    );
                }
            }

            function checkInputsForPartialSig(inputs, action) {
                inputs.forEach(input => {
                    let throws = false;
                    let pSigs = [];
                    if ((input.partialSig || []).length === 0) {
                        if (!input.finalScriptSig && !input.finalScriptWitness) return;
                        pSigs = getPsigsFromInputFinalScripts(input);
                    } else {
                        pSigs = input.partialSig;
                    }
                    pSigs.forEach(pSig => {
                        const {hashType} = bscript.signature.decode(pSig.signature);
                        const whitelist = [];
                        const isAnyoneCanPay =
                            hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
                        if (isAnyoneCanPay) whitelist.push('addInput');
                        const hashMod = hashType & 0x1f;
                        switch (hashMod) {
                            case transaction_1.Transaction.SIGHASH_ALL:
                                break;
                            case transaction_1.Transaction.SIGHASH_SINGLE:
                            case transaction_1.Transaction.SIGHASH_NONE:
                                whitelist.push('addOutput');
                                whitelist.push('setInputSequence');
                                break;
                        }
                        if (whitelist.indexOf(action) === -1) {
                            throws = true;
                        }
                    });
                    if (throws) {
                        throw new Error('Can not modify transaction, signatures exist.');
                    }
                });
            }

            function checkPartialSigSighashes(input) {
                if (!input.sighashType || !input.partialSig) return;
                const {partialSig, sighashType} = input;
                partialSig.forEach(pSig => {
                    const {hashType} = bscript.signature.decode(pSig.signature);
                    if (sighashType !== hashType) {
                        throw new Error('Signature sighash does not match input sighash type');
                    }
                });
            }

            function checkScriptForPubkey(pubkey, script, action) {
                const pubkeyHash = crypto_1.hash160(pubkey);
                const decompiled = bscript.decompile(script);
                if (decompiled === null) throw new Error('Unknown script error');
                const hasKey = decompiled.some(element => {
                    if (typeof element === 'number') return false;
                    return element.equals(pubkey) || element.equals(pubkeyHash);
                });
                if (!hasKey) {
                    throw new Error(
                        `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
                    );
                }
            }

            function checkTxEmpty(tx) {
                const isEmpty = tx.ins.every(
                    input =>
                        input.script &&
                        input.script.length === 0 &&
                        input.witness &&
                        input.witness.length === 0,
                );
                if (!isEmpty) {
                    throw new Error('Format Error: Transaction ScriptSigs are not empty');
                }
            }

            function checkTxForDupeIns(tx, cache) {
                tx.ins.forEach(input => {
                    checkTxInputCache(cache, input);
                });
            }

            function checkTxInputCache(cache, input) {
                const key =
                    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +
                    ':' +
                    input.index;
                if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
                cache.__TX_IN_CACHE[key] = 1;
            }

            function scriptCheckerFactory(payment, paymentScriptName) {
                return (inputIndex, scriptPubKey, redeemScript) => {
                    const redeemScriptOutput = payment({
                        redeem: {output: redeemScript},
                    }).output;
                    if (!scriptPubKey.equals(redeemScriptOutput)) {
                        throw new Error(
                            `${paymentScriptName} for input #${inputIndex} doesn't match the scriptPubKey in the prevout`,
                        );
                    }
                };
            }

            const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
            const checkWitnessScript = scriptCheckerFactory(
                payments.p2wsh,
                'Witness script',
            );

            function getTxCacheValue(key, name, inputs, c) {
                if (!inputs.every(isFinalized))
                    throw new Error(`PSBT must be finalized to calculate ${name}`);
                if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
                if (key === '__FEE' && c.__FEE) return c.__FEE;
                let tx;
                let mustFinalize = true;
                if (c.__EXTRACTED_TX) {
                    tx = c.__EXTRACTED_TX;
                    mustFinalize = false;
                } else {
                    tx = c.__TX.clone();
                }
                inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
                if (key === '__FEE_RATE') return c.__FEE_RATE;
                else if (key === '__FEE') return c.__FEE;
            }

            function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
                const scriptType = classifyScript(script);
                if (!canFinalize(input, script, scriptType))
                    throw new Error(`Can not finalize input #${inputIndex}`);
                return prepareFinalScripts(
                    script,
                    scriptType,
                    input.partialSig,
                    isSegwit,
                    isP2SH,
                    isP2WSH,
                );
            }

            function prepareFinalScripts(
                script,
                scriptType,
                partialSig,
                isSegwit,
                isP2SH,
                isP2WSH,
            ) {
                let finalScriptSig;
                let finalScriptWitness;
                // Wow, the payments API is very handy
                const payment = getPayment(script, scriptType, partialSig);
                const p2wsh = !isP2WSH ? null : payments.p2wsh({redeem: payment});
                const p2sh = !isP2SH ? null : payments.p2sh({redeem: p2wsh || payment});
                if (isSegwit) {
                    if (p2wsh) {
                        finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
                    } else {
                        finalScriptWitness = witnessStackToScriptWitness(payment.witness);
                    }
                    if (p2sh) {
                        finalScriptSig = p2sh.input;
                    }
                } else {
                    if (p2sh) {
                        finalScriptSig = p2sh.input;
                    } else {
                        finalScriptSig = payment.input;
                    }
                }
                return {
                    finalScriptSig,
                    finalScriptWitness,
                };
            }

            function getHashAndSighashType(
                inputs,
                inputIndex,
                pubkey,
                cache,
                sighashTypes,
            ) {
                const input = utils_1.checkForInput(inputs, inputIndex);
                const {hash, sighashType, script} = getHashForSig(
                    inputIndex,
                    input,
                    cache,
                    sighashTypes,
                );
                checkScriptForPubkey(pubkey, script, 'sign');
                return {
                    hash,
                    sighashType,
                };
            }

            function getHashForSig(inputIndex, input, cache, sighashTypes) {
                const unsignedTx = cache.__TX;
                const sighashType =
                    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
                if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
                    const str = sighashTypeToString(sighashType);
                    throw new Error(
                        `Sighash type is not allowed. Retry the sign method passing the ` +
                        `sighashTypes array of whitelisted types. Sighash type: ${str}`,
                    );
                }
                let hash;
                let script;
                if (input.nonWitnessUtxo) {
                    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
                        cache,
                        input,
                        inputIndex,
                    );
                    const prevoutHash = unsignedTx.ins[inputIndex].hash;
                    const utxoHash = nonWitnessUtxoTx.getHash();
                    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
                    if (!prevoutHash.equals(utxoHash)) {
                        throw new Error(
                            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
                        );
                    }
                    const prevoutIndex = unsignedTx.ins[inputIndex].index;
                    const prevout = nonWitnessUtxoTx.outs[prevoutIndex];
                    if (input.redeemScript) {
                        // If a redeemScript is provided, the scriptPubKey must be for that redeemScript
                        checkRedeemScript(inputIndex, prevout.script, input.redeemScript);
                        script = input.redeemScript;
                    } else {
                        script = prevout.script;
                    }
                    if (isP2WSHScript(script)) {
                        if (!input.witnessScript)
                            throw new Error('Segwit input needs witnessScript if not P2WPKH');
                        checkWitnessScript(inputIndex, script, input.witnessScript);
                        hash = unsignedTx.hashForWitnessV0(
                            inputIndex,
                            input.witnessScript,
                            prevout.value,
                            sighashType,
                        );
                        script = input.witnessScript;
                    } else if (isP2WPKH(script)) {
                        // P2WPKH uses the P2PKH template for prevoutScript when signing
                        const signingScript = payments.p2pkh({hash: script.slice(2)}).output;
                        hash = unsignedTx.hashForWitnessV0(
                            inputIndex,
                            signingScript,
                            prevout.value,
                            sighashType,
                        );
                    } else {
                        hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);
                    }
                } else if (input.witnessUtxo) {
                    let _script; // so we don't shadow the `let script` above
                    if (input.redeemScript) {
                        // If a redeemScript is provided, the scriptPubKey must be for that redeemScript
                        checkRedeemScript(
                            inputIndex,
                            input.witnessUtxo.script,
                            input.redeemScript,
                        );
                        _script = input.redeemScript;
                    } else {
                        _script = input.witnessUtxo.script;
                    }
                    if (isP2WPKH(_script)) {
                        // P2WPKH uses the P2PKH template for prevoutScript when signing
                        const signingScript = payments.p2pkh({hash: _script.slice(2)}).output;
                        hash = unsignedTx.hashForWitnessV0(
                            inputIndex,
                            signingScript,
                            input.witnessUtxo.value,
                            sighashType,
                        );
                        script = _script;
                    } else if (isP2WSHScript(_script)) {
                        if (!input.witnessScript)
                            throw new Error('Segwit input needs witnessScript if not P2WPKH');
                        checkWitnessScript(inputIndex, _script, input.witnessScript);
                        hash = unsignedTx.hashForWitnessV0(
                            inputIndex,
                            input.witnessScript,
                            input.witnessUtxo.value,
                            sighashType,
                        );
                        // want to make sure the script we return is the actual meaningful script
                        script = input.witnessScript;
                    } else {
                        throw new Error(
                            `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
                            `${_script.toString('hex')}`,
                        );
                    }
                } else {
                    throw new Error('Need a Utxo input item for signing');
                }
                return {
                    script,
                    sighashType,
                    hash,
                };
            }

            function getPayment(script, scriptType, partialSig) {
                let payment;
                switch (scriptType) {
                    case 'multisig':
                        const sigs = getSortedSigs(script, partialSig);
                        payment = payments.p2ms({
                            output: script,
                            signatures: sigs,
                        });
                        break;
                    case 'pubkey':
                        payment = payments.p2pk({
                            output: script,
                            signature: partialSig[0].signature,
                        });
                        break;
                    case 'pubkeyhash':
                        payment = payments.p2pkh({
                            output: script,
                            pubkey: partialSig[0].pubkey,
                            signature: partialSig[0].signature,
                        });
                        break;
                    case 'witnesspubkeyhash':
                        payment = payments.p2wpkh({
                            output: script,
                            pubkey: partialSig[0].pubkey,
                            signature: partialSig[0].signature,
                        });
                        break;
                }
                return payment;
            }

            function getPsigsFromInputFinalScripts(input) {
                const scriptItems = !input.finalScriptSig
                    ? []
                    : bscript.decompile(input.finalScriptSig) || [];
                const witnessItems = !input.finalScriptWitness
                    ? []
                    : bscript.decompile(input.finalScriptWitness) || [];
                return scriptItems
                    .concat(witnessItems)
                    .filter(item => {
                        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
                    })
                    .map(sig => ({signature: sig}));
            }

            function getScriptFromInput(inputIndex, input, cache) {
                const unsignedTx = cache.__TX;
                const res = {
                    script: null,
                    isSegwit: false,
                    isP2SH: false,
                    isP2WSH: false,
                };
                res.isP2SH = !!input.redeemScript;
                res.isP2WSH = !!input.witnessScript;
                if (input.witnessScript) {
                    res.script = input.witnessScript;
                } else if (input.redeemScript) {
                    res.script = input.redeemScript;
                } else {
                    if (input.nonWitnessUtxo) {
                        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
                            cache,
                            input,
                            inputIndex,
                        );
                        const prevoutIndex = unsignedTx.ins[inputIndex].index;
                        res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
                    } else if (input.witnessUtxo) {
                        res.script = input.witnessUtxo.script;
                    }
                }
                if (input.witnessScript || isP2WPKH(res.script)) {
                    res.isSegwit = true;
                }
                return res;
            }

            function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
                const input = utils_1.checkForInput(inputs, inputIndex);
                if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
                    throw new Error('Need bip32Derivation to sign with HD');
                }
                const myDerivations = input.bip32Derivation
                    .map(bipDv => {
                        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
                            return bipDv;
                        } else {
                            return;
                        }
                    })
                    .filter(v => !!v);
                if (myDerivations.length === 0) {
                    throw new Error(
                        'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
                    );
                }
                const signers = myDerivations.map(bipDv => {
                    const node = hdKeyPair.derivePath(bipDv.path);
                    if (!bipDv.pubkey.equals(node.publicKey)) {
                        throw new Error('pubkey did not match bip32Derivation');
                    }
                    return node;
                });
                return signers;
            }

            function getSortedSigs(script, partialSig) {
                const p2ms = payments.p2ms({output: script});
                // for each pubkey in order of p2ms script
                return p2ms.pubkeys
                    .map(pk => {
                        // filter partialSig array by pubkey being equal
                        return (
                            partialSig.filter(ps => {
                                return ps.pubkey.equals(pk);
                            })[0] || {}
                        ).signature;
                        // Any pubkey without a match will return undefined
                        // this last filter removes all the undefined items in the array.
                    })
                    .filter(v => !!v);
            }

            function scriptWitnessToWitnessStack(buffer) {
                let offset = 0;

                function readSlice(n) {
                    offset += n;
                    return buffer.slice(offset - n, offset);
                }

                function readVarInt() {
                    const vi = varuint.decode(buffer, offset);
                    offset += varuint.decode.bytes;
                    return vi;
                }

                function readVarSlice() {
                    return readSlice(readVarInt());
                }

                function readVector() {
                    const count = readVarInt();
                    const vector = [];
                    for (let i = 0; i < count; i++) vector.push(readVarSlice());
                    return vector;
                }

                return readVector();
            }

            function sighashTypeToString(sighashType) {
                let text =
                    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
                        ? 'SIGHASH_ANYONECANPAY | '
                        : '';
                const sigMod = sighashType & 0x1f;
                switch (sigMod) {
                    case transaction_1.Transaction.SIGHASH_ALL:
                        text += 'SIGHASH_ALL';
                        break;
                    case transaction_1.Transaction.SIGHASH_SINGLE:
                        text += 'SIGHASH_SINGLE';
                        break;
                    case transaction_1.Transaction.SIGHASH_NONE:
                        text += 'SIGHASH_NONE';
                        break;
                }
                return text;
            }

            function witnessStackToScriptWitness(witness) {
                let buffer = Buffer.allocUnsafe(0);

                function writeSlice(slice) {
                    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
                }

                function writeVarInt(i) {
                    const currentLen = buffer.length;
                    const varintLen = varuint.encodingLength(i);
                    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
                    varuint.encode(i, buffer, currentLen);
                }

                function writeVarSlice(slice) {
                    writeVarInt(slice.length);
                    writeSlice(slice);
                }

                function writeVector(vector) {
                    writeVarInt(vector.length);
                    vector.forEach(writeVarSlice);
                }

                writeVector(witness);
                return buffer;
            }

            function addNonWitnessTxCache(cache, input, inputIndex) {
                cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
                const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
                cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
                const self = cache;
                const selfIndex = inputIndex;
                delete input.nonWitnessUtxo;
                Object.defineProperty(input, 'nonWitnessUtxo', {
                    enumerable: true,
                    get() {
                        const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
                        const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
                        if (buf !== undefined) {
                            return buf;
                        } else {
                            const newBuf = txCache.toBuffer();
                            self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
                            return newBuf;
                        }
                    },
                    set(data) {
                        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
                    },
                });
            }

            function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
                let inputAmount = 0;
                inputs.forEach((input, idx) => {
                    if (mustFinalize && input.finalScriptSig)
                        tx.ins[idx].script = input.finalScriptSig;
                    if (mustFinalize && input.finalScriptWitness) {
                        tx.ins[idx].witness = scriptWitnessToWitnessStack(
                            input.finalScriptWitness,
                        );
                    }
                    if (input.witnessUtxo) {
                        inputAmount += input.witnessUtxo.value;
                    } else if (input.nonWitnessUtxo) {
                        const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
                        const vout = tx.ins[idx].index;
                        const out = nwTx.outs[vout];
                        inputAmount += out.value;
                    }
                });
                const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
                const fee = inputAmount - outputAmount;
                if (fee < 0) {
                    throw new Error('Outputs are spending more than Inputs');
                }
                const bytes = tx.virtualSize();
                cache.__FEE = fee;
                cache.__EXTRACTED_TX = tx;
                cache.__FEE_RATE = Math.floor(fee / bytes);
            }

            function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
                const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
                if (!c[inputIndex]) {
                    addNonWitnessTxCache(cache, input, inputIndex);
                }
                return c[inputIndex];
            }

            function classifyScript(script) {
                if (isP2WPKH(script)) return 'witnesspubkeyhash';
                if (isP2PKH(script)) return 'pubkeyhash';
                if (isP2MS(script)) return 'multisig';
                if (isP2PK(script)) return 'pubkey';
                return 'nonstandard';
            }

            function range(n) {
                return [...Array(n).keys()];
            }

        }).call(this, require("buffer").Buffer)

    }, {
        "./address": 74,
        "./bufferutils": 76,
        "./crypto": 78,
        "./ecpair": 79,
        "./networks": 81,
        "./payments": 83,
        "./script": 92,
        "./transaction": 116,
        "bip174": 55,
        "bip174/src/lib/converter/varint": 51,
        "bip174/src/lib/utils": 57,
        "buffer": 3
    }],
    92: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const scriptNumber = require('./script_number');
            const scriptSignature = require('./script_signature');
            const types = require('./types');
            const bip66 = require('bip66');
            const ecc = require('tiny-secp256k1');
            const pushdata = require('pushdata-bitcoin');
            const typeforce = require('typeforce');
            exports.OPS = require('bitcoin-ops');
            const REVERSE_OPS = require('bitcoin-ops/map');
            const OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1
            function isOPInt(value) {
                return (
                    types.Number(value) &&
                    (value === exports.OPS.OP_0 ||
                        (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||
                        value === exports.OPS.OP_1NEGATE)
                );
            }

            function isPushOnlyChunk(value) {
                return types.Buffer(value) || isOPInt(value);
            }

            function isPushOnly(value) {
                return types.Array(value) && value.every(isPushOnlyChunk);
            }

            exports.isPushOnly = isPushOnly;

            function asMinimalOP(buffer) {
                if (buffer.length === 0) return exports.OPS.OP_0;
                if (buffer.length !== 1) return;
                if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
                if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;
            }

            function chunksIsBuffer(buf) {
                return Buffer.isBuffer(buf);
            }

            function chunksIsArray(buf) {
                return types.Array(buf);
            }

            function singleChunkIsBuffer(buf) {
                return Buffer.isBuffer(buf);
            }

            function compile(chunks) {
                // TODO: remove me
                if (chunksIsBuffer(chunks)) return chunks;
                typeforce(types.Array, chunks);
                const bufferSize = chunks.reduce((accum, chunk) => {
                    // data chunk
                    if (singleChunkIsBuffer(chunk)) {
                        // adhere to BIP62.3, minimal push policy
                        if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
                            return accum + 1;
                        }
                        return accum + pushdata.encodingLength(chunk.length) + chunk.length;
                    }
                    // opcode
                    return accum + 1;
                }, 0.0);
                const buffer = Buffer.allocUnsafe(bufferSize);
                let offset = 0;
                chunks.forEach(chunk => {
                    // data chunk
                    if (singleChunkIsBuffer(chunk)) {
                        // adhere to BIP62.3, minimal push policy
                        const opcode = asMinimalOP(chunk);
                        if (opcode !== undefined) {
                            buffer.writeUInt8(opcode, offset);
                            offset += 1;
                            return;
                        }
                        offset += pushdata.encode(buffer, chunk.length, offset);
                        chunk.copy(buffer, offset);
                        offset += chunk.length;
                        // opcode
                    } else {
                        buffer.writeUInt8(chunk, offset);
                        offset += 1;
                    }
                });
                if (offset !== buffer.length) throw new Error('Could not decode chunks');
                return buffer;
            }

            exports.compile = compile;

            function decompile(buffer) {
                // TODO: remove me
                if (chunksIsArray(buffer)) return buffer;
                typeforce(types.Buffer, buffer);
                const chunks = [];
                let i = 0;
                while (i < buffer.length) {
                    const opcode = buffer[i];
                    // data chunk
                    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {
                        const d = pushdata.decode(buffer, i);
                        // did reading a pushDataInt fail?
                        if (d === null) return null;
                        i += d.size;
                        // attempt to read too much data?
                        if (i + d.number > buffer.length) return null;
                        const data = buffer.slice(i, i + d.number);
                        i += d.number;
                        // decompile minimally
                        const op = asMinimalOP(data);
                        if (op !== undefined) {
                            chunks.push(op);
                        } else {
                            chunks.push(data);
                        }
                        // opcode
                    } else {
                        chunks.push(opcode);
                        i += 1;
                    }
                }
                return chunks;
            }

            exports.decompile = decompile;

            function toASM(chunks) {
                if (chunksIsBuffer(chunks)) {
                    chunks = decompile(chunks);
                }
                return chunks
                    .map(chunk => {
                        // data?
                        if (singleChunkIsBuffer(chunk)) {
                            const op = asMinimalOP(chunk);
                            if (op === undefined) return chunk.toString('hex');
                            chunk = op;
                        }
                        // opcode!
                        return REVERSE_OPS[chunk];
                    })
                    .join(' ');
            }

            exports.toASM = toASM;

            function fromASM(asm) {
                typeforce(types.String, asm);
                return compile(
                    asm.split(' ').map(chunkStr => {
                        // opcode?
                        if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];
                        typeforce(types.Hex, chunkStr);
                        // data!
                        return Buffer.from(chunkStr, 'hex');
                    }),
                );
            }

            exports.fromASM = fromASM;

            function toStack(chunks) {
                chunks = decompile(chunks);
                typeforce(isPushOnly, chunks);
                return chunks.map(op => {
                    if (singleChunkIsBuffer(op)) return op;
                    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);
                    return scriptNumber.encode(op - OP_INT_BASE);
                });
            }

            exports.toStack = toStack;

            function isCanonicalPubKey(buffer) {
                return ecc.isPoint(buffer);
            }

            exports.isCanonicalPubKey = isCanonicalPubKey;

            function isDefinedHashType(hashType) {
                const hashTypeMod = hashType & ~0x80;
                // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
                return hashTypeMod > 0x00 && hashTypeMod < 0x04;
            }

            exports.isDefinedHashType = isDefinedHashType;

            function isCanonicalScriptSignature(buffer) {
                if (!Buffer.isBuffer(buffer)) return false;
                if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
                return bip66.check(buffer.slice(0, -1));
            }

            exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
// tslint:disable-next-line variable-name
            exports.number = scriptNumber;
            exports.signature = scriptSignature;

        }).call(this, require("buffer").Buffer)

    }, {
        "./script_number": 93,
        "./script_signature": 94,
        "./types": 118,
        "bip66": 71,
        "bitcoin-ops": 72,
        "bitcoin-ops/map": 73,
        "buffer": 3,
        "pushdata-bitcoin": 169,
        "tiny-secp256k1": 181,
        "typeforce": 185
    }],
    93: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});

            function decode(buffer, maxLength, minimal) {
                maxLength = maxLength || 4;
                minimal = minimal === undefined ? true : minimal;
                const length = buffer.length;
                if (length === 0) return 0;
                if (length > maxLength) throw new TypeError('Script number overflow');
                if (minimal) {
                    if ((buffer[length - 1] & 0x7f) === 0) {
                        if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
                            throw new Error('Non-minimally encoded script number');
                    }
                }
                // 40-bit
                if (length === 5) {
                    const a = buffer.readUInt32LE(0);
                    const b = buffer.readUInt8(4);
                    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
                    return b * 0x100000000 + a;
                }
                // 32-bit / 24-bit / 16-bit / 8-bit
                let result = 0;
                for (let i = 0; i < length; ++i) {
                    result |= buffer[i] << (8 * i);
                }
                if (buffer[length - 1] & 0x80)
                    return -(result & ~(0x80 << (8 * (length - 1))));
                return result;
            }

            exports.decode = decode;

            function scriptNumSize(i) {
                return i > 0x7fffffff
                    ? 5
                    : i > 0x7fffff
                        ? 4
                        : i > 0x7fff
                            ? 3
                            : i > 0x7f
                                ? 2
                                : i > 0x00
                                    ? 1
                                    : 0;
            }

            function encode(_number) {
                let value = Math.abs(_number);
                const size = scriptNumSize(value);
                const buffer = Buffer.allocUnsafe(size);
                const negative = _number < 0;
                for (let i = 0; i < size; ++i) {
                    buffer.writeUInt8(value & 0xff, i);
                    value >>= 8;
                }
                if (buffer[size - 1] & 0x80) {
                    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
                } else if (negative) {
                    buffer[size - 1] |= 0x80;
                }
                return buffer;
            }

            exports.encode = encode;

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    94: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const types = require('./types');
            const bip66 = require('bip66');
            const typeforce = require('typeforce');
            const ZERO = Buffer.alloc(1, 0);

            function toDER(x) {
                let i = 0;
                while (x[i] === 0) ++i;
                if (i === x.length) return ZERO;
                x = x.slice(i);
                if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
                return x;
            }

            function fromDER(x) {
                if (x[0] === 0x00) x = x.slice(1);
                const buffer = Buffer.alloc(32, 0);
                const bstart = Math.max(0, 32 - x.length);
                x.copy(buffer, bstart);
                return buffer;
            }

// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
            function decode(buffer) {
                const hashType = buffer.readUInt8(buffer.length - 1);
                const hashTypeMod = hashType & ~0x80;
                if (hashTypeMod <= 0 || hashTypeMod >= 4)
                    throw new Error('Invalid hashType ' + hashType);
                const decoded = bip66.decode(buffer.slice(0, -1));
                const r = fromDER(decoded.r);
                const s = fromDER(decoded.s);
                const signature = Buffer.concat([r, s], 64);
                return {signature, hashType};
            }

            exports.decode = decode;

            function encode(signature, hashType) {
                typeforce(
                    {
                        signature: types.BufferN(64),
                        hashType: types.UInt8,
                    },
                    {signature, hashType},
                );
                const hashTypeMod = hashType & ~0x80;
                if (hashTypeMod <= 0 || hashTypeMod >= 4)
                    throw new Error('Invalid hashType ' + hashType);
                const hashTypeBuffer = Buffer.allocUnsafe(1);
                hashTypeBuffer.writeUInt8(hashType, 0);
                const r = toDER(signature.slice(0, 32));
                const s = toDER(signature.slice(32, 64));
                return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
            }

            exports.encode = encode;

        }).call(this, require("buffer").Buffer)

    }, {"./types": 118, "bip66": 71, "buffer": 3, "typeforce": 185}],
    95: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const input = require('./input');
        exports.input = input;
        const output = require('./output');
        exports.output = output;

    }, {"./input": 96, "./output": 97}],
    96: [function (require, module, exports) {
        'use strict';
// OP_0 [signatures ...]
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function partialSignature(value) {
            return (
                value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)
            );
        }

        function check(script, allowIncomplete) {
            const chunks = bscript.decompile(script);
            if (chunks.length < 2) return false;
            if (chunks[0] !== script_1.OPS.OP_0) return false;
            if (allowIncomplete) {
                return chunks.slice(1).every(partialSignature);
            }
            return chunks.slice(1).every(bscript.isCanonicalScriptSignature);
        }

        exports.check = check;
        check.toJSON = () => {
            return 'multisig input';
        };

    }, {"../../script": 92}],
    97: [function (require, module, exports) {
        'use strict';
// m [pubKeys ...] n OP_CHECKMULTISIG
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');
        const types = require('../../types');
        const OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1
        function check(script, allowIncomplete) {
            const chunks = bscript.decompile(script);
            if (chunks.length < 4) return false;
            if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;
            if (!types.Number(chunks[0])) return false;
            if (!types.Number(chunks[chunks.length - 2])) return false;
            const m = chunks[0] - OP_INT_BASE;
            const n = chunks[chunks.length - 2] - OP_INT_BASE;
            if (m <= 0) return false;
            if (n > 16) return false;
            if (m > n) return false;
            if (n !== chunks.length - 3) return false;
            if (allowIncomplete) return true;
            const keys = chunks.slice(1, -2);
            return keys.every(bscript.isCanonicalPubKey);
        }

        exports.check = check;
        check.toJSON = () => {
            return 'multi-sig output';
        };

    }, {"../../script": 92, "../../types": 118}],
    98: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
// OP_RETURN {data}
        const bscript = require('../script');
        const OPS = bscript.OPS;

        function check(script) {
            const buffer = bscript.compile(script);
            return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;
        }

        exports.check = check;
        check.toJSON = () => {
            return 'null data output';
        };
        const output = {check};
        exports.output = output;

    }, {"../script": 92}],
    99: [function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments)
    }, {"./input": 100, "./output": 101, "dup": 95}],
    100: [function (require, module, exports) {
        'use strict';
// {signature}
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');

        function check(script) {
            const chunks = bscript.decompile(script);
            return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);
        }

        exports.check = check;
        check.toJSON = () => {
            return 'pubKey input';
        };

    }, {"../../script": 92}],
    101: [function (require, module, exports) {
        'use strict';
// {pubKey} OP_CHECKSIG
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function check(script) {
            const chunks = bscript.decompile(script);
            return (
                chunks.length === 2 &&
                bscript.isCanonicalPubKey(chunks[0]) &&
                chunks[1] === script_1.OPS.OP_CHECKSIG
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'pubKey output';
        };

    }, {"../../script": 92}],
    102: [function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments)
    }, {"./input": 103, "./output": 104, "dup": 95}],
    103: [function (require, module, exports) {
        'use strict';
// {signature} {pubKey}
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');

        function check(script) {
            const chunks = bscript.decompile(script);
            return (
                chunks.length === 2 &&
                bscript.isCanonicalScriptSignature(chunks[0]) &&
                bscript.isCanonicalPubKey(chunks[1])
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'pubKeyHash input';
        };

    }, {"../../script": 92}],
    104: [function (require, module, exports) {
        'use strict';
// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function check(script) {
            const buffer = bscript.compile(script);
            return (
                buffer.length === 25 &&
                buffer[0] === script_1.OPS.OP_DUP &&
                buffer[1] === script_1.OPS.OP_HASH160 &&
                buffer[2] === 0x14 &&
                buffer[23] === script_1.OPS.OP_EQUALVERIFY &&
                buffer[24] === script_1.OPS.OP_CHECKSIG
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'pubKeyHash output';
        };

    }, {"../../script": 92}],
    105: [function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments)
    }, {"./input": 106, "./output": 107, "dup": 95}],
    106: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
// <scriptSig> {serialized scriptPubKey script}
            Object.defineProperty(exports, '__esModule', {value: true});
            const bscript = require('../../script');
            const p2ms = require('../multisig');
            const p2pk = require('../pubkey');
            const p2pkh = require('../pubkeyhash');
            const p2wpkho = require('../witnesspubkeyhash/output');
            const p2wsho = require('../witnessscripthash/output');

            function check(script, allowIncomplete) {
                const chunks = bscript.decompile(script);
                if (chunks.length < 1) return false;
                const lastChunk = chunks[chunks.length - 1];
                if (!Buffer.isBuffer(lastChunk)) return false;
                const scriptSigChunks = bscript.decompile(
                    bscript.compile(chunks.slice(0, -1)),
                );
                const redeemScriptChunks = bscript.decompile(lastChunk);
                // is redeemScript a valid script?
                if (!redeemScriptChunks) return false;
                // is redeemScriptSig push only?
                if (!bscript.isPushOnly(scriptSigChunks)) return false;
                // is witness?
                if (chunks.length === 1) {
                    return (
                        p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)
                    );
                }
                // match types
                if (
                    p2pkh.input.check(scriptSigChunks) &&
                    p2pkh.output.check(redeemScriptChunks)
                )
                    return true;
                if (
                    p2ms.input.check(scriptSigChunks, allowIncomplete) &&
                    p2ms.output.check(redeemScriptChunks)
                )
                    return true;
                if (
                    p2pk.input.check(scriptSigChunks) &&
                    p2pk.output.check(redeemScriptChunks)
                )
                    return true;
                return false;
            }

            exports.check = check;
            check.toJSON = () => {
                return 'scriptHash input';
            };

        }).call(this, {"isBuffer": require("../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})

    }, {
        "../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js": 8,
        "../../script": 92,
        "../multisig": 95,
        "../pubkey": 99,
        "../pubkeyhash": 102,
        "../witnesspubkeyhash/output": 112,
        "../witnessscripthash/output": 115
    }],
    107: [function (require, module, exports) {
        'use strict';
// OP_HASH160 {scriptHash} OP_EQUAL
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function check(script) {
            const buffer = bscript.compile(script);
            return (
                buffer.length === 23 &&
                buffer[0] === script_1.OPS.OP_HASH160 &&
                buffer[1] === 0x14 &&
                buffer[22] === script_1.OPS.OP_EQUAL
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'scriptHash output';
        };

    }, {"../../script": 92}],
    108: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const output = require('./output');
        exports.output = output;

    }, {"./output": 109}],
    109: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
// OP_RETURN {aa21a9ed} {commitment}
            Object.defineProperty(exports, '__esModule', {value: true});
            const bscript = require('../../script');
            const script_1 = require('../../script');
            const types = require('../../types');
            const typeforce = require('typeforce');
            const HEADER = Buffer.from('aa21a9ed', 'hex');

            function check(script) {
                const buffer = bscript.compile(script);
                return (
                    buffer.length > 37 &&
                    buffer[0] === script_1.OPS.OP_RETURN &&
                    buffer[1] === 0x24 &&
                    buffer.slice(2, 6).equals(HEADER)
                );
            }

            exports.check = check;
            check.toJSON = () => {
                return 'Witness commitment output';
            };

            function encode(commitment) {
                typeforce(types.Hash256bit, commitment);
                const buffer = Buffer.allocUnsafe(36);
                HEADER.copy(buffer, 0);
                commitment.copy(buffer, 4);
                return bscript.compile([script_1.OPS.OP_RETURN, buffer]);
            }

            exports.encode = encode;

            function decode(buffer) {
                typeforce(check, buffer);
                return bscript.decompile(buffer)[1].slice(4, 36);
            }

            exports.decode = decode;

        }).call(this, require("buffer").Buffer)

    }, {"../../script": 92, "../../types": 118, "buffer": 3, "typeforce": 185}],
    110: [function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments)
    }, {"./input": 111, "./output": 112, "dup": 95}],
    111: [function (require, module, exports) {
        'use strict';
// {signature} {pubKey}
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');

        function isCompressedCanonicalPubKey(pubKey) {
            return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;
        }

        function check(script) {
            const chunks = bscript.decompile(script);
            return (
                chunks.length === 2 &&
                bscript.isCanonicalScriptSignature(chunks[0]) &&
                isCompressedCanonicalPubKey(chunks[1])
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'witnessPubKeyHash input';
        };

    }, {"../../script": 92}],
    112: [function (require, module, exports) {
        'use strict';
// OP_0 {pubKeyHash}
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function check(script) {
            const buffer = bscript.compile(script);
            return (
                buffer.length === 22 &&
                buffer[0] === script_1.OPS.OP_0 &&
                buffer[1] === 0x14
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'Witness pubKeyHash output';
        };

    }, {"../../script": 92}],
    113: [function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments)
    }, {"./input": 114, "./output": 115, "dup": 95}],
    114: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
// <scriptSig> {serialized scriptPubKey script}
            Object.defineProperty(exports, '__esModule', {value: true});
            const bscript = require('../../script');
            const typeforce = require('typeforce');
            const p2ms = require('../multisig');
            const p2pk = require('../pubkey');
            const p2pkh = require('../pubkeyhash');

            function check(chunks, allowIncomplete) {
                typeforce(typeforce.Array, chunks);
                if (chunks.length < 1) return false;
                const witnessScript = chunks[chunks.length - 1];
                if (!Buffer.isBuffer(witnessScript)) return false;
                const witnessScriptChunks = bscript.decompile(witnessScript);
                // is witnessScript a valid script?
                if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;
                const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));
                // match types
                if (
                    p2pkh.input.check(witnessRawScriptSig) &&
                    p2pkh.output.check(witnessScriptChunks)
                )
                    return true;
                if (
                    p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&
                    p2ms.output.check(witnessScriptChunks)
                )
                    return true;
                if (
                    p2pk.input.check(witnessRawScriptSig) &&
                    p2pk.output.check(witnessScriptChunks)
                )
                    return true;
                return false;
            }

            exports.check = check;
            check.toJSON = () => {
                return 'witnessScriptHash input';
            };

        }).call(this, {"isBuffer": require("../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})

    }, {
        "../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js": 8,
        "../../script": 92,
        "../multisig": 95,
        "../pubkey": 99,
        "../pubkeyhash": 102,
        "typeforce": 185
    }],
    115: [function (require, module, exports) {
        'use strict';
// OP_0 {scriptHash}
        Object.defineProperty(exports, '__esModule', {value: true});
        const bscript = require('../../script');
        const script_1 = require('../../script');

        function check(script) {
            const buffer = bscript.compile(script);
            return (
                buffer.length === 34 &&
                buffer[0] === script_1.OPS.OP_0 &&
                buffer[1] === 0x20
            );
        }

        exports.check = check;
        check.toJSON = () => {
            return 'Witness scriptHash output';
        };

    }, {"../../script": 92}],
    116: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const bufferutils = require('./bufferutils');
            const bufferutils_1 = require('./bufferutils');
            const bcrypto = require('./crypto');
            const bscript = require('./script');
            const script_1 = require('./script');
            const types = require('./types');
            const typeforce = require('typeforce');
            const varuint = require('varuint-bitcoin');

            function varSliceSize(someScript) {
                const length = someScript.length;
                return varuint.encodingLength(length) + length;
            }

            function vectorSize(someVector) {
                const length = someVector.length;
                return (
                    varuint.encodingLength(length) +
                    someVector.reduce((sum, witness) => {
                        return sum + varSliceSize(witness);
                    }, 0)
                );
            }

            const EMPTY_SCRIPT = Buffer.allocUnsafe(0);
            const EMPTY_WITNESS = [];
            const ZERO = Buffer.from(
                '0000000000000000000000000000000000000000000000000000000000000000',
                'hex',
            );
            const ONE = Buffer.from(
                '0000000000000000000000000000000000000000000000000000000000000001',
                'hex',
            );
            const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
            const BLANK_OUTPUT = {
                script: EMPTY_SCRIPT,
                valueBuffer: VALUE_UINT64_MAX,
            };

            function isOutput(out) {
                return out.value !== undefined;
            }

            class Transaction {
                constructor() {
                    this.version = 1;
                    this.locktime = 0;
                    this.ins = [];
                    this.outs = [];
                }

                static fromBuffer(buffer, _NO_STRICT) {
                    let offset = 0;

                    function readSlice(n) {
                        offset += n;
                        return buffer.slice(offset - n, offset);
                    }

                    function readUInt32() {
                        const i = buffer.readUInt32LE(offset);
                        offset += 4;
                        return i;
                    }

                    function readInt32() {
                        const i = buffer.readInt32LE(offset);
                        offset += 4;
                        return i;
                    }

                    function readUInt64() {
                        const i = bufferutils.readUInt64LE(buffer, offset);
                        offset += 8;
                        return i;
                    }

                    function readVarInt() {
                        const vi = varuint.decode(buffer, offset);
                        offset += varuint.decode.bytes;
                        return vi;
                    }

                    function readVarSlice() {
                        return readSlice(readVarInt());
                    }

                    function readVector() {
                        const count = readVarInt();
                        const vector = [];
                        for (let i = 0; i < count; i++) vector.push(readVarSlice());
                        return vector;
                    }

                    const tx = new Transaction();
                    tx.version = readInt32();
                    const marker = buffer.readUInt8(offset);
                    const flag = buffer.readUInt8(offset + 1);
                    let hasWitnesses = false;
                    if (
                        marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
                        flag === Transaction.ADVANCED_TRANSACTION_FLAG
                    ) {
                        offset += 2;
                        hasWitnesses = true;
                    }
                    const vinLen = readVarInt();
                    for (let i = 0; i < vinLen; ++i) {
                        tx.ins.push({
                            hash: readSlice(32),
                            index: readUInt32(),
                            script: readVarSlice(),
                            sequence: readUInt32(),
                            witness: EMPTY_WITNESS,
                        });
                    }
                    const voutLen = readVarInt();
                    for (let i = 0; i < voutLen; ++i) {
                        tx.outs.push({
                            value: readUInt64(),
                            script: readVarSlice(),
                        });
                    }
                    if (hasWitnesses) {
                        for (let i = 0; i < vinLen; ++i) {
                            tx.ins[i].witness = readVector();
                        }
                        // was this pointless?
                        if (!tx.hasWitnesses())
                            throw new Error('Transaction has superfluous witness data');
                    }
                    tx.locktime = readUInt32();
                    if (_NO_STRICT) return tx;
                    if (offset !== buffer.length)
                        throw new Error('Transaction has unexpected data');
                    return tx;
                }

                static fromHex(hex) {
                    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
                }

                static isCoinbaseHash(buffer) {
                    typeforce(types.Hash256bit, buffer);
                    for (let i = 0; i < 32; ++i) {
                        if (buffer[i] !== 0) return false;
                    }
                    return true;
                }

                isCoinbase() {
                    return (
                        this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
                    );
                }

                addInput(hash, index, sequence, scriptSig) {
                    typeforce(
                        types.tuple(
                            types.Hash256bit,
                            types.UInt32,
                            types.maybe(types.UInt32),
                            types.maybe(types.Buffer),
                        ),
                        arguments,
                    );
                    if (types.Null(sequence)) {
                        sequence = Transaction.DEFAULT_SEQUENCE;
                    }
                    // Add the input and return the input's index
                    return (
                        this.ins.push({
                            hash,
                            index,
                            script: scriptSig || EMPTY_SCRIPT,
                            sequence: sequence,
                            witness: EMPTY_WITNESS,
                        }) - 1
                    );
                }

                addOutput(scriptPubKey, value) {
                    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
                    // Add the output and return the output's index
                    return (
                        this.outs.push({
                            script: scriptPubKey,
                            value,
                        }) - 1
                    );
                }

                hasWitnesses() {
                    return this.ins.some(x => {
                        return x.witness.length !== 0;
                    });
                }

                weight() {
                    const base = this.byteLength(false);
                    const total = this.byteLength(true);
                    return base * 3 + total;
                }

                virtualSize() {
                    return Math.ceil(this.weight() / 4);
                }

                byteLength(_ALLOW_WITNESS = true) {
                    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
                    return (
                        (hasWitnesses ? 10 : 8) +
                        varuint.encodingLength(this.ins.length) +
                        varuint.encodingLength(this.outs.length) +
                        this.ins.reduce((sum, input) => {
                            return sum + 40 + varSliceSize(input.script);
                        }, 0) +
                        this.outs.reduce((sum, output) => {
                            return sum + 8 + varSliceSize(output.script);
                        }, 0) +
                        (hasWitnesses
                            ? this.ins.reduce((sum, input) => {
                                return sum + vectorSize(input.witness);
                            }, 0)
                            : 0)
                    );
                }

                clone() {
                    const newTx = new Transaction();
                    newTx.version = this.version;
                    newTx.locktime = this.locktime;
                    newTx.ins = this.ins.map(txIn => {
                        return {
                            hash: txIn.hash,
                            index: txIn.index,
                            script: txIn.script,
                            sequence: txIn.sequence,
                            witness: txIn.witness,
                        };
                    });
                    newTx.outs = this.outs.map(txOut => {
                        return {
                            script: txOut.script,
                            value: txOut.value,
                        };
                    });
                    return newTx;
                }

                /**
                 * Hash transaction for signing a specific input.
                 *
                 * Bitcoin uses a different hash for each signed transaction input.
                 * This method copies the transaction, makes the necessary changes based on the
                 * hashType, and then hashes the result.
                 * This hash can then be used to sign the provided transaction input.
                 */
                hashForSignature(inIndex, prevOutScript, hashType) {
                    typeforce(
                        types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
                        arguments,
                    );
                    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
                    if (inIndex >= this.ins.length) return ONE;
                    // ignore OP_CODESEPARATOR
                    const ourScript = bscript.compile(
                        bscript.decompile(prevOutScript).filter(x => {
                            return x !== script_1.OPS.OP_CODESEPARATOR;
                        }),
                    );
                    const txTmp = this.clone();
                    // SIGHASH_NONE: ignore all outputs? (wildcard payee)
                    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
                        txTmp.outs = [];
                        // ignore sequence numbers (except at inIndex)
                        txTmp.ins.forEach((input, i) => {
                            if (i === inIndex) return;
                            input.sequence = 0;
                        });
                        // SIGHASH_SINGLE: ignore all outputs, except at the same index?
                    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
                        // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
                        if (inIndex >= this.outs.length) return ONE;
                        // truncate outputs after
                        txTmp.outs.length = inIndex + 1;
                        // "blank" outputs before
                        for (let i = 0; i < inIndex; i++) {
                            txTmp.outs[i] = BLANK_OUTPUT;
                        }
                        // ignore sequence numbers (except at inIndex)
                        txTmp.ins.forEach((input, y) => {
                            if (y === inIndex) return;
                            input.sequence = 0;
                        });
                    }
                    // SIGHASH_ANYONECANPAY: ignore inputs entirely?
                    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
                        txTmp.ins = [txTmp.ins[inIndex]];
                        txTmp.ins[0].script = ourScript;
                        // SIGHASH_ALL: only ignore input scripts
                    } else {
                        // "blank" others input scripts
                        txTmp.ins.forEach(input => {
                            input.script = EMPTY_SCRIPT;
                        });
                        txTmp.ins[inIndex].script = ourScript;
                    }
                    // serialize and hash
                    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
                    buffer.writeInt32LE(hashType, buffer.length - 4);
                    txTmp.__toBuffer(buffer, 0, false);
                    return bcrypto.hash256(buffer);
                }

                hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
                    typeforce(
                        types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
                        arguments,
                    );
                    let tbuffer = Buffer.from([]);
                    let toffset = 0;

                    function writeSlice(slice) {
                        toffset += slice.copy(tbuffer, toffset);
                    }

                    function writeUInt32(i) {
                        toffset = tbuffer.writeUInt32LE(i, toffset);
                    }

                    function writeUInt64(i) {
                        toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);
                    }

                    function writeVarInt(i) {
                        varuint.encode(i, tbuffer, toffset);
                        toffset += varuint.encode.bytes;
                    }

                    function writeVarSlice(slice) {
                        writeVarInt(slice.length);
                        writeSlice(slice);
                    }

                    let hashOutputs = ZERO;
                    let hashPrevouts = ZERO;
                    let hashSequence = ZERO;
                    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
                        tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
                        toffset = 0;
                        this.ins.forEach(txIn => {
                            writeSlice(txIn.hash);
                            writeUInt32(txIn.index);
                        });
                        hashPrevouts = bcrypto.hash256(tbuffer);
                    }
                    if (
                        !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
                        (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
                        (hashType & 0x1f) !== Transaction.SIGHASH_NONE
                    ) {
                        tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
                        toffset = 0;
                        this.ins.forEach(txIn => {
                            writeUInt32(txIn.sequence);
                        });
                        hashSequence = bcrypto.hash256(tbuffer);
                    }
                    if (
                        (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
                        (hashType & 0x1f) !== Transaction.SIGHASH_NONE
                    ) {
                        const txOutsSize = this.outs.reduce((sum, output) => {
                            return sum + 8 + varSliceSize(output.script);
                        }, 0);
                        tbuffer = Buffer.allocUnsafe(txOutsSize);
                        toffset = 0;
                        this.outs.forEach(out => {
                            writeUInt64(out.value);
                            writeVarSlice(out.script);
                        });
                        hashOutputs = bcrypto.hash256(tbuffer);
                    } else if (
                        (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
                        inIndex < this.outs.length
                    ) {
                        const output = this.outs[inIndex];
                        tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
                        toffset = 0;
                        writeUInt64(output.value);
                        writeVarSlice(output.script);
                        hashOutputs = bcrypto.hash256(tbuffer);
                    }
                    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
                    toffset = 0;
                    const input = this.ins[inIndex];
                    writeUInt32(this.version);
                    writeSlice(hashPrevouts);
                    writeSlice(hashSequence);
                    writeSlice(input.hash);
                    writeUInt32(input.index);
                    writeVarSlice(prevOutScript);
                    writeUInt64(value);
                    writeUInt32(input.sequence);
                    writeSlice(hashOutputs);
                    writeUInt32(this.locktime);
                    writeUInt32(hashType);
                    return bcrypto.hash256(tbuffer);
                }

                getHash(forWitness) {
                    // wtxid for coinbase is always 32 bytes of 0x00
                    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
                    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
                }

                getId() {
                    // transaction hash's are displayed in reverse order
                    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');
                }

                toBuffer(buffer, initialOffset) {
                    return this.__toBuffer(buffer, initialOffset, true);
                }

                toHex() {
                    return this.toBuffer(undefined, undefined).toString('hex');
                }

                setInputScript(index, scriptSig) {
                    typeforce(types.tuple(types.Number, types.Buffer), arguments);
                    this.ins[index].script = scriptSig;
                }

                setWitness(index, witness) {
                    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
                    this.ins[index].witness = witness;
                }

                __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
                    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
                    let offset = initialOffset || 0;

                    function writeSlice(slice) {
                        offset += slice.copy(buffer, offset);
                    }

                    function writeUInt8(i) {
                        offset = buffer.writeUInt8(i, offset);
                    }

                    function writeUInt32(i) {
                        offset = buffer.writeUInt32LE(i, offset);
                    }

                    function writeInt32(i) {
                        offset = buffer.writeInt32LE(i, offset);
                    }

                    function writeUInt64(i) {
                        offset = bufferutils.writeUInt64LE(buffer, i, offset);
                    }

                    function writeVarInt(i) {
                        varuint.encode(i, buffer, offset);
                        offset += varuint.encode.bytes;
                    }

                    function writeVarSlice(slice) {
                        writeVarInt(slice.length);
                        writeSlice(slice);
                    }

                    function writeVector(vector) {
                        writeVarInt(vector.length);
                        vector.forEach(writeVarSlice);
                    }

                    writeInt32(this.version);
                    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
                    if (hasWitnesses) {
                        writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
                        writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
                    }
                    writeVarInt(this.ins.length);
                    this.ins.forEach(txIn => {
                        writeSlice(txIn.hash);
                        writeUInt32(txIn.index);
                        writeVarSlice(txIn.script);
                        writeUInt32(txIn.sequence);
                    });
                    writeVarInt(this.outs.length);
                    this.outs.forEach(txOut => {
                        if (isOutput(txOut)) {
                            writeUInt64(txOut.value);
                        } else {
                            writeSlice(txOut.valueBuffer);
                        }
                        writeVarSlice(txOut.script);
                    });
                    if (hasWitnesses) {
                        this.ins.forEach(input => {
                            writeVector(input.witness);
                        });
                    }
                    writeUInt32(this.locktime);
                    // avoid slicing unless necessary
                    if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);
                    return buffer;
                }
            }

            Transaction.DEFAULT_SEQUENCE = 0xffffffff;
            Transaction.SIGHASH_ALL = 0x01;
            Transaction.SIGHASH_NONE = 0x02;
            Transaction.SIGHASH_SINGLE = 0x03;
            Transaction.SIGHASH_ANYONECANPAY = 0x80;
            Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
            Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
            exports.Transaction = Transaction;

        }).call(this, require("buffer").Buffer)

    }, {
        "./bufferutils": 76,
        "./crypto": 78,
        "./script": 92,
        "./types": 118,
        "buffer": 3,
        "typeforce": 185,
        "varuint-bitcoin": 187
    }],
    117: [function (require, module, exports) {
        (function (Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', {value: true});
            const baddress = require('./address');
            const bufferutils_1 = require('./bufferutils');
            const classify = require('./classify');
            const bcrypto = require('./crypto');
            const ECPair = require('./ecpair');
            const networks = require('./networks');
            const payments = require('./payments');
            const bscript = require('./script');
            const script_1 = require('./script');
            const transaction_1 = require('./transaction');
            const types = require('./types');
            const typeforce = require('typeforce');
            const SCRIPT_TYPES = classify.types;
            const PREVOUT_TYPES = new Set([
                // Raw
                'p2pkh',
                'p2pk',
                'p2wpkh',
                'p2ms',
                // P2SH wrapped
                'p2sh-p2pkh',
                'p2sh-p2pk',
                'p2sh-p2wpkh',
                'p2sh-p2ms',
                // P2WSH wrapped
                'p2wsh-p2pkh',
                'p2wsh-p2pk',
                'p2wsh-p2ms',
                // P2SH-P2WSH wrapper
                'p2sh-p2wsh-p2pkh',
                'p2sh-p2wsh-p2pk',
                'p2sh-p2wsh-p2ms',
            ]);

            function tfMessage(type, value, message) {
                try {
                    typeforce(type, value);
                } catch (err) {
                    throw new Error(message);
                }
            }

            function txIsString(tx) {
                return typeof tx === 'string' || tx instanceof String;
            }

            function txIsTransaction(tx) {
                return tx instanceof transaction_1.Transaction;
            }

            class TransactionBuilder {
                // WARNING: maximumFeeRate is __NOT__ to be relied on,
                //          it's just another potential safety mechanism (safety in-depth)
                constructor(network = networks.bitcoin, maximumFeeRate = 2500) {
                    this.network = network;
                    this.maximumFeeRate = maximumFeeRate;
                    this.__PREV_TX_SET = {};
                    this.__INPUTS = [];
                    this.__TX = new transaction_1.Transaction();
                    this.__TX.version = 2;
                    this.__USE_LOW_R = false;
                    console.warn(
                        'Deprecation Warning: TransactionBuilder will be removed in the future. ' +
                        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +
                        'are available in the transactions-psbt.js integration test file on our ' +
                        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +
                        'files as well.',
                    );
                }

                static fromTransaction(transaction, network) {
                    const txb = new TransactionBuilder(network);
                    // Copy transaction fields
                    txb.setVersion(transaction.version);
                    txb.setLockTime(transaction.locktime);
                    // Copy outputs (done first to avoid signature invalidation)
                    transaction.outs.forEach(txOut => {
                        txb.addOutput(txOut.script, txOut.value);
                    });
                    // Copy inputs
                    transaction.ins.forEach(txIn => {
                        txb.__addInputUnsafe(txIn.hash, txIn.index, {
                            sequence: txIn.sequence,
                            script: txIn.script,
                            witness: txIn.witness,
                        });
                    });
                    // fix some things not possible through the public API
                    txb.__INPUTS.forEach((input, i) => {
                        fixMultisigOrder(input, transaction, i);
                    });
                    return txb;
                }

                setLowR(setting) {
                    typeforce(typeforce.maybe(typeforce.Boolean), setting);
                    if (setting === undefined) {
                        setting = true;
                    }
                    this.__USE_LOW_R = setting;
                    return setting;
                }

                setLockTime(locktime) {
                    typeforce(types.UInt32, locktime);
                    // if any signatures exist, throw
                    if (
                        this.__INPUTS.some(input => {
                            if (!input.signatures) return false;
                            return input.signatures.some(s => s !== undefined);
                        })
                    ) {
                        throw new Error('No, this would invalidate signatures');
                    }
                    this.__TX.locktime = locktime;
                }

                setVersion(version) {
                    typeforce(types.UInt32, version);
                    // XXX: this might eventually become more complex depending on what the versions represent
                    this.__TX.version = version;
                }

                addInput(txHash, vout, sequence, prevOutScript) {
                    if (!this.__canModifyInputs()) {
                        throw new Error('No, this would invalidate signatures');
                    }
                    let value;
                    // is it a hex string?
                    if (txIsString(txHash)) {
                        // transaction hashs's are displayed in reverse order, un-reverse it
                        txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));
                        // is it a Transaction object?
                    } else if (txIsTransaction(txHash)) {
                        const txOut = txHash.outs[vout];
                        prevOutScript = txOut.script;
                        value = txOut.value;
                        txHash = txHash.getHash(false);
                    }
                    return this.__addInputUnsafe(txHash, vout, {
                        sequence,
                        prevOutScript,
                        value,
                    });
                }

                addOutput(scriptPubKey, value) {
                    if (!this.__canModifyOutputs()) {
                        throw new Error('No, this would invalidate signatures');
                    }
                    // Attempt to get a script if it's a base58 or bech32 address string
                    if (typeof scriptPubKey === 'string') {
                        scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);
                    }
                    return this.__TX.addOutput(scriptPubKey, value);
                }

                build() {
                    return this.__build(false);
                }

                buildIncomplete() {
                    return this.__build(true);
                }

                sign(
                    signParams,
                    keyPair,
                    redeemScript,
                    hashType,
                    witnessValue,
                    witnessScript,
                ) {
                    trySign(
                        getSigningData(
                            this.network,
                            this.__INPUTS,
                            this.__needsOutputs.bind(this),
                            this.__TX,
                            signParams,
                            keyPair,
                            redeemScript,
                            hashType,
                            witnessValue,
                            witnessScript,
                            this.__USE_LOW_R,
                        ),
                    );
                }

                __addInputUnsafe(txHash, vout, options) {
                    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {
                        throw new Error('coinbase inputs not supported');
                    }
                    const prevTxOut = txHash.toString('hex') + ':' + vout;
                    if (this.__PREV_TX_SET[prevTxOut] !== undefined)
                        throw new Error('Duplicate TxOut: ' + prevTxOut);
                    let input = {};
                    // derive what we can from the scriptSig
                    if (options.script !== undefined) {
                        input = expandInput(options.script, options.witness || []);
                    }
                    // if an input value was given, retain it
                    if (options.value !== undefined) {
                        input.value = options.value;
                    }
                    // derive what we can from the previous transactions output script
                    if (!input.prevOutScript && options.prevOutScript) {
                        let prevOutType;
                        if (!input.pubkeys && !input.signatures) {
                            const expanded = expandOutput(options.prevOutScript);
                            if (expanded.pubkeys) {
                                input.pubkeys = expanded.pubkeys;
                                input.signatures = expanded.signatures;
                            }
                            prevOutType = expanded.type;
                        }
                        input.prevOutScript = options.prevOutScript;
                        input.prevOutType = prevOutType || classify.output(options.prevOutScript);
                    }
                    const vin = this.__TX.addInput(
                        txHash,
                        vout,
                        options.sequence,
                        options.scriptSig,
                    );
                    this.__INPUTS[vin] = input;
                    this.__PREV_TX_SET[prevTxOut] = true;
                    return vin;
                }

                __build(allowIncomplete) {
                    if (!allowIncomplete) {
                        if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');
                        if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');
                    }
                    const tx = this.__TX.clone();
                    // create script signatures from inputs
                    this.__INPUTS.forEach((input, i) => {
                        if (!input.prevOutType && !allowIncomplete)
                            throw new Error('Transaction is not complete');
                        const result = build(input.prevOutType, input, allowIncomplete);
                        if (!result) {
                            if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)
                                throw new Error('Unknown input type');
                            if (!allowIncomplete) throw new Error('Not enough information');
                            return;
                        }
                        tx.setInputScript(i, result.input);
                        tx.setWitness(i, result.witness);
                    });
                    if (!allowIncomplete) {
                        // do not rely on this, its merely a last resort
                        if (this.__overMaximumFees(tx.virtualSize())) {
                            throw new Error('Transaction has absurd fees');
                        }
                    }
                    return tx;
                }

                __canModifyInputs() {
                    return this.__INPUTS.every(input => {
                        if (!input.signatures) return true;
                        return input.signatures.every(signature => {
                            if (!signature) return true;
                            const hashType = signatureHashType(signature);
                            // if SIGHASH_ANYONECANPAY is set, signatures would not
                            // be invalidated by more inputs
                            return (
                                (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0
                            );
                        });
                    });
                }

                __needsOutputs(signingHashType) {
                    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {
                        return this.__TX.outs.length === 0;
                    }
                    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs
                    // .build() will fail, but .buildIncomplete() is OK
                    return (
                        this.__TX.outs.length === 0 &&
                        this.__INPUTS.some(input => {
                            if (!input.signatures) return false;
                            return input.signatures.some(signature => {
                                if (!signature) return false; // no signature, no issue
                                const hashType = signatureHashType(signature);
                                if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs
                                return true; // SIGHASH_* does care
                            });
                        })
                    );
                }

                __canModifyOutputs() {
                    const nInputs = this.__TX.ins.length;
                    const nOutputs = this.__TX.outs.length;
                    return this.__INPUTS.every(input => {
                        if (input.signatures === undefined) return true;
                        return input.signatures.every(signature => {
                            if (!signature) return true;
                            const hashType = signatureHashType(signature);
                            const hashTypeMod = hashType & 0x1f;
                            if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;
                            if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {
                                // if SIGHASH_SINGLE is set, and nInputs > nOutputs
                                // some signatures would be invalidated by the addition
                                // of more outputs
                                return nInputs <= nOutputs;
                            }
                            return false;
                        });
                    });
                }

                __overMaximumFees(bytes) {
                    // not all inputs will have .value defined
                    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);
                    // but all outputs do, and if we have any input value
                    // we can immediately determine if the outputs are too small
                    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);
                    const fee = incoming - outgoing;
                    const feeRate = fee / bytes;
                    return feeRate > this.maximumFeeRate;
                }
            }

            exports.TransactionBuilder = TransactionBuilder;

            function expandInput(scriptSig, witnessStack, type, scriptPubKey) {
                if (scriptSig.length === 0 && witnessStack.length === 0) return {};
                if (!type) {
                    let ssType = classify.input(scriptSig, true);
                    let wsType = classify.witness(witnessStack, true);
                    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;
                    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;
                    type = ssType || wsType;
                }
                switch (type) {
                    case SCRIPT_TYPES.P2WPKH: {
                        const {output, pubkey, signature} = payments.p2wpkh({
                            witness: witnessStack,
                        });
                        return {
                            prevOutScript: output,
                            prevOutType: SCRIPT_TYPES.P2WPKH,
                            pubkeys: [pubkey],
                            signatures: [signature],
                        };
                    }
                    case SCRIPT_TYPES.P2PKH: {
                        const {output, pubkey, signature} = payments.p2pkh({
                            input: scriptSig,
                        });
                        return {
                            prevOutScript: output,
                            prevOutType: SCRIPT_TYPES.P2PKH,
                            pubkeys: [pubkey],
                            signatures: [signature],
                        };
                    }
                    case SCRIPT_TYPES.P2PK: {
                        const {signature} = payments.p2pk({input: scriptSig});
                        return {
                            prevOutType: SCRIPT_TYPES.P2PK,
                            pubkeys: [undefined],
                            signatures: [signature],
                        };
                    }
                    case SCRIPT_TYPES.P2MS: {
                        const {m, pubkeys, signatures} = payments.p2ms(
                            {
                                input: scriptSig,
                                output: scriptPubKey,
                            },
                            {allowIncomplete: true},
                        );
                        return {
                            prevOutType: SCRIPT_TYPES.P2MS,
                            pubkeys,
                            signatures,
                            maxSignatures: m,
                        };
                    }
                }
                if (type === SCRIPT_TYPES.P2SH) {
                    const {output, redeem} = payments.p2sh({
                        input: scriptSig,
                        witness: witnessStack,
                    });
                    const outputType = classify.output(redeem.output);
                    const expanded = expandInput(
                        redeem.input,
                        redeem.witness,
                        outputType,
                        redeem.output,
                    );
                    if (!expanded.prevOutType) return {};
                    return {
                        prevOutScript: output,
                        prevOutType: SCRIPT_TYPES.P2SH,
                        redeemScript: redeem.output,
                        redeemScriptType: expanded.prevOutType,
                        witnessScript: expanded.witnessScript,
                        witnessScriptType: expanded.witnessScriptType,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                    };
                }
                if (type === SCRIPT_TYPES.P2WSH) {
                    const {output, redeem} = payments.p2wsh({
                        input: scriptSig,
                        witness: witnessStack,
                    });
                    const outputType = classify.output(redeem.output);
                    let expanded;
                    if (outputType === SCRIPT_TYPES.P2WPKH) {
                        expanded = expandInput(redeem.input, redeem.witness, outputType);
                    } else {
                        expanded = expandInput(
                            bscript.compile(redeem.witness),
                            [],
                            outputType,
                            redeem.output,
                        );
                    }
                    if (!expanded.prevOutType) return {};
                    return {
                        prevOutScript: output,
                        prevOutType: SCRIPT_TYPES.P2WSH,
                        witnessScript: redeem.output,
                        witnessScriptType: expanded.prevOutType,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                    };
                }
                return {
                    prevOutType: SCRIPT_TYPES.NONSTANDARD,
                    prevOutScript: scriptSig,
                };
            }

// could be done in expandInput, but requires the original Transaction for hashForSignature
            function fixMultisigOrder(input, transaction, vin) {
                if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)
                    return;
                if (input.pubkeys.length === input.signatures.length) return;
                const unmatched = input.signatures.concat();
                input.signatures = input.pubkeys.map(pubKey => {
                    const keyPair = ECPair.fromPublicKey(pubKey);
                    let match;
                    // check for a signature
                    unmatched.some((signature, i) => {
                        // skip if undefined || OP_0
                        if (!signature) return false;
                        // TODO: avoid O(n) hashForSignature
                        const parsed = bscript.signature.decode(signature);
                        const hash = transaction.hashForSignature(
                            vin,
                            input.redeemScript,
                            parsed.hashType,
                        );
                        // skip if signature does not match pubKey
                        if (!keyPair.verify(hash, parsed.signature)) return false;
                        // remove matched signature from unmatched
                        unmatched[i] = undefined;
                        match = signature;
                        return true;
                    });
                    return match;
                });
            }

            function expandOutput(script, ourPubKey) {
                typeforce(types.Buffer, script);
                const type = classify.output(script);
                switch (type) {
                    case SCRIPT_TYPES.P2PKH: {
                        if (!ourPubKey) return {type};
                        // does our hash160(pubKey) match the output scripts?
                        const pkh1 = payments.p2pkh({output: script}).hash;
                        const pkh2 = bcrypto.hash160(ourPubKey);
                        if (!pkh1.equals(pkh2)) return {type};
                        return {
                            type,
                            pubkeys: [ourPubKey],
                            signatures: [undefined],
                        };
                    }
                    case SCRIPT_TYPES.P2WPKH: {
                        if (!ourPubKey) return {type};
                        // does our hash160(pubKey) match the output scripts?
                        const wpkh1 = payments.p2wpkh({output: script}).hash;
                        const wpkh2 = bcrypto.hash160(ourPubKey);
                        if (!wpkh1.equals(wpkh2)) return {type};
                        return {
                            type,
                            pubkeys: [ourPubKey],
                            signatures: [undefined],
                        };
                    }
                    case SCRIPT_TYPES.P2PK: {
                        const p2pk = payments.p2pk({output: script});
                        return {
                            type,
                            pubkeys: [p2pk.pubkey],
                            signatures: [undefined],
                        };
                    }
                    case SCRIPT_TYPES.P2MS: {
                        const p2ms = payments.p2ms({output: script});
                        return {
                            type,
                            pubkeys: p2ms.pubkeys,
                            signatures: p2ms.pubkeys.map(() => undefined),
                            maxSignatures: p2ms.m,
                        };
                    }
                }
                return {type};
            }

            function prepareInput(input, ourPubKey, redeemScript, witnessScript) {
                if (redeemScript && witnessScript) {
                    const p2wsh = payments.p2wsh({
                        redeem: {output: witnessScript},
                    });
                    const p2wshAlt = payments.p2wsh({output: redeemScript});
                    const p2sh = payments.p2sh({redeem: {output: redeemScript}});
                    const p2shAlt = payments.p2sh({redeem: p2wsh});
                    // enforces P2SH(P2WSH(...))
                    if (!p2wsh.hash.equals(p2wshAlt.hash))
                        throw new Error('Witness script inconsistent with prevOutScript');
                    if (!p2sh.hash.equals(p2shAlt.hash))
                        throw new Error('Redeem script inconsistent with prevOutScript');
                    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
                    if (!expanded.pubkeys)
                        throw new Error(
                            expanded.type +
                            ' not supported as witnessScript (' +
                            bscript.toASM(witnessScript) +
                            ')',
                        );
                    if (input.signatures && input.signatures.some(x => x !== undefined)) {
                        expanded.signatures = input.signatures;
                    }
                    const signScript = witnessScript;
                    if (expanded.type === SCRIPT_TYPES.P2WPKH)
                        throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');
                    return {
                        redeemScript,
                        redeemScriptType: SCRIPT_TYPES.P2WSH,
                        witnessScript,
                        witnessScriptType: expanded.type,
                        prevOutType: SCRIPT_TYPES.P2SH,
                        prevOutScript: p2sh.output,
                        hasWitness: true,
                        signScript,
                        signType: expanded.type,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                        maxSignatures: expanded.maxSignatures,
                    };
                }
                if (redeemScript) {
                    const p2sh = payments.p2sh({redeem: {output: redeemScript}});
                    if (input.prevOutScript) {
                        let p2shAlt;
                        try {
                            p2shAlt = payments.p2sh({output: input.prevOutScript});
                        } catch (e) {
                            throw new Error('PrevOutScript must be P2SH');
                        }
                        if (!p2sh.hash.equals(p2shAlt.hash))
                            throw new Error('Redeem script inconsistent with prevOutScript');
                    }
                    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);
                    if (!expanded.pubkeys)
                        throw new Error(
                            expanded.type +
                            ' not supported as redeemScript (' +
                            bscript.toASM(redeemScript) +
                            ')',
                        );
                    if (input.signatures && input.signatures.some(x => x !== undefined)) {
                        expanded.signatures = input.signatures;
                    }
                    let signScript = redeemScript;
                    if (expanded.type === SCRIPT_TYPES.P2WPKH) {
                        signScript = payments.p2pkh({pubkey: expanded.pubkeys[0]}).output;
                    }
                    return {
                        redeemScript,
                        redeemScriptType: expanded.type,
                        prevOutType: SCRIPT_TYPES.P2SH,
                        prevOutScript: p2sh.output,
                        hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
                        signScript,
                        signType: expanded.type,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                        maxSignatures: expanded.maxSignatures,
                    };
                }
                if (witnessScript) {
                    const p2wsh = payments.p2wsh({redeem: {output: witnessScript}});
                    if (input.prevOutScript) {
                        const p2wshAlt = payments.p2wsh({output: input.prevOutScript});
                        if (!p2wsh.hash.equals(p2wshAlt.hash))
                            throw new Error('Witness script inconsistent with prevOutScript');
                    }
                    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
                    if (!expanded.pubkeys)
                        throw new Error(
                            expanded.type +
                            ' not supported as witnessScript (' +
                            bscript.toASM(witnessScript) +
                            ')',
                        );
                    if (input.signatures && input.signatures.some(x => x !== undefined)) {
                        expanded.signatures = input.signatures;
                    }
                    const signScript = witnessScript;
                    if (expanded.type === SCRIPT_TYPES.P2WPKH)
                        throw new Error('P2WSH(P2WPKH) is a consensus failure');
                    return {
                        witnessScript,
                        witnessScriptType: expanded.type,
                        prevOutType: SCRIPT_TYPES.P2WSH,
                        prevOutScript: p2wsh.output,
                        hasWitness: true,
                        signScript,
                        signType: expanded.type,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                        maxSignatures: expanded.maxSignatures,
                    };
                }
                if (input.prevOutType && input.prevOutScript) {
                    // embedded scripts are not possible without extra information
                    if (input.prevOutType === SCRIPT_TYPES.P2SH)
                        throw new Error(
                            'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',
                        );
                    if (input.prevOutType === SCRIPT_TYPES.P2WSH)
                        throw new Error(
                            'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',
                        );
                    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');
                    const expanded = expandOutput(input.prevOutScript, ourPubKey);
                    if (!expanded.pubkeys)
                        throw new Error(
                            expanded.type +
                            ' not supported (' +
                            bscript.toASM(input.prevOutScript) +
                            ')',
                        );
                    if (input.signatures && input.signatures.some(x => x !== undefined)) {
                        expanded.signatures = input.signatures;
                    }
                    let signScript = input.prevOutScript;
                    if (expanded.type === SCRIPT_TYPES.P2WPKH) {
                        signScript = payments.p2pkh({pubkey: expanded.pubkeys[0]}).output;
                    }
                    return {
                        prevOutType: expanded.type,
                        prevOutScript: input.prevOutScript,
                        hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
                        signScript,
                        signType: expanded.type,
                        pubkeys: expanded.pubkeys,
                        signatures: expanded.signatures,
                        maxSignatures: expanded.maxSignatures,
                    };
                }
                const prevOutScript = payments.p2pkh({pubkey: ourPubKey}).output;
                return {
                    prevOutType: SCRIPT_TYPES.P2PKH,
                    prevOutScript,
                    hasWitness: false,
                    signScript: prevOutScript,
                    signType: SCRIPT_TYPES.P2PKH,
                    pubkeys: [ourPubKey],
                    signatures: [undefined],
                };
            }

            function build(type, input, allowIncomplete) {
                const pubkeys = input.pubkeys || [];
                let signatures = input.signatures || [];
                switch (type) {
                    case SCRIPT_TYPES.P2PKH: {
                        if (pubkeys.length === 0) break;
                        if (signatures.length === 0) break;
                        return payments.p2pkh({pubkey: pubkeys[0], signature: signatures[0]});
                    }
                    case SCRIPT_TYPES.P2WPKH: {
                        if (pubkeys.length === 0) break;
                        if (signatures.length === 0) break;
                        return payments.p2wpkh({pubkey: pubkeys[0], signature: signatures[0]});
                    }
                    case SCRIPT_TYPES.P2PK: {
                        if (pubkeys.length === 0) break;
                        if (signatures.length === 0) break;
                        return payments.p2pk({signature: signatures[0]});
                    }
                    case SCRIPT_TYPES.P2MS: {
                        const m = input.maxSignatures;
                        if (allowIncomplete) {
                            signatures = signatures.map(x => x || script_1.OPS.OP_0);
                        } else {
                            signatures = signatures.filter(x => x);
                        }
                        // if the transaction is not not complete (complete), or if signatures.length === m, validate
                        // otherwise, the number of OP_0's may be >= m, so don't validate (boo)
                        const validate = !allowIncomplete || m === signatures.length;
                        return payments.p2ms(
                            {m, pubkeys, signatures},
                            {allowIncomplete, validate},
                        );
                    }
                    case SCRIPT_TYPES.P2SH: {
                        const redeem = build(input.redeemScriptType, input, allowIncomplete);
                        if (!redeem) return;
                        return payments.p2sh({
                            redeem: {
                                output: redeem.output || input.redeemScript,
                                input: redeem.input,
                                witness: redeem.witness,
                            },
                        });
                    }
                    case SCRIPT_TYPES.P2WSH: {
                        const redeem = build(input.witnessScriptType, input, allowIncomplete);
                        if (!redeem) return;
                        return payments.p2wsh({
                            redeem: {
                                output: input.witnessScript,
                                input: redeem.input,
                                witness: redeem.witness,
                            },
                        });
                    }
                }
            }

            function canSign(input) {
                return (
                    input.signScript !== undefined &&
                    input.signType !== undefined &&
                    input.pubkeys !== undefined &&
                    input.signatures !== undefined &&
                    input.signatures.length === input.pubkeys.length &&
                    input.pubkeys.length > 0 &&
                    (input.hasWitness === false || input.value !== undefined)
                );
            }

            function signatureHashType(buffer) {
                return buffer.readUInt8(buffer.length - 1);
            }

            function checkSignArgs(inputs, signParams) {
                if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {
                    throw new TypeError(
                        `Unknown prevOutScriptType "${signParams.prevOutScriptType}"`,
                    );
                }
                tfMessage(
                    typeforce.Number,
                    signParams.vin,
                    `sign must include vin parameter as Number (input index)`,
                );
                tfMessage(
                    types.Signer,
                    signParams.keyPair,
                    `sign must include keyPair parameter as Signer interface`,
                );
                tfMessage(
                    typeforce.maybe(typeforce.Number),
                    signParams.hashType,
                    `sign hashType parameter must be a number`,
                );
                const prevOutType = (inputs[signParams.vin] || []).prevOutType;
                const posType = signParams.prevOutScriptType;
                switch (posType) {
                    case 'p2pkh':
                        if (prevOutType && prevOutType !== 'pubkeyhash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.redeemScript,
                            `${posType} requires NO redeemScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessValue,
                            `${posType} requires NO witnessValue`,
                        );
                        break;
                    case 'p2pk':
                        if (prevOutType && prevOutType !== 'pubkey') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.redeemScript,
                            `${posType} requires NO redeemScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessValue,
                            `${posType} requires NO witnessValue`,
                        );
                        break;
                    case 'p2wpkh':
                        if (prevOutType && prevOutType !== 'witnesspubkeyhash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.redeemScript,
                            `${posType} requires NO redeemScript`,
                        );
                        tfMessage(
                            types.Satoshi,
                            signParams.witnessValue,
                            `${posType} requires witnessValue`,
                        );
                        break;
                    case 'p2ms':
                        if (prevOutType && prevOutType !== 'multisig') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.redeemScript,
                            `${posType} requires NO redeemScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessValue,
                            `${posType} requires NO witnessValue`,
                        );
                        break;
                    case 'p2sh-p2wpkh':
                        if (prevOutType && prevOutType !== 'scripthash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.Buffer,
                            signParams.redeemScript,
                            `${posType} requires redeemScript`,
                        );
                        tfMessage(
                            types.Satoshi,
                            signParams.witnessValue,
                            `${posType} requires witnessValue`,
                        );
                        break;
                    case 'p2sh-p2ms':
                    case 'p2sh-p2pk':
                    case 'p2sh-p2pkh':
                        if (prevOutType && prevOutType !== 'scripthash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessScript,
                            `${posType} requires NO witnessScript`,
                        );
                        tfMessage(
                            typeforce.Buffer,
                            signParams.redeemScript,
                            `${posType} requires redeemScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.witnessValue,
                            `${posType} requires NO witnessValue`,
                        );
                        break;
                    case 'p2wsh-p2ms':
                    case 'p2wsh-p2pk':
                    case 'p2wsh-p2pkh':
                        if (prevOutType && prevOutType !== 'witnessscripthash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.Buffer,
                            signParams.witnessScript,
                            `${posType} requires witnessScript`,
                        );
                        tfMessage(
                            typeforce.value(undefined),
                            signParams.redeemScript,
                            `${posType} requires NO redeemScript`,
                        );
                        tfMessage(
                            types.Satoshi,
                            signParams.witnessValue,
                            `${posType} requires witnessValue`,
                        );
                        break;
                    case 'p2sh-p2wsh-p2ms':
                    case 'p2sh-p2wsh-p2pk':
                    case 'p2sh-p2wsh-p2pkh':
                        if (prevOutType && prevOutType !== 'scripthash') {
                            throw new TypeError(
                                `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
                            );
                        }
                        tfMessage(
                            typeforce.Buffer,
                            signParams.witnessScript,
                            `${posType} requires witnessScript`,
                        );
                        tfMessage(
                            typeforce.Buffer,
                            signParams.redeemScript,
                            `${posType} requires witnessScript`,
                        );
                        tfMessage(
                            types.Satoshi,
                            signParams.witnessValue,
                            `${posType} requires witnessScript`,
                        );
                        break;
                }
            }

            function trySign({
                                 input,
                                 ourPubKey,
                                 keyPair,
                                 signatureHash,
                                 hashType,
                                 useLowR,
                             }) {
                // enforce in order signing of public keys
                let signed = false;
                for (const [i, pubKey] of input.pubkeys.entries()) {
                    if (!ourPubKey.equals(pubKey)) continue;
                    if (input.signatures[i]) throw new Error('Signature already exists');
                    // TODO: add tests
                    if (ourPubKey.length !== 33 && input.hasWitness) {
                        throw new Error(
                            'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',
                        );
                    }
                    const signature = keyPair.sign(signatureHash, useLowR);
                    input.signatures[i] = bscript.signature.encode(signature, hashType);
                    signed = true;
                }
                if (!signed) throw new Error('Key pair cannot sign for this input');
            }

            function getSigningData(
                network,
                inputs,
                needsOutputs,
                tx,
                signParams,
                keyPair,
                redeemScript,
                hashType,
                witnessValue,
                witnessScript,
                useLowR,
            ) {
                let vin;
                if (typeof signParams === 'number') {
                    console.warn(
                        'DEPRECATED: TransactionBuilder sign method arguments ' +
                        'will change in v6, please use the TxbSignArg interface',
                    );
                    vin = signParams;
                } else if (typeof signParams === 'object') {
                    checkSignArgs(inputs, signParams);
                    ({
                        vin,
                        keyPair,
                        redeemScript,
                        hashType,
                        witnessValue,
                        witnessScript,
                    } = signParams);
                } else {
                    throw new TypeError(
                        'TransactionBuilder sign first arg must be TxbSignArg or number',
                    );
                }
                if (keyPair === undefined) {
                    throw new Error('sign requires keypair');
                }
                // TODO: remove keyPair.network matching in 4.0.0
                if (keyPair.network && keyPair.network !== network)
                    throw new TypeError('Inconsistent network');
                if (!inputs[vin]) throw new Error('No input at index: ' + vin);
                hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;
                if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');
                const input = inputs[vin];
                // if redeemScript was previously provided, enforce consistency
                if (
                    input.redeemScript !== undefined &&
                    redeemScript &&
                    !input.redeemScript.equals(redeemScript)
                ) {
                    throw new Error('Inconsistent redeemScript');
                }
                const ourPubKey =
                    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());
                if (!canSign(input)) {
                    if (witnessValue !== undefined) {
                        if (input.value !== undefined && input.value !== witnessValue)
                            throw new Error('Input did not match witnessValue');
                        typeforce(types.Satoshi, witnessValue);
                        input.value = witnessValue;
                    }
                    if (!canSign(input)) {
                        const prepared = prepareInput(
                            input,
                            ourPubKey,
                            redeemScript,
                            witnessScript,
                        );
                        // updates inline
                        Object.assign(input, prepared);
                    }
                    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');
                }
                // ready to sign
                let signatureHash;
                if (input.hasWitness) {
                    signatureHash = tx.hashForWitnessV0(
                        vin,
                        input.signScript,
                        input.value,
                        hashType,
                    );
                } else {
                    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);
                }
                return {
                    input,
                    ourPubKey,
                    keyPair,
                    signatureHash,
                    hashType,
                    useLowR: !!useLowR,
                };
            }

        }).call(this, require("buffer").Buffer)

    }, {
        "./address": 74,
        "./bufferutils": 76,
        "./classify": 77,
        "./crypto": 78,
        "./ecpair": 79,
        "./networks": 81,
        "./payments": 83,
        "./script": 92,
        "./transaction": 116,
        "./types": 118,
        "buffer": 3,
        "typeforce": 185
    }],
    118: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', {value: true});
        const typeforce = require('typeforce');
        const UINT31_MAX = Math.pow(2, 31) - 1;

        function UInt31(value) {
            return typeforce.UInt32(value) && value <= UINT31_MAX;
        }

        exports.UInt31 = UInt31;

        function BIP32Path(value) {
            return typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
        }

        exports.BIP32Path = BIP32Path;
        BIP32Path.toJSON = () => {
            return 'BIP32 derivation path';
        };

        function Signer(obj) {
            return (
                (typeforce.Buffer(obj.publicKey) ||
                    typeof obj.getPublicKey === 'function') &&
                typeof obj.sign === 'function'
            );
        }

        exports.Signer = Signer;
        const SATOSHI_MAX = 21 * 1e14;

        function Satoshi(value) {
            return typeforce.UInt53(value) && value <= SATOSHI_MAX;
        }

        exports.Satoshi = Satoshi;
// external dependent types
        exports.ECPoint = typeforce.quacksLike('Point');
// exposed, external API
        exports.Network = typeforce.compile({
            messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
            bip32: {
                public: typeforce.UInt32,
                private: typeforce.UInt32,
            },
            pubKeyHash: typeforce.UInt8,
            scriptHash: typeforce.UInt8,
            wif: typeforce.UInt8,
        });
        exports.Buffer256bit = typeforce.BufferN(32);
        exports.Hash160bit = typeforce.BufferN(20);
        exports.Hash256bit = typeforce.BufferN(32);
        exports.Number = typeforce.Number; // tslint:disable-line variable-name
        exports.Array = typeforce.Array;
        exports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name
        exports.String = typeforce.String; // tslint:disable-line variable-name
        exports.Buffer = typeforce.Buffer;
        exports.Hex = typeforce.Hex;
        exports.maybe = typeforce.maybe;
        exports.tuple = typeforce.tuple;
        exports.UInt8 = typeforce.UInt8;
        exports.UInt32 = typeforce.UInt32;
        exports.Function = typeforce.Function;
        exports.BufferN = typeforce.BufferN;
        exports.Null = typeforce.Null;
        exports.oneOf = typeforce.oneOf;

    }, {"typeforce": 185}],
    119: [function (require, module, exports) {
        (function (module, exports) {
            'use strict';

            // Utils
            function assert(val, msg) {
                if (!val) throw new Error(msg || 'Assertion failed');
            }

            // Could use `inherits` module, but don't want to move from single file
            // architecture yet.
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function () {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }

            // BN

            function BN(number, base, endian) {
                if (BN.isBN(number)) {
                    return number;
                }

                this.negative = 0;
                this.words = null;
                this.length = 0;

                // Reduction context
                this.red = null;

                if (number !== null) {
                    if (base === 'le' || base === 'be') {
                        endian = base;
                        base = 10;
                    }

                    this._init(number || 0, base || 10, endian || 'be');
                }
            }

            if (typeof module === 'object') {
                module.exports = BN;
            } else {
                exports.BN = BN;
            }

            BN.BN = BN;
            BN.wordSize = 26;

            var Buffer;
            try {
                Buffer = require('buffer').Buffer;
            } catch (e) {
            }

            BN.isBN = function isBN(num) {
                if (num instanceof BN) {
                    return true;
                }

                return num !== null && typeof num === 'object' &&
                    num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
            };

            BN.max = function max(left, right) {
                if (left.cmp(right) > 0) return left;
                return right;
            };

            BN.min = function min(left, right) {
                if (left.cmp(right) < 0) return left;
                return right;
            };

            BN.prototype._init = function init(number, base, endian) {
                if (typeof number === 'number') {
                    return this._initNumber(number, base, endian);
                }

                if (typeof number === 'object') {
                    return this._initArray(number, base, endian);
                }

                if (base === 'hex') {
                    base = 16;
                }
                assert(base === (base | 0) && base >= 2 && base <= 36);

                number = number.toString().replace(/\s+/g, '');
                var start = 0;
                if (number[0] === '-') {
                    start++;
                }

                if (base === 16) {
                    this._parseHex(number, start);
                } else {
                    this._parseBase(number, base, start);
                }

                if (number[0] === '-') {
                    this.negative = 1;
                }

                this.strip();

                if (endian !== 'le') return;

                this._initArray(this.toArray(), base, endian);
            };

            BN.prototype._initNumber = function _initNumber(number, base, endian) {
                if (number < 0) {
                    this.negative = 1;
                    number = -number;
                }
                if (number < 0x4000000) {
                    this.words = [number & 0x3ffffff];
                    this.length = 1;
                } else if (number < 0x10000000000000) {
                    this.words = [
                        number & 0x3ffffff,
                        (number / 0x4000000) & 0x3ffffff
                    ];
                    this.length = 2;
                } else {
                    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
                    this.words = [
                        number & 0x3ffffff,
                        (number / 0x4000000) & 0x3ffffff,
                        1
                    ];
                    this.length = 3;
                }

                if (endian !== 'le') return;

                // Reverse the bytes
                this._initArray(this.toArray(), base, endian);
            };

            BN.prototype._initArray = function _initArray(number, base, endian) {
                // Perhaps a Uint8Array
                assert(typeof number.length === 'number');
                if (number.length <= 0) {
                    this.words = [0];
                    this.length = 1;
                    return this;
                }

                this.length = Math.ceil(number.length / 3);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }

                var j, w;
                var off = 0;
                if (endian === 'be') {
                    for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                } else if (endian === 'le') {
                    for (i = 0, j = 0; i < number.length; i += 3) {
                        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                }
                return this.strip();
            };

            function parseHex(str, start, end) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;

                    r <<= 4;

                    // 'a' - 'f'
                    if (c >= 49 && c <= 54) {
                        r |= c - 49 + 0xa;

                        // 'A' - 'F'
                    } else if (c >= 17 && c <= 22) {
                        r |= c - 17 + 0xa;

                        // '0' - '9'
                    } else {
                        r |= c & 0xf;
                    }
                }
                return r;
            }

            BN.prototype._parseHex = function _parseHex(number, start) {
                // Create possibly bigger array to ensure that it fits the number
                this.length = Math.ceil((number.length - start) / 6);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }

                var j, w;
                // Scan 24-bit chunks and add them to the number
                var off = 0;
                for (i = number.length - 6, j = 0; i >= start; i -= 6) {
                    w = parseHex(number, i, i + 6);
                    this.words[j] |= (w << off) & 0x3ffffff;
                    // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
                    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                    off += 24;
                    if (off >= 26) {
                        off -= 26;
                        j++;
                    }
                }
                if (i + 6 !== start) {
                    w = parseHex(number, start, i + 6);
                    this.words[j] |= (w << off) & 0x3ffffff;
                    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                }
                this.strip();
            };

            function parseBase(str, start, end, mul) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;

                    r *= mul;

                    // 'a'
                    if (c >= 49) {
                        r += c - 49 + 0xa;

                        // 'A'
                    } else if (c >= 17) {
                        r += c - 17 + 0xa;

                        // '0' - '9'
                    } else {
                        r += c;
                    }
                }
                return r;
            }

            BN.prototype._parseBase = function _parseBase(number, base, start) {
                // Initialize as zero
                this.words = [0];
                this.length = 1;

                // Find length of limb in base
                for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
                    limbLen++;
                }
                limbLen--;
                limbPow = (limbPow / base) | 0;

                var total = number.length - start;
                var mod = total % limbLen;
                var end = Math.min(total, total - mod) + start;

                var word = 0;
                for (var i = start; i < end; i += limbLen) {
                    word = parseBase(number, i, i + limbLen, base);

                    this.imuln(limbPow);
                    if (this.words[0] + word < 0x4000000) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }

                if (mod !== 0) {
                    var pow = 1;
                    word = parseBase(number, i, number.length, base);

                    for (i = 0; i < mod; i++) {
                        pow *= base;
                    }

                    this.imuln(pow);
                    if (this.words[0] + word < 0x4000000) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }
            };

            BN.prototype.copy = function copy(dest) {
                dest.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    dest.words[i] = this.words[i];
                }
                dest.length = this.length;
                dest.negative = this.negative;
                dest.red = this.red;
            };

            BN.prototype.clone = function clone() {
                var r = new BN(null);
                this.copy(r);
                return r;
            };

            BN.prototype._expand = function _expand(size) {
                while (this.length < size) {
                    this.words[this.length++] = 0;
                }
                return this;
            };

            // Remove leading `0` from `this`
            BN.prototype.strip = function strip() {
                while (this.length > 1 && this.words[this.length - 1] === 0) {
                    this.length--;
                }
                return this._normSign();
            };

            BN.prototype._normSign = function _normSign() {
                // -0 = 0
                if (this.length === 1 && this.words[0] === 0) {
                    this.negative = 0;
                }
                return this;
            };

            BN.prototype.inspect = function inspect() {
                return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            };

            /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

            var zeros = [
                '',
                '0',
                '00',
                '000',
                '0000',
                '00000',
                '000000',
                '0000000',
                '00000000',
                '000000000',
                '0000000000',
                '00000000000',
                '000000000000',
                '0000000000000',
                '00000000000000',
                '000000000000000',
                '0000000000000000',
                '00000000000000000',
                '000000000000000000',
                '0000000000000000000',
                '00000000000000000000',
                '000000000000000000000',
                '0000000000000000000000',
                '00000000000000000000000',
                '000000000000000000000000',
                '0000000000000000000000000'
            ];

            var groupSizes = [
                0, 0,
                25, 16, 12, 11, 10, 9, 8,
                8, 7, 7, 7, 7, 6, 6,
                6, 6, 6, 6, 6, 5, 5,
                5, 5, 5, 5, 5, 5, 5,
                5, 5, 5, 5, 5, 5, 5
            ];

            var groupBases = [
                0, 0,
                33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
                43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
                16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
                6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
                24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
            ];

            BN.prototype.toString = function toString(base, padding) {
                base = base || 10;
                padding = padding | 0 || 1;

                var out;
                if (base === 16 || base === 'hex') {
                    out = '';
                    var off = 0;
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = (((w << off) | carry) & 0xffffff).toString(16);
                        carry = (w >>> (24 - off)) & 0xffffff;
                        if (carry !== 0 || i !== this.length - 1) {
                            out = zeros[6 - word.length] + word + out;
                        } else {
                            out = word + out;
                        }
                        off += 2;
                        if (off >= 26) {
                            off -= 26;
                            i--;
                        }
                    }
                    if (carry !== 0) {
                        out = carry.toString(16) + out;
                    }
                    while (out.length % padding !== 0) {
                        out = '0' + out;
                    }
                    if (this.negative !== 0) {
                        out = '-' + out;
                    }
                    return out;
                }

                if (base === (base | 0) && base >= 2 && base <= 36) {
                    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
                    var groupSize = groupSizes[base];
                    // var groupBase = Math.pow(base, groupSize);
                    var groupBase = groupBases[base];
                    out = '';
                    var c = this.clone();
                    c.negative = 0;
                    while (!c.isZero()) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);

                        if (!c.isZero()) {
                            out = zeros[groupSize - r.length] + r + out;
                        } else {
                            out = r + out;
                        }
                    }
                    if (this.isZero()) {
                        out = '0' + out;
                    }
                    while (out.length % padding !== 0) {
                        out = '0' + out;
                    }
                    if (this.negative !== 0) {
                        out = '-' + out;
                    }
                    return out;
                }

                assert(false, 'Base should be between 2 and 36');
            };

            BN.prototype.toNumber = function toNumber() {
                var ret = this.words[0];
                if (this.length === 2) {
                    ret += this.words[1] * 0x4000000;
                } else if (this.length === 3 && this.words[2] === 0x01) {
                    // NOTE: at this stage it is known that the top bit is set
                    ret += 0x10000000000000 + (this.words[1] * 0x4000000);
                } else if (this.length > 2) {
                    assert(false, 'Number can only safely store up to 53 bits');
                }
                return (this.negative !== 0) ? -ret : ret;
            };

            BN.prototype.toJSON = function toJSON() {
                return this.toString(16);
            };

            BN.prototype.toBuffer = function toBuffer(endian, length) {
                assert(typeof Buffer !== 'undefined');
                return this.toArrayLike(Buffer, endian, length);
            };

            BN.prototype.toArray = function toArray(endian, length) {
                return this.toArrayLike(Array, endian, length);
            };

            BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
                var byteLength = this.byteLength();
                var reqLength = length || Math.max(1, byteLength);
                assert(byteLength <= reqLength, 'byte array longer than desired length');
                assert(reqLength > 0, 'Requested array length <= 0');

                this.strip();
                var littleEndian = endian === 'le';
                var res = new ArrayType(reqLength);

                var b, i;
                var q = this.clone();
                if (!littleEndian) {
                    // Assume big-endian
                    for (i = 0; i < reqLength - byteLength; i++) {
                        res[i] = 0;
                    }

                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(0xff);
                        q.iushrn(8);

                        res[reqLength - i - 1] = b;
                    }
                } else {
                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(0xff);
                        q.iushrn(8);

                        res[i] = b;
                    }

                    for (; i < reqLength; i++) {
                        res[i] = 0;
                    }
                }

                return res;
            };

            if (Math.clz32) {
                BN.prototype._countBits = function _countBits(w) {
                    return 32 - Math.clz32(w);
                };
            } else {
                BN.prototype._countBits = function _countBits(w) {
                    var t = w;
                    var r = 0;
                    if (t >= 0x1000) {
                        r += 13;
                        t >>>= 13;
                    }
                    if (t >= 0x40) {
                        r += 7;
                        t >>>= 7;
                    }
                    if (t >= 0x8) {
                        r += 4;
                        t >>>= 4;
                    }
                    if (t >= 0x02) {
                        r += 2;
                        t >>>= 2;
                    }
                    return r + t;
                };
            }

            BN.prototype._zeroBits = function _zeroBits(w) {
                // Short-cut
                if (w === 0) return 26;

                var t = w;
                var r = 0;
                if ((t & 0x1fff) === 0) {
                    r += 13;
                    t >>>= 13;
                }
                if ((t & 0x7f) === 0) {
                    r += 7;
                    t >>>= 7;
                }
                if ((t & 0xf) === 0) {
                    r += 4;
                    t >>>= 4;
                }
                if ((t & 0x3) === 0) {
                    r += 2;
                    t >>>= 2;
                }
                if ((t & 0x1) === 0) {
                    r++;
                }
                return r;
            };

            // Return number of used bits in a BN
            BN.prototype.bitLength = function bitLength() {
                var w = this.words[this.length - 1];
                var hi = this._countBits(w);
                return (this.length - 1) * 26 + hi;
            };

            function toBitArray(num) {
                var w = new Array(num.bitLength());

                for (var bit = 0; bit < w.length; bit++) {
                    var off = (bit / 26) | 0;
                    var wbit = bit % 26;

                    w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
                }

                return w;
            }

            // Number of trailing zero bits
            BN.prototype.zeroBits = function zeroBits() {
                if (this.isZero()) return 0;

                var r = 0;
                for (var i = 0; i < this.length; i++) {
                    var b = this._zeroBits(this.words[i]);
                    r += b;
                    if (b !== 26) break;
                }
                return r;
            };

            BN.prototype.byteLength = function byteLength() {
                return Math.ceil(this.bitLength() / 8);
            };

            BN.prototype.toTwos = function toTwos(width) {
                if (this.negative !== 0) {
                    return this.abs().inotn(width).iaddn(1);
                }
                return this.clone();
            };

            BN.prototype.fromTwos = function fromTwos(width) {
                if (this.testn(width - 1)) {
                    return this.notn(width).iaddn(1).ineg();
                }
                return this.clone();
            };

            BN.prototype.isNeg = function isNeg() {
                return this.negative !== 0;
            };

            // Return negative clone of `this`
            BN.prototype.neg = function neg() {
                return this.clone().ineg();
            };

            BN.prototype.ineg = function ineg() {
                if (!this.isZero()) {
                    this.negative ^= 1;
                }

                return this;
            };

            // Or `num` with `this` in-place
            BN.prototype.iuor = function iuor(num) {
                while (this.length < num.length) {
                    this.words[this.length++] = 0;
                }

                for (var i = 0; i < num.length; i++) {
                    this.words[i] = this.words[i] | num.words[i];
                }

                return this.strip();
            };

            BN.prototype.ior = function ior(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuor(num);
            };

            // Or `num` with `this`
            BN.prototype.or = function or(num) {
                if (this.length > num.length) return this.clone().ior(num);
                return num.clone().ior(this);
            };

            BN.prototype.uor = function uor(num) {
                if (this.length > num.length) return this.clone().iuor(num);
                return num.clone().iuor(this);
            };

            // And `num` with `this` in-place
            BN.prototype.iuand = function iuand(num) {
                // b = min-length(num, this)
                var b;
                if (this.length > num.length) {
                    b = num;
                } else {
                    b = this;
                }

                for (var i = 0; i < b.length; i++) {
                    this.words[i] = this.words[i] & num.words[i];
                }

                this.length = b.length;

                return this.strip();
            };

            BN.prototype.iand = function iand(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuand(num);
            };

            // And `num` with `this`
            BN.prototype.and = function and(num) {
                if (this.length > num.length) return this.clone().iand(num);
                return num.clone().iand(this);
            };

            BN.prototype.uand = function uand(num) {
                if (this.length > num.length) return this.clone().iuand(num);
                return num.clone().iuand(this);
            };

            // Xor `num` with `this` in-place
            BN.prototype.iuxor = function iuxor(num) {
                // a.length > b.length
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }

                for (var i = 0; i < b.length; i++) {
                    this.words[i] = a.words[i] ^ b.words[i];
                }

                if (this !== a) {
                    for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }

                this.length = a.length;

                return this.strip();
            };

            BN.prototype.ixor = function ixor(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuxor(num);
            };

            // Xor `num` with `this`
            BN.prototype.xor = function xor(num) {
                if (this.length > num.length) return this.clone().ixor(num);
                return num.clone().ixor(this);
            };

            BN.prototype.uxor = function uxor(num) {
                if (this.length > num.length) return this.clone().iuxor(num);
                return num.clone().iuxor(this);
            };

            // Not ``this`` with ``width`` bitwidth
            BN.prototype.inotn = function inotn(width) {
                assert(typeof width === 'number' && width >= 0);

                var bytesNeeded = Math.ceil(width / 26) | 0;
                var bitsLeft = width % 26;

                // Extend the buffer with leading zeroes
                this._expand(bytesNeeded);

                if (bitsLeft > 0) {
                    bytesNeeded--;
                }

                // Handle complete words
                for (var i = 0; i < bytesNeeded; i++) {
                    this.words[i] = ~this.words[i] & 0x3ffffff;
                }

                // Handle the residue
                if (bitsLeft > 0) {
                    this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
                }

                // And remove leading zeroes
                return this.strip();
            };

            BN.prototype.notn = function notn(width) {
                return this.clone().inotn(width);
            };

            // Set `bit` of `this`
            BN.prototype.setn = function setn(bit, val) {
                assert(typeof bit === 'number' && bit >= 0);

                var off = (bit / 26) | 0;
                var wbit = bit % 26;

                this._expand(off + 1);

                if (val) {
                    this.words[off] = this.words[off] | (1 << wbit);
                } else {
                    this.words[off] = this.words[off] & ~(1 << wbit);
                }

                return this.strip();
            };

            // Add `num` to `this` in-place
            BN.prototype.iadd = function iadd(num) {
                var r;

                // negative + positive
                if (this.negative !== 0 && num.negative === 0) {
                    this.negative = 0;
                    r = this.isub(num);
                    this.negative ^= 1;
                    return this._normSign();

                    // positive + negative
                } else if (this.negative === 0 && num.negative !== 0) {
                    num.negative = 0;
                    r = this.isub(num);
                    num.negative = 1;
                    return r._normSign();
                }

                // a.length > b.length
                var a, b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }

                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                    this.words[i] = r & 0x3ffffff;
                    carry = r >>> 26;
                }
                for (; carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    this.words[i] = r & 0x3ffffff;
                    carry = r >>> 26;
                }

                this.length = a.length;
                if (carry !== 0) {
                    this.words[this.length] = carry;
                    this.length++;
                    // Copy the rest of the words
                } else if (a !== this) {
                    for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }

                return this;
            };

            // Add `num` to `this`
            BN.prototype.add = function add(num) {
                var res;
                if (num.negative !== 0 && this.negative === 0) {
                    num.negative = 0;
                    res = this.sub(num);
                    num.negative ^= 1;
                    return res;
                } else if (num.negative === 0 && this.negative !== 0) {
                    this.negative = 0;
                    res = num.sub(this);
                    this.negative = 1;
                    return res;
                }

                if (this.length > num.length) return this.clone().iadd(num);

                return num.clone().iadd(this);
            };

            // Subtract `num` from `this` in-place
            BN.prototype.isub = function isub(num) {
                // this - (-num) = this + num
                if (num.negative !== 0) {
                    num.negative = 0;
                    var r = this.iadd(num);
                    num.negative = 1;
                    return r._normSign();

                    // -this - num = -(this + num)
                } else if (this.negative !== 0) {
                    this.negative = 0;
                    this.iadd(num);
                    this.negative = 1;
                    return this._normSign();
                }

                // At this point both numbers are positive
                var cmp = this.cmp(num);

                // Optimization - zeroify
                if (cmp === 0) {
                    this.negative = 0;
                    this.length = 1;
                    this.words[0] = 0;
                    return this;
                }

                // a > b
                var a, b;
                if (cmp > 0) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }

                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 0x3ffffff;
                }
                for (; carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 0x3ffffff;
                }

                // Copy rest of the words
                if (carry === 0 && i < a.length && a !== this) {
                    for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }

                this.length = Math.max(this.length, i);

                if (a !== this) {
                    this.negative = 1;
                }

                return this.strip();
            };

            // Subtract `num` from `this`
            BN.prototype.sub = function sub(num) {
                return this.clone().isub(num);
            };

            function smallMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                var len = (self.length + num.length) | 0;
                out.length = len;
                len = (len - 1) | 0;

                // Peel one iteration (compiler can't do it, because of code complexity)
                var a = self.words[0] | 0;
                var b = num.words[0] | 0;
                var r = a * b;

                var lo = r & 0x3ffffff;
                var carry = (r / 0x4000000) | 0;
                out.words[0] = lo;

                for (var k = 1; k < len; k++) {
                    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                    // note that ncarry could be >= 0x3ffffff
                    var ncarry = carry >>> 26;
                    var rword = carry & 0x3ffffff;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = (k - j) | 0;
                        a = self.words[i] | 0;
                        b = num.words[j] | 0;
                        r = a * b + rword;
                        ncarry += (r / 0x4000000) | 0;
                        rword = r & 0x3ffffff;
                    }
                    out.words[k] = rword | 0;
                    carry = ncarry | 0;
                }
                if (carry !== 0) {
                    out.words[k] = carry | 0;
                } else {
                    out.length--;
                }

                return out.strip();
            }

            // TODO(indutny): it may be reasonable to omit it for users who don't need
            // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
            // multiplication (like elliptic secp256k1).
            var comb10MulTo = function comb10MulTo(self, num, out) {
                var a = self.words;
                var b = num.words;
                var o = out.words;
                var c = 0;
                var lo;
                var mid;
                var hi;
                var a0 = a[0] | 0;
                var al0 = a0 & 0x1fff;
                var ah0 = a0 >>> 13;
                var a1 = a[1] | 0;
                var al1 = a1 & 0x1fff;
                var ah1 = a1 >>> 13;
                var a2 = a[2] | 0;
                var al2 = a2 & 0x1fff;
                var ah2 = a2 >>> 13;
                var a3 = a[3] | 0;
                var al3 = a3 & 0x1fff;
                var ah3 = a3 >>> 13;
                var a4 = a[4] | 0;
                var al4 = a4 & 0x1fff;
                var ah4 = a4 >>> 13;
                var a5 = a[5] | 0;
                var al5 = a5 & 0x1fff;
                var ah5 = a5 >>> 13;
                var a6 = a[6] | 0;
                var al6 = a6 & 0x1fff;
                var ah6 = a6 >>> 13;
                var a7 = a[7] | 0;
                var al7 = a7 & 0x1fff;
                var ah7 = a7 >>> 13;
                var a8 = a[8] | 0;
                var al8 = a8 & 0x1fff;
                var ah8 = a8 >>> 13;
                var a9 = a[9] | 0;
                var al9 = a9 & 0x1fff;
                var ah9 = a9 >>> 13;
                var b0 = b[0] | 0;
                var bl0 = b0 & 0x1fff;
                var bh0 = b0 >>> 13;
                var b1 = b[1] | 0;
                var bl1 = b1 & 0x1fff;
                var bh1 = b1 >>> 13;
                var b2 = b[2] | 0;
                var bl2 = b2 & 0x1fff;
                var bh2 = b2 >>> 13;
                var b3 = b[3] | 0;
                var bl3 = b3 & 0x1fff;
                var bh3 = b3 >>> 13;
                var b4 = b[4] | 0;
                var bl4 = b4 & 0x1fff;
                var bh4 = b4 >>> 13;
                var b5 = b[5] | 0;
                var bl5 = b5 & 0x1fff;
                var bh5 = b5 >>> 13;
                var b6 = b[6] | 0;
                var bl6 = b6 & 0x1fff;
                var bh6 = b6 >>> 13;
                var b7 = b[7] | 0;
                var bl7 = b7 & 0x1fff;
                var bh7 = b7 >>> 13;
                var b8 = b[8] | 0;
                var bl8 = b8 & 0x1fff;
                var bh8 = b8 >>> 13;
                var b9 = b[9] | 0;
                var bl9 = b9 & 0x1fff;
                var bh9 = b9 >>> 13;

                out.negative = self.negative ^ num.negative;
                out.length = 19;
                /* k = 0 */
                lo = Math.imul(al0, bl0);
                mid = Math.imul(al0, bh0);
                mid = (mid + Math.imul(ah0, bl0)) | 0;
                hi = Math.imul(ah0, bh0);
                var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
                w0 &= 0x3ffffff;
                /* k = 1 */
                lo = Math.imul(al1, bl0);
                mid = Math.imul(al1, bh0);
                mid = (mid + Math.imul(ah1, bl0)) | 0;
                hi = Math.imul(ah1, bh0);
                lo = (lo + Math.imul(al0, bl1)) | 0;
                mid = (mid + Math.imul(al0, bh1)) | 0;
                mid = (mid + Math.imul(ah0, bl1)) | 0;
                hi = (hi + Math.imul(ah0, bh1)) | 0;
                var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
                w1 &= 0x3ffffff;
                /* k = 2 */
                lo = Math.imul(al2, bl0);
                mid = Math.imul(al2, bh0);
                mid = (mid + Math.imul(ah2, bl0)) | 0;
                hi = Math.imul(ah2, bh0);
                lo = (lo + Math.imul(al1, bl1)) | 0;
                mid = (mid + Math.imul(al1, bh1)) | 0;
                mid = (mid + Math.imul(ah1, bl1)) | 0;
                hi = (hi + Math.imul(ah1, bh1)) | 0;
                lo = (lo + Math.imul(al0, bl2)) | 0;
                mid = (mid + Math.imul(al0, bh2)) | 0;
                mid = (mid + Math.imul(ah0, bl2)) | 0;
                hi = (hi + Math.imul(ah0, bh2)) | 0;
                var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
                w2 &= 0x3ffffff;
                /* k = 3 */
                lo = Math.imul(al3, bl0);
                mid = Math.imul(al3, bh0);
                mid = (mid + Math.imul(ah3, bl0)) | 0;
                hi = Math.imul(ah3, bh0);
                lo = (lo + Math.imul(al2, bl1)) | 0;
                mid = (mid + Math.imul(al2, bh1)) | 0;
                mid = (mid + Math.imul(ah2, bl1)) | 0;
                hi = (hi + Math.imul(ah2, bh1)) | 0;
                lo = (lo + Math.imul(al1, bl2)) | 0;
                mid = (mid + Math.imul(al1, bh2)) | 0;
                mid = (mid + Math.imul(ah1, bl2)) | 0;
                hi = (hi + Math.imul(ah1, bh2)) | 0;
                lo = (lo + Math.imul(al0, bl3)) | 0;
                mid = (mid + Math.imul(al0, bh3)) | 0;
                mid = (mid + Math.imul(ah0, bl3)) | 0;
                hi = (hi + Math.imul(ah0, bh3)) | 0;
                var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
                w3 &= 0x3ffffff;
                /* k = 4 */
                lo = Math.imul(al4, bl0);
                mid = Math.imul(al4, bh0);
                mid = (mid + Math.imul(ah4, bl0)) | 0;
                hi = Math.imul(ah4, bh0);
                lo = (lo + Math.imul(al3, bl1)) | 0;
                mid = (mid + Math.imul(al3, bh1)) | 0;
                mid = (mid + Math.imul(ah3, bl1)) | 0;
                hi = (hi + Math.imul(ah3, bh1)) | 0;
                lo = (lo + Math.imul(al2, bl2)) | 0;
                mid = (mid + Math.imul(al2, bh2)) | 0;
                mid = (mid + Math.imul(ah2, bl2)) | 0;
                hi = (hi + Math.imul(ah2, bh2)) | 0;
                lo = (lo + Math.imul(al1, bl3)) | 0;
                mid = (mid + Math.imul(al1, bh3)) | 0;
                mid = (mid + Math.imul(ah1, bl3)) | 0;
                hi = (hi + Math.imul(ah1, bh3)) | 0;
                lo = (lo + Math.imul(al0, bl4)) | 0;
                mid = (mid + Math.imul(al0, bh4)) | 0;
                mid = (mid + Math.imul(ah0, bl4)) | 0;
                hi = (hi + Math.imul(ah0, bh4)) | 0;
                var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
                w4 &= 0x3ffffff;
                /* k = 5 */
                lo = Math.imul(al5, bl0);
                mid = Math.imul(al5, bh0);
                mid = (mid + Math.imul(ah5, bl0)) | 0;
                hi = Math.imul(ah5, bh0);
                lo = (lo + Math.imul(al4, bl1)) | 0;
                mid = (mid + Math.imul(al4, bh1)) | 0;
                mid = (mid + Math.imul(ah4, bl1)) | 0;
                hi = (hi + Math.imul(ah4, bh1)) | 0;
                lo = (lo + Math.imul(al3, bl2)) | 0;
                mid = (mid + Math.imul(al3, bh2)) | 0;
                mid = (mid + Math.imul(ah3, bl2)) | 0;
                hi = (hi + Math.imul(ah3, bh2)) | 0;
                lo = (lo + Math.imul(al2, bl3)) | 0;
                mid = (mid + Math.imul(al2, bh3)) | 0;
                mid = (mid + Math.imul(ah2, bl3)) | 0;
                hi = (hi + Math.imul(ah2, bh3)) | 0;
                lo = (lo + Math.imul(al1, bl4)) | 0;
                mid = (mid + Math.imul(al1, bh4)) | 0;
                mid = (mid + Math.imul(ah1, bl4)) | 0;
                hi = (hi + Math.imul(ah1, bh4)) | 0;
                lo = (lo + Math.imul(al0, bl5)) | 0;
                mid = (mid + Math.imul(al0, bh5)) | 0;
                mid = (mid + Math.imul(ah0, bl5)) | 0;
                hi = (hi + Math.imul(ah0, bh5)) | 0;
                var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
                w5 &= 0x3ffffff;
                /* k = 6 */
                lo = Math.imul(al6, bl0);
                mid = Math.imul(al6, bh0);
                mid = (mid + Math.imul(ah6, bl0)) | 0;
                hi = Math.imul(ah6, bh0);
                lo = (lo + Math.imul(al5, bl1)) | 0;
                mid = (mid + Math.imul(al5, bh1)) | 0;
                mid = (mid + Math.imul(ah5, bl1)) | 0;
                hi = (hi + Math.imul(ah5, bh1)) | 0;
                lo = (lo + Math.imul(al4, bl2)) | 0;
                mid = (mid + Math.imul(al4, bh2)) | 0;
                mid = (mid + Math.imul(ah4, bl2)) | 0;
                hi = (hi + Math.imul(ah4, bh2)) | 0;
                lo = (lo + Math.imul(al3, bl3)) | 0;
                mid = (mid + Math.imul(al3, bh3)) | 0;
                mid = (mid + Math.imul(ah3, bl3)) | 0;
                hi = (hi + Math.imul(ah3, bh3)) | 0;
                lo = (lo + Math.imul(al2, bl4)) | 0;
                mid = (mid + Math.imul(al2, bh4)) | 0;
                mid = (mid + Math.imul(ah2, bl4)) | 0;
                hi = (hi + Math.imul(ah2, bh4)) | 0;
                lo = (lo + Math.imul(al1, bl5)) | 0;
                mid = (mid + Math.imul(al1, bh5)) | 0;
                mid = (mid + Math.imul(ah1, bl5)) | 0;
                hi = (hi + Math.imul(ah1, bh5)) | 0;
                lo = (lo + Math.imul(al0, bl6)) | 0;
                mid = (mid + Math.imul(al0, bh6)) | 0;
                mid = (mid + Math.imul(ah0, bl6)) | 0;
                hi = (hi + Math.imul(ah0, bh6)) | 0;
                var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
                w6 &= 0x3ffffff;
                /* k = 7 */
                lo = Math.imul(al7, bl0);
                mid = Math.imul(al7, bh0);
                mid = (mid + Math.imul(ah7, bl0)) | 0;
                hi = Math.imul(ah7, bh0);
                lo = (lo + Math.imul(al6, bl1)) | 0;
                mid = (mid + Math.imul(al6, bh1)) | 0;
                mid = (mid + Math.imul(ah6, bl1)) | 0;
                hi = (hi + Math.imul(ah6, bh1)) | 0;
                lo = (lo + Math.imul(al5, bl2)) | 0;
                mid = (mid + Math.imul(al5, bh2)) | 0;
                mid = (mid + Math.imul(ah5, bl2)) | 0;
                hi = (hi + Math.imul(ah5, bh2)) | 0;
                lo = (lo + Math.imul(al4, bl3)) | 0;
                mid = (mid + Math.imul(al4, bh3)) | 0;
                mid = (mid + Math.imul(ah4, bl3)) | 0;
                hi = (hi + Math.imul(ah4, bh3)) | 0;
                lo = (lo + Math.imul(al3, bl4)) | 0;
                mid = (mid + Math.imul(al3, bh4)) | 0;
                mid = (mid + Math.imul(ah3, bl4)) | 0;
                hi = (hi + Math.imul(ah3, bh4)) | 0;
                lo = (lo + Math.imul(al2, bl5)) | 0;
                mid = (mid + Math.imul(al2, bh5)) | 0;
                mid = (mid + Math.imul(ah2, bl5)) | 0;
                hi = (hi + Math.imul(ah2, bh5)) | 0;
                lo = (lo + Math.imul(al1, bl6)) | 0;
                mid = (mid + Math.imul(al1, bh6)) | 0;
                mid = (mid + Math.imul(ah1, bl6)) | 0;
                hi = (hi + Math.imul(ah1, bh6)) | 0;
                lo = (lo + Math.imul(al0, bl7)) | 0;
                mid = (mid + Math.imul(al0, bh7)) | 0;
                mid = (mid + Math.imul(ah0, bl7)) | 0;
                hi = (hi + Math.imul(ah0, bh7)) | 0;
                var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
                w7 &= 0x3ffffff;
                /* k = 8 */
                lo = Math.imul(al8, bl0);
                mid = Math.imul(al8, bh0);
                mid = (mid + Math.imul(ah8, bl0)) | 0;
                hi = Math.imul(ah8, bh0);
                lo = (lo + Math.imul(al7, bl1)) | 0;
                mid = (mid + Math.imul(al7, bh1)) | 0;
                mid = (mid + Math.imul(ah7, bl1)) | 0;
                hi = (hi + Math.imul(ah7, bh1)) | 0;
                lo = (lo + Math.imul(al6, bl2)) | 0;
                mid = (mid + Math.imul(al6, bh2)) | 0;
                mid = (mid + Math.imul(ah6, bl2)) | 0;
                hi = (hi + Math.imul(ah6, bh2)) | 0;
                lo = (lo + Math.imul(al5, bl3)) | 0;
                mid = (mid + Math.imul(al5, bh3)) | 0;
                mid = (mid + Math.imul(ah5, bl3)) | 0;
                hi = (hi + Math.imul(ah5, bh3)) | 0;
                lo = (lo + Math.imul(al4, bl4)) | 0;
                mid = (mid + Math.imul(al4, bh4)) | 0;
                mid = (mid + Math.imul(ah4, bl4)) | 0;
                hi = (hi + Math.imul(ah4, bh4)) | 0;
                lo = (lo + Math.imul(al3, bl5)) | 0;
                mid = (mid + Math.imul(al3, bh5)) | 0;
                mid = (mid + Math.imul(ah3, bl5)) | 0;
                hi = (hi + Math.imul(ah3, bh5)) | 0;
                lo = (lo + Math.imul(al2, bl6)) | 0;
                mid = (mid + Math.imul(al2, bh6)) | 0;
                mid = (mid + Math.imul(ah2, bl6)) | 0;
                hi = (hi + Math.imul(ah2, bh6)) | 0;
                lo = (lo + Math.imul(al1, bl7)) | 0;
                mid = (mid + Math.imul(al1, bh7)) | 0;
                mid = (mid + Math.imul(ah1, bl7)) | 0;
                hi = (hi + Math.imul(ah1, bh7)) | 0;
                lo = (lo + Math.imul(al0, bl8)) | 0;
                mid = (mid + Math.imul(al0, bh8)) | 0;
                mid = (mid + Math.imul(ah0, bl8)) | 0;
                hi = (hi + Math.imul(ah0, bh8)) | 0;
                var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
                w8 &= 0x3ffffff;
                /* k = 9 */
                lo = Math.imul(al9, bl0);
                mid = Math.imul(al9, bh0);
                mid = (mid + Math.imul(ah9, bl0)) | 0;
                hi = Math.imul(ah9, bh0);
                lo = (lo + Math.imul(al8, bl1)) | 0;
                mid = (mid + Math.imul(al8, bh1)) | 0;
                mid = (mid + Math.imul(ah8, bl1)) | 0;
                hi = (hi + Math.imul(ah8, bh1)) | 0;
                lo = (lo + Math.imul(al7, bl2)) | 0;
                mid = (mid + Math.imul(al7, bh2)) | 0;
                mid = (mid + Math.imul(ah7, bl2)) | 0;
                hi = (hi + Math.imul(ah7, bh2)) | 0;
                lo = (lo + Math.imul(al6, bl3)) | 0;
                mid = (mid + Math.imul(al6, bh3)) | 0;
                mid = (mid + Math.imul(ah6, bl3)) | 0;
                hi = (hi + Math.imul(ah6, bh3)) | 0;
                lo = (lo + Math.imul(al5, bl4)) | 0;
                mid = (mid + Math.imul(al5, bh4)) | 0;
                mid = (mid + Math.imul(ah5, bl4)) | 0;
                hi = (hi + Math.imul(ah5, bh4)) | 0;
                lo = (lo + Math.imul(al4, bl5)) | 0;
                mid = (mid + Math.imul(al4, bh5)) | 0;
                mid = (mid + Math.imul(ah4, bl5)) | 0;
                hi = (hi + Math.imul(ah4, bh5)) | 0;
                lo = (lo + Math.imul(al3, bl6)) | 0;
                mid = (mid + Math.imul(al3, bh6)) | 0;
                mid = (mid + Math.imul(ah3, bl6)) | 0;
                hi = (hi + Math.imul(ah3, bh6)) | 0;
                lo = (lo + Math.imul(al2, bl7)) | 0;
                mid = (mid + Math.imul(al2, bh7)) | 0;
                mid = (mid + Math.imul(ah2, bl7)) | 0;
                hi = (hi + Math.imul(ah2, bh7)) | 0;
                lo = (lo + Math.imul(al1, bl8)) | 0;
                mid = (mid + Math.imul(al1, bh8)) | 0;
                mid = (mid + Math.imul(ah1, bl8)) | 0;
                hi = (hi + Math.imul(ah1, bh8)) | 0;
                lo = (lo + Math.imul(al0, bl9)) | 0;
                mid = (mid + Math.imul(al0, bh9)) | 0;
                mid = (mid + Math.imul(ah0, bl9)) | 0;
                hi = (hi + Math.imul(ah0, bh9)) | 0;
                var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
                w9 &= 0x3ffffff;
                /* k = 10 */
                lo = Math.imul(al9, bl1);
                mid = Math.imul(al9, bh1);
                mid = (mid + Math.imul(ah9, bl1)) | 0;
                hi = Math.imul(ah9, bh1);
                lo = (lo + Math.imul(al8, bl2)) | 0;
                mid = (mid + Math.imul(al8, bh2)) | 0;
                mid = (mid + Math.imul(ah8, bl2)) | 0;
                hi = (hi + Math.imul(ah8, bh2)) | 0;
                lo = (lo + Math.imul(al7, bl3)) | 0;
                mid = (mid + Math.imul(al7, bh3)) | 0;
                mid = (mid + Math.imul(ah7, bl3)) | 0;
                hi = (hi + Math.imul(ah7, bh3)) | 0;
                lo = (lo + Math.imul(al6, bl4)) | 0;
                mid = (mid + Math.imul(al6, bh4)) | 0;
                mid = (mid + Math.imul(ah6, bl4)) | 0;
                hi = (hi + Math.imul(ah6, bh4)) | 0;
                lo = (lo + Math.imul(al5, bl5)) | 0;
                mid = (mid + Math.imul(al5, bh5)) | 0;
                mid = (mid + Math.imul(ah5, bl5)) | 0;
                hi = (hi + Math.imul(ah5, bh5)) | 0;
                lo = (lo + Math.imul(al4, bl6)) | 0;
                mid = (mid + Math.imul(al4, bh6)) | 0;
                mid = (mid + Math.imul(ah4, bl6)) | 0;
                hi = (hi + Math.imul(ah4, bh6)) | 0;
                lo = (lo + Math.imul(al3, bl7)) | 0;
                mid = (mid + Math.imul(al3, bh7)) | 0;
                mid = (mid + Math.imul(ah3, bl7)) | 0;
                hi = (hi + Math.imul(ah3, bh7)) | 0;
                lo = (lo + Math.imul(al2, bl8)) | 0;
                mid = (mid + Math.imul(al2, bh8)) | 0;
                mid = (mid + Math.imul(ah2, bl8)) | 0;
                hi = (hi + Math.imul(ah2, bh8)) | 0;
                lo = (lo + Math.imul(al1, bl9)) | 0;
                mid = (mid + Math.imul(al1, bh9)) | 0;
                mid = (mid + Math.imul(ah1, bl9)) | 0;
                hi = (hi + Math.imul(ah1, bh9)) | 0;
                var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
                w10 &= 0x3ffffff;
                /* k = 11 */
                lo = Math.imul(al9, bl2);
                mid = Math.imul(al9, bh2);
                mid = (mid + Math.imul(ah9, bl2)) | 0;
                hi = Math.imul(ah9, bh2);
                lo = (lo + Math.imul(al8, bl3)) | 0;
                mid = (mid + Math.imul(al8, bh3)) | 0;
                mid = (mid + Math.imul(ah8, bl3)) | 0;
                hi = (hi + Math.imul(ah8, bh3)) | 0;
                lo = (lo + Math.imul(al7, bl4)) | 0;
                mid = (mid + Math.imul(al7, bh4)) | 0;
                mid = (mid + Math.imul(ah7, bl4)) | 0;
                hi = (hi + Math.imul(ah7, bh4)) | 0;
                lo = (lo + Math.imul(al6, bl5)) | 0;
                mid = (mid + Math.imul(al6, bh5)) | 0;
                mid = (mid + Math.imul(ah6, bl5)) | 0;
                hi = (hi + Math.imul(ah6, bh5)) | 0;
                lo = (lo + Math.imul(al5, bl6)) | 0;
                mid = (mid + Math.imul(al5, bh6)) | 0;
                mid = (mid + Math.imul(ah5, bl6)) | 0;
                hi = (hi + Math.imul(ah5, bh6)) | 0;
                lo = (lo + Math.imul(al4, bl7)) | 0;
                mid = (mid + Math.imul(al4, bh7)) | 0;
                mid = (mid + Math.imul(ah4, bl7)) | 0;
                hi = (hi + Math.imul(ah4, bh7)) | 0;
                lo = (lo + Math.imul(al3, bl8)) | 0;
                mid = (mid + Math.imul(al3, bh8)) | 0;
                mid = (mid + Math.imul(ah3, bl8)) | 0;
                hi = (hi + Math.imul(ah3, bh8)) | 0;
                lo = (lo + Math.imul(al2, bl9)) | 0;
                mid = (mid + Math.imul(al2, bh9)) | 0;
                mid = (mid + Math.imul(ah2, bl9)) | 0;
                hi = (hi + Math.imul(ah2, bh9)) | 0;
                var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
                w11 &= 0x3ffffff;
                /* k = 12 */
                lo = Math.imul(al9, bl3);
                mid = Math.imul(al9, bh3);
                mid = (mid + Math.imul(ah9, bl3)) | 0;
                hi = Math.imul(ah9, bh3);
                lo = (lo + Math.imul(al8, bl4)) | 0;
                mid = (mid + Math.imul(al8, bh4)) | 0;
                mid = (mid + Math.imul(ah8, bl4)) | 0;
                hi = (hi + Math.imul(ah8, bh4)) | 0;
                lo = (lo + Math.imul(al7, bl5)) | 0;
                mid = (mid + Math.imul(al7, bh5)) | 0;
                mid = (mid + Math.imul(ah7, bl5)) | 0;
                hi = (hi + Math.imul(ah7, bh5)) | 0;
                lo = (lo + Math.imul(al6, bl6)) | 0;
                mid = (mid + Math.imul(al6, bh6)) | 0;
                mid = (mid + Math.imul(ah6, bl6)) | 0;
                hi = (hi + Math.imul(ah6, bh6)) | 0;
                lo = (lo + Math.imul(al5, bl7)) | 0;
                mid = (mid + Math.imul(al5, bh7)) | 0;
                mid = (mid + Math.imul(ah5, bl7)) | 0;
                hi = (hi + Math.imul(ah5, bh7)) | 0;
                lo = (lo + Math.imul(al4, bl8)) | 0;
                mid = (mid + Math.imul(al4, bh8)) | 0;
                mid = (mid + Math.imul(ah4, bl8)) | 0;
                hi = (hi + Math.imul(ah4, bh8)) | 0;
                lo = (lo + Math.imul(al3, bl9)) | 0;
                mid = (mid + Math.imul(al3, bh9)) | 0;
                mid = (mid + Math.imul(ah3, bl9)) | 0;
                hi = (hi + Math.imul(ah3, bh9)) | 0;
                var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
                w12 &= 0x3ffffff;
                /* k = 13 */
                lo = Math.imul(al9, bl4);
                mid = Math.imul(al9, bh4);
                mid = (mid + Math.imul(ah9, bl4)) | 0;
                hi = Math.imul(ah9, bh4);
                lo = (lo + Math.imul(al8, bl5)) | 0;
                mid = (mid + Math.imul(al8, bh5)) | 0;
                mid = (mid + Math.imul(ah8, bl5)) | 0;
                hi = (hi + Math.imul(ah8, bh5)) | 0;
                lo = (lo + Math.imul(al7, bl6)) | 0;
                mid = (mid + Math.imul(al7, bh6)) | 0;
                mid = (mid + Math.imul(ah7, bl6)) | 0;
                hi = (hi + Math.imul(ah7, bh6)) | 0;
                lo = (lo + Math.imul(al6, bl7)) | 0;
                mid = (mid + Math.imul(al6, bh7)) | 0;
                mid = (mid + Math.imul(ah6, bl7)) | 0;
                hi = (hi + Math.imul(ah6, bh7)) | 0;
                lo = (lo + Math.imul(al5, bl8)) | 0;
                mid = (mid + Math.imul(al5, bh8)) | 0;
                mid = (mid + Math.imul(ah5, bl8)) | 0;
                hi = (hi + Math.imul(ah5, bh8)) | 0;
                lo = (lo + Math.imul(al4, bl9)) | 0;
                mid = (mid + Math.imul(al4, bh9)) | 0;
                mid = (mid + Math.imul(ah4, bl9)) | 0;
                hi = (hi + Math.imul(ah4, bh9)) | 0;
                var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
                w13 &= 0x3ffffff;
                /* k = 14 */
                lo = Math.imul(al9, bl5);
                mid = Math.imul(al9, bh5);
                mid = (mid + Math.imul(ah9, bl5)) | 0;
                hi = Math.imul(ah9, bh5);
                lo = (lo + Math.imul(al8, bl6)) | 0;
                mid = (mid + Math.imul(al8, bh6)) | 0;
                mid = (mid + Math.imul(ah8, bl6)) | 0;
                hi = (hi + Math.imul(ah8, bh6)) | 0;
                lo = (lo + Math.imul(al7, bl7)) | 0;
                mid = (mid + Math.imul(al7, bh7)) | 0;
                mid = (mid + Math.imul(ah7, bl7)) | 0;
                hi = (hi + Math.imul(ah7, bh7)) | 0;
                lo = (lo + Math.imul(al6, bl8)) | 0;
                mid = (mid + Math.imul(al6, bh8)) | 0;
                mid = (mid + Math.imul(ah6, bl8)) | 0;
                hi = (hi + Math.imul(ah6, bh8)) | 0;
                lo = (lo + Math.imul(al5, bl9)) | 0;
                mid = (mid + Math.imul(al5, bh9)) | 0;
                mid = (mid + Math.imul(ah5, bl9)) | 0;
                hi = (hi + Math.imul(ah5, bh9)) | 0;
                var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
                w14 &= 0x3ffffff;
                /* k = 15 */
                lo = Math.imul(al9, bl6);
                mid = Math.imul(al9, bh6);
                mid = (mid + Math.imul(ah9, bl6)) | 0;
                hi = Math.imul(ah9, bh6);
                lo = (lo + Math.imul(al8, bl7)) | 0;
                mid = (mid + Math.imul(al8, bh7)) | 0;
                mid = (mid + Math.imul(ah8, bl7)) | 0;
                hi = (hi + Math.imul(ah8, bh7)) | 0;
                lo = (lo + Math.imul(al7, bl8)) | 0;
                mid = (mid + Math.imul(al7, bh8)) | 0;
                mid = (mid + Math.imul(ah7, bl8)) | 0;
                hi = (hi + Math.imul(ah7, bh8)) | 0;
                lo = (lo + Math.imul(al6, bl9)) | 0;
                mid = (mid + Math.imul(al6, bh9)) | 0;
                mid = (mid + Math.imul(ah6, bl9)) | 0;
                hi = (hi + Math.imul(ah6, bh9)) | 0;
                var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
                w15 &= 0x3ffffff;
                /* k = 16 */
                lo = Math.imul(al9, bl7);
                mid = Math.imul(al9, bh7);
                mid = (mid + Math.imul(ah9, bl7)) | 0;
                hi = Math.imul(ah9, bh7);
                lo = (lo + Math.imul(al8, bl8)) | 0;
                mid = (mid + Math.imul(al8, bh8)) | 0;
                mid = (mid + Math.imul(ah8, bl8)) | 0;
                hi = (hi + Math.imul(ah8, bh8)) | 0;
                lo = (lo + Math.imul(al7, bl9)) | 0;
                mid = (mid + Math.imul(al7, bh9)) | 0;
                mid = (mid + Math.imul(ah7, bl9)) | 0;
                hi = (hi + Math.imul(ah7, bh9)) | 0;
                var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
                w16 &= 0x3ffffff;
                /* k = 17 */
                lo = Math.imul(al9, bl8);
                mid = Math.imul(al9, bh8);
                mid = (mid + Math.imul(ah9, bl8)) | 0;
                hi = Math.imul(ah9, bh8);
                lo = (lo + Math.imul(al8, bl9)) | 0;
                mid = (mid + Math.imul(al8, bh9)) | 0;
                mid = (mid + Math.imul(ah8, bl9)) | 0;
                hi = (hi + Math.imul(ah8, bh9)) | 0;
                var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
                w17 &= 0x3ffffff;
                /* k = 18 */
                lo = Math.imul(al9, bl9);
                mid = Math.imul(al9, bh9);
                mid = (mid + Math.imul(ah9, bl9)) | 0;
                hi = Math.imul(ah9, bh9);
                var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
                w18 &= 0x3ffffff;
                o[0] = w0;
                o[1] = w1;
                o[2] = w2;
                o[3] = w3;
                o[4] = w4;
                o[5] = w5;
                o[6] = w6;
                o[7] = w7;
                o[8] = w8;
                o[9] = w9;
                o[10] = w10;
                o[11] = w11;
                o[12] = w12;
                o[13] = w13;
                o[14] = w14;
                o[15] = w15;
                o[16] = w16;
                o[17] = w17;
                o[18] = w18;
                if (c !== 0) {
                    o[19] = c;
                    out.length++;
                }
                return out;
            };

            // Polyfill comb
            if (!Math.imul) {
                comb10MulTo = smallMulTo;
            }

            function bigMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                out.length = self.length + num.length;

                var carry = 0;
                var hncarry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                    // note that ncarry could be >= 0x3ffffff
                    var ncarry = hncarry;
                    hncarry = 0;
                    var rword = carry & 0x3ffffff;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = self.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;

                        var lo = r & 0x3ffffff;
                        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                        lo = (lo + rword) | 0;
                        rword = lo & 0x3ffffff;
                        ncarry = (ncarry + (lo >>> 26)) | 0;

                        hncarry += ncarry >>> 26;
                        ncarry &= 0x3ffffff;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                    ncarry = hncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }

                return out.strip();
            }

            function jumboMulTo(self, num, out) {
                var fftm = new FFTM();
                return fftm.mulp(self, num, out);
            }

            BN.prototype.mulTo = function mulTo(num, out) {
                var res;
                var len = this.length + num.length;
                if (this.length === 10 && num.length === 10) {
                    res = comb10MulTo(this, num, out);
                } else if (len < 63) {
                    res = smallMulTo(this, num, out);
                } else if (len < 1024) {
                    res = bigMulTo(this, num, out);
                } else {
                    res = jumboMulTo(this, num, out);
                }

                return res;
            };

            // Cooley-Tukey algorithm for FFT
            // slightly revisited to rely on looping instead of recursion

            function FFTM(x, y) {
                this.x = x;
                this.y = y;
            }

            FFTM.prototype.makeRBT = function makeRBT(N) {
                var t = new Array(N);
                var l = BN.prototype._countBits(N) - 1;
                for (var i = 0; i < N; i++) {
                    t[i] = this.revBin(i, l, N);
                }

                return t;
            };

            // Returns binary-reversed representation of `x`
            FFTM.prototype.revBin = function revBin(x, l, N) {
                if (x === 0 || x === N - 1) return x;

                var rb = 0;
                for (var i = 0; i < l; i++) {
                    rb |= (x & 1) << (l - i - 1);
                    x >>= 1;
                }

                return rb;
            };

            // Performs "tweedling" phase, therefore 'emulating'
            // behaviour of the recursive algorithm
            FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
                for (var i = 0; i < N; i++) {
                    rtws[i] = rws[rbt[i]];
                    itws[i] = iws[rbt[i]];
                }
            };

            FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
                this.permute(rbt, rws, iws, rtws, itws, N);

                for (var s = 1; s < N; s <<= 1) {
                    var l = s << 1;

                    var rtwdf = Math.cos(2 * Math.PI / l);
                    var itwdf = Math.sin(2 * Math.PI / l);

                    for (var p = 0; p < N; p += l) {
                        var rtwdf_ = rtwdf;
                        var itwdf_ = itwdf;

                        for (var j = 0; j < s; j++) {
                            var re = rtws[p + j];
                            var ie = itws[p + j];

                            var ro = rtws[p + j + s];
                            var io = itws[p + j + s];

                            var rx = rtwdf_ * ro - itwdf_ * io;

                            io = rtwdf_ * io + itwdf_ * ro;
                            ro = rx;

                            rtws[p + j] = re + ro;
                            itws[p + j] = ie + io;

                            rtws[p + j + s] = re - ro;
                            itws[p + j + s] = ie - io;

                            /* jshint maxdepth : false */
                            if (j !== l) {
                                rx = rtwdf * rtwdf_ - itwdf * itwdf_;

                                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                                rtwdf_ = rx;
                            }
                        }
                    }
                }
            };

            FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
                var N = Math.max(m, n) | 1;
                var odd = N & 1;
                var i = 0;
                for (N = N / 2 | 0; N; N = N >>> 1) {
                    i++;
                }

                return 1 << i + 1 + odd;
            };

            FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
                if (N <= 1) return;

                for (var i = 0; i < N / 2; i++) {
                    var t = rws[i];

                    rws[i] = rws[N - i - 1];
                    rws[N - i - 1] = t;

                    t = iws[i];

                    iws[i] = -iws[N - i - 1];
                    iws[N - i - 1] = -t;
                }
            };

            FFTM.prototype.normalize13b = function normalize13b(ws, N) {
                var carry = 0;
                for (var i = 0; i < N / 2; i++) {
                    var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
                        Math.round(ws[2 * i] / N) +
                        carry;

                    ws[i] = w & 0x3ffffff;

                    if (w < 0x4000000) {
                        carry = 0;
                    } else {
                        carry = w / 0x4000000 | 0;
                    }
                }

                return ws;
            };

            FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
                var carry = 0;
                for (var i = 0; i < len; i++) {
                    carry = carry + (ws[i] | 0);

                    rws[2 * i] = carry & 0x1fff;
                    carry = carry >>> 13;
                    rws[2 * i + 1] = carry & 0x1fff;
                    carry = carry >>> 13;
                }

                // Pad with zeroes
                for (i = 2 * len; i < N; ++i) {
                    rws[i] = 0;
                }

                assert(carry === 0);
                assert((carry & ~0x1fff) === 0);
            };

            FFTM.prototype.stub = function stub(N) {
                var ph = new Array(N);
                for (var i = 0; i < N; i++) {
                    ph[i] = 0;
                }

                return ph;
            };

            FFTM.prototype.mulp = function mulp(x, y, out) {
                var N = 2 * this.guessLen13b(x.length, y.length);

                var rbt = this.makeRBT(N);

                var _ = this.stub(N);

                var rws = new Array(N);
                var rwst = new Array(N);
                var iwst = new Array(N);

                var nrws = new Array(N);
                var nrwst = new Array(N);
                var niwst = new Array(N);

                var rmws = out.words;
                rmws.length = N;

                this.convert13b(x.words, x.length, rws, N);
                this.convert13b(y.words, y.length, nrws, N);

                this.transform(rws, _, rwst, iwst, N, rbt);
                this.transform(nrws, _, nrwst, niwst, N, rbt);

                for (var i = 0; i < N; i++) {
                    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                    rwst[i] = rx;
                }

                this.conjugate(rwst, iwst, N);
                this.transform(rwst, iwst, rmws, _, N, rbt);
                this.conjugate(rmws, _, N);
                this.normalize13b(rmws, N);

                out.negative = x.negative ^ y.negative;
                out.length = x.length + y.length;
                return out.strip();
            };

            // Multiply `this` by `num`
            BN.prototype.mul = function mul(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return this.mulTo(num, out);
            };

            // Multiply employing FFT
            BN.prototype.mulf = function mulf(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return jumboMulTo(this, num, out);
            };

            // In-place Multiplication
            BN.prototype.imul = function imul(num) {
                return this.clone().mulTo(num, this);
            };

            BN.prototype.imuln = function imuln(num) {
                assert(typeof num === 'number');
                assert(num < 0x4000000);

                // Carry
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = (this.words[i] | 0) * num;
                    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
                    carry >>= 26;
                    carry += (w / 0x4000000) | 0;
                    // NOTE: lo is 27bit maximum
                    carry += lo >>> 26;
                    this.words[i] = lo & 0x3ffffff;
                }

                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }

                return this;
            };

            BN.prototype.muln = function muln(num) {
                return this.clone().imuln(num);
            };

            // `this` * `this`
            BN.prototype.sqr = function sqr() {
                return this.mul(this);
            };

            // `this` * `this` in-place
            BN.prototype.isqr = function isqr() {
                return this.imul(this.clone());
            };

            // Math.pow(`this`, `num`)
            BN.prototype.pow = function pow(num) {
                var w = toBitArray(num);
                if (w.length === 0) return new BN(1);

                // Skip leading zeroes
                var res = this;
                for (var i = 0; i < w.length; i++, res = res.sqr()) {
                    if (w[i] !== 0) break;
                }

                if (++i < w.length) {
                    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                        if (w[i] === 0) continue;

                        res = res.mul(q);
                    }
                }

                return res;
            };

            // Shift-left in-place
            BN.prototype.iushln = function iushln(bits) {
                assert(typeof bits === 'number' && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
                var i;

                if (r !== 0) {
                    var carry = 0;

                    for (i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = ((this.words[i] | 0) - newCarry) << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> (26 - r);
                    }

                    if (carry) {
                        this.words[i] = carry;
                        this.length++;
                    }
                }

                if (s !== 0) {
                    for (i = this.length - 1; i >= 0; i--) {
                        this.words[i + s] = this.words[i];
                    }

                    for (i = 0; i < s; i++) {
                        this.words[i] = 0;
                    }

                    this.length += s;
                }

                return this.strip();
            };

            BN.prototype.ishln = function ishln(bits) {
                // TODO(indutny): implement me
                assert(this.negative === 0);
                return this.iushln(bits);
            };

            // Shift-right in-place
            // NOTE: `hint` is a lowest bit before trailing zeroes
            // NOTE: if `extended` is present - it will be filled with destroyed bits
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                assert(typeof bits === 'number' && bits >= 0);
                var h;
                if (hint) {
                    h = (hint - (hint % 26)) / 26;
                } else {
                    h = 0;
                }

                var r = bits % 26;
                var s = Math.min((bits - r) / 26, this.length);
                var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                var maskedWords = extended;

                h -= s;
                h = Math.max(0, h);

                // Extended mode, copy masked part
                if (maskedWords) {
                    for (var i = 0; i < s; i++) {
                        maskedWords.words[i] = this.words[i];
                    }
                    maskedWords.length = s;
                }

                if (s === 0) {
                    // No-op, we should not move anything at all
                } else if (this.length > s) {
                    this.length -= s;
                    for (i = 0; i < this.length; i++) {
                        this.words[i] = this.words[i + s];
                    }
                } else {
                    this.words[0] = 0;
                    this.length = 1;
                }

                var carry = 0;
                for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                    var word = this.words[i] | 0;
                    this.words[i] = (carry << (26 - r)) | (word >>> r);
                    carry = word & mask;
                }

                // Push carried bits as a mask
                if (maskedWords && carry !== 0) {
                    maskedWords.words[maskedWords.length++] = carry;
                }

                if (this.length === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                }

                return this.strip();
            };

            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                // TODO(indutny): implement me
                assert(this.negative === 0);
                return this.iushrn(bits, hint, extended);
            };

            // Shift-left
            BN.prototype.shln = function shln(bits) {
                return this.clone().ishln(bits);
            };

            BN.prototype.ushln = function ushln(bits) {
                return this.clone().iushln(bits);
            };

            // Shift-right
            BN.prototype.shrn = function shrn(bits) {
                return this.clone().ishrn(bits);
            };

            BN.prototype.ushrn = function ushrn(bits) {
                return this.clone().iushrn(bits);
            };

            // Test if n bit is set
            BN.prototype.testn = function testn(bit) {
                assert(typeof bit === 'number' && bit >= 0);
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;

                // Fast case: bit is much higher than all existing words
                if (this.length <= s) return false;

                // Check bit and return
                var w = this.words[s];

                return !!(w & q);
            };

            // Return only lowers bits of number (in-place)
            BN.prototype.imaskn = function imaskn(bits) {
                assert(typeof bits === 'number' && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;

                assert(this.negative === 0, 'imaskn works only with positive numbers');

                if (this.length <= s) {
                    return this;
                }

                if (r !== 0) {
                    s++;
                }
                this.length = Math.min(s, this.length);

                if (r !== 0) {
                    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                    this.words[this.length - 1] &= mask;
                }

                return this.strip();
            };

            // Return only lowers bits of number
            BN.prototype.maskn = function maskn(bits) {
                return this.clone().imaskn(bits);
            };

            // Add plain number `num` to `this`
            BN.prototype.iaddn = function iaddn(num) {
                assert(typeof num === 'number');
                assert(num < 0x4000000);
                if (num < 0) return this.isubn(-num);

                // Possible sign change
                if (this.negative !== 0) {
                    if (this.length === 1 && (this.words[0] | 0) < num) {
                        this.words[0] = num - (this.words[0] | 0);
                        this.negative = 0;
                        return this;
                    }

                    this.negative = 0;
                    this.isubn(num);
                    this.negative = 1;
                    return this;
                }

                // Add without checks
                return this._iaddn(num);
            };

            BN.prototype._iaddn = function _iaddn(num) {
                this.words[0] += num;

                // Carry
                for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
                    this.words[i] -= 0x4000000;
                    if (i === this.length - 1) {
                        this.words[i + 1] = 1;
                    } else {
                        this.words[i + 1]++;
                    }
                }
                this.length = Math.max(this.length, i + 1);

                return this;
            };

            // Subtract plain number `num` from `this`
            BN.prototype.isubn = function isubn(num) {
                assert(typeof num === 'number');
                assert(num < 0x4000000);
                if (num < 0) return this.iaddn(-num);

                if (this.negative !== 0) {
                    this.negative = 0;
                    this.iaddn(num);
                    this.negative = 1;
                    return this;
                }

                this.words[0] -= num;

                if (this.length === 1 && this.words[0] < 0) {
                    this.words[0] = -this.words[0];
                    this.negative = 1;
                } else {
                    // Carry
                    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                        this.words[i] += 0x4000000;
                        this.words[i + 1] -= 1;
                    }
                }

                return this.strip();
            };

            BN.prototype.addn = function addn(num) {
                return this.clone().iaddn(num);
            };

            BN.prototype.subn = function subn(num) {
                return this.clone().isubn(num);
            };

            BN.prototype.iabs = function iabs() {
                this.negative = 0;

                return this;
            };

            BN.prototype.abs = function abs() {
                return this.clone().iabs();
            };

            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                var len = num.length + shift;
                var i;

                this._expand(len);

                var w;
                var carry = 0;
                for (i = 0; i < num.length; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    var right = (num.words[i] | 0) * mul;
                    w -= right & 0x3ffffff;
                    carry = (w >> 26) - ((right / 0x4000000) | 0);
                    this.words[i + shift] = w & 0x3ffffff;
                }
                for (; i < this.length - shift; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    carry = w >> 26;
                    this.words[i + shift] = w & 0x3ffffff;
                }

                if (carry === 0) return this.strip();

                // Subtraction overflow
                assert(carry === -1);
                carry = 0;
                for (i = 0; i < this.length; i++) {
                    w = -(this.words[i] | 0) + carry;
                    carry = w >> 26;
                    this.words[i] = w & 0x3ffffff;
                }
                this.negative = 1;

                return this.strip();
            };

            BN.prototype._wordDiv = function _wordDiv(num, mode) {
                var shift = this.length - num.length;

                var a = this.clone();
                var b = num;

                // Normalize
                var bhi = b.words[b.length - 1] | 0;
                var bhiBits = this._countBits(bhi);
                shift = 26 - bhiBits;
                if (shift !== 0) {
                    b = b.ushln(shift);
                    a.iushln(shift);
                    bhi = b.words[b.length - 1] | 0;
                }

                // Initialize quotient
                var m = a.length - b.length;
                var q;

                if (mode !== 'mod') {
                    q = new BN(null);
                    q.length = m + 1;
                    q.words = new Array(q.length);
                    for (var i = 0; i < q.length; i++) {
                        q.words[i] = 0;
                    }
                }

                var diff = a.clone()._ishlnsubmul(b, 1, m);
                if (diff.negative === 0) {
                    a = diff;
                    if (q) {
                        q.words[m] = 1;
                    }
                }

                for (var j = m - 1; j >= 0; j--) {
                    var qj = (a.words[b.length + j] | 0) * 0x4000000 +
                        (a.words[b.length + j - 1] | 0);

                    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
                    // (0x7ffffff)
                    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

                    a._ishlnsubmul(b, qj, j);
                    while (a.negative !== 0) {
                        qj--;
                        a.negative = 0;
                        a._ishlnsubmul(b, 1, j);
                        if (!a.isZero()) {
                            a.negative ^= 1;
                        }
                    }
                    if (q) {
                        q.words[j] = qj;
                    }
                }
                if (q) {
                    q.strip();
                }
                a.strip();

                // Denormalize
                if (mode !== 'div' && shift !== 0) {
                    a.iushrn(shift);
                }

                return {
                    div: q || null,
                    mod: a
                };
            };

            // NOTE: 1) `mode` can be set to `mod` to request mod only,
            //       to `div` to request div only, or be absent to
            //       request both div & mod
            //       2) `positive` is true if unsigned mod is requested
            BN.prototype.divmod = function divmod(num, mode, positive) {
                assert(!num.isZero());

                if (this.isZero()) {
                    return {
                        div: new BN(0),
                        mod: new BN(0)
                    };
                }

                var div, mod, res;
                if (this.negative !== 0 && num.negative === 0) {
                    res = this.neg().divmod(num, mode);

                    if (mode !== 'mod') {
                        div = res.div.neg();
                    }

                    if (mode !== 'div') {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.iadd(num);
                        }
                    }

                    return {
                        div: div,
                        mod: mod
                    };
                }

                if (this.negative === 0 && num.negative !== 0) {
                    res = this.divmod(num.neg(), mode);

                    if (mode !== 'mod') {
                        div = res.div.neg();
                    }

                    return {
                        div: div,
                        mod: res.mod
                    };
                }

                if ((this.negative & num.negative) !== 0) {
                    res = this.neg().divmod(num.neg(), mode);

                    if (mode !== 'div') {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.isub(num);
                        }
                    }

                    return {
                        div: res.div,
                        mod: mod
                    };
                }

                // Both numbers are positive at this point

                // Strip both numbers to approximate shift value
                if (num.length > this.length || this.cmp(num) < 0) {
                    return {
                        div: new BN(0),
                        mod: this
                    };
                }

                // Very short reduction
                if (num.length === 1) {
                    if (mode === 'div') {
                        return {
                            div: this.divn(num.words[0]),
                            mod: null
                        };
                    }

                    if (mode === 'mod') {
                        return {
                            div: null,
                            mod: new BN(this.modn(num.words[0]))
                        };
                    }

                    return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    };
                }

                return this._wordDiv(num, mode);
            };

            // Find `this` / `num`
            BN.prototype.div = function div(num) {
                return this.divmod(num, 'div', false).div;
            };

            // Find `this` % `num`
            BN.prototype.mod = function mod(num) {
                return this.divmod(num, 'mod', false).mod;
            };

            BN.prototype.umod = function umod(num) {
                return this.divmod(num, 'mod', true).mod;
            };

            // Find Round(`this` / `num`)
            BN.prototype.divRound = function divRound(num) {
                var dm = this.divmod(num);

                // Fast case - exact division
                if (dm.mod.isZero()) return dm.div;

                var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

                var half = num.ushrn(1);
                var r2 = num.andln(1);
                var cmp = mod.cmp(half);

                // Round down
                if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

                // Round up
                return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
            };

            BN.prototype.modn = function modn(num) {
                assert(num <= 0x3ffffff);
                var p = (1 << 26) % num;

                var acc = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    acc = (p * acc + (this.words[i] | 0)) % num;
                }

                return acc;
            };

            // In-place division by number
            BN.prototype.idivn = function idivn(num) {
                assert(num <= 0x3ffffff);

                var carry = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var w = (this.words[i] | 0) + carry * 0x4000000;
                    this.words[i] = (w / num) | 0;
                    carry = w % num;
                }

                return this.strip();
            };

            BN.prototype.divn = function divn(num) {
                return this.clone().idivn(num);
            };

            BN.prototype.egcd = function egcd(p) {
                assert(p.negative === 0);
                assert(!p.isZero());

                var x = this;
                var y = p.clone();

                if (x.negative !== 0) {
                    x = x.umod(p);
                } else {
                    x = x.clone();
                }

                // A * x + B * y = x
                var A = new BN(1);
                var B = new BN(0);

                // C * x + D * y = y
                var C = new BN(0);
                var D = new BN(1);

                var g = 0;

                while (x.isEven() && y.isEven()) {
                    x.iushrn(1);
                    y.iushrn(1);
                    ++g;
                }

                var yp = y.clone();
                var xp = x.clone();

                while (!x.isZero()) {
                    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        x.iushrn(i);
                        while (i-- > 0) {
                            if (A.isOdd() || B.isOdd()) {
                                A.iadd(yp);
                                B.isub(xp);
                            }

                            A.iushrn(1);
                            B.iushrn(1);
                        }
                    }

                    for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        y.iushrn(j);
                        while (j-- > 0) {
                            if (C.isOdd() || D.isOdd()) {
                                C.iadd(yp);
                                D.isub(xp);
                            }

                            C.iushrn(1);
                            D.iushrn(1);
                        }
                    }

                    if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                    } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                    }
                }

                return {
                    a: C,
                    b: D,
                    gcd: y.iushln(g)
                };
            };

            // This is reduced incarnation of the binary EEA
            // above, designated to invert members of the
            // _prime_ fields F(p) at a maximal speed
            BN.prototype._invmp = function _invmp(p) {
                assert(p.negative === 0);
                assert(!p.isZero());

                var a = this;
                var b = p.clone();

                if (a.negative !== 0) {
                    a = a.umod(p);
                } else {
                    a = a.clone();
                }

                var x1 = new BN(1);
                var x2 = new BN(0);

                var delta = b.clone();

                while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        a.iushrn(i);
                        while (i-- > 0) {
                            if (x1.isOdd()) {
                                x1.iadd(delta);
                            }

                            x1.iushrn(1);
                        }
                    }

                    for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        b.iushrn(j);
                        while (j-- > 0) {
                            if (x2.isOdd()) {
                                x2.iadd(delta);
                            }

                            x2.iushrn(1);
                        }
                    }

                    if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                    } else {
                        b.isub(a);
                        x2.isub(x1);
                    }
                }

                var res;
                if (a.cmpn(1) === 0) {
                    res = x1;
                } else {
                    res = x2;
                }

                if (res.cmpn(0) < 0) {
                    res.iadd(p);
                }

                return res;
            };

            BN.prototype.gcd = function gcd(num) {
                if (this.isZero()) return num.abs();
                if (num.isZero()) return this.abs();

                var a = this.clone();
                var b = num.clone();
                a.negative = 0;
                b.negative = 0;

                // Remove common factor of two
                for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                    a.iushrn(1);
                    b.iushrn(1);
                }

                do {
                    while (a.isEven()) {
                        a.iushrn(1);
                    }
                    while (b.isEven()) {
                        b.iushrn(1);
                    }

                    var r = a.cmp(b);
                    if (r < 0) {
                        // Swap `a` and `b` to make `a` always bigger than `b`
                        var t = a;
                        a = b;
                        b = t;
                    } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                    }

                    a.isub(b);
                } while (true);

                return b.iushln(shift);
            };

            // Invert number in the field F(num)
            BN.prototype.invm = function invm(num) {
                return this.egcd(num).a.umod(num);
            };

            BN.prototype.isEven = function isEven() {
                return (this.words[0] & 1) === 0;
            };

            BN.prototype.isOdd = function isOdd() {
                return (this.words[0] & 1) === 1;
            };

            // And first word and num
            BN.prototype.andln = function andln(num) {
                return this.words[0] & num;
            };

            // Increment at the bit position in-line
            BN.prototype.bincn = function bincn(bit) {
                assert(typeof bit === 'number');
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;

                // Fast case: bit is much higher than all existing words
                if (this.length <= s) {
                    this._expand(s + 1);
                    this.words[s] |= q;
                    return this;
                }

                // Add bit and propagate, if needed
                var carry = q;
                for (var i = s; carry !== 0 && i < this.length; i++) {
                    var w = this.words[i] | 0;
                    w += carry;
                    carry = w >>> 26;
                    w &= 0x3ffffff;
                    this.words[i] = w;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };

            BN.prototype.isZero = function isZero() {
                return this.length === 1 && this.words[0] === 0;
            };

            BN.prototype.cmpn = function cmpn(num) {
                var negative = num < 0;

                if (this.negative !== 0 && !negative) return -1;
                if (this.negative === 0 && negative) return 1;

                this.strip();

                var res;
                if (this.length > 1) {
                    res = 1;
                } else {
                    if (negative) {
                        num = -num;
                    }

                    assert(num <= 0x3ffffff, 'Number is too big');

                    var w = this.words[0] | 0;
                    res = w === num ? 0 : w < num ? -1 : 1;
                }
                if (this.negative !== 0) return -res | 0;
                return res;
            };

            // Compare two numbers and return:
            // 1 - if `this` > `num`
            // 0 - if `this` == `num`
            // -1 - if `this` < `num`
            BN.prototype.cmp = function cmp(num) {
                if (this.negative !== 0 && num.negative === 0) return -1;
                if (this.negative === 0 && num.negative !== 0) return 1;

                var res = this.ucmp(num);
                if (this.negative !== 0) return -res | 0;
                return res;
            };

            // Unsigned comparison
            BN.prototype.ucmp = function ucmp(num) {
                // At this point both numbers have the same sign
                if (this.length > num.length) return 1;
                if (this.length < num.length) return -1;

                var res = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var a = this.words[i] | 0;
                    var b = num.words[i] | 0;

                    if (a === b) continue;
                    if (a < b) {
                        res = -1;
                    } else if (a > b) {
                        res = 1;
                    }
                    break;
                }
                return res;
            };

            BN.prototype.gtn = function gtn(num) {
                return this.cmpn(num) === 1;
            };

            BN.prototype.gt = function gt(num) {
                return this.cmp(num) === 1;
            };

            BN.prototype.gten = function gten(num) {
                return this.cmpn(num) >= 0;
            };

            BN.prototype.gte = function gte(num) {
                return this.cmp(num) >= 0;
            };

            BN.prototype.ltn = function ltn(num) {
                return this.cmpn(num) === -1;
            };

            BN.prototype.lt = function lt(num) {
                return this.cmp(num) === -1;
            };

            BN.prototype.lten = function lten(num) {
                return this.cmpn(num) <= 0;
            };

            BN.prototype.lte = function lte(num) {
                return this.cmp(num) <= 0;
            };

            BN.prototype.eqn = function eqn(num) {
                return this.cmpn(num) === 0;
            };

            BN.prototype.eq = function eq(num) {
                return this.cmp(num) === 0;
            };

            //
            // A reduce context, could be using montgomery or something better, depending
            // on the `m` itself.
            //
            BN.red = function red(num) {
                return new Red(num);
            };

            BN.prototype.toRed = function toRed(ctx) {
                assert(!this.red, 'Already a number in reduction context');
                assert(this.negative === 0, 'red works only with positives');
                return ctx.convertTo(this)._forceRed(ctx);
            };

            BN.prototype.fromRed = function fromRed() {
                assert(this.red, 'fromRed works only with numbers in reduction context');
                return this.red.convertFrom(this);
            };

            BN.prototype._forceRed = function _forceRed(ctx) {
                this.red = ctx;
                return this;
            };

            BN.prototype.forceRed = function forceRed(ctx) {
                assert(!this.red, 'Already a number in reduction context');
                return this._forceRed(ctx);
            };

            BN.prototype.redAdd = function redAdd(num) {
                assert(this.red, 'redAdd works only with red numbers');
                return this.red.add(this, num);
            };

            BN.prototype.redIAdd = function redIAdd(num) {
                assert(this.red, 'redIAdd works only with red numbers');
                return this.red.iadd(this, num);
            };

            BN.prototype.redSub = function redSub(num) {
                assert(this.red, 'redSub works only with red numbers');
                return this.red.sub(this, num);
            };

            BN.prototype.redISub = function redISub(num) {
                assert(this.red, 'redISub works only with red numbers');
                return this.red.isub(this, num);
            };

            BN.prototype.redShl = function redShl(num) {
                assert(this.red, 'redShl works only with red numbers');
                return this.red.shl(this, num);
            };

            BN.prototype.redMul = function redMul(num) {
                assert(this.red, 'redMul works only with red numbers');
                this.red._verify2(this, num);
                return this.red.mul(this, num);
            };

            BN.prototype.redIMul = function redIMul(num) {
                assert(this.red, 'redMul works only with red numbers');
                this.red._verify2(this, num);
                return this.red.imul(this, num);
            };

            BN.prototype.redSqr = function redSqr() {
                assert(this.red, 'redSqr works only with red numbers');
                this.red._verify1(this);
                return this.red.sqr(this);
            };

            BN.prototype.redISqr = function redISqr() {
                assert(this.red, 'redISqr works only with red numbers');
                this.red._verify1(this);
                return this.red.isqr(this);
            };

            // Square root over p
            BN.prototype.redSqrt = function redSqrt() {
                assert(this.red, 'redSqrt works only with red numbers');
                this.red._verify1(this);
                return this.red.sqrt(this);
            };

            BN.prototype.redInvm = function redInvm() {
                assert(this.red, 'redInvm works only with red numbers');
                this.red._verify1(this);
                return this.red.invm(this);
            };

            // Return negative clone of `this` % `red modulo`
            BN.prototype.redNeg = function redNeg() {
                assert(this.red, 'redNeg works only with red numbers');
                this.red._verify1(this);
                return this.red.neg(this);
            };

            BN.prototype.redPow = function redPow(num) {
                assert(this.red && !num.red, 'redPow(normalNum)');
                this.red._verify1(this);
                return this.red.pow(this, num);
            };

            // Prime numbers with efficient reduction
            var primes = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };

            // Pseudo-Mersenne prime
            function MPrime(name, p) {
                // P = 2 ^ N - K
                this.name = name;
                this.p = new BN(p, 16);
                this.n = this.p.bitLength();
                this.k = new BN(1).iushln(this.n).isub(this.p);

                this.tmp = this._tmp();
            }

            MPrime.prototype._tmp = function _tmp() {
                var tmp = new BN(null);
                tmp.words = new Array(Math.ceil(this.n / 13));
                return tmp;
            };

            MPrime.prototype.ireduce = function ireduce(num) {
                // Assumes that `num` is less than `P^2`
                // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
                var r = num;
                var rlen;

                do {
                    this.split(r, this.tmp);
                    r = this.imulK(r);
                    r = r.iadd(this.tmp);
                    rlen = r.bitLength();
                } while (rlen > this.n);

                var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                if (cmp === 0) {
                    r.words[0] = 0;
                    r.length = 1;
                } else if (cmp > 0) {
                    r.isub(this.p);
                } else {
                    r.strip();
                }

                return r;
            };

            MPrime.prototype.split = function split(input, out) {
                input.iushrn(this.n, 0, out);
            };

            MPrime.prototype.imulK = function imulK(num) {
                return num.imul(this.k);
            };

            function K256() {
                MPrime.call(
                    this,
                    'k256',
                    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
            }

            inherits(K256, MPrime);

            K256.prototype.split = function split(input, output) {
                // 256 = 9 * 26 + 22
                var mask = 0x3fffff;

                var outLen = Math.min(input.length, 9);
                for (var i = 0; i < outLen; i++) {
                    output.words[i] = input.words[i];
                }
                output.length = outLen;

                if (input.length <= 9) {
                    input.words[0] = 0;
                    input.length = 1;
                    return;
                }

                // Shift by 9 limbs
                var prev = input.words[9];
                output.words[output.length++] = prev & mask;

                for (i = 10; i < input.length; i++) {
                    var next = input.words[i] | 0;
                    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                    prev = next;
                }
                prev >>>= 22;
                input.words[i - 10] = prev;
                if (prev === 0 && input.length > 10) {
                    input.length -= 10;
                } else {
                    input.length -= 9;
                }
            };

            K256.prototype.imulK = function imulK(num) {
                // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
                num.words[num.length] = 0;
                num.words[num.length + 1] = 0;
                num.length += 2;

                // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
                var lo = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = num.words[i] | 0;
                    lo += w * 0x3d1;
                    num.words[i] = lo & 0x3ffffff;
                    lo = w * 0x40 + ((lo / 0x4000000) | 0);
                }

                // Fast length reduction
                if (num.words[num.length - 1] === 0) {
                    num.length--;
                    if (num.words[num.length - 1] === 0) {
                        num.length--;
                    }
                }
                return num;
            };

            function P224() {
                MPrime.call(
                    this,
                    'p224',
                    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
            }

            inherits(P224, MPrime);

            function P192() {
                MPrime.call(
                    this,
                    'p192',
                    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
            }

            inherits(P192, MPrime);

            function P25519() {
                // 2 ^ 255 - 19
                MPrime.call(
                    this,
                    '25519',
                    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
            }

            inherits(P25519, MPrime);

            P25519.prototype.imulK = function imulK(num) {
                // K = 0x13
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var hi = (num.words[i] | 0) * 0x13 + carry;
                    var lo = hi & 0x3ffffff;
                    hi >>>= 26;

                    num.words[i] = lo;
                    carry = hi;
                }
                if (carry !== 0) {
                    num.words[num.length++] = carry;
                }
                return num;
            };

            // Exported mostly for testing purposes, use plain name instead
            BN._prime = function prime(name) {
                // Cached version of prime
                if (primes[name]) return primes[name];

                var prime;
                if (name === 'k256') {
                    prime = new K256();
                } else if (name === 'p224') {
                    prime = new P224();
                } else if (name === 'p192') {
                    prime = new P192();
                } else if (name === 'p25519') {
                    prime = new P25519();
                } else {
                    throw new Error('Unknown prime ' + name);
                }
                primes[name] = prime;

                return prime;
            };

            //
            // Base reduction engine
            //
            function Red(m) {
                if (typeof m === 'string') {
                    var prime = BN._prime(m);
                    this.m = prime.p;
                    this.prime = prime;
                } else {
                    assert(m.gtn(1), 'modulus must be greater than 1');
                    this.m = m;
                    this.prime = null;
                }
            }

            Red.prototype._verify1 = function _verify1(a) {
                assert(a.negative === 0, 'red works only with positives');
                assert(a.red, 'red works only with red numbers');
            };

            Red.prototype._verify2 = function _verify2(a, b) {
                assert((a.negative | b.negative) === 0, 'red works only with positives');
                assert(a.red && a.red === b.red,
                    'red works only with red numbers');
            };

            Red.prototype.imod = function imod(a) {
                if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                return a.umod(this.m)._forceRed(this);
            };

            Red.prototype.neg = function neg(a) {
                if (a.isZero()) {
                    return a.clone();
                }

                return this.m.sub(a)._forceRed(this);
            };

            Red.prototype.add = function add(a, b) {
                this._verify2(a, b);

                var res = a.add(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res._forceRed(this);
            };

            Red.prototype.iadd = function iadd(a, b) {
                this._verify2(a, b);

                var res = a.iadd(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res;
            };

            Red.prototype.sub = function sub(a, b) {
                this._verify2(a, b);

                var res = a.sub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res._forceRed(this);
            };

            Red.prototype.isub = function isub(a, b) {
                this._verify2(a, b);

                var res = a.isub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res;
            };

            Red.prototype.shl = function shl(a, num) {
                this._verify1(a);
                return this.imod(a.ushln(num));
            };

            Red.prototype.imul = function imul(a, b) {
                this._verify2(a, b);
                return this.imod(a.imul(b));
            };

            Red.prototype.mul = function mul(a, b) {
                this._verify2(a, b);
                return this.imod(a.mul(b));
            };

            Red.prototype.isqr = function isqr(a) {
                return this.imul(a, a.clone());
            };

            Red.prototype.sqr = function sqr(a) {
                return this.mul(a, a);
            };

            Red.prototype.sqrt = function sqrt(a) {
                if (a.isZero()) return a.clone();

                var mod3 = this.m.andln(3);
                assert(mod3 % 2 === 1);

                // Fast case
                if (mod3 === 3) {
                    var pow = this.m.add(new BN(1)).iushrn(2);
                    return this.pow(a, pow);
                }

                // Tonelli-Shanks algorithm (Totally unoptimized and slow)
                //
                // Find Q and S, that Q * 2 ^ S = (P - 1)
                var q = this.m.subn(1);
                var s = 0;
                while (!q.isZero() && q.andln(1) === 0) {
                    s++;
                    q.iushrn(1);
                }
                assert(!q.isZero());

                var one = new BN(1).toRed(this);
                var nOne = one.redNeg();

                // Find quadratic non-residue
                // NOTE: Max is such because of generalized Riemann hypothesis.
                var lpow = this.m.subn(1).iushrn(1);
                var z = this.m.bitLength();
                z = new BN(2 * z * z).toRed(this);

                while (this.pow(z, lpow).cmp(nOne) !== 0) {
                    z.redIAdd(nOne);
                }

                var c = this.pow(z, q);
                var r = this.pow(a, q.addn(1).iushrn(1));
                var t = this.pow(a, q);
                var m = s;
                while (t.cmp(one) !== 0) {
                    var tmp = t;
                    for (var i = 0; tmp.cmp(one) !== 0; i++) {
                        tmp = tmp.redSqr();
                    }
                    assert(i < m);
                    var b = this.pow(c, new BN(1).iushln(m - i - 1));

                    r = r.redMul(b);
                    c = b.redSqr();
                    t = t.redMul(c);
                    m = i;
                }

                return r;
            };

            Red.prototype.invm = function invm(a) {
                var inv = a._invmp(this.m);
                if (inv.negative !== 0) {
                    inv.negative = 0;
                    return this.imod(inv).redNeg();
                } else {
                    return this.imod(inv);
                }
            };

            Red.prototype.pow = function pow(a, num) {
                if (num.isZero()) return new BN(1).toRed(this);
                if (num.cmpn(1) === 0) return a.clone();

                var windowSize = 4;
                var wnd = new Array(1 << windowSize);
                wnd[0] = new BN(1).toRed(this);
                wnd[1] = a;
                for (var i = 2; i < wnd.length; i++) {
                    wnd[i] = this.mul(wnd[i - 1], a);
                }

                var res = wnd[0];
                var current = 0;
                var currentLen = 0;
                var start = num.bitLength() % 26;
                if (start === 0) {
                    start = 26;
                }

                for (i = num.length - 1; i >= 0; i--) {
                    var word = num.words[i];
                    for (var j = start - 1; j >= 0; j--) {
                        var bit = (word >> j) & 1;
                        if (res !== wnd[0]) {
                            res = this.sqr(res);
                        }

                        if (bit === 0 && current === 0) {
                            currentLen = 0;
                            continue;
                        }

                        current <<= 1;
                        current |= bit;
                        currentLen++;
                        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

                        res = this.mul(res, wnd[current]);
                        currentLen = 0;
                        current = 0;
                    }
                    start = 26;
                }

                return res;
            };

            Red.prototype.convertTo = function convertTo(num) {
                var r = num.umod(this.m);

                return r === num ? r.clone() : r;
            };

            Red.prototype.convertFrom = function convertFrom(num) {
                var res = num.clone();
                res.red = null;
                return res;
            };

            //
            // Montgomery method engine
            //

            BN.mont = function mont(num) {
                return new Mont(num);
            };

            function Mont(m) {
                Red.call(this, m);

                this.shift = this.m.bitLength();
                if (this.shift % 26 !== 0) {
                    this.shift += 26 - (this.shift % 26);
                }

                this.r = new BN(1).iushln(this.shift);
                this.r2 = this.imod(this.r.sqr());
                this.rinv = this.r._invmp(this.m);

                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                this.minv = this.minv.umod(this.r);
                this.minv = this.r.sub(this.minv);
            }

            inherits(Mont, Red);

            Mont.prototype.convertTo = function convertTo(num) {
                return this.imod(num.ushln(this.shift));
            };

            Mont.prototype.convertFrom = function convertFrom(num) {
                var r = this.imod(num.mul(this.rinv));
                r.red = null;
                return r;
            };

            Mont.prototype.imul = function imul(a, b) {
                if (a.isZero() || b.isZero()) {
                    a.words[0] = 0;
                    a.length = 1;
                    return a;
                }

                var t = a.imul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;

                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }

                return res._forceRed(this);
            };

            Mont.prototype.mul = function mul(a, b) {
                if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

                var t = a.mul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }

                return res._forceRed(this);
            };

            Mont.prototype.invm = function invm(a) {
                // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
                var res = this.imod(a._invmp(this.m).mul(this.r2));
                return res._forceRed(this);
            };
        })(typeof module === 'undefined' || module, this);

    }, {"buffer": 2}],
    120: [function (require, module, exports) {
        var r;

        module.exports = function rand(len) {
            if (!r)
                r = new Rand(null);

            return r.generate(len);
        };

        function Rand(rand) {
            this.rand = rand;
        }

        module.exports.Rand = Rand;

        Rand.prototype.generate = function generate(len) {
            return this._rand(len);
        };

// Emulate crypto API using randy
        Rand.prototype._rand = function _rand(n) {
            if (this.rand.getBytes)
                return this.rand.getBytes(n);

            var res = new Uint8Array(n);
            for (var i = 0; i < res.length; i++)
                res[i] = this.rand.getByte();
            return res;
        };

        if (typeof self === 'object') {
            if (self.crypto && self.crypto.getRandomValues) {
                // Modern browsers
                Rand.prototype._rand = function _rand(n) {
                    var arr = new Uint8Array(n);
                    self.crypto.getRandomValues(arr);
                    return arr;
                };
            } else if (self.msCrypto && self.msCrypto.getRandomValues) {
                // IE
                Rand.prototype._rand = function _rand(n) {
                    var arr = new Uint8Array(n);
                    self.msCrypto.getRandomValues(arr);
                    return arr;
                };

                // Safari's WebWorkers do not have `crypto`
            } else if (typeof window === 'object') {
                // Old junk
                Rand.prototype._rand = function () {
                    throw new Error('Not implemented yet');
                };
            }
        } else {
            // Node.js or Web worker with no crypto support
            try {
                var crypto = require('crypto');
                if (typeof crypto.randomBytes !== 'function')
                    throw new Error('Not supported');

                Rand.prototype._rand = function _rand(n) {
                    return crypto.randomBytes(n);
                };
            } catch (e) {
            }
        }

    }, {"crypto": 2}],
    121: [function (require, module, exports) {
        var basex = require('base-x')
        var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

        module.exports = basex(ALPHABET)

    }, {"base-x": 33}],
    122: [function (require, module, exports) {
        'use strict'

        var base58 = require('bs58')
        var Buffer = require('safe-buffer').Buffer

        module.exports = function (checksumFn) {
            // Encode a buffer as a base58-check encoded string
            function encode(payload) {
                var checksum = checksumFn(payload)

                return base58.encode(Buffer.concat([
                    payload,
                    checksum
                ], payload.length + 4))
            }

            function decodeRaw(buffer) {
                var payload = buffer.slice(0, -4)
                var checksum = buffer.slice(-4)
                var newChecksum = checksumFn(payload)

                if (checksum[0] ^ newChecksum[0] |
                    checksum[1] ^ newChecksum[1] |
                    checksum[2] ^ newChecksum[2] |
                    checksum[3] ^ newChecksum[3]) return

                return payload
            }

            // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
            function decodeUnsafe(string) {
                var buffer = base58.decodeUnsafe(string)
                if (!buffer) return

                return decodeRaw(buffer)
            }

            function decode(string) {
                var buffer = base58.decode(string)
                var payload = decodeRaw(buffer, checksumFn)
                if (!payload) throw new Error('Invalid checksum')
                return payload
            }

            return {
                encode: encode,
                decode: decode,
                decodeUnsafe: decodeUnsafe
            }
        }

    }, {"bs58": 121, "safe-buffer": 172}],
    123: [function (require, module, exports) {
        'use strict'

        var createHash = require('create-hash')
        var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
        function sha256x2(buffer) {
            var tmp = createHash('sha256').update(buffer).digest()
            return createHash('sha256').update(tmp).digest()
        }

        module.exports = bs58checkBase(sha256x2)

    }, {"./base": 122, "create-hash": 125}],
    124: [function (require, module, exports) {
        var Buffer = require('safe-buffer').Buffer
        var Transform = require('stream').Transform
        var StringDecoder = require('string_decoder').StringDecoder
        var inherits = require('inherits')

        function CipherBase(hashMode) {
            Transform.call(this)
            this.hashMode = typeof hashMode === 'string'
            if (this.hashMode) {
                this[hashMode] = this._finalOrDigest
            } else {
                this.final = this._finalOrDigest
            }
            if (this._final) {
                this.__final = this._final
                this._final = null
            }
            this._decoder = null
            this._encoding = null
        }

        inherits(CipherBase, Transform)

        CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
            if (typeof data === 'string') {
                data = Buffer.from(data, inputEnc)
            }

            var outData = this._update(data)
            if (this.hashMode) return this

            if (outputEnc) {
                outData = this._toString(outData, outputEnc)
            }

            return outData
        }

        CipherBase.prototype.setAutoPadding = function () {
        }
        CipherBase.prototype.getAuthTag = function () {
            throw new Error('trying to get auth tag in unsupported state')
        }

        CipherBase.prototype.setAuthTag = function () {
            throw new Error('trying to set auth tag in unsupported state')
        }

        CipherBase.prototype.setAAD = function () {
            throw new Error('trying to set aad in unsupported state')
        }

        CipherBase.prototype._transform = function (data, _, next) {
            var err
            try {
                if (this.hashMode) {
                    this._update(data)
                } else {
                    this.push(this._update(data))
                }
            } catch (e) {
                err = e
            } finally {
                next(err)
            }
        }
        CipherBase.prototype._flush = function (done) {
            var err
            try {
                this.push(this.__final())
            } catch (e) {
                err = e
            }

            done(err)
        }
        CipherBase.prototype._finalOrDigest = function (outputEnc) {
            var outData = this.__final() || Buffer.alloc(0)
            if (outputEnc) {
                outData = this._toString(outData, outputEnc, true)
            }
            return outData
        }

        CipherBase.prototype._toString = function (value, enc, fin) {
            if (!this._decoder) {
                this._decoder = new StringDecoder(enc)
                this._encoding = enc
            }

            if (this._encoding !== enc) throw new Error('can\'t switch encodings')

            var out = this._decoder.write(value)
            if (fin) {
                out += this._decoder.end()
            }

            return out
        }

        module.exports = CipherBase

    }, {"inherits": 159, "safe-buffer": 172, "stream": 28, "string_decoder": 29}],
    125: [function (require, module, exports) {
        'use strict'
        var inherits = require('inherits')
        var MD5 = require('md5.js')
        var RIPEMD160 = require('ripemd160')
        var sha = require('sha.js')
        var Base = require('cipher-base')

        function Hash(hash) {
            Base.call(this, 'digest')

            this._hash = hash
        }

        inherits(Hash, Base)

        Hash.prototype._update = function (data) {
            this._hash.update(data)
        }

        Hash.prototype._final = function () {
            return this._hash.digest()
        }

        module.exports = function createHash(alg) {
            alg = alg.toLowerCase()
            if (alg === 'md5') return new MD5()
            if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

            return new Hash(sha(alg))
        }

    }, {"cipher-base": 124, "inherits": 159, "md5.js": 160, "ripemd160": 171, "sha.js": 174}],
    126: [function (require, module, exports) {
        var MD5 = require('md5.js')

        module.exports = function (buffer) {
            return new MD5().update(buffer).digest()
        }

    }, {"md5.js": 160}],
    127: [function (require, module, exports) {
        'use strict'
        var inherits = require('inherits')
        var Legacy = require('./legacy')
        var Base = require('cipher-base')
        var Buffer = require('safe-buffer').Buffer
        var md5 = require('create-hash/md5')
        var RIPEMD160 = require('ripemd160')

        var sha = require('sha.js')

        var ZEROS = Buffer.alloc(128)

        function Hmac(alg, key) {
            Base.call(this, 'digest')
            if (typeof key === 'string') {
                key = Buffer.from(key)
            }

            var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

            this._alg = alg
            this._key = key
            if (key.length > blocksize) {
                var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
                key = hash.update(key).digest()
            } else if (key.length < blocksize) {
                key = Buffer.concat([key, ZEROS], blocksize)
            }

            var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
            var opad = this._opad = Buffer.allocUnsafe(blocksize)

            for (var i = 0; i < blocksize; i++) {
                ipad[i] = key[i] ^ 0x36
                opad[i] = key[i] ^ 0x5C
            }
            this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
            this._hash.update(ipad)
        }

        inherits(Hmac, Base)

        Hmac.prototype._update = function (data) {
            this._hash.update(data)
        }

        Hmac.prototype._final = function () {
            var h = this._hash.digest()
            var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
            return hash.update(this._opad).update(h).digest()
        }

        module.exports = function createHmac(alg, key) {
            alg = alg.toLowerCase()
            if (alg === 'rmd160' || alg === 'ripemd160') {
                return new Hmac('rmd160', key)
            }
            if (alg === 'md5') {
                return new Legacy(md5, key)
            }
            return new Hmac(alg, key)
        }

    }, {
        "./legacy": 128,
        "cipher-base": 124,
        "create-hash/md5": 126,
        "inherits": 159,
        "ripemd160": 171,
        "safe-buffer": 172,
        "sha.js": 174
    }],
    128: [function (require, module, exports) {
        'use strict'
        var inherits = require('inherits')
        var Buffer = require('safe-buffer').Buffer

        var Base = require('cipher-base')

        var ZEROS = Buffer.alloc(128)
        var blocksize = 64

        function Hmac(alg, key) {
            Base.call(this, 'digest')
            if (typeof key === 'string') {
                key = Buffer.from(key)
            }

            this._alg = alg
            this._key = key

            if (key.length > blocksize) {
                key = alg(key)
            } else if (key.length < blocksize) {
                key = Buffer.concat([key, ZEROS], blocksize)
            }

            var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
            var opad = this._opad = Buffer.allocUnsafe(blocksize)

            for (var i = 0; i < blocksize; i++) {
                ipad[i] = key[i] ^ 0x36
                opad[i] = key[i] ^ 0x5C
            }

            this._hash = [ipad]
        }

        inherits(Hmac, Base)

        Hmac.prototype._update = function (data) {
            this._hash.push(data)
        }

        Hmac.prototype._final = function () {
            var h = this._alg(Buffer.concat(this._hash))
            return this._alg(Buffer.concat([this._opad, h]))
        }
        module.exports = Hmac

    }, {"cipher-base": 124, "inherits": 159, "safe-buffer": 172}],
    129: [function (require, module, exports) {
        'use strict';

        var elliptic = exports;

        elliptic.version = require('../package.json').version;
        elliptic.utils = require('./elliptic/utils');
        elliptic.rand = require('brorand');
        elliptic.curve = require('./elliptic/curve');
        elliptic.curves = require('./elliptic/curves');

// Protocols
        elliptic.ec = require('./elliptic/ec');
        elliptic.eddsa = require('./elliptic/eddsa');

    }, {
        "../package.json": 144,
        "./elliptic/curve": 132,
        "./elliptic/curves": 135,
        "./elliptic/ec": 136,
        "./elliptic/eddsa": 139,
        "./elliptic/utils": 143,
        "brorand": 120
    }],
    130: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');
        var utils = require('../utils');
        var getNAF = utils.getNAF;
        var getJSF = utils.getJSF;
        var assert = utils.assert;

        function BaseCurve(type, conf) {
            this.type = type;
            this.p = new BN(conf.p, 16);

            // Use Montgomery, when there is no fast reduction for the prime
            this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

            // Useful for many curves
            this.zero = new BN(0).toRed(this.red);
            this.one = new BN(1).toRed(this.red);
            this.two = new BN(2).toRed(this.red);

            // Curve configuration, optional
            this.n = conf.n && new BN(conf.n, 16);
            this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

            // Temporary arrays
            this._wnafT1 = new Array(4);
            this._wnafT2 = new Array(4);
            this._wnafT3 = new Array(4);
            this._wnafT4 = new Array(4);

            this._bitLength = this.n ? this.n.bitLength() : 0;

            // Generalized Greg Maxwell's trick
            var adjustCount = this.n && this.p.div(this.n);
            if (!adjustCount || adjustCount.cmpn(100) > 0) {
                this.redN = null;
            } else {
                this._maxwellTrick = true;
                this.redN = this.n.toRed(this.red);
            }
        }

        module.exports = BaseCurve;

        BaseCurve.prototype.point = function point() {
            throw new Error('Not implemented');
        };

        BaseCurve.prototype.validate = function validate() {
            throw new Error('Not implemented');
        };

        BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
            assert(p.precomputed);
            var doubles = p._getDoubles();

            var naf = getNAF(k, 1, this._bitLength);
            var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
            I /= 3;

            // Translate into more windowed form
            var repr = [];
            for (var j = 0; j < naf.length; j += doubles.step) {
                var nafW = 0;
                for (var k = j + doubles.step - 1; k >= j; k--)
                    nafW = (nafW << 1) + naf[k];
                repr.push(nafW);
            }

            var a = this.jpoint(null, null, null);
            var b = this.jpoint(null, null, null);
            for (var i = I; i > 0; i--) {
                for (var j = 0; j < repr.length; j++) {
                    var nafW = repr[j];
                    if (nafW === i)
                        b = b.mixedAdd(doubles.points[j]);
                    else if (nafW === -i)
                        b = b.mixedAdd(doubles.points[j].neg());
                }
                a = a.add(b);
            }
            return a.toP();
        };

        BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
            var w = 4;

            // Precompute window
            var nafPoints = p._getNAFPoints(w);
            w = nafPoints.wnd;
            var wnd = nafPoints.points;

            // Get NAF form
            var naf = getNAF(k, w, this._bitLength);

            // Add `this`*(N+1) for every w-NAF index
            var acc = this.jpoint(null, null, null);
            for (var i = naf.length - 1; i >= 0; i--) {
                // Count zeroes
                for (var k = 0; i >= 0 && naf[i] === 0; i--)
                    k++;
                if (i >= 0)
                    k++;
                acc = acc.dblp(k);

                if (i < 0)
                    break;
                var z = naf[i];
                assert(z !== 0);
                if (p.type === 'affine') {
                    // J +- P
                    if (z > 0)
                        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                    else
                        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
                } else {
                    // J +- J
                    if (z > 0)
                        acc = acc.add(wnd[(z - 1) >> 1]);
                    else
                        acc = acc.add(wnd[(-z - 1) >> 1].neg());
                }
            }
            return p.type === 'affine' ? acc.toP() : acc;
        };

        BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                               points,
                                                               coeffs,
                                                               len,
                                                               jacobianResult) {
            var wndWidth = this._wnafT1;
            var wnd = this._wnafT2;
            var naf = this._wnafT3;

            // Fill all arrays
            var max = 0;
            for (var i = 0; i < len; i++) {
                var p = points[i];
                var nafPoints = p._getNAFPoints(defW);
                wndWidth[i] = nafPoints.wnd;
                wnd[i] = nafPoints.points;
            }

            // Comb small window NAFs
            for (var i = len - 1; i >= 1; i -= 2) {
                var a = i - 1;
                var b = i;
                if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                    naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
                    naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
                    max = Math.max(naf[a].length, max);
                    max = Math.max(naf[b].length, max);
                    continue;
                }

                var comb = [
                    points[a], /* 1 */
                    null, /* 3 */
                    null, /* 5 */
                    points[b] /* 7 */
                ];

                // Try to avoid Projective points, if possible
                if (points[a].y.cmp(points[b].y) === 0) {
                    comb[1] = points[a].add(points[b]);
                    comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                    comb[1] = points[a].toJ().mixedAdd(points[b]);
                    comb[2] = points[a].add(points[b].neg());
                } else {
                    comb[1] = points[a].toJ().mixedAdd(points[b]);
                    comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                }

                var index = [
                    -3, /* -1 -1 */
                    -1, /* -1 0 */
                    -5, /* -1 1 */
                    -7, /* 0 -1 */
                    0, /* 0 0 */
                    7, /* 0 1 */
                    5, /* 1 -1 */
                    1, /* 1 0 */
                    3  /* 1 1 */
                ];

                var jsf = getJSF(coeffs[a], coeffs[b]);
                max = Math.max(jsf[0].length, max);
                naf[a] = new Array(max);
                naf[b] = new Array(max);
                for (var j = 0; j < max; j++) {
                    var ja = jsf[0][j] | 0;
                    var jb = jsf[1][j] | 0;

                    naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                    naf[b][j] = 0;
                    wnd[a] = comb;
                }
            }

            var acc = this.jpoint(null, null, null);
            var tmp = this._wnafT4;
            for (var i = max; i >= 0; i--) {
                var k = 0;

                while (i >= 0) {
                    var zero = true;
                    for (var j = 0; j < len; j++) {
                        tmp[j] = naf[j][i] | 0;
                        if (tmp[j] !== 0)
                            zero = false;
                    }
                    if (!zero)
                        break;
                    k++;
                    i--;
                }
                if (i >= 0)
                    k++;
                acc = acc.dblp(k);
                if (i < 0)
                    break;

                for (var j = 0; j < len; j++) {
                    var z = tmp[j];
                    var p;
                    if (z === 0)
                        continue;
                    else if (z > 0)
                        p = wnd[j][(z - 1) >> 1];
                    else if (z < 0)
                        p = wnd[j][(-z - 1) >> 1].neg();

                    if (p.type === 'affine')
                        acc = acc.mixedAdd(p);
                    else
                        acc = acc.add(p);
                }
            }
            // Zeroify references
            for (var i = 0; i < len; i++)
                wnd[i] = null;

            if (jacobianResult)
                return acc;
            else
                return acc.toP();
        };

        function BasePoint(curve, type) {
            this.curve = curve;
            this.type = type;
            this.precomputed = null;
        }

        BaseCurve.BasePoint = BasePoint;

        BasePoint.prototype.eq = function eq(/*other*/) {
            throw new Error('Not implemented');
        };

        BasePoint.prototype.validate = function validate() {
            return this.curve.validate(this);
        };

        BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            bytes = utils.toArray(bytes, enc);

            var len = this.p.byteLength();

            // uncompressed, hybrid-odd, hybrid-even
            if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
                bytes.length - 1 === 2 * len) {
                if (bytes[0] === 0x06)
                    assert(bytes[bytes.length - 1] % 2 === 0);
                else if (bytes[0] === 0x07)
                    assert(bytes[bytes.length - 1] % 2 === 1);

                var res = this.point(bytes.slice(1, 1 + len),
                    bytes.slice(1 + len, 1 + 2 * len));

                return res;
            } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
                bytes.length - 1 === len) {
                return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
            }
            throw new Error('Unknown point format');
        };

        BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
            return this.encode(enc, true);
        };

        BasePoint.prototype._encode = function _encode(compact) {
            var len = this.curve.p.byteLength();
            var x = this.getX().toArray('be', len);

            if (compact)
                return [this.getY().isEven() ? 0x02 : 0x03].concat(x);

            return [0x04].concat(x, this.getY().toArray('be', len));
        };

        BasePoint.prototype.encode = function encode(enc, compact) {
            return utils.encode(this._encode(compact), enc);
        };

        BasePoint.prototype.precompute = function precompute(power) {
            if (this.precomputed)
                return this;

            var precomputed = {
                doubles: null,
                naf: null,
                beta: null
            };
            precomputed.naf = this._getNAFPoints(8);
            precomputed.doubles = this._getDoubles(4, power);
            precomputed.beta = this._getBeta();
            this.precomputed = precomputed;

            return this;
        };

        BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
            if (!this.precomputed)
                return false;

            var doubles = this.precomputed.doubles;
            if (!doubles)
                return false;

            return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
        };

        BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
            if (this.precomputed && this.precomputed.doubles)
                return this.precomputed.doubles;

            var doubles = [this];
            var acc = this;
            for (var i = 0; i < power; i += step) {
                for (var j = 0; j < step; j++)
                    acc = acc.dbl();
                doubles.push(acc);
            }
            return {
                step: step,
                points: doubles
            };
        };

        BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
            if (this.precomputed && this.precomputed.naf)
                return this.precomputed.naf;

            var res = [this];
            var max = (1 << wnd) - 1;
            var dbl = max === 1 ? null : this.dbl();
            for (var i = 1; i < max; i++)
                res[i] = res[i - 1].add(dbl);
            return {
                wnd: wnd,
                points: res
            };
        };

        BasePoint.prototype._getBeta = function _getBeta() {
            return null;
        };

        BasePoint.prototype.dblp = function dblp(k) {
            var r = this;
            for (var i = 0; i < k; i++)
                r = r.dbl();
            return r;
        };

    }, {"../utils": 143, "bn.js": 119}],
    131: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var BN = require('bn.js');
        var inherits = require('inherits');
        var Base = require('./base');

        var assert = utils.assert;

        function EdwardsCurve(conf) {
            // NOTE: Important as we are creating point in Base.call()
            this.twisted = (conf.a | 0) !== 1;
            this.mOneA = this.twisted && (conf.a | 0) === -1;
            this.extended = this.mOneA;

            Base.call(this, 'edwards', conf);

            this.a = new BN(conf.a, 16).umod(this.red.m);
            this.a = this.a.toRed(this.red);
            this.c = new BN(conf.c, 16).toRed(this.red);
            this.c2 = this.c.redSqr();
            this.d = new BN(conf.d, 16).toRed(this.red);
            this.dd = this.d.redAdd(this.d);

            assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
            this.oneC = (conf.c | 0) === 1;
        }

        inherits(EdwardsCurve, Base);
        module.exports = EdwardsCurve;

        EdwardsCurve.prototype._mulA = function _mulA(num) {
            if (this.mOneA)
                return num.redNeg();
            else
                return this.a.redMul(num);
        };

        EdwardsCurve.prototype._mulC = function _mulC(num) {
            if (this.oneC)
                return num;
            else
                return this.c.redMul(num);
        };

// Just for compatibility with Short curve
        EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
            return this.point(x, y, z, t);
        };

        EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new BN(x, 16);
            if (!x.red)
                x = x.toRed(this.red);

            var x2 = x.redSqr();
            var rhs = this.c2.redSub(this.a.redMul(x2));
            var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

            var y2 = rhs.redMul(lhs.redInvm());
            var y = y2.redSqrt();
            if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
                throw new Error('invalid point');

            var isOdd = y.fromRed().isOdd();
            if (odd && !isOdd || !odd && isOdd)
                y = y.redNeg();

            return this.point(x, y);
        };

        EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
            y = new BN(y, 16);
            if (!y.red)
                y = y.toRed(this.red);

            // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
            var y2 = y.redSqr();
            var lhs = y2.redSub(this.c2);
            var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
            var x2 = lhs.redMul(rhs.redInvm());

            if (x2.cmp(this.zero) === 0) {
                if (odd)
                    throw new Error('invalid point');
                else
                    return this.point(this.zero, y);
            }

            var x = x2.redSqrt();
            if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
                throw new Error('invalid point');

            if (x.fromRed().isOdd() !== odd)
                x = x.redNeg();

            return this.point(x, y);
        };

        EdwardsCurve.prototype.validate = function validate(point) {
            if (point.isInfinity())
                return true;

            // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
            point.normalize();

            var x2 = point.x.redSqr();
            var y2 = point.y.redSqr();
            var lhs = x2.redMul(this.a).redAdd(y2);
            var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

            return lhs.cmp(rhs) === 0;
        };

        function Point(curve, x, y, z, t) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && y === null && z === null) {
                this.x = this.curve.zero;
                this.y = this.curve.one;
                this.z = this.curve.one;
                this.t = this.curve.zero;
                this.zOne = true;
            } else {
                this.x = new BN(x, 16);
                this.y = new BN(y, 16);
                this.z = z ? new BN(z, 16) : this.curve.one;
                this.t = t && new BN(t, 16);
                if (!this.x.red)
                    this.x = this.x.toRed(this.curve.red);
                if (!this.y.red)
                    this.y = this.y.toRed(this.curve.red);
                if (!this.z.red)
                    this.z = this.z.toRed(this.curve.red);
                if (this.t && !this.t.red)
                    this.t = this.t.toRed(this.curve.red);
                this.zOne = this.z === this.curve.one;

                // Use extended coordinates
                if (this.curve.extended && !this.t) {
                    this.t = this.x.redMul(this.y);
                    if (!this.zOne)
                        this.t = this.t.redMul(this.z.redInvm());
                }
            }
        }

        inherits(Point, Base.BasePoint);

        EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
        };

        EdwardsCurve.prototype.point = function point(x, y, z, t) {
            return new Point(this, x, y, z, t);
        };

        Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1], obj[2]);
        };

        Point.prototype.inspect = function inspect() {
            if (this.isInfinity())
                return '<EC Point Infinity>';
            return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                ' y: ' + this.y.fromRed().toString(16, 2) +
                ' z: ' + this.z.fromRed().toString(16, 2) + '>';
        };

        Point.prototype.isInfinity = function isInfinity() {
            // XXX This code assumes that zero is always zero in red
            return this.x.cmpn(0) === 0 &&
                (this.y.cmp(this.z) === 0 ||
                    (this.zOne && this.y.cmp(this.curve.c) === 0));
        };

        Point.prototype._extDbl = function _extDbl() {
            // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
            //     #doubling-dbl-2008-hwcd
            // 4M + 4S

            // A = X1^2
            var a = this.x.redSqr();
            // B = Y1^2
            var b = this.y.redSqr();
            // C = 2 * Z1^2
            var c = this.z.redSqr();
            c = c.redIAdd(c);
            // D = a * A
            var d = this.curve._mulA(a);
            // E = (X1 + Y1)^2 - A - B
            var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
            // G = D + B
            var g = d.redAdd(b);
            // F = G - C
            var f = g.redSub(c);
            // H = D - B
            var h = d.redSub(b);
            // X3 = E * F
            var nx = e.redMul(f);
            // Y3 = G * H
            var ny = g.redMul(h);
            // T3 = E * H
            var nt = e.redMul(h);
            // Z3 = F * G
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
        };

        Point.prototype._projDbl = function _projDbl() {
            // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
            //     #doubling-dbl-2008-bbjlp
            //     #doubling-dbl-2007-bl
            // and others
            // Generally 3M + 4S or 2M + 4S

            // B = (X1 + Y1)^2
            var b = this.x.redAdd(this.y).redSqr();
            // C = X1^2
            var c = this.x.redSqr();
            // D = Y1^2
            var d = this.y.redSqr();

            var nx;
            var ny;
            var nz;
            if (this.curve.twisted) {
                // E = a * C
                var e = this.curve._mulA(c);
                // F = E + D
                var f = e.redAdd(d);
                if (this.zOne) {
                    // X3 = (B - C - D) * (F - 2)
                    nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                    // Y3 = F * (E - D)
                    ny = f.redMul(e.redSub(d));
                    // Z3 = F^2 - 2 * F
                    nz = f.redSqr().redSub(f).redSub(f);
                } else {
                    // H = Z1^2
                    var h = this.z.redSqr();
                    // J = F - 2 * H
                    var j = f.redSub(h).redISub(h);
                    // X3 = (B-C-D)*J
                    nx = b.redSub(c).redISub(d).redMul(j);
                    // Y3 = F * (E - D)
                    ny = f.redMul(e.redSub(d));
                    // Z3 = F * J
                    nz = f.redMul(j);
                }
            } else {
                // E = C + D
                var e = c.redAdd(d);
                // H = (c * Z1)^2
                var h = this.curve._mulC(this.z).redSqr();
                // J = E - 2 * H
                var j = e.redSub(h).redSub(h);
                // X3 = c * (B - E) * J
                nx = this.curve._mulC(b.redISub(e)).redMul(j);
                // Y3 = c * E * (C - D)
                ny = this.curve._mulC(e).redMul(c.redISub(d));
                // Z3 = E * J
                nz = e.redMul(j);
            }
            return this.curve.point(nx, ny, nz);
        };

        Point.prototype.dbl = function dbl() {
            if (this.isInfinity())
                return this;

            // Double in extended coordinates
            if (this.curve.extended)
                return this._extDbl();
            else
                return this._projDbl();
        };

        Point.prototype._extAdd = function _extAdd(p) {
            // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
            //     #addition-add-2008-hwcd-3
            // 8M

            // A = (Y1 - X1) * (Y2 - X2)
            var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
            // B = (Y1 + X1) * (Y2 + X2)
            var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
            // C = T1 * k * T2
            var c = this.t.redMul(this.curve.dd).redMul(p.t);
            // D = Z1 * 2 * Z2
            var d = this.z.redMul(p.z.redAdd(p.z));
            // E = B - A
            var e = b.redSub(a);
            // F = D - C
            var f = d.redSub(c);
            // G = D + C
            var g = d.redAdd(c);
            // H = B + A
            var h = b.redAdd(a);
            // X3 = E * F
            var nx = e.redMul(f);
            // Y3 = G * H
            var ny = g.redMul(h);
            // T3 = E * H
            var nt = e.redMul(h);
            // Z3 = F * G
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
        };

        Point.prototype._projAdd = function _projAdd(p) {
            // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
            //     #addition-add-2008-bbjlp
            //     #addition-add-2007-bl
            // 10M + 1S

            // A = Z1 * Z2
            var a = this.z.redMul(p.z);
            // B = A^2
            var b = a.redSqr();
            // C = X1 * X2
            var c = this.x.redMul(p.x);
            // D = Y1 * Y2
            var d = this.y.redMul(p.y);
            // E = d * C * D
            var e = this.curve.d.redMul(c).redMul(d);
            // F = B - E
            var f = b.redSub(e);
            // G = B + E
            var g = b.redAdd(e);
            // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
            var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
            var nx = a.redMul(f).redMul(tmp);
            var ny;
            var nz;
            if (this.curve.twisted) {
                // Y3 = A * G * (D - a * C)
                ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
                // Z3 = F * G
                nz = f.redMul(g);
            } else {
                // Y3 = A * G * (D - C)
                ny = a.redMul(g).redMul(d.redSub(c));
                // Z3 = c * F * G
                nz = this.curve._mulC(f).redMul(g);
            }
            return this.curve.point(nx, ny, nz);
        };

        Point.prototype.add = function add(p) {
            if (this.isInfinity())
                return p;
            if (p.isInfinity())
                return this;

            if (this.curve.extended)
                return this._extAdd(p);
            else
                return this._projAdd(p);
        };

        Point.prototype.mul = function mul(k) {
            if (this._hasDoubles(k))
                return this.curve._fixedNafMul(this, k);
            else
                return this.curve._wnafMul(this, k);
        };

        Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
            return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
        };

        Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
            return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
        };

        Point.prototype.normalize = function normalize() {
            if (this.zOne)
                return this;

            // Normalize coordinates
            var zi = this.z.redInvm();
            this.x = this.x.redMul(zi);
            this.y = this.y.redMul(zi);
            if (this.t)
                this.t = this.t.redMul(zi);
            this.z = this.curve.one;
            this.zOne = true;
            return this;
        };

        Point.prototype.neg = function neg() {
            return this.curve.point(this.x.redNeg(),
                this.y,
                this.z,
                this.t && this.t.redNeg());
        };

        Point.prototype.getX = function getX() {
            this.normalize();
            return this.x.fromRed();
        };

        Point.prototype.getY = function getY() {
            this.normalize();
            return this.y.fromRed();
        };

        Point.prototype.eq = function eq(other) {
            return this === other ||
                this.getX().cmp(other.getX()) === 0 &&
                this.getY().cmp(other.getY()) === 0;
        };

        Point.prototype.eqXToP = function eqXToP(x) {
            var rx = x.toRed(this.curve.red).redMul(this.z);
            if (this.x.cmp(rx) === 0)
                return true;

            var xc = x.clone();
            var t = this.curve.redN.redMul(this.z);
            for (; ;) {
                xc.iadd(this.curve.n);
                if (xc.cmp(this.curve.p) >= 0)
                    return false;

                rx.redIAdd(t);
                if (this.x.cmp(rx) === 0)
                    return true;
            }
        };

// Compatibility with BaseCurve
        Point.prototype.toP = Point.prototype.normalize;
        Point.prototype.mixedAdd = Point.prototype.add;

    }, {"../utils": 143, "./base": 130, "bn.js": 119, "inherits": 159}],
    132: [function (require, module, exports) {
        'use strict';

        var curve = exports;

        curve.base = require('./base');
        curve.short = require('./short');
        curve.mont = require('./mont');
        curve.edwards = require('./edwards');

    }, {"./base": 130, "./edwards": 131, "./mont": 133, "./short": 134}],
    133: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');
        var inherits = require('inherits');
        var Base = require('./base');

        var utils = require('../utils');

        function MontCurve(conf) {
            Base.call(this, 'mont', conf);

            this.a = new BN(conf.a, 16).toRed(this.red);
            this.b = new BN(conf.b, 16).toRed(this.red);
            this.i4 = new BN(4).toRed(this.red).redInvm();
            this.two = new BN(2).toRed(this.red);
            this.a24 = this.i4.redMul(this.a.redAdd(this.two));
        }

        inherits(MontCurve, Base);
        module.exports = MontCurve;

        MontCurve.prototype.validate = function validate(point) {
            var x = point.normalize().x;
            var x2 = x.redSqr();
            var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
            var y = rhs.redSqrt();

            return y.redSqr().cmp(rhs) === 0;
        };

        function Point(curve, x, z) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && z === null) {
                this.x = this.curve.one;
                this.z = this.curve.zero;
            } else {
                this.x = new BN(x, 16);
                this.z = new BN(z, 16);
                if (!this.x.red)
                    this.x = this.x.toRed(this.curve.red);
                if (!this.z.red)
                    this.z = this.z.toRed(this.curve.red);
            }
        }

        inherits(Point, Base.BasePoint);

        MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            return this.point(utils.toArray(bytes, enc), 1);
        };

        MontCurve.prototype.point = function point(x, z) {
            return new Point(this, x, z);
        };

        MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
        };

        Point.prototype.precompute = function precompute() {
            // No-op
        };

        Point.prototype._encode = function _encode() {
            return this.getX().toArray('be', this.curve.p.byteLength());
        };

        Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1] || curve.one);
        };

        Point.prototype.inspect = function inspect() {
            if (this.isInfinity())
                return '<EC Point Infinity>';
            return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                ' z: ' + this.z.fromRed().toString(16, 2) + '>';
        };

        Point.prototype.isInfinity = function isInfinity() {
            // XXX This code assumes that zero is always zero in red
            return this.z.cmpn(0) === 0;
        };

        Point.prototype.dbl = function dbl() {
            // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
            // 2M + 2S + 4A

            // A = X1 + Z1
            var a = this.x.redAdd(this.z);
            // AA = A^2
            var aa = a.redSqr();
            // B = X1 - Z1
            var b = this.x.redSub(this.z);
            // BB = B^2
            var bb = b.redSqr();
            // C = AA - BB
            var c = aa.redSub(bb);
            // X3 = AA * BB
            var nx = aa.redMul(bb);
            // Z3 = C * (BB + A24 * C)
            var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
            return this.curve.point(nx, nz);
        };

        Point.prototype.add = function add() {
            throw new Error('Not supported on Montgomery curve');
        };

        Point.prototype.diffAdd = function diffAdd(p, diff) {
            // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
            // 4M + 2S + 6A

            // A = X2 + Z2
            var a = this.x.redAdd(this.z);
            // B = X2 - Z2
            var b = this.x.redSub(this.z);
            // C = X3 + Z3
            var c = p.x.redAdd(p.z);
            // D = X3 - Z3
            var d = p.x.redSub(p.z);
            // DA = D * A
            var da = d.redMul(a);
            // CB = C * B
            var cb = c.redMul(b);
            // X5 = Z1 * (DA + CB)^2
            var nx = diff.z.redMul(da.redAdd(cb).redSqr());
            // Z5 = X1 * (DA - CB)^2
            var nz = diff.x.redMul(da.redISub(cb).redSqr());
            return this.curve.point(nx, nz);
        };

        Point.prototype.mul = function mul(k) {
            var t = k.clone();
            var a = this; // (N / 2) * Q + Q
            var b = this.curve.point(null, null); // (N / 2) * Q
            var c = this; // Q

            for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
                bits.push(t.andln(1));

            for (var i = bits.length - 1; i >= 0; i--) {
                if (bits[i] === 0) {
                    // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
                    a = a.diffAdd(b, c);
                    // N * Q = 2 * ((N / 2) * Q + Q))
                    b = b.dbl();
                } else {
                    // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
                    b = a.diffAdd(b, c);
                    // N * Q + Q = 2 * ((N / 2) * Q + Q)
                    a = a.dbl();
                }
            }
            return b;
        };

        Point.prototype.mulAdd = function mulAdd() {
            throw new Error('Not supported on Montgomery curve');
        };

        Point.prototype.jumlAdd = function jumlAdd() {
            throw new Error('Not supported on Montgomery curve');
        };

        Point.prototype.eq = function eq(other) {
            return this.getX().cmp(other.getX()) === 0;
        };

        Point.prototype.normalize = function normalize() {
            this.x = this.x.redMul(this.z.redInvm());
            this.z = this.curve.one;
            return this;
        };

        Point.prototype.getX = function getX() {
            // Normalize coordinates
            this.normalize();

            return this.x.fromRed();
        };

    }, {"../utils": 143, "./base": 130, "bn.js": 119, "inherits": 159}],
    134: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var BN = require('bn.js');
        var inherits = require('inherits');
        var Base = require('./base');

        var assert = utils.assert;

        function ShortCurve(conf) {
            Base.call(this, 'short', conf);

            this.a = new BN(conf.a, 16).toRed(this.red);
            this.b = new BN(conf.b, 16).toRed(this.red);
            this.tinv = this.two.redInvm();

            this.zeroA = this.a.fromRed().cmpn(0) === 0;
            this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

            // If the curve is endomorphic, precalculate beta and lambda
            this.endo = this._getEndomorphism(conf);
            this._endoWnafT1 = new Array(4);
            this._endoWnafT2 = new Array(4);
        }

        inherits(ShortCurve, Base);
        module.exports = ShortCurve;

        ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
            // No efficient endomorphism
            if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
                return;

            // Compute beta and lambda, that lambda * P = (beta * Px; Py)
            var beta;
            var lambda;
            if (conf.beta) {
                beta = new BN(conf.beta, 16).toRed(this.red);
            } else {
                var betas = this._getEndoRoots(this.p);
                // Choose the smallest beta
                beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
                beta = beta.toRed(this.red);
            }
            if (conf.lambda) {
                lambda = new BN(conf.lambda, 16);
            } else {
                // Choose the lambda that is matching selected beta
                var lambdas = this._getEndoRoots(this.n);
                if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                    lambda = lambdas[0];
                } else {
                    lambda = lambdas[1];
                    assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
                }
            }

            // Get basis vectors, used for balanced length-two representation
            var basis;
            if (conf.basis) {
                basis = conf.basis.map(function (vec) {
                    return {
                        a: new BN(vec.a, 16),
                        b: new BN(vec.b, 16)
                    };
                });
            } else {
                basis = this._getEndoBasis(lambda);
            }

            return {
                beta: beta,
                lambda: lambda,
                basis: basis
            };
        };

        ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
            // Find roots of for x^2 + x + 1 in F
            // Root = (-1 +- Sqrt(-3)) / 2
            //
            var red = num === this.p ? this.red : BN.mont(num);
            var tinv = new BN(2).toRed(red).redInvm();
            var ntinv = tinv.redNeg();

            var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

            var l1 = ntinv.redAdd(s).fromRed();
            var l2 = ntinv.redSub(s).fromRed();
            return [l1, l2];
        };

        ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
            // aprxSqrt >= sqrt(this.n)
            var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

            // 3.74
            // Run EGCD, until r(L + 1) < aprxSqrt
            var u = lambda;
            var v = this.n.clone();
            var x1 = new BN(1);
            var y1 = new BN(0);
            var x2 = new BN(0);
            var y2 = new BN(1);

            // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
            var a0;
            var b0;
            // First vector
            var a1;
            var b1;
            // Second vector
            var a2;
            var b2;

            var prevR;
            var i = 0;
            var r;
            var x;
            while (u.cmpn(0) !== 0) {
                var q = v.div(u);
                r = v.sub(q.mul(u));
                x = x2.sub(q.mul(x1));
                var y = y2.sub(q.mul(y1));

                if (!a1 && r.cmp(aprxSqrt) < 0) {
                    a0 = prevR.neg();
                    b0 = x1;
                    a1 = r.neg();
                    b1 = x;
                } else if (a1 && ++i === 2) {
                    break;
                }
                prevR = r;

                v = u;
                u = r;
                x2 = x1;
                x1 = x;
                y2 = y1;
                y1 = y;
            }
            a2 = r.neg();
            b2 = x;

            var len1 = a1.sqr().add(b1.sqr());
            var len2 = a2.sqr().add(b2.sqr());
            if (len2.cmp(len1) >= 0) {
                a2 = a0;
                b2 = b0;
            }

            // Normalize signs
            if (a1.negative) {
                a1 = a1.neg();
                b1 = b1.neg();
            }
            if (a2.negative) {
                a2 = a2.neg();
                b2 = b2.neg();
            }

            return [
                {a: a1, b: b1},
                {a: a2, b: b2}
            ];
        };

        ShortCurve.prototype._endoSplit = function _endoSplit(k) {
            var basis = this.endo.basis;
            var v1 = basis[0];
            var v2 = basis[1];

            var c1 = v2.b.mul(k).divRound(this.n);
            var c2 = v1.b.neg().mul(k).divRound(this.n);

            var p1 = c1.mul(v1.a);
            var p2 = c2.mul(v2.a);
            var q1 = c1.mul(v1.b);
            var q2 = c2.mul(v2.b);

            // Calculate answer
            var k1 = k.sub(p1).sub(p2);
            var k2 = q1.add(q2).neg();
            return {k1: k1, k2: k2};
        };

        ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new BN(x, 16);
            if (!x.red)
                x = x.toRed(this.red);

            var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
            var y = y2.redSqrt();
            if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
                throw new Error('invalid point');

            // XXX Is there any way to tell if the number is odd without converting it
            // to non-red form?
            var isOdd = y.fromRed().isOdd();
            if (odd && !isOdd || !odd && isOdd)
                y = y.redNeg();

            return this.point(x, y);
        };

        ShortCurve.prototype.validate = function validate(point) {
            if (point.inf)
                return true;

            var x = point.x;
            var y = point.y;

            var ax = this.a.redMul(x);
            var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
            return y.redSqr().redISub(rhs).cmpn(0) === 0;
        };

        ShortCurve.prototype._endoWnafMulAdd =
            function _endoWnafMulAdd(points, coeffs, jacobianResult) {
                var npoints = this._endoWnafT1;
                var ncoeffs = this._endoWnafT2;
                for (var i = 0; i < points.length; i++) {
                    var split = this._endoSplit(coeffs[i]);
                    var p = points[i];
                    var beta = p._getBeta();

                    if (split.k1.negative) {
                        split.k1.ineg();
                        p = p.neg(true);
                    }
                    if (split.k2.negative) {
                        split.k2.ineg();
                        beta = beta.neg(true);
                    }

                    npoints[i * 2] = p;
                    npoints[i * 2 + 1] = beta;
                    ncoeffs[i * 2] = split.k1;
                    ncoeffs[i * 2 + 1] = split.k2;
                }
                var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

                // Clean-up references to points and coefficients
                for (var j = 0; j < i * 2; j++) {
                    npoints[j] = null;
                    ncoeffs[j] = null;
                }
                return res;
            };

        function Point(curve, x, y, isRed) {
            Base.BasePoint.call(this, curve, 'affine');
            if (x === null && y === null) {
                this.x = null;
                this.y = null;
                this.inf = true;
            } else {
                this.x = new BN(x, 16);
                this.y = new BN(y, 16);
                // Force redgomery representation when loading from JSON
                if (isRed) {
                    this.x.forceRed(this.curve.red);
                    this.y.forceRed(this.curve.red);
                }
                if (!this.x.red)
                    this.x = this.x.toRed(this.curve.red);
                if (!this.y.red)
                    this.y = this.y.toRed(this.curve.red);
                this.inf = false;
            }
        }

        inherits(Point, Base.BasePoint);

        ShortCurve.prototype.point = function point(x, y, isRed) {
            return new Point(this, x, y, isRed);
        };

        ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
            return Point.fromJSON(this, obj, red);
        };

        Point.prototype._getBeta = function _getBeta() {
            if (!this.curve.endo)
                return;

            var pre = this.precomputed;
            if (pre && pre.beta)
                return pre.beta;

            var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (pre) {
                var curve = this.curve;
                var endoMul = function (p) {
                    return curve.point(p.x.redMul(curve.endo.beta), p.y);
                };
                pre.beta = beta;
                beta.precomputed = {
                    beta: null,
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: pre.naf.points.map(endoMul)
                    },
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: pre.doubles.points.map(endoMul)
                    }
                };
            }
            return beta;
        };

        Point.prototype.toJSON = function toJSON() {
            if (!this.precomputed)
                return [this.x, this.y];

            return [this.x, this.y, this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }];
        };

        Point.fromJSON = function fromJSON(curve, obj, red) {
            if (typeof obj === 'string')
                obj = JSON.parse(obj);
            var res = curve.point(obj[0], obj[1], red);
            if (!obj[2])
                return res;

            function obj2point(obj) {
                return curve.point(obj[0], obj[1], red);
            }

            var pre = obj[2];
            res.precomputed = {
                beta: null,
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: [res].concat(pre.doubles.points.map(obj2point))
                },
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: [res].concat(pre.naf.points.map(obj2point))
                }
            };
            return res;
        };

        Point.prototype.inspect = function inspect() {
            if (this.isInfinity())
                return '<EC Point Infinity>';
            return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                ' y: ' + this.y.fromRed().toString(16, 2) + '>';
        };

        Point.prototype.isInfinity = function isInfinity() {
            return this.inf;
        };

        Point.prototype.add = function add(p) {
            // O + P = P
            if (this.inf)
                return p;

            // P + O = P
            if (p.inf)
                return this;

            // P + P = 2P
            if (this.eq(p))
                return this.dbl();

            // P + (-P) = O
            if (this.neg().eq(p))
                return this.curve.point(null, null);

            // P + Q = O
            if (this.x.cmp(p.x) === 0)
                return this.curve.point(null, null);

            var c = this.y.redSub(p.y);
            if (c.cmpn(0) !== 0)
                c = c.redMul(this.x.redSub(p.x).redInvm());
            var nx = c.redSqr().redISub(this.x).redISub(p.x);
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
        };

        Point.prototype.dbl = function dbl() {
            if (this.inf)
                return this;

            // 2P = O
            var ys1 = this.y.redAdd(this.y);
            if (ys1.cmpn(0) === 0)
                return this.curve.point(null, null);

            var a = this.curve.a;

            var x2 = this.x.redSqr();
            var dyinv = ys1.redInvm();
            var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

            var nx = c.redSqr().redISub(this.x.redAdd(this.x));
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
        };

        Point.prototype.getX = function getX() {
            return this.x.fromRed();
        };

        Point.prototype.getY = function getY() {
            return this.y.fromRed();
        };

        Point.prototype.mul = function mul(k) {
            k = new BN(k, 16);
            if (this.isInfinity())
                return this;
            else if (this._hasDoubles(k))
                return this.curve._fixedNafMul(this, k);
            else if (this.curve.endo)
                return this.curve._endoWnafMulAdd([this], [k]);
            else
                return this.curve._wnafMul(this, k);
        };

        Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
            var points = [this, p2];
            var coeffs = [k1, k2];
            if (this.curve.endo)
                return this.curve._endoWnafMulAdd(points, coeffs);
            else
                return this.curve._wnafMulAdd(1, points, coeffs, 2);
        };

        Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
            var points = [this, p2];
            var coeffs = [k1, k2];
            if (this.curve.endo)
                return this.curve._endoWnafMulAdd(points, coeffs, true);
            else
                return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
        };

        Point.prototype.eq = function eq(p) {
            return this === p ||
                this.inf === p.inf &&
                (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
        };

        Point.prototype.neg = function neg(_precompute) {
            if (this.inf)
                return this;

            var res = this.curve.point(this.x, this.y.redNeg());
            if (_precompute && this.precomputed) {
                var pre = this.precomputed;
                var negate = function (p) {
                    return p.neg();
                };
                res.precomputed = {
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: pre.naf.points.map(negate)
                    },
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: pre.doubles.points.map(negate)
                    }
                };
            }
            return res;
        };

        Point.prototype.toJ = function toJ() {
            if (this.inf)
                return this.curve.jpoint(null, null, null);

            var res = this.curve.jpoint(this.x, this.y, this.curve.one);
            return res;
        };

        function JPoint(curve, x, y, z) {
            Base.BasePoint.call(this, curve, 'jacobian');
            if (x === null && y === null && z === null) {
                this.x = this.curve.one;
                this.y = this.curve.one;
                this.z = new BN(0);
            } else {
                this.x = new BN(x, 16);
                this.y = new BN(y, 16);
                this.z = new BN(z, 16);
            }
            if (!this.x.red)
                this.x = this.x.toRed(this.curve.red);
            if (!this.y.red)
                this.y = this.y.toRed(this.curve.red);
            if (!this.z.red)
                this.z = this.z.toRed(this.curve.red);

            this.zOne = this.z === this.curve.one;
        }

        inherits(JPoint, Base.BasePoint);

        ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
            return new JPoint(this, x, y, z);
        };

        JPoint.prototype.toP = function toP() {
            if (this.isInfinity())
                return this.curve.point(null, null);

            var zinv = this.z.redInvm();
            var zinv2 = zinv.redSqr();
            var ax = this.x.redMul(zinv2);
            var ay = this.y.redMul(zinv2).redMul(zinv);

            return this.curve.point(ax, ay);
        };

        JPoint.prototype.neg = function neg() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
        };

        JPoint.prototype.add = function add(p) {
            // O + P = P
            if (this.isInfinity())
                return p;

            // P + O = P
            if (p.isInfinity())
                return this;

            // 12M + 4S + 7A
            var pz2 = p.z.redSqr();
            var z2 = this.z.redSqr();
            var u1 = this.x.redMul(pz2);
            var u2 = p.x.redMul(z2);
            var s1 = this.y.redMul(pz2.redMul(p.z));
            var s2 = p.y.redMul(z2.redMul(this.z));

            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
                if (r.cmpn(0) !== 0)
                    return this.curve.jpoint(null, null, null);
                else
                    return this.dbl();
            }

            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);

            var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(p.z).redMul(h);

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype.mixedAdd = function mixedAdd(p) {
            // O + P = P
            if (this.isInfinity())
                return p.toJ();

            // P + O = P
            if (p.isInfinity())
                return this;

            // 8M + 3S + 7A
            var z2 = this.z.redSqr();
            var u1 = this.x;
            var u2 = p.x.redMul(z2);
            var s1 = this.y;
            var s2 = p.y.redMul(z2).redMul(this.z);

            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
                if (r.cmpn(0) !== 0)
                    return this.curve.jpoint(null, null, null);
                else
                    return this.dbl();
            }

            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);

            var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(h);

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype.dblp = function dblp(pow) {
            if (pow === 0)
                return this;
            if (this.isInfinity())
                return this;
            if (!pow)
                return this.dbl();

            if (this.curve.zeroA || this.curve.threeA) {
                var r = this;
                for (var i = 0; i < pow; i++)
                    r = r.dbl();
                return r;
            }

            // 1M + 2S + 1A + N * (4S + 5M + 8A)
            // N = 1 => 6M + 6S + 9A
            var a = this.curve.a;
            var tinv = this.curve.tinv;

            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();

            // Reuse results
            var jyd = jy.redAdd(jy);
            for (var i = 0; i < pow; i++) {
                var jx2 = jx.redSqr();
                var jyd2 = jyd.redSqr();
                var jyd4 = jyd2.redSqr();
                var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

                var t1 = jx.redMul(jyd2);
                var nx = c.redSqr().redISub(t1.redAdd(t1));
                var t2 = t1.redISub(nx);
                var dny = c.redMul(t2);
                dny = dny.redIAdd(dny).redISub(jyd4);
                var nz = jyd.redMul(jz);
                if (i + 1 < pow)
                    jz4 = jz4.redMul(jyd4);

                jx = nx;
                jz = nz;
                jyd = dny;
            }

            return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
        };

        JPoint.prototype.dbl = function dbl() {
            if (this.isInfinity())
                return this;

            if (this.curve.zeroA)
                return this._zeroDbl();
            else if (this.curve.threeA)
                return this._threeDbl();
            else
                return this._dbl();
        };

        JPoint.prototype._zeroDbl = function _zeroDbl() {
            var nx;
            var ny;
            var nz;
            // Z = 1
            if (this.zOne) {
                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                //     #doubling-mdbl-2007-bl
                // 1M + 5S + 14A

                // XX = X1^2
                var xx = this.x.redSqr();
                // YY = Y1^2
                var yy = this.y.redSqr();
                // YYYY = YY^2
                var yyyy = yy.redSqr();
                // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                s = s.redIAdd(s);
                // M = 3 * XX + a; a = 0
                var m = xx.redAdd(xx).redIAdd(xx);
                // T = M ^ 2 - 2*S
                var t = m.redSqr().redISub(s).redISub(s);

                // 8 * YYYY
                var yyyy8 = yyyy.redIAdd(yyyy);
                yyyy8 = yyyy8.redIAdd(yyyy8);
                yyyy8 = yyyy8.redIAdd(yyyy8);

                // X3 = T
                nx = t;
                // Y3 = M * (S - T) - 8 * YYYY
                ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                // Z3 = 2*Y1
                nz = this.y.redAdd(this.y);
            } else {
                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                //     #doubling-dbl-2009-l
                // 2M + 5S + 13A

                // A = X1^2
                var a = this.x.redSqr();
                // B = Y1^2
                var b = this.y.redSqr();
                // C = B^2
                var c = b.redSqr();
                // D = 2 * ((X1 + B)^2 - A - C)
                var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
                d = d.redIAdd(d);
                // E = 3 * A
                var e = a.redAdd(a).redIAdd(a);
                // F = E^2
                var f = e.redSqr();

                // 8 * C
                var c8 = c.redIAdd(c);
                c8 = c8.redIAdd(c8);
                c8 = c8.redIAdd(c8);

                // X3 = F - 2 * D
                nx = f.redISub(d).redISub(d);
                // Y3 = E * (D - X3) - 8 * C
                ny = e.redMul(d.redISub(nx)).redISub(c8);
                // Z3 = 2 * Y1 * Z1
                nz = this.y.redMul(this.z);
                nz = nz.redIAdd(nz);
            }

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype._threeDbl = function _threeDbl() {
            var nx;
            var ny;
            var nz;
            // Z = 1
            if (this.zOne) {
                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
                //     #doubling-mdbl-2007-bl
                // 1M + 5S + 15A

                // XX = X1^2
                var xx = this.x.redSqr();
                // YY = Y1^2
                var yy = this.y.redSqr();
                // YYYY = YY^2
                var yyyy = yy.redSqr();
                // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                s = s.redIAdd(s);
                // M = 3 * XX + a
                var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
                // T = M^2 - 2 * S
                var t = m.redSqr().redISub(s).redISub(s);
                // X3 = T
                nx = t;
                // Y3 = M * (S - T) - 8 * YYYY
                var yyyy8 = yyyy.redIAdd(yyyy);
                yyyy8 = yyyy8.redIAdd(yyyy8);
                yyyy8 = yyyy8.redIAdd(yyyy8);
                ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                // Z3 = 2 * Y1
                nz = this.y.redAdd(this.y);
            } else {
                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
                // 3M + 5S

                // delta = Z1^2
                var delta = this.z.redSqr();
                // gamma = Y1^2
                var gamma = this.y.redSqr();
                // beta = X1 * gamma
                var beta = this.x.redMul(gamma);
                // alpha = 3 * (X1 - delta) * (X1 + delta)
                var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
                alpha = alpha.redAdd(alpha).redIAdd(alpha);
                // X3 = alpha^2 - 8 * beta
                var beta4 = beta.redIAdd(beta);
                beta4 = beta4.redIAdd(beta4);
                var beta8 = beta4.redAdd(beta4);
                nx = alpha.redSqr().redISub(beta8);
                // Z3 = (Y1 + Z1)^2 - gamma - delta
                nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
                // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
                var ggamma8 = gamma.redSqr();
                ggamma8 = ggamma8.redIAdd(ggamma8);
                ggamma8 = ggamma8.redIAdd(ggamma8);
                ggamma8 = ggamma8.redIAdd(ggamma8);
                ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
            }

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype._dbl = function _dbl() {
            var a = this.curve.a;

            // 4M + 6S + 10A
            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();

            var jx2 = jx.redSqr();
            var jy2 = jy.redSqr();

            var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

            var jxd4 = jx.redAdd(jx);
            jxd4 = jxd4.redIAdd(jxd4);
            var t1 = jxd4.redMul(jy2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);

            var jyd8 = jy2.redSqr();
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            var ny = c.redMul(t2).redISub(jyd8);
            var nz = jy.redAdd(jy).redMul(jz);

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype.trpl = function trpl() {
            if (!this.curve.zeroA)
                return this.dbl().add(this);

            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
            // 5M + 10S + ...

            // XX = X1^2
            var xx = this.x.redSqr();
            // YY = Y1^2
            var yy = this.y.redSqr();
            // ZZ = Z1^2
            var zz = this.z.redSqr();
            // YYYY = YY^2
            var yyyy = yy.redSqr();
            // M = 3 * XX + a * ZZ2; a = 0
            var m = xx.redAdd(xx).redIAdd(xx);
            // MM = M^2
            var mm = m.redSqr();
            // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
            var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            e = e.redIAdd(e);
            e = e.redAdd(e).redIAdd(e);
            e = e.redISub(mm);
            // EE = E^2
            var ee = e.redSqr();
            // T = 16*YYYY
            var t = yyyy.redIAdd(yyyy);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            // U = (M + E)^2 - MM - EE - T
            var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
            // X3 = 4 * (X1 * EE - 4 * YY * U)
            var yyu4 = yy.redMul(u);
            yyu4 = yyu4.redIAdd(yyu4);
            yyu4 = yyu4.redIAdd(yyu4);
            var nx = this.x.redMul(ee).redISub(yyu4);
            nx = nx.redIAdd(nx);
            nx = nx.redIAdd(nx);
            // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
            var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            // Z3 = (Z1 + E)^2 - ZZ - EE
            var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

            return this.curve.jpoint(nx, ny, nz);
        };

        JPoint.prototype.mul = function mul(k, kbase) {
            k = new BN(k, kbase);

            return this.curve._wnafMul(this, k);
        };

        JPoint.prototype.eq = function eq(p) {
            if (p.type === 'affine')
                return this.eq(p.toJ());

            if (this === p)
                return true;

            // x1 * z2^2 == x2 * z1^2
            var z2 = this.z.redSqr();
            var pz2 = p.z.redSqr();
            if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
                return false;

            // y1 * z2^3 == y2 * z1^3
            var z3 = z2.redMul(this.z);
            var pz3 = pz2.redMul(p.z);
            return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
        };

        JPoint.prototype.eqXToP = function eqXToP(x) {
            var zs = this.z.redSqr();
            var rx = x.toRed(this.curve.red).redMul(zs);
            if (this.x.cmp(rx) === 0)
                return true;

            var xc = x.clone();
            var t = this.curve.redN.redMul(zs);
            for (; ;) {
                xc.iadd(this.curve.n);
                if (xc.cmp(this.curve.p) >= 0)
                    return false;

                rx.redIAdd(t);
                if (this.x.cmp(rx) === 0)
                    return true;
            }
        };

        JPoint.prototype.inspect = function inspect() {
            if (this.isInfinity())
                return '<EC JPoint Infinity>';
            return '<EC JPoint x: ' + this.x.toString(16, 2) +
                ' y: ' + this.y.toString(16, 2) +
                ' z: ' + this.z.toString(16, 2) + '>';
        };

        JPoint.prototype.isInfinity = function isInfinity() {
            // XXX This code assumes that zero is always zero in red
            return this.z.cmpn(0) === 0;
        };

    }, {"../utils": 143, "./base": 130, "bn.js": 119, "inherits": 159}],
    135: [function (require, module, exports) {
        'use strict';

        var curves = exports;

        var hash = require('hash.js');
        var curve = require('./curve');
        var utils = require('./utils');

        var assert = utils.assert;

        function PresetCurve(options) {
            if (options.type === 'short')
                this.curve = new curve.short(options);
            else if (options.type === 'edwards')
                this.curve = new curve.edwards(options);
            else
                this.curve = new curve.mont(options);
            this.g = this.curve.g;
            this.n = this.curve.n;
            this.hash = options.hash;

            assert(this.g.validate(), 'Invalid curve');
            assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
        }

        curves.PresetCurve = PresetCurve;

        function defineCurve(name, options) {
            Object.defineProperty(curves, name, {
                configurable: true,
                enumerable: true,
                get: function () {
                    var curve = new PresetCurve(options);
                    Object.defineProperty(curves, name, {
                        configurable: true,
                        enumerable: true,
                        value: curve
                    });
                    return curve;
                }
            });
        }

        defineCurve('p192', {
            type: 'short',
            prime: 'p192',
            p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
            b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
            n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
            hash: hash.sha256,
            gRed: false,
            g: [
                '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
            ]
        });

        defineCurve('p224', {
            type: 'short',
            prime: 'p224',
            p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
            b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
            n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
            hash: hash.sha256,
            gRed: false,
            g: [
                'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
            ]
        });

        defineCurve('p256', {
            type: 'short',
            prime: null,
            p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
            a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
            b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
            n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
            hash: hash.sha256,
            gRed: false,
            g: [
                '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
            ]
        });

        defineCurve('p384', {
            type: 'short',
            prime: null,
            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'fffffffe ffffffff 00000000 00000000 ffffffff',
            a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'fffffffe ffffffff 00000000 00000000 fffffffc',
            b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
                '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
            n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
                'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
            hash: hash.sha384,
            gRed: false,
            g: [
                'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
                '5502f25d bf55296c 3a545e38 72760ab7',
                '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
                '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
            ]
        });

        defineCurve('p521', {
            type: 'short',
            prime: null,
            p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'ffffffff ffffffff ffffffff ffffffff ffffffff',
            a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'ffffffff ffffffff ffffffff ffffffff fffffffc',
            b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
                '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
                '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
            n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
                'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
            hash: hash.sha512,
            gRed: false,
            g: [
                '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
                '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
                'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
                '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
                '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
                '3fad0761 353c7086 a272c240 88be9476 9fd16650'
            ]
        });

        defineCurve('curve25519', {
            type: 'mont',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '76d06',
            b: '1',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: [
                '9'
            ]
        });

        defineCurve('ed25519', {
            type: 'edwards',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '-1',
            c: '1',
            // -121665 * (121666^(-1)) (mod P)
            d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: [
                '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

                // 4/5
                '6666666666666666666666666666666666666666666666666666666666666658'
            ]
        });

        var pre;
        try {
            pre = require('./precomputed/secp256k1');
        } catch (e) {
            pre = undefined;
        }

        defineCurve('secp256k1', {
            type: 'short',
            prime: 'k256',
            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
            a: '0',
            b: '7',
            n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
            h: '1',
            hash: hash.sha256,

            // Precomputed endomorphism
            beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
            lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
            basis: [
                {
                    a: '3086d221a7d46bcde86c90e49284eb15',
                    b: '-e4437ed6010e88286f547fa90abfe4c3'
                },
                {
                    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                    b: '3086d221a7d46bcde86c90e49284eb15'
                }
            ],

            gRed: false,
            g: [
                '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                pre
            ]
        });

    }, {"./curve": 132, "./precomputed/secp256k1": 142, "./utils": 143, "hash.js": 146}],
    136: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');
        var HmacDRBG = require('hmac-drbg');
        var utils = require('../utils');
        var curves = require('../curves');
        var rand = require('brorand');
        var assert = utils.assert;

        var KeyPair = require('./key');
        var Signature = require('./signature');

        function EC(options) {
            if (!(this instanceof EC))
                return new EC(options);

            // Shortcut `elliptic.ec(curve-name)`
            if (typeof options === 'string') {
                assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);

                options = curves[options];
            }

            // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
            if (options instanceof curves.PresetCurve)
                options = {curve: options};

            this.curve = options.curve.curve;
            this.n = this.curve.n;
            this.nh = this.n.ushrn(1);
            this.g = this.curve.g;

            // Point on curve
            this.g = options.curve.g;
            this.g.precompute(options.curve.n.bitLength() + 1);

            // Hash for function for DRBG
            this.hash = options.hash || options.curve.hash;
        }

        module.exports = EC;

        EC.prototype.keyPair = function keyPair(options) {
            return new KeyPair(this, options);
        };

        EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
            return KeyPair.fromPrivate(this, priv, enc);
        };

        EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
            return KeyPair.fromPublic(this, pub, enc);
        };

        EC.prototype.genKeyPair = function genKeyPair(options) {
            if (!options)
                options = {};

            // Instantiate Hmac_DRBG
            var drbg = new HmacDRBG({
                hash: this.hash,
                pers: options.pers,
                persEnc: options.persEnc || 'utf8',
                entropy: options.entropy || rand(this.hash.hmacStrength),
                entropyEnc: options.entropy && options.entropyEnc || 'utf8',
                nonce: this.n.toArray()
            });

            var bytes = this.n.byteLength();
            var ns2 = this.n.sub(new BN(2));
            do {
                var priv = new BN(drbg.generate(bytes));
                if (priv.cmp(ns2) > 0)
                    continue;

                priv.iaddn(1);
                return this.keyFromPrivate(priv);
            } while (true);
        };

        EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
            var delta = msg.byteLength() * 8 - this.n.bitLength();
            if (delta > 0)
                msg = msg.ushrn(delta);
            if (!truncOnly && msg.cmp(this.n) >= 0)
                return msg.sub(this.n);
            else
                return msg;
        };

        EC.prototype.sign = function sign(msg, key, enc, options) {
            if (typeof enc === 'object') {
                options = enc;
                enc = null;
            }
            if (!options)
                options = {};

            key = this.keyFromPrivate(key, enc);
            msg = this._truncateToN(new BN(msg, 16));

            // Zero-extend key to provide enough entropy
            var bytes = this.n.byteLength();
            var bkey = key.getPrivate().toArray('be', bytes);

            // Zero-extend nonce to have the same byte size as N
            var nonce = msg.toArray('be', bytes);

            // Instantiate Hmac_DRBG
            var drbg = new HmacDRBG({
                hash: this.hash,
                entropy: bkey,
                nonce: nonce,
                pers: options.pers,
                persEnc: options.persEnc || 'utf8'
            });

            // Number of bytes to generate
            var ns1 = this.n.sub(new BN(1));

            for (var iter = 0; true; iter++) {
                var k = options.k ?
                    options.k(iter) :
                    new BN(drbg.generate(this.n.byteLength()));
                k = this._truncateToN(k, true);
                if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
                    continue;

                var kp = this.g.mul(k);
                if (kp.isInfinity())
                    continue;

                var kpX = kp.getX();
                var r = kpX.umod(this.n);
                if (r.cmpn(0) === 0)
                    continue;

                var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
                s = s.umod(this.n);
                if (s.cmpn(0) === 0)
                    continue;

                var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                    (kpX.cmp(r) !== 0 ? 2 : 0);

                // Use complement of `s`, if it is > `n / 2`
                if (options.canonical && s.cmp(this.nh) > 0) {
                    s = this.n.sub(s);
                    recoveryParam ^= 1;
                }

                return new Signature({r: r, s: s, recoveryParam: recoveryParam});
            }
        };

        EC.prototype.verify = function verify(msg, signature, key, enc) {
            msg = this._truncateToN(new BN(msg, 16));
            key = this.keyFromPublic(key, enc);
            signature = new Signature(signature, 'hex');

            // Perform primitive values validation
            var r = signature.r;
            var s = signature.s;
            if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
                return false;
            if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
                return false;

            // Validate signature
            var sinv = s.invm(this.n);
            var u1 = sinv.mul(msg).umod(this.n);
            var u2 = sinv.mul(r).umod(this.n);

            if (!this.curve._maxwellTrick) {
                var p = this.g.mulAdd(u1, key.getPublic(), u2);
                if (p.isInfinity())
                    return false;

                return p.getX().umod(this.n).cmp(r) === 0;
            }

            // NOTE: Greg Maxwell's trick, inspired by:
            // https://git.io/vad3K

            var p = this.g.jmulAdd(u1, key.getPublic(), u2);
            if (p.isInfinity())
                return false;

            // Compare `p.x` of Jacobian point with `r`,
            // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
            // inverse of `p.z^2`
            return p.eqXToP(r);
        };

        EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
            assert((3 & j) === j, 'The recovery param is more than two bits');
            signature = new Signature(signature, enc);

            var n = this.n;
            var e = new BN(msg);
            var r = signature.r;
            var s = signature.s;

            // A set LSB signifies that the y-coordinate is odd
            var isYOdd = j & 1;
            var isSecondKey = j >> 1;
            if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
                throw new Error('Unable to find sencond key candinate');

            // 1.1. Let x = r + jn.
            if (isSecondKey)
                r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
            else
                r = this.curve.pointFromX(r, isYOdd);

            var rInv = signature.r.invm(n);
            var s1 = n.sub(e).mul(rInv).umod(n);
            var s2 = s.mul(rInv).umod(n);

            // 1.6.1 Compute Q = r^-1 (sR -  eG)
            //               Q = r^-1 (sR + -eG)
            return this.g.mulAdd(s1, r, s2);
        };

        EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
            signature = new Signature(signature, enc);
            if (signature.recoveryParam !== null)
                return signature.recoveryParam;

            for (var i = 0; i < 4; i++) {
                var Qprime;
                try {
                    Qprime = this.recoverPubKey(e, signature, i);
                } catch (e) {
                    continue;
                }

                if (Qprime.eq(Q))
                    return i;
            }
            throw new Error('Unable to find valid recovery factor');
        };

    }, {
        "../curves": 135,
        "../utils": 143,
        "./key": 137,
        "./signature": 138,
        "bn.js": 119,
        "brorand": 120,
        "hmac-drbg": 158
    }],
    137: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');
        var utils = require('../utils');
        var assert = utils.assert;

        function KeyPair(ec, options) {
            this.ec = ec;
            this.priv = null;
            this.pub = null;

            // KeyPair(ec, { priv: ..., pub: ... })
            if (options.priv)
                this._importPrivate(options.priv, options.privEnc);
            if (options.pub)
                this._importPublic(options.pub, options.pubEnc);
        }

        module.exports = KeyPair;

        KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
            if (pub instanceof KeyPair)
                return pub;

            return new KeyPair(ec, {
                pub: pub,
                pubEnc: enc
            });
        };

        KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
            if (priv instanceof KeyPair)
                return priv;

            return new KeyPair(ec, {
                priv: priv,
                privEnc: enc
            });
        };

        KeyPair.prototype.validate = function validate() {
            var pub = this.getPublic();

            if (pub.isInfinity())
                return {result: false, reason: 'Invalid public key'};
            if (!pub.validate())
                return {result: false, reason: 'Public key is not a point'};
            if (!pub.mul(this.ec.curve.n).isInfinity())
                return {result: false, reason: 'Public key * N != O'};

            return {result: true, reason: null};
        };

        KeyPair.prototype.getPublic = function getPublic(compact, enc) {
            // compact is optional argument
            if (typeof compact === 'string') {
                enc = compact;
                compact = null;
            }

            if (!this.pub)
                this.pub = this.ec.g.mul(this.priv);

            if (!enc)
                return this.pub;

            return this.pub.encode(enc, compact);
        };

        KeyPair.prototype.getPrivate = function getPrivate(enc) {
            if (enc === 'hex')
                return this.priv.toString(16, 2);
            else
                return this.priv;
        };

        KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
            this.priv = new BN(key, enc || 16);

            // Ensure that the priv won't be bigger than n, otherwise we may fail
            // in fixed multiplication method
            this.priv = this.priv.umod(this.ec.curve.n);
        };

        KeyPair.prototype._importPublic = function _importPublic(key, enc) {
            if (key.x || key.y) {
                // Montgomery points only have an `x` coordinate.
                // Weierstrass/Edwards points on the other hand have both `x` and
                // `y` coordinates.
                if (this.ec.curve.type === 'mont') {
                    assert(key.x, 'Need x coordinate');
                } else if (this.ec.curve.type === 'short' ||
                    this.ec.curve.type === 'edwards') {
                    assert(key.x && key.y, 'Need both x and y coordinate');
                }
                this.pub = this.ec.curve.point(key.x, key.y);
                return;
            }
            this.pub = this.ec.curve.decodePoint(key, enc);
        };

// ECDH
        KeyPair.prototype.derive = function derive(pub) {
            return pub.mul(this.priv).getX();
        };

// ECDSA
        KeyPair.prototype.sign = function sign(msg, enc, options) {
            return this.ec.sign(msg, this, enc, options);
        };

        KeyPair.prototype.verify = function verify(msg, signature) {
            return this.ec.verify(msg, signature, this);
        };

        KeyPair.prototype.inspect = function inspect() {
            return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
                ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
        };

    }, {"../utils": 143, "bn.js": 119}],
    138: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');

        var utils = require('../utils');
        var assert = utils.assert;

        function Signature(options, enc) {
            if (options instanceof Signature)
                return options;

            if (this._importDER(options, enc))
                return;

            assert(options.r && options.s, 'Signature without r or s');
            this.r = new BN(options.r, 16);
            this.s = new BN(options.s, 16);
            if (options.recoveryParam === undefined)
                this.recoveryParam = null;
            else
                this.recoveryParam = options.recoveryParam;
        }

        module.exports = Signature;

        function Position() {
            this.place = 0;
        }

        function getLength(buf, p) {
            var initial = buf[p.place++];
            if (!(initial & 0x80)) {
                return initial;
            }
            var octetLen = initial & 0xf;
            var val = 0;
            for (var i = 0, off = p.place; i < octetLen; i++, off++) {
                val <<= 8;
                val |= buf[off];
            }
            p.place = off;
            return val;
        }

        function rmPadding(buf) {
            var i = 0;
            var len = buf.length - 1;
            while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
                i++;
            }
            if (i === 0) {
                return buf;
            }
            return buf.slice(i);
        }

        Signature.prototype._importDER = function _importDER(data, enc) {
            data = utils.toArray(data, enc);
            var p = new Position();
            if (data[p.place++] !== 0x30) {
                return false;
            }
            var len = getLength(data, p);
            if ((len + p.place) !== data.length) {
                return false;
            }
            if (data[p.place++] !== 0x02) {
                return false;
            }
            var rlen = getLength(data, p);
            var r = data.slice(p.place, rlen + p.place);
            p.place += rlen;
            if (data[p.place++] !== 0x02) {
                return false;
            }
            var slen = getLength(data, p);
            if (data.length !== slen + p.place) {
                return false;
            }
            var s = data.slice(p.place, slen + p.place);
            if (r[0] === 0 && (r[1] & 0x80)) {
                r = r.slice(1);
            }
            if (s[0] === 0 && (s[1] & 0x80)) {
                s = s.slice(1);
            }

            this.r = new BN(r);
            this.s = new BN(s);
            this.recoveryParam = null;

            return true;
        };

        function constructLength(arr, len) {
            if (len < 0x80) {
                arr.push(len);
                return;
            }
            var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
            arr.push(octets | 0x80);
            while (--octets) {
                arr.push((len >>> (octets << 3)) & 0xff);
            }
            arr.push(len);
        }

        Signature.prototype.toDER = function toDER(enc) {
            var r = this.r.toArray();
            var s = this.s.toArray();

            // Pad values
            if (r[0] & 0x80)
                r = [0].concat(r);
            // Pad values
            if (s[0] & 0x80)
                s = [0].concat(s);

            r = rmPadding(r);
            s = rmPadding(s);

            while (!s[0] && !(s[1] & 0x80)) {
                s = s.slice(1);
            }
            var arr = [0x02];
            constructLength(arr, r.length);
            arr = arr.concat(r);
            arr.push(0x02);
            constructLength(arr, s.length);
            var backHalf = arr.concat(s);
            var res = [0x30];
            constructLength(res, backHalf.length);
            res = res.concat(backHalf);
            return utils.encode(res, enc);
        };

    }, {"../utils": 143, "bn.js": 119}],
    139: [function (require, module, exports) {
        'use strict';

        var hash = require('hash.js');
        var curves = require('../curves');
        var utils = require('../utils');
        var assert = utils.assert;
        var parseBytes = utils.parseBytes;
        var KeyPair = require('./key');
        var Signature = require('./signature');

        function EDDSA(curve) {
            assert(curve === 'ed25519', 'only tested with ed25519 so far');

            if (!(this instanceof EDDSA))
                return new EDDSA(curve);

            var curve = curves[curve].curve;
            this.curve = curve;
            this.g = curve.g;
            this.g.precompute(curve.n.bitLength() + 1);

            this.pointClass = curve.point().constructor;
            this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
            this.hash = hash.sha512;
        }

        module.exports = EDDSA;

        /**
         * @param {Array|String} message - message bytes
         * @param {Array|String|KeyPair} secret - secret bytes or a keypair
         * @returns {Signature} - signature
         */
        EDDSA.prototype.sign = function sign(message, secret) {
            message = parseBytes(message);
            var key = this.keyFromSecret(secret);
            var r = this.hashInt(key.messagePrefix(), message);
            var R = this.g.mul(r);
            var Rencoded = this.encodePoint(R);
            var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
                .mul(key.priv());
            var S = r.add(s_).umod(this.curve.n);
            return this.makeSignature({R: R, S: S, Rencoded: Rencoded});
        };

        /**
         * @param {Array} message - message bytes
         * @param {Array|String|Signature} sig - sig bytes
         * @param {Array|String|Point|KeyPair} pub - public key
         * @returns {Boolean} - true if public key matches sig of message
         */
        EDDSA.prototype.verify = function verify(message, sig, pub) {
            message = parseBytes(message);
            sig = this.makeSignature(sig);
            var key = this.keyFromPublic(pub);
            var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
            var SG = this.g.mul(sig.S());
            var RplusAh = sig.R().add(key.pub().mul(h));
            return RplusAh.eq(SG);
        };

        EDDSA.prototype.hashInt = function hashInt() {
            var hash = this.hash();
            for (var i = 0; i < arguments.length; i++)
                hash.update(arguments[i]);
            return utils.intFromLE(hash.digest()).umod(this.curve.n);
        };

        EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
            return KeyPair.fromPublic(this, pub);
        };

        EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
            return KeyPair.fromSecret(this, secret);
        };

        EDDSA.prototype.makeSignature = function makeSignature(sig) {
            if (sig instanceof Signature)
                return sig;
            return new Signature(this, sig);
        };

        /**
         * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
         *
         * EDDSA defines methods for encoding and decoding points and integers. These are
         * helper convenience methods, that pass along to utility functions implied
         * parameters.
         *
         */
        EDDSA.prototype.encodePoint = function encodePoint(point) {
            var enc = point.getY().toArray('le', this.encodingLength);
            enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
            return enc;
        };

        EDDSA.prototype.decodePoint = function decodePoint(bytes) {
            bytes = utils.parseBytes(bytes);

            var lastIx = bytes.length - 1;
            var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
            var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

            var y = utils.intFromLE(normed);
            return this.curve.pointFromY(y, xIsOdd);
        };

        EDDSA.prototype.encodeInt = function encodeInt(num) {
            return num.toArray('le', this.encodingLength);
        };

        EDDSA.prototype.decodeInt = function decodeInt(bytes) {
            return utils.intFromLE(bytes);
        };

        EDDSA.prototype.isPoint = function isPoint(val) {
            return val instanceof this.pointClass;
        };

    }, {"../curves": 135, "../utils": 143, "./key": 140, "./signature": 141, "hash.js": 146}],
    140: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var assert = utils.assert;
        var parseBytes = utils.parseBytes;
        var cachedProperty = utils.cachedProperty;

        /**
         * @param {EDDSA} eddsa - instance
         * @param {Object} params - public/private key parameters
         *
         * @param {Array<Byte>} [params.secret] - secret seed bytes
         * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
         * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
         *
         */
        function KeyPair(eddsa, params) {
            this.eddsa = eddsa;
            this._secret = parseBytes(params.secret);
            if (eddsa.isPoint(params.pub))
                this._pub = params.pub;
            else
                this._pubBytes = parseBytes(params.pub);
        }

        KeyPair.fromPublic = function fromPublic(eddsa, pub) {
            if (pub instanceof KeyPair)
                return pub;
            return new KeyPair(eddsa, {pub: pub});
        };

        KeyPair.fromSecret = function fromSecret(eddsa, secret) {
            if (secret instanceof KeyPair)
                return secret;
            return new KeyPair(eddsa, {secret: secret});
        };

        KeyPair.prototype.secret = function secret() {
            return this._secret;
        };

        cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
            return this.eddsa.encodePoint(this.pub());
        });

        cachedProperty(KeyPair, 'pub', function pub() {
            if (this._pubBytes)
                return this.eddsa.decodePoint(this._pubBytes);
            return this.eddsa.g.mul(this.priv());
        });

        cachedProperty(KeyPair, 'privBytes', function privBytes() {
            var eddsa = this.eddsa;
            var hash = this.hash();
            var lastIx = eddsa.encodingLength - 1;

            var a = hash.slice(0, eddsa.encodingLength);
            a[0] &= 248;
            a[lastIx] &= 127;
            a[lastIx] |= 64;

            return a;
        });

        cachedProperty(KeyPair, 'priv', function priv() {
            return this.eddsa.decodeInt(this.privBytes());
        });

        cachedProperty(KeyPair, 'hash', function hash() {
            return this.eddsa.hash().update(this.secret()).digest();
        });

        cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
            return this.hash().slice(this.eddsa.encodingLength);
        });

        KeyPair.prototype.sign = function sign(message) {
            assert(this._secret, 'KeyPair can only verify');
            return this.eddsa.sign(message, this);
        };

        KeyPair.prototype.verify = function verify(message, sig) {
            return this.eddsa.verify(message, sig, this);
        };

        KeyPair.prototype.getSecret = function getSecret(enc) {
            assert(this._secret, 'KeyPair is public only');
            return utils.encode(this.secret(), enc);
        };

        KeyPair.prototype.getPublic = function getPublic(enc) {
            return utils.encode(this.pubBytes(), enc);
        };

        module.exports = KeyPair;

    }, {"../utils": 143}],
    141: [function (require, module, exports) {
        'use strict';

        var BN = require('bn.js');
        var utils = require('../utils');
        var assert = utils.assert;
        var cachedProperty = utils.cachedProperty;
        var parseBytes = utils.parseBytes;

        /**
         * @param {EDDSA} eddsa - eddsa instance
         * @param {Array<Bytes>|Object} sig -
         * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
         * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
         * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
         * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
         */
        function Signature(eddsa, sig) {
            this.eddsa = eddsa;

            if (typeof sig !== 'object')
                sig = parseBytes(sig);

            if (Array.isArray(sig)) {
                sig = {
                    R: sig.slice(0, eddsa.encodingLength),
                    S: sig.slice(eddsa.encodingLength)
                };
            }

            assert(sig.R && sig.S, 'Signature without R or S');

            if (eddsa.isPoint(sig.R))
                this._R = sig.R;
            if (sig.S instanceof BN)
                this._S = sig.S;

            this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
            this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
        }

        cachedProperty(Signature, 'S', function S() {
            return this.eddsa.decodeInt(this.Sencoded());
        });

        cachedProperty(Signature, 'R', function R() {
            return this.eddsa.decodePoint(this.Rencoded());
        });

        cachedProperty(Signature, 'Rencoded', function Rencoded() {
            return this.eddsa.encodePoint(this.R());
        });

        cachedProperty(Signature, 'Sencoded', function Sencoded() {
            return this.eddsa.encodeInt(this.S());
        });

        Signature.prototype.toBytes = function toBytes() {
            return this.Rencoded().concat(this.Sencoded());
        };

        Signature.prototype.toHex = function toHex() {
            return utils.encode(this.toBytes(), 'hex').toUpperCase();
        };

        module.exports = Signature;

    }, {"../utils": 143, "bn.js": 119}],
    142: [function (require, module, exports) {
        module.exports = {
            doubles: {
                step: 4,
                points: [
                    [
                        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                    ],
                    [
                        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                    ],
                    [
                        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                    ],
                    [
                        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                    ],
                    [
                        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                    ],
                    [
                        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                    ],
                    [
                        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                    ],
                    [
                        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                    ],
                    [
                        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                    ],
                    [
                        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                    ],
                    [
                        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                    ],
                    [
                        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                    ],
                    [
                        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                    ],
                    [
                        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                    ],
                    [
                        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                    ],
                    [
                        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                    ],
                    [
                        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                    ],
                    [
                        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                    ],
                    [
                        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                    ],
                    [
                        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                    ],
                    [
                        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                    ],
                    [
                        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                    ],
                    [
                        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                    ],
                    [
                        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                    ],
                    [
                        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                    ],
                    [
                        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                    ],
                    [
                        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                    ],
                    [
                        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                    ],
                    [
                        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                    ],
                    [
                        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                    ],
                    [
                        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                    ],
                    [
                        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                    ],
                    [
                        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                    ],
                    [
                        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                    ],
                    [
                        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                    ],
                    [
                        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                    ],
                    [
                        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                    ],
                    [
                        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                    ],
                    [
                        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                    ],
                    [
                        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                    ],
                    [
                        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                    ],
                    [
                        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                    ],
                    [
                        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                    ],
                    [
                        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                    ],
                    [
                        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                    ],
                    [
                        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                    ],
                    [
                        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                    ],
                    [
                        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                    ],
                    [
                        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                    ],
                    [
                        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                    ],
                    [
                        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                    ],
                    [
                        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                    ],
                    [
                        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                    ],
                    [
                        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                    ],
                    [
                        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                    ],
                    [
                        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                    ],
                    [
                        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                    ],
                    [
                        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                    ],
                    [
                        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                    ],
                    [
                        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                    ],
                    [
                        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                    ],
                    [
                        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                    ],
                    [
                        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                    ],
                    [
                        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                    ],
                    [
                        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                    ]
                ]
            },
            naf: {
                wnd: 7,
                points: [
                    [
                        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                    ],
                    [
                        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                    ],
                    [
                        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                    ],
                    [
                        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                    ],
                    [
                        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                    ],
                    [
                        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                    ],
                    [
                        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                    ],
                    [
                        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                    ],
                    [
                        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                    ],
                    [
                        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                    ],
                    [
                        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                    ],
                    [
                        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                    ],
                    [
                        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                    ],
                    [
                        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                    ],
                    [
                        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                    ],
                    [
                        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                    ],
                    [
                        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                    ],
                    [
                        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                    ],
                    [
                        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                    ],
                    [
                        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                    ],
                    [
                        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                    ],
                    [
                        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                    ],
                    [
                        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                    ],
                    [
                        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                    ],
                    [
                        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                    ],
                    [
                        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                    ],
                    [
                        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                    ],
                    [
                        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                    ],
                    [
                        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                    ],
                    [
                        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                    ],
                    [
                        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                    ],
                    [
                        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                    ],
                    [
                        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                    ],
                    [
                        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                    ],
                    [
                        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                    ],
                    [
                        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                    ],
                    [
                        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                    ],
                    [
                        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                    ],
                    [
                        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                    ],
                    [
                        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                    ],
                    [
                        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                    ],
                    [
                        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                    ],
                    [
                        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                    ],
                    [
                        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                    ],
                    [
                        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                    ],
                    [
                        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                    ],
                    [
                        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                    ],
                    [
                        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                    ],
                    [
                        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                    ],
                    [
                        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                    ],
                    [
                        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                    ],
                    [
                        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                    ],
                    [
                        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                    ],
                    [
                        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                    ],
                    [
                        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                    ],
                    [
                        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                    ],
                    [
                        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                    ],
                    [
                        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                    ],
                    [
                        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                    ],
                    [
                        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                    ],
                    [
                        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                    ],
                    [
                        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                    ],
                    [
                        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                    ],
                    [
                        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                    ],
                    [
                        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                    ],
                    [
                        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                    ],
                    [
                        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                    ],
                    [
                        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                    ],
                    [
                        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                    ],
                    [
                        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                    ],
                    [
                        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                    ],
                    [
                        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                    ],
                    [
                        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                    ],
                    [
                        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                    ],
                    [
                        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                    ],
                    [
                        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                    ],
                    [
                        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                    ],
                    [
                        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                    ],
                    [
                        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                    ],
                    [
                        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                    ],
                    [
                        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                    ],
                    [
                        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                    ],
                    [
                        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                    ],
                    [
                        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                    ],
                    [
                        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                    ],
                    [
                        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                    ],
                    [
                        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                    ],
                    [
                        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                    ],
                    [
                        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                    ],
                    [
                        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                    ],
                    [
                        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                    ],
                    [
                        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                    ],
                    [
                        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                    ],
                    [
                        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                    ],
                    [
                        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                    ],
                    [
                        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                    ],
                    [
                        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                    ],
                    [
                        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                    ],
                    [
                        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                    ],
                    [
                        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                    ],
                    [
                        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                    ],
                    [
                        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                    ],
                    [
                        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                    ],
                    [
                        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                    ],
                    [
                        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                    ],
                    [
                        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                    ],
                    [
                        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                    ],
                    [
                        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                    ],
                    [
                        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                    ],
                    [
                        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                    ],
                    [
                        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                    ],
                    [
                        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                    ],
                    [
                        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                    ],
                    [
                        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                    ],
                    [
                        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                    ],
                    [
                        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                    ],
                    [
                        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                    ],
                    [
                        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                    ],
                    [
                        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                    ],
                    [
                        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                    ],
                    [
                        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                    ],
                    [
                        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                    ],
                    [
                        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                    ],
                    [
                        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                    ],
                    [
                        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                    ],
                    [
                        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                    ],
                    [
                        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                    ]
                ]
            }
        };

    }, {}],
    143: [function (require, module, exports) {
        'use strict';

        var utils = exports;
        var BN = require('bn.js');
        var minAssert = require('minimalistic-assert');
        var minUtils = require('minimalistic-crypto-utils');

        utils.assert = minAssert;
        utils.toArray = minUtils.toArray;
        utils.zero2 = minUtils.zero2;
        utils.toHex = minUtils.toHex;
        utils.encode = minUtils.encode;

// Represent num in a w-NAF form
        function getNAF(num, w, bits) {
            var naf = new Array(Math.max(num.bitLength(), bits) + 1);
            naf.fill(0);

            var ws = 1 << (w + 1);
            var k = num.clone();

            for (var i = 0; i < naf.length; i++) {
                var z;
                var mod = k.andln(ws - 1);
                if (k.isOdd()) {
                    if (mod > (ws >> 1) - 1)
                        z = (ws >> 1) - mod;
                    else
                        z = mod;
                    k.isubn(z);
                } else {
                    z = 0;
                }

                naf[i] = z;
                k.iushrn(1);
            }

            return naf;
        }

        utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
        function getJSF(k1, k2) {
            var jsf = [
                [],
                []
            ];

            k1 = k1.clone();
            k2 = k2.clone();
            var d1 = 0;
            var d2 = 0;
            while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

                // First phase
                var m14 = (k1.andln(3) + d1) & 3;
                var m24 = (k2.andln(3) + d2) & 3;
                if (m14 === 3)
                    m14 = -1;
                if (m24 === 3)
                    m24 = -1;
                var u1;
                if ((m14 & 1) === 0) {
                    u1 = 0;
                } else {
                    var m8 = (k1.andln(7) + d1) & 7;
                    if ((m8 === 3 || m8 === 5) && m24 === 2)
                        u1 = -m14;
                    else
                        u1 = m14;
                }
                jsf[0].push(u1);

                var u2;
                if ((m24 & 1) === 0) {
                    u2 = 0;
                } else {
                    var m8 = (k2.andln(7) + d2) & 7;
                    if ((m8 === 3 || m8 === 5) && m14 === 2)
                        u2 = -m24;
                    else
                        u2 = m24;
                }
                jsf[1].push(u2);

                // Second phase
                if (2 * d1 === u1 + 1)
                    d1 = 1 - d1;
                if (2 * d2 === u2 + 1)
                    d2 = 1 - d2;
                k1.iushrn(1);
                k2.iushrn(1);
            }

            return jsf;
        }

        utils.getJSF = getJSF;

        function cachedProperty(obj, name, computer) {
            var key = '_' + name;
            obj.prototype[name] = function cachedProperty() {
                return this[key] !== undefined ? this[key] :
                    this[key] = computer.call(this);
            };
        }

        utils.cachedProperty = cachedProperty;

        function parseBytes(bytes) {
            return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                bytes;
        }

        utils.parseBytes = parseBytes;

        function intFromLE(bytes) {
            return new BN(bytes, 'hex', 'le');
        }

        utils.intFromLE = intFromLE;


    }, {"bn.js": 119, "minimalistic-assert": 162, "minimalistic-crypto-utils": 163}],
    144: [function (require, module, exports) {
        module.exports = {
            "_from": "elliptic@^6.4.0",
            "_id": "elliptic@6.5.2",
            "_inBundle": false,
            "_integrity": "sha512-f4x70okzZbIQl/NSRLkI/+tteV/9WqL98zx+SQ69KbXxmVrmjwsNUPn/gYJJ0sHvEak24cZgHIPegRePAtA/xw==",
            "_location": "/elliptic",
            "_phantomChildren": {},
            "_requested": {
                "type": "range",
                "registry": true,
                "raw": "elliptic@^6.4.0",
                "name": "elliptic",
                "escapedName": "elliptic",
                "rawSpec": "^6.4.0",
                "saveSpec": null,
                "fetchSpec": "^6.4.0"
            },
            "_requiredBy": [
                "/tiny-secp256k1"
            ],
            "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.2.tgz",
            "_shasum": "05c5678d7173c049d8ca433552224a495d0e3762",
            "_spec": "elliptic@^6.4.0",
            "_where": "C:\\Users\\emman\\Desktop\\browserify_intro\\node_modules\\tiny-secp256k1",
            "author": {
                "name": "Fedor Indutny",
                "email": "fedor@indutny.com"
            },
            "bugs": {
                "url": "https://github.com/indutny/elliptic/issues"
            },
            "bundleDependencies": false,
            "dependencies": {
                "bn.js": "^4.4.0",
                "brorand": "^1.0.1",
                "hash.js": "^1.0.0",
                "hmac-drbg": "^1.0.0",
                "inherits": "^2.0.1",
                "minimalistic-assert": "^1.0.0",
                "minimalistic-crypto-utils": "^1.0.0"
            },
            "deprecated": false,
            "description": "EC cryptography",
            "devDependencies": {
                "brfs": "^1.4.3",
                "coveralls": "^3.0.8",
                "grunt": "^1.0.4",
                "grunt-browserify": "^5.0.0",
                "grunt-cli": "^1.2.0",
                "grunt-contrib-connect": "^1.0.0",
                "grunt-contrib-copy": "^1.0.0",
                "grunt-contrib-uglify": "^1.0.1",
                "grunt-mocha-istanbul": "^3.0.1",
                "grunt-saucelabs": "^9.0.1",
                "istanbul": "^0.4.2",
                "jscs": "^3.0.7",
                "jshint": "^2.10.3",
                "mocha": "^6.2.2"
            },
            "files": [
                "lib"
            ],
            "homepage": "https://github.com/indutny/elliptic",
            "keywords": [
                "EC",
                "Elliptic",
                "curve",
                "Cryptography"
            ],
            "license": "MIT",
            "main": "lib/elliptic.js",
            "name": "elliptic",
            "repository": {
                "type": "git",
                "url": "git+ssh://git@github.com/indutny/elliptic.git"
            },
            "scripts": {
                "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
                "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
                "lint": "npm run jscs && npm run jshint",
                "test": "npm run lint && npm run unit",
                "unit": "istanbul test _mocha --reporter=spec test/index.js",
                "version": "grunt dist && git add dist/"
            },
            "version": "6.5.2"
        }

    }, {}],
    145: [function (require, module, exports) {
        'use strict'
        var Buffer = require('safe-buffer').Buffer
        var Transform = require('stream').Transform
        var inherits = require('inherits')

        function throwIfNotStringOrBuffer(val, prefix) {
            if (!Buffer.isBuffer(val) && typeof val !== 'string') {
                throw new TypeError(prefix + ' must be a string or a buffer')
            }
        }

        function HashBase(blockSize) {
            Transform.call(this)

            this._block = Buffer.allocUnsafe(blockSize)
            this._blockSize = blockSize
            this._blockOffset = 0
            this._length = [0, 0, 0, 0]

            this._finalized = false
        }

        inherits(HashBase, Transform)

        HashBase.prototype._transform = function (chunk, encoding, callback) {
            var error = null
            try {
                this.update(chunk, encoding)
            } catch (err) {
                error = err
            }

            callback(error)
        }

        HashBase.prototype._flush = function (callback) {
            var error = null
            try {
                this.push(this.digest())
            } catch (err) {
                error = err
            }

            callback(error)
        }

        HashBase.prototype.update = function (data, encoding) {
            throwIfNotStringOrBuffer(data, 'Data')
            if (this._finalized) throw new Error('Digest already called')
            if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

            // consume data
            var block = this._block
            var offset = 0
            while (this._blockOffset + data.length - offset >= this._blockSize) {
                for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
                this._update()
                this._blockOffset = 0
            }
            while (offset < data.length) block[this._blockOffset++] = data[offset++]

            // update length
            for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
                this._length[j] += carry
                carry = (this._length[j] / 0x0100000000) | 0
                if (carry > 0) this._length[j] -= 0x0100000000 * carry
            }

            return this
        }

        HashBase.prototype._update = function () {
            throw new Error('_update is not implemented')
        }

        HashBase.prototype.digest = function (encoding) {
            if (this._finalized) throw new Error('Digest already called')
            this._finalized = true

            var digest = this._digest()
            if (encoding !== undefined) digest = digest.toString(encoding)

            // reset state
            this._block.fill(0)
            this._blockOffset = 0
            for (var i = 0; i < 4; ++i) this._length[i] = 0

            return digest
        }

        HashBase.prototype._digest = function () {
            throw new Error('_digest is not implemented')
        }

        module.exports = HashBase

    }, {"inherits": 159, "safe-buffer": 172, "stream": 28}],
    146: [function (require, module, exports) {
        var hash = exports;

        hash.utils = require('./hash/utils');
        hash.common = require('./hash/common');
        hash.sha = require('./hash/sha');
        hash.ripemd = require('./hash/ripemd');
        hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
        hash.sha1 = hash.sha.sha1;
        hash.sha256 = hash.sha.sha256;
        hash.sha224 = hash.sha.sha224;
        hash.sha384 = hash.sha.sha384;
        hash.sha512 = hash.sha.sha512;
        hash.ripemd160 = hash.ripemd.ripemd160;

    }, {"./hash/common": 147, "./hash/hmac": 148, "./hash/ripemd": 149, "./hash/sha": 150, "./hash/utils": 157}],
    147: [function (require, module, exports) {
        'use strict';

        var utils = require('./utils');
        var assert = require('minimalistic-assert');

        function BlockHash() {
            this.pending = null;
            this.pendingTotal = 0;
            this.blockSize = this.constructor.blockSize;
            this.outSize = this.constructor.outSize;
            this.hmacStrength = this.constructor.hmacStrength;
            this.padLength = this.constructor.padLength / 8;
            this.endian = 'big';

            this._delta8 = this.blockSize / 8;
            this._delta32 = this.blockSize / 32;
        }

        exports.BlockHash = BlockHash;

        BlockHash.prototype.update = function update(msg, enc) {
            // Convert message to array, pad it, and join into 32bit blocks
            msg = utils.toArray(msg, enc);
            if (!this.pending)
                this.pending = msg;
            else
                this.pending = this.pending.concat(msg);
            this.pendingTotal += msg.length;

            // Enough data, try updating
            if (this.pending.length >= this._delta8) {
                msg = this.pending;

                // Process pending data in blocks
                var r = msg.length % this._delta8;
                this.pending = msg.slice(msg.length - r, msg.length);
                if (this.pending.length === 0)
                    this.pending = null;

                msg = utils.join32(msg, 0, msg.length - r, this.endian);
                for (var i = 0; i < msg.length; i += this._delta32)
                    this._update(msg, i, i + this._delta32);
            }

            return this;
        };

        BlockHash.prototype.digest = function digest(enc) {
            this.update(this._pad());
            assert(this.pending === null);

            return this._digest(enc);
        };

        BlockHash.prototype._pad = function pad() {
            var len = this.pendingTotal;
            var bytes = this._delta8;
            var k = bytes - ((len + this.padLength) % bytes);
            var res = new Array(k + this.padLength);
            res[0] = 0x80;
            for (var i = 1; i < k; i++)
                res[i] = 0;

            // Append length
            len <<= 3;
            if (this.endian === 'big') {
                for (var t = 8; t < this.padLength; t++)
                    res[i++] = 0;

                res[i++] = 0;
                res[i++] = 0;
                res[i++] = 0;
                res[i++] = 0;
                res[i++] = (len >>> 24) & 0xff;
                res[i++] = (len >>> 16) & 0xff;
                res[i++] = (len >>> 8) & 0xff;
                res[i++] = len & 0xff;
            } else {
                res[i++] = len & 0xff;
                res[i++] = (len >>> 8) & 0xff;
                res[i++] = (len >>> 16) & 0xff;
                res[i++] = (len >>> 24) & 0xff;
                res[i++] = 0;
                res[i++] = 0;
                res[i++] = 0;
                res[i++] = 0;

                for (t = 8; t < this.padLength; t++)
                    res[i++] = 0;
            }

            return res;
        };

    }, {"./utils": 157, "minimalistic-assert": 162}],
    148: [function (require, module, exports) {
        'use strict';

        var utils = require('./utils');
        var assert = require('minimalistic-assert');

        function Hmac(hash, key, enc) {
            if (!(this instanceof Hmac))
                return new Hmac(hash, key, enc);
            this.Hash = hash;
            this.blockSize = hash.blockSize / 8;
            this.outSize = hash.outSize / 8;
            this.inner = null;
            this.outer = null;

            this._init(utils.toArray(key, enc));
        }

        module.exports = Hmac;

        Hmac.prototype._init = function init(key) {
            // Shorten key, if needed
            if (key.length > this.blockSize)
                key = new this.Hash().update(key).digest();
            assert(key.length <= this.blockSize);

            // Add padding to key
            for (var i = key.length; i < this.blockSize; i++)
                key.push(0);

            for (i = 0; i < key.length; i++)
                key[i] ^= 0x36;
            this.inner = new this.Hash().update(key);

            // 0x36 ^ 0x5c = 0x6a
            for (i = 0; i < key.length; i++)
                key[i] ^= 0x6a;
            this.outer = new this.Hash().update(key);
        };

        Hmac.prototype.update = function update(msg, enc) {
            this.inner.update(msg, enc);
            return this;
        };

        Hmac.prototype.digest = function digest(enc) {
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc);
        };

    }, {"./utils": 157, "minimalistic-assert": 162}],
    149: [function (require, module, exports) {
        'use strict';

        var utils = require('./utils');
        var common = require('./common');

        var rotl32 = utils.rotl32;
        var sum32 = utils.sum32;
        var sum32_3 = utils.sum32_3;
        var sum32_4 = utils.sum32_4;
        var BlockHash = common.BlockHash;

        function RIPEMD160() {
            if (!(this instanceof RIPEMD160))
                return new RIPEMD160();

            BlockHash.call(this);

            this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
            this.endian = 'little';
        }

        utils.inherits(RIPEMD160, BlockHash);
        exports.ripemd160 = RIPEMD160;

        RIPEMD160.blockSize = 512;
        RIPEMD160.outSize = 160;
        RIPEMD160.hmacStrength = 192;
        RIPEMD160.padLength = 64;

        RIPEMD160.prototype._update = function update(msg, start) {
            var A = this.h[0];
            var B = this.h[1];
            var C = this.h[2];
            var D = this.h[3];
            var E = this.h[4];
            var Ah = A;
            var Bh = B;
            var Ch = C;
            var Dh = D;
            var Eh = E;
            for (var j = 0; j < 80; j++) {
                var T = sum32(
                    rotl32(
                        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
                        s[j]),
                    E);
                A = E;
                E = D;
                D = rotl32(C, 10);
                C = B;
                B = T;
                T = sum32(
                    rotl32(
                        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
                        sh[j]),
                    Eh);
                Ah = Eh;
                Eh = Dh;
                Dh = rotl32(Ch, 10);
                Ch = Bh;
                Bh = T;
            }
            T = sum32_3(this.h[1], C, Dh);
            this.h[1] = sum32_3(this.h[2], D, Eh);
            this.h[2] = sum32_3(this.h[3], E, Ah);
            this.h[3] = sum32_3(this.h[4], A, Bh);
            this.h[4] = sum32_3(this.h[0], B, Ch);
            this.h[0] = T;
        };

        RIPEMD160.prototype._digest = function digest(enc) {
            if (enc === 'hex')
                return utils.toHex32(this.h, 'little');
            else
                return utils.split32(this.h, 'little');
        };

        function f(j, x, y, z) {
            if (j <= 15)
                return x ^ y ^ z;
            else if (j <= 31)
                return (x & y) | ((~x) & z);
            else if (j <= 47)
                return (x | (~y)) ^ z;
            else if (j <= 63)
                return (x & z) | (y & (~z));
            else
                return x ^ (y | (~z));
        }

        function K(j) {
            if (j <= 15)
                return 0x00000000;
            else if (j <= 31)
                return 0x5a827999;
            else if (j <= 47)
                return 0x6ed9eba1;
            else if (j <= 63)
                return 0x8f1bbcdc;
            else
                return 0xa953fd4e;
        }

        function Kh(j) {
            if (j <= 15)
                return 0x50a28be6;
            else if (j <= 31)
                return 0x5c4dd124;
            else if (j <= 47)
                return 0x6d703ef3;
            else if (j <= 63)
                return 0x7a6d76e9;
            else
                return 0x00000000;
        }

        var r = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
            3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
            1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
            4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
        ];

        var rh = [
            5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
            6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
            15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
            8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
            12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
        ];

        var s = [
            11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
            7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
            11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
            11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
            9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
        ];

        var sh = [
            8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
            9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
            9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
            15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
            8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
        ];

    }, {"./common": 147, "./utils": 157}],
    150: [function (require, module, exports) {
        'use strict';

        exports.sha1 = require('./sha/1');
        exports.sha224 = require('./sha/224');
        exports.sha256 = require('./sha/256');
        exports.sha384 = require('./sha/384');
        exports.sha512 = require('./sha/512');

    }, {"./sha/1": 151, "./sha/224": 152, "./sha/256": 153, "./sha/384": 154, "./sha/512": 155}],
    151: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var common = require('../common');
        var shaCommon = require('./common');

        var rotl32 = utils.rotl32;
        var sum32 = utils.sum32;
        var sum32_5 = utils.sum32_5;
        var ft_1 = shaCommon.ft_1;
        var BlockHash = common.BlockHash;

        var sha1_K = [
            0x5A827999, 0x6ED9EBA1,
            0x8F1BBCDC, 0xCA62C1D6
        ];

        function SHA1() {
            if (!(this instanceof SHA1))
                return new SHA1();

            BlockHash.call(this);
            this.h = [
                0x67452301, 0xefcdab89, 0x98badcfe,
                0x10325476, 0xc3d2e1f0];
            this.W = new Array(80);
        }

        utils.inherits(SHA1, BlockHash);
        module.exports = SHA1;

        SHA1.blockSize = 512;
        SHA1.outSize = 160;
        SHA1.hmacStrength = 80;
        SHA1.padLength = 64;

        SHA1.prototype._update = function _update(msg, start) {
            var W = this.W;

            for (var i = 0; i < 16; i++)
                W[i] = msg[start + i];

            for (; i < W.length; i++)
                W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

            var a = this.h[0];
            var b = this.h[1];
            var c = this.h[2];
            var d = this.h[3];
            var e = this.h[4];

            for (i = 0; i < W.length; i++) {
                var s = ~~(i / 20);
                var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
                e = d;
                d = c;
                c = rotl32(b, 30);
                b = a;
                a = t;
            }

            this.h[0] = sum32(this.h[0], a);
            this.h[1] = sum32(this.h[1], b);
            this.h[2] = sum32(this.h[2], c);
            this.h[3] = sum32(this.h[3], d);
            this.h[4] = sum32(this.h[4], e);
        };

        SHA1.prototype._digest = function digest(enc) {
            if (enc === 'hex')
                return utils.toHex32(this.h, 'big');
            else
                return utils.split32(this.h, 'big');
        };

    }, {"../common": 147, "../utils": 157, "./common": 156}],
    152: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var SHA256 = require('./256');

        function SHA224() {
            if (!(this instanceof SHA224))
                return new SHA224();

            SHA256.call(this);
            this.h = [
                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
        }

        utils.inherits(SHA224, SHA256);
        module.exports = SHA224;

        SHA224.blockSize = 512;
        SHA224.outSize = 224;
        SHA224.hmacStrength = 192;
        SHA224.padLength = 64;

        SHA224.prototype._digest = function digest(enc) {
            // Just truncate output
            if (enc === 'hex')
                return utils.toHex32(this.h.slice(0, 7), 'big');
            else
                return utils.split32(this.h.slice(0, 7), 'big');
        };


    }, {"../utils": 157, "./256": 153}],
    153: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var common = require('../common');
        var shaCommon = require('./common');
        var assert = require('minimalistic-assert');

        var sum32 = utils.sum32;
        var sum32_4 = utils.sum32_4;
        var sum32_5 = utils.sum32_5;
        var ch32 = shaCommon.ch32;
        var maj32 = shaCommon.maj32;
        var s0_256 = shaCommon.s0_256;
        var s1_256 = shaCommon.s1_256;
        var g0_256 = shaCommon.g0_256;
        var g1_256 = shaCommon.g1_256;

        var BlockHash = common.BlockHash;

        var sha256_K = [
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
            0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
            0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
            0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
            0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
            0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
            0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
            0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
            0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
        ];

        function SHA256() {
            if (!(this instanceof SHA256))
                return new SHA256();

            BlockHash.call(this);
            this.h = [
                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
            ];
            this.k = sha256_K;
            this.W = new Array(64);
        }

        utils.inherits(SHA256, BlockHash);
        module.exports = SHA256;

        SHA256.blockSize = 512;
        SHA256.outSize = 256;
        SHA256.hmacStrength = 192;
        SHA256.padLength = 64;

        SHA256.prototype._update = function _update(msg, start) {
            var W = this.W;

            for (var i = 0; i < 16; i++)
                W[i] = msg[start + i];
            for (; i < W.length; i++)
                W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

            var a = this.h[0];
            var b = this.h[1];
            var c = this.h[2];
            var d = this.h[3];
            var e = this.h[4];
            var f = this.h[5];
            var g = this.h[6];
            var h = this.h[7];

            assert(this.k.length === W.length);
            for (i = 0; i < W.length; i++) {
                var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
                var T2 = sum32(s0_256(a), maj32(a, b, c));
                h = g;
                g = f;
                f = e;
                e = sum32(d, T1);
                d = c;
                c = b;
                b = a;
                a = sum32(T1, T2);
            }

            this.h[0] = sum32(this.h[0], a);
            this.h[1] = sum32(this.h[1], b);
            this.h[2] = sum32(this.h[2], c);
            this.h[3] = sum32(this.h[3], d);
            this.h[4] = sum32(this.h[4], e);
            this.h[5] = sum32(this.h[5], f);
            this.h[6] = sum32(this.h[6], g);
            this.h[7] = sum32(this.h[7], h);
        };

        SHA256.prototype._digest = function digest(enc) {
            if (enc === 'hex')
                return utils.toHex32(this.h, 'big');
            else
                return utils.split32(this.h, 'big');
        };

    }, {"../common": 147, "../utils": 157, "./common": 156, "minimalistic-assert": 162}],
    154: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');

        var SHA512 = require('./512');

        function SHA384() {
            if (!(this instanceof SHA384))
                return new SHA384();

            SHA512.call(this);
            this.h = [
                0xcbbb9d5d, 0xc1059ed8,
                0x629a292a, 0x367cd507,
                0x9159015a, 0x3070dd17,
                0x152fecd8, 0xf70e5939,
                0x67332667, 0xffc00b31,
                0x8eb44a87, 0x68581511,
                0xdb0c2e0d, 0x64f98fa7,
                0x47b5481d, 0xbefa4fa4];
        }

        utils.inherits(SHA384, SHA512);
        module.exports = SHA384;

        SHA384.blockSize = 1024;
        SHA384.outSize = 384;
        SHA384.hmacStrength = 192;
        SHA384.padLength = 128;

        SHA384.prototype._digest = function digest(enc) {
            if (enc === 'hex')
                return utils.toHex32(this.h.slice(0, 12), 'big');
            else
                return utils.split32(this.h.slice(0, 12), 'big');
        };

    }, {"../utils": 157, "./512": 155}],
    155: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var common = require('../common');
        var assert = require('minimalistic-assert');

        var rotr64_hi = utils.rotr64_hi;
        var rotr64_lo = utils.rotr64_lo;
        var shr64_hi = utils.shr64_hi;
        var shr64_lo = utils.shr64_lo;
        var sum64 = utils.sum64;
        var sum64_hi = utils.sum64_hi;
        var sum64_lo = utils.sum64_lo;
        var sum64_4_hi = utils.sum64_4_hi;
        var sum64_4_lo = utils.sum64_4_lo;
        var sum64_5_hi = utils.sum64_5_hi;
        var sum64_5_lo = utils.sum64_5_lo;

        var BlockHash = common.BlockHash;

        var sha512_K = [
            0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
            0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
            0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
            0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
            0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
            0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
            0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
            0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
            0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
            0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
            0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
            0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
            0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
            0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
            0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
            0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
            0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
            0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
            0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
            0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
            0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
            0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
            0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
            0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
            0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
            0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
            0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
            0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
            0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
            0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
            0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
            0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
            0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
            0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
            0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
            0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
            0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
            0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
            0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
            0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
        ];

        function SHA512() {
            if (!(this instanceof SHA512))
                return new SHA512();

            BlockHash.call(this);
            this.h = [
                0x6a09e667, 0xf3bcc908,
                0xbb67ae85, 0x84caa73b,
                0x3c6ef372, 0xfe94f82b,
                0xa54ff53a, 0x5f1d36f1,
                0x510e527f, 0xade682d1,
                0x9b05688c, 0x2b3e6c1f,
                0x1f83d9ab, 0xfb41bd6b,
                0x5be0cd19, 0x137e2179];
            this.k = sha512_K;
            this.W = new Array(160);
        }

        utils.inherits(SHA512, BlockHash);
        module.exports = SHA512;

        SHA512.blockSize = 1024;
        SHA512.outSize = 512;
        SHA512.hmacStrength = 192;
        SHA512.padLength = 128;

        SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
            var W = this.W;

            // 32 x 32bit words
            for (var i = 0; i < 32; i++)
                W[i] = msg[start + i];
            for (; i < W.length; i += 2) {
                var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
                var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
                var c1_hi = W[i - 14];  // i - 7
                var c1_lo = W[i - 13];
                var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
                var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
                var c3_hi = W[i - 32];  // i - 16
                var c3_lo = W[i - 31];

                W[i] = sum64_4_hi(
                    c0_hi, c0_lo,
                    c1_hi, c1_lo,
                    c2_hi, c2_lo,
                    c3_hi, c3_lo);
                W[i + 1] = sum64_4_lo(
                    c0_hi, c0_lo,
                    c1_hi, c1_lo,
                    c2_hi, c2_lo,
                    c3_hi, c3_lo);
            }
        };

        SHA512.prototype._update = function _update(msg, start) {
            this._prepareBlock(msg, start);

            var W = this.W;

            var ah = this.h[0];
            var al = this.h[1];
            var bh = this.h[2];
            var bl = this.h[3];
            var ch = this.h[4];
            var cl = this.h[5];
            var dh = this.h[6];
            var dl = this.h[7];
            var eh = this.h[8];
            var el = this.h[9];
            var fh = this.h[10];
            var fl = this.h[11];
            var gh = this.h[12];
            var gl = this.h[13];
            var hh = this.h[14];
            var hl = this.h[15];

            assert(this.k.length === W.length);
            for (var i = 0; i < W.length; i += 2) {
                var c0_hi = hh;
                var c0_lo = hl;
                var c1_hi = s1_512_hi(eh, el);
                var c1_lo = s1_512_lo(eh, el);
                var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
                var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
                var c3_hi = this.k[i];
                var c3_lo = this.k[i + 1];
                var c4_hi = W[i];
                var c4_lo = W[i + 1];

                var T1_hi = sum64_5_hi(
                    c0_hi, c0_lo,
                    c1_hi, c1_lo,
                    c2_hi, c2_lo,
                    c3_hi, c3_lo,
                    c4_hi, c4_lo);
                var T1_lo = sum64_5_lo(
                    c0_hi, c0_lo,
                    c1_hi, c1_lo,
                    c2_hi, c2_lo,
                    c3_hi, c3_lo,
                    c4_hi, c4_lo);

                c0_hi = s0_512_hi(ah, al);
                c0_lo = s0_512_lo(ah, al);
                c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
                c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

                var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
                var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

                hh = gh;
                hl = gl;

                gh = fh;
                gl = fl;

                fh = eh;
                fl = el;

                eh = sum64_hi(dh, dl, T1_hi, T1_lo);
                el = sum64_lo(dl, dl, T1_hi, T1_lo);

                dh = ch;
                dl = cl;

                ch = bh;
                cl = bl;

                bh = ah;
                bl = al;

                ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
                al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
            }

            sum64(this.h, 0, ah, al);
            sum64(this.h, 2, bh, bl);
            sum64(this.h, 4, ch, cl);
            sum64(this.h, 6, dh, dl);
            sum64(this.h, 8, eh, el);
            sum64(this.h, 10, fh, fl);
            sum64(this.h, 12, gh, gl);
            sum64(this.h, 14, hh, hl);
        };

        SHA512.prototype._digest = function digest(enc) {
            if (enc === 'hex')
                return utils.toHex32(this.h, 'big');
            else
                return utils.split32(this.h, 'big');
        };

        function ch64_hi(xh, xl, yh, yl, zh) {
            var r = (xh & yh) ^ ((~xh) & zh);
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function ch64_lo(xh, xl, yh, yl, zh, zl) {
            var r = (xl & yl) ^ ((~xl) & zl);
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function maj64_hi(xh, xl, yh, yl, zh) {
            var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function maj64_lo(xh, xl, yh, yl, zh, zl) {
            var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function s0_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 28);
            var c1_hi = rotr64_hi(xl, xh, 2);  // 34
            var c2_hi = rotr64_hi(xl, xh, 7);  // 39

            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function s0_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 28);
            var c1_lo = rotr64_lo(xl, xh, 2);  // 34
            var c2_lo = rotr64_lo(xl, xh, 7);  // 39

            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function s1_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 14);
            var c1_hi = rotr64_hi(xh, xl, 18);
            var c2_hi = rotr64_hi(xl, xh, 9);  // 41

            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function s1_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 14);
            var c1_lo = rotr64_lo(xh, xl, 18);
            var c2_lo = rotr64_lo(xl, xh, 9);  // 41

            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function g0_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 1);
            var c1_hi = rotr64_hi(xh, xl, 8);
            var c2_hi = shr64_hi(xh, xl, 7);

            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function g0_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 1);
            var c1_lo = rotr64_lo(xh, xl, 8);
            var c2_lo = shr64_lo(xh, xl, 7);

            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function g1_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 19);
            var c1_hi = rotr64_hi(xl, xh, 29);  // 61
            var c2_hi = shr64_hi(xh, xl, 6);

            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

        function g1_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 19);
            var c1_lo = rotr64_lo(xl, xh, 29);  // 61
            var c2_lo = shr64_lo(xh, xl, 6);

            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0)
                r += 0x100000000;
            return r;
        }

    }, {"../common": 147, "../utils": 157, "minimalistic-assert": 162}],
    156: [function (require, module, exports) {
        'use strict';

        var utils = require('../utils');
        var rotr32 = utils.rotr32;

        function ft_1(s, x, y, z) {
            if (s === 0)
                return ch32(x, y, z);
            if (s === 1 || s === 3)
                return p32(x, y, z);
            if (s === 2)
                return maj32(x, y, z);
        }

        exports.ft_1 = ft_1;

        function ch32(x, y, z) {
            return (x & y) ^ ((~x) & z);
        }

        exports.ch32 = ch32;

        function maj32(x, y, z) {
            return (x & y) ^ (x & z) ^ (y & z);
        }

        exports.maj32 = maj32;

        function p32(x, y, z) {
            return x ^ y ^ z;
        }

        exports.p32 = p32;

        function s0_256(x) {
            return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
        }

        exports.s0_256 = s0_256;

        function s1_256(x) {
            return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
        }

        exports.s1_256 = s1_256;

        function g0_256(x) {
            return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
        }

        exports.g0_256 = g0_256;

        function g1_256(x) {
            return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
        }

        exports.g1_256 = g1_256;

    }, {"../utils": 157}],
    157: [function (require, module, exports) {
        'use strict';

        var assert = require('minimalistic-assert');
        var inherits = require('inherits');

        exports.inherits = inherits;

        function isSurrogatePair(msg, i) {
            if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
                return false;
            }
            if (i < 0 || i + 1 >= msg.length) {
                return false;
            }
            return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
        }

        function toArray(msg, enc) {
            if (Array.isArray(msg))
                return msg.slice();
            if (!msg)
                return [];
            var res = [];
            if (typeof msg === 'string') {
                if (!enc) {
                    // Inspired by stringToUtf8ByteArray() in closure-library by Google
                    // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
                    // Apache License 2.0
                    // https://github.com/google/closure-library/blob/master/LICENSE
                    var p = 0;
                    for (var i = 0; i < msg.length; i++) {
                        var c = msg.charCodeAt(i);
                        if (c < 128) {
                            res[p++] = c;
                        } else if (c < 2048) {
                            res[p++] = (c >> 6) | 192;
                            res[p++] = (c & 63) | 128;
                        } else if (isSurrogatePair(msg, i)) {
                            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                            res[p++] = (c >> 18) | 240;
                            res[p++] = ((c >> 12) & 63) | 128;
                            res[p++] = ((c >> 6) & 63) | 128;
                            res[p++] = (c & 63) | 128;
                        } else {
                            res[p++] = (c >> 12) | 224;
                            res[p++] = ((c >> 6) & 63) | 128;
                            res[p++] = (c & 63) | 128;
                        }
                    }
                } else if (enc === 'hex') {
                    msg = msg.replace(/[^a-z0-9]+/ig, '');
                    if (msg.length % 2 !== 0)
                        msg = '0' + msg;
                    for (i = 0; i < msg.length; i += 2)
                        res.push(parseInt(msg[i] + msg[i + 1], 16));
                }
            } else {
                for (i = 0; i < msg.length; i++)
                    res[i] = msg[i] | 0;
            }
            return res;
        }

        exports.toArray = toArray;

        function toHex(msg) {
            var res = '';
            for (var i = 0; i < msg.length; i++)
                res += zero2(msg[i].toString(16));
            return res;
        }

        exports.toHex = toHex;

        function htonl(w) {
            var res = (w >>> 24) |
                ((w >>> 8) & 0xff00) |
                ((w << 8) & 0xff0000) |
                ((w & 0xff) << 24);
            return res >>> 0;
        }

        exports.htonl = htonl;

        function toHex32(msg, endian) {
            var res = '';
            for (var i = 0; i < msg.length; i++) {
                var w = msg[i];
                if (endian === 'little')
                    w = htonl(w);
                res += zero8(w.toString(16));
            }
            return res;
        }

        exports.toHex32 = toHex32;

        function zero2(word) {
            if (word.length === 1)
                return '0' + word;
            else
                return word;
        }

        exports.zero2 = zero2;

        function zero8(word) {
            if (word.length === 7)
                return '0' + word;
            else if (word.length === 6)
                return '00' + word;
            else if (word.length === 5)
                return '000' + word;
            else if (word.length === 4)
                return '0000' + word;
            else if (word.length === 3)
                return '00000' + word;
            else if (word.length === 2)
                return '000000' + word;
            else if (word.length === 1)
                return '0000000' + word;
            else
                return word;
        }

        exports.zero8 = zero8;

        function join32(msg, start, end, endian) {
            var len = end - start;
            assert(len % 4 === 0);
            var res = new Array(len / 4);
            for (var i = 0, k = start; i < res.length; i++, k += 4) {
                var w;
                if (endian === 'big')
                    w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
                else
                    w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
                res[i] = w >>> 0;
            }
            return res;
        }

        exports.join32 = join32;

        function split32(msg, endian) {
            var res = new Array(msg.length * 4);
            for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
                var m = msg[i];
                if (endian === 'big') {
                    res[k] = m >>> 24;
                    res[k + 1] = (m >>> 16) & 0xff;
                    res[k + 2] = (m >>> 8) & 0xff;
                    res[k + 3] = m & 0xff;
                } else {
                    res[k + 3] = m >>> 24;
                    res[k + 2] = (m >>> 16) & 0xff;
                    res[k + 1] = (m >>> 8) & 0xff;
                    res[k] = m & 0xff;
                }
            }
            return res;
        }

        exports.split32 = split32;

        function rotr32(w, b) {
            return (w >>> b) | (w << (32 - b));
        }

        exports.rotr32 = rotr32;

        function rotl32(w, b) {
            return (w << b) | (w >>> (32 - b));
        }

        exports.rotl32 = rotl32;

        function sum32(a, b) {
            return (a + b) >>> 0;
        }

        exports.sum32 = sum32;

        function sum32_3(a, b, c) {
            return (a + b + c) >>> 0;
        }

        exports.sum32_3 = sum32_3;

        function sum32_4(a, b, c, d) {
            return (a + b + c + d) >>> 0;
        }

        exports.sum32_4 = sum32_4;

        function sum32_5(a, b, c, d, e) {
            return (a + b + c + d + e) >>> 0;
        }

        exports.sum32_5 = sum32_5;

        function sum64(buf, pos, ah, al) {
            var bh = buf[pos];
            var bl = buf[pos + 1];

            var lo = (al + bl) >>> 0;
            var hi = (lo < al ? 1 : 0) + ah + bh;
            buf[pos] = hi >>> 0;
            buf[pos + 1] = lo;
        }

        exports.sum64 = sum64;

        function sum64_hi(ah, al, bh, bl) {
            var lo = (al + bl) >>> 0;
            var hi = (lo < al ? 1 : 0) + ah + bh;
            return hi >>> 0;
        }

        exports.sum64_hi = sum64_hi;

        function sum64_lo(ah, al, bh, bl) {
            var lo = al + bl;
            return lo >>> 0;
        }

        exports.sum64_lo = sum64_lo;

        function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
            var carry = 0;
            var lo = al;
            lo = (lo + bl) >>> 0;
            carry += lo < al ? 1 : 0;
            lo = (lo + cl) >>> 0;
            carry += lo < cl ? 1 : 0;
            lo = (lo + dl) >>> 0;
            carry += lo < dl ? 1 : 0;

            var hi = ah + bh + ch + dh + carry;
            return hi >>> 0;
        }

        exports.sum64_4_hi = sum64_4_hi;

        function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
            var lo = al + bl + cl + dl;
            return lo >>> 0;
        }

        exports.sum64_4_lo = sum64_4_lo;

        function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
            var carry = 0;
            var lo = al;
            lo = (lo + bl) >>> 0;
            carry += lo < al ? 1 : 0;
            lo = (lo + cl) >>> 0;
            carry += lo < cl ? 1 : 0;
            lo = (lo + dl) >>> 0;
            carry += lo < dl ? 1 : 0;
            lo = (lo + el) >>> 0;
            carry += lo < el ? 1 : 0;

            var hi = ah + bh + ch + dh + eh + carry;
            return hi >>> 0;
        }

        exports.sum64_5_hi = sum64_5_hi;

        function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
            var lo = al + bl + cl + dl + el;

            return lo >>> 0;
        }

        exports.sum64_5_lo = sum64_5_lo;

        function rotr64_hi(ah, al, num) {
            var r = (al << (32 - num)) | (ah >>> num);
            return r >>> 0;
        }

        exports.rotr64_hi = rotr64_hi;

        function rotr64_lo(ah, al, num) {
            var r = (ah << (32 - num)) | (al >>> num);
            return r >>> 0;
        }

        exports.rotr64_lo = rotr64_lo;

        function shr64_hi(ah, al, num) {
            return ah >>> num;
        }

        exports.shr64_hi = shr64_hi;

        function shr64_lo(ah, al, num) {
            var r = (ah << (32 - num)) | (al >>> num);
            return r >>> 0;
        }

        exports.shr64_lo = shr64_lo;

    }, {"inherits": 159, "minimalistic-assert": 162}],
    158: [function (require, module, exports) {
        'use strict';

        var hash = require('hash.js');
        var utils = require('minimalistic-crypto-utils');
        var assert = require('minimalistic-assert');

        function HmacDRBG(options) {
            if (!(this instanceof HmacDRBG))
                return new HmacDRBG(options);
            this.hash = options.hash;
            this.predResist = !!options.predResist;

            this.outLen = this.hash.outSize;
            this.minEntropy = options.minEntropy || this.hash.hmacStrength;

            this._reseed = null;
            this.reseedInterval = null;
            this.K = null;
            this.V = null;

            var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
            var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
            var pers = utils.toArray(options.pers, options.persEnc || 'hex');
            assert(entropy.length >= (this.minEntropy / 8),
                'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
            this._init(entropy, nonce, pers);
        }

        module.exports = HmacDRBG;

        HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
            var seed = entropy.concat(nonce).concat(pers);

            this.K = new Array(this.outLen / 8);
            this.V = new Array(this.outLen / 8);
            for (var i = 0; i < this.V.length; i++) {
                this.K[i] = 0x00;
                this.V[i] = 0x01;
            }

            this._update(seed);
            this._reseed = 1;
            this.reseedInterval = 0x1000000000000;  // 2^48
        };

        HmacDRBG.prototype._hmac = function hmac() {
            return new hash.hmac(this.hash, this.K);
        };

        HmacDRBG.prototype._update = function update(seed) {
            var kmac = this._hmac()
                .update(this.V)
                .update([0x00]);
            if (seed)
                kmac = kmac.update(seed);
            this.K = kmac.digest();
            this.V = this._hmac().update(this.V).digest();
            if (!seed)
                return;

            this.K = this._hmac()
                .update(this.V)
                .update([0x01])
                .update(seed)
                .digest();
            this.V = this._hmac().update(this.V).digest();
        };

        HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
            // Optional entropy enc
            if (typeof entropyEnc !== 'string') {
                addEnc = add;
                add = entropyEnc;
                entropyEnc = null;
            }

            entropy = utils.toArray(entropy, entropyEnc);
            add = utils.toArray(add, addEnc);

            assert(entropy.length >= (this.minEntropy / 8),
                'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

            this._update(entropy.concat(add || []));
            this._reseed = 1;
        };

        HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
            if (this._reseed > this.reseedInterval)
                throw new Error('Reseed is required');

            // Optional encoding
            if (typeof enc !== 'string') {
                addEnc = add;
                add = enc;
                enc = null;
            }

            // Optional additional data
            if (add) {
                add = utils.toArray(add, addEnc || 'hex');
                this._update(add);
            }

            var temp = [];
            while (temp.length < len) {
                this.V = this._hmac().update(this.V).digest();
                temp = temp.concat(this.V);
            }

            var res = temp.slice(0, len);
            this._update(add);
            this._reseed++;
            return utils.encode(res, enc);
        };

    }, {"hash.js": 146, "minimalistic-assert": 162, "minimalistic-crypto-utils": 163}],
    159: [function (require, module, exports) {
        arguments[4][7][0].apply(exports, arguments)
    }, {"dup": 7}],
    160: [function (require, module, exports) {
        'use strict'
        var inherits = require('inherits')
        var HashBase = require('hash-base')
        var Buffer = require('safe-buffer').Buffer

        var ARRAY16 = new Array(16)

        function MD5() {
            HashBase.call(this, 64)

            // state
            this._a = 0x67452301
            this._b = 0xefcdab89
            this._c = 0x98badcfe
            this._d = 0x10325476
        }

        inherits(MD5, HashBase)

        MD5.prototype._update = function () {
            var M = ARRAY16
            for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

            var a = this._a
            var b = this._b
            var c = this._c
            var d = this._d

            a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
            d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
            c = fnF(c, d, a, b, M[2], 0x242070db, 17)
            b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
            a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
            d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
            c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
            b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
            a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
            d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
            c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
            b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
            a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
            d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
            c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
            b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

            a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
            d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
            c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
            b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
            a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
            d = fnG(d, a, b, c, M[10], 0x02441453, 9)
            c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
            b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
            a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
            d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
            c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
            b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
            a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
            d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
            c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
            b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

            a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
            d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
            c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
            b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
            a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
            d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
            c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
            b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
            a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
            d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
            c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
            b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
            a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
            d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
            c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
            b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

            a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
            d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
            c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
            b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
            a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
            d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
            c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
            b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
            a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
            d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
            c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
            b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
            a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
            d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
            c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
            b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

            this._a = (this._a + a) | 0
            this._b = (this._b + b) | 0
            this._c = (this._c + c) | 0
            this._d = (this._d + d) | 0
        }

        MD5.prototype._digest = function () {
            // create padding and handle blocks
            this._block[this._blockOffset++] = 0x80
            if (this._blockOffset > 56) {
                this._block.fill(0, this._blockOffset, 64)
                this._update()
                this._blockOffset = 0
            }

            this._block.fill(0, this._blockOffset, 56)
            this._block.writeUInt32LE(this._length[0], 56)
            this._block.writeUInt32LE(this._length[1], 60)
            this._update()

            // produce result
            var buffer = Buffer.allocUnsafe(16)
            buffer.writeInt32LE(this._a, 0)
            buffer.writeInt32LE(this._b, 4)
            buffer.writeInt32LE(this._c, 8)
            buffer.writeInt32LE(this._d, 12)
            return buffer
        }

        function rotl(x, n) {
            return (x << n) | (x >>> (32 - n))
        }

        function fnF(a, b, c, d, m, k, s) {
            return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
        }

        function fnG(a, b, c, d, m, k, s) {
            return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
        }

        function fnH(a, b, c, d, m, k, s) {
            return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
        }

        function fnI(a, b, c, d, m, k, s) {
            return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
        }

        module.exports = MD5

    }, {"hash-base": 145, "inherits": 159, "safe-buffer": 172}],
    161: [function (require, module, exports) {
        (function (Buffer) {
// constant-space merkle root calculation algorithm
            module.exports = function fastRoot(values, digestFn) {
                if (!Array.isArray(values)) throw TypeError('Expected values Array')
                if (typeof digestFn !== 'function') throw TypeError('Expected digest Function')

                var length = values.length
                var results = values.concat()

                while (length > 1) {
                    var j = 0

                    for (var i = 0; i < length; i += 2, ++j) {
                        var left = results[i]
                        var right = i + 1 === length ? left : results[i + 1]
                        var data = Buffer.concat([left, right])

                        results[j] = digestFn(data)
                    }

                    length = j
                }

                return results[0]
            }

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3}],
    162: [function (require, module, exports) {
        module.exports = assert;

        function assert(val, msg) {
            if (!val)
                throw new Error(msg || 'Assertion failed');
        }

        assert.equal = function assertEqual(l, r, msg) {
            if (l != r)
                throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
        };

    }, {}],
    163: [function (require, module, exports) {
        'use strict';

        var utils = exports;

        function toArray(msg, enc) {
            if (Array.isArray(msg))
                return msg.slice();
            if (!msg)
                return [];
            var res = [];
            if (typeof msg !== 'string') {
                for (var i = 0; i < msg.length; i++)
                    res[i] = msg[i] | 0;
                return res;
            }
            if (enc === 'hex') {
                msg = msg.replace(/[^a-z0-9]+/ig, '');
                if (msg.length % 2 !== 0)
                    msg = '0' + msg;
                for (var i = 0; i < msg.length; i += 2)
                    res.push(parseInt(msg[i] + msg[i + 1], 16));
            } else {
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    var hi = c >> 8;
                    var lo = c & 0xff;
                    if (hi)
                        res.push(hi, lo);
                    else
                        res.push(lo);
                }
            }
            return res;
        }

        utils.toArray = toArray;

        function zero2(word) {
            if (word.length === 1)
                return '0' + word;
            else
                return word;
        }

        utils.zero2 = zero2;

        function toHex(msg) {
            var res = '';
            for (var i = 0; i < msg.length; i++)
                res += zero2(msg[i].toString(16));
            return res;
        }

        utils.toHex = toHex;

        utils.encode = function encode(arr, enc) {
            if (enc === 'hex')
                return toHex(arr);
            else
                return arr;
        };

    }, {}],
    164: [function (require, module, exports) {
        exports.pbkdf2 = require('./lib/async')
        exports.pbkdf2Sync = require('./lib/sync')

    }, {"./lib/async": 165, "./lib/sync": 168}],
    165: [function (require, module, exports) {
        (function (process, global) {
            var checkParameters = require('./precondition')
            var defaultEncoding = require('./default-encoding')
            var sync = require('./sync')
            var Buffer = require('safe-buffer').Buffer

            var ZERO_BUF
            var subtle = global.crypto && global.crypto.subtle
            var toBrowser = {
                'sha': 'SHA-1',
                'sha-1': 'SHA-1',
                'sha1': 'SHA-1',
                'sha256': 'SHA-256',
                'sha-256': 'SHA-256',
                'sha384': 'SHA-384',
                'sha-384': 'SHA-384',
                'sha-512': 'SHA-512',
                'sha512': 'SHA-512'
            }
            var checks = []

            function checkNative(algo) {
                if (global.process && !global.process.browser) {
                    return Promise.resolve(false)
                }
                if (!subtle || !subtle.importKey || !subtle.deriveBits) {
                    return Promise.resolve(false)
                }
                if (checks[algo] !== undefined) {
                    return checks[algo]
                }
                ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
                var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
                    .then(function () {
                        return true
                    }).catch(function () {
                        return false
                    })
                checks[algo] = prom
                return prom
            }

            function browserPbkdf2(password, salt, iterations, length, algo) {
                return subtle.importKey(
                    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
                ).then(function (key) {
                    return subtle.deriveBits({
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: iterations,
                        hash: {
                            name: algo
                        }
                    }, key, length << 3)
                }).then(function (res) {
                    return Buffer.from(res)
                })
            }

            function resolvePromise(promise, callback) {
                promise.then(function (out) {
                    process.nextTick(function () {
                        callback(null, out)
                    })
                }, function (e) {
                    process.nextTick(function () {
                        callback(e)
                    })
                })
            }

            module.exports = function (password, salt, iterations, keylen, digest, callback) {
                if (typeof digest === 'function') {
                    callback = digest
                    digest = undefined
                }

                digest = digest || 'sha1'
                var algo = toBrowser[digest.toLowerCase()]

                if (!algo || typeof global.Promise !== 'function') {
                    return process.nextTick(function () {
                        var out
                        try {
                            out = sync(password, salt, iterations, keylen, digest)
                        } catch (e) {
                            return callback(e)
                        }
                        callback(null, out)
                    })
                }

                checkParameters(password, salt, iterations, keylen)
                if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
                if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
                if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

                resolvePromise(checkNative(algo).then(function (resp) {
                    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

                    return sync(password, salt, iterations, keylen, digest)
                }), callback)
            }

        }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {"./default-encoding": 166, "./precondition": 167, "./sync": 168, "_process": 11, "safe-buffer": 172}],
    166: [function (require, module, exports) {
        (function (process) {
            var defaultEncoding
            /* istanbul ignore next */
            if (process.browser) {
                defaultEncoding = 'utf-8'
            } else {
                var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

                defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
            }
            module.exports = defaultEncoding

        }).call(this, require('_process'))

    }, {"_process": 11}],
    167: [function (require, module, exports) {
        (function (Buffer) {
            var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

            function checkBuffer(buf, name) {
                if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
                    throw new TypeError(name + ' must be a buffer or string')
                }
            }

            module.exports = function (password, salt, iterations, keylen) {
                checkBuffer(password, 'Password')
                checkBuffer(salt, 'Salt')

                if (typeof iterations !== 'number') {
                    throw new TypeError('Iterations not a number')
                }

                if (iterations < 0) {
                    throw new TypeError('Bad iterations')
                }

                if (typeof keylen !== 'number') {
                    throw new TypeError('Key length not a number')
                }

                if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
                    throw new TypeError('Bad key length')
                }
            }

        }).call(this, {"isBuffer": require("../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})

    }, {"../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js": 8}],
    168: [function (require, module, exports) {
        var md5 = require('create-hash/md5')
        var RIPEMD160 = require('ripemd160')
        var sha = require('sha.js')

        var checkParameters = require('./precondition')
        var defaultEncoding = require('./default-encoding')
        var Buffer = require('safe-buffer').Buffer
        var ZEROS = Buffer.alloc(128)
        var sizes = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20
        }

        function Hmac(alg, key, saltLen) {
            var hash = getDigest(alg)
            var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

            if (key.length > blocksize) {
                key = hash(key)
            } else if (key.length < blocksize) {
                key = Buffer.concat([key, ZEROS], blocksize)
            }

            var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
            var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
            for (var i = 0; i < blocksize; i++) {
                ipad[i] = key[i] ^ 0x36
                opad[i] = key[i] ^ 0x5C
            }

            var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
            ipad.copy(ipad1, 0, 0, blocksize)
            this.ipad1 = ipad1
            this.ipad2 = ipad
            this.opad = opad
            this.alg = alg
            this.blocksize = blocksize
            this.hash = hash
            this.size = sizes[alg]
        }

        Hmac.prototype.run = function (data, ipad) {
            data.copy(ipad, this.blocksize)
            var h = this.hash(ipad)
            h.copy(this.opad, this.blocksize)
            return this.hash(this.opad)
        }

        function getDigest(alg) {
            function shaFunc(data) {
                return sha(alg).update(data).digest()
            }

            function rmd160Func(data) {
                return new RIPEMD160().update(data).digest()
            }

            if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
            if (alg === 'md5') return md5
            return shaFunc
        }

        function pbkdf2(password, salt, iterations, keylen, digest) {
            checkParameters(password, salt, iterations, keylen)

            if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
            if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

            digest = digest || 'sha1'

            var hmac = new Hmac(digest, password, salt.length)

            var DK = Buffer.allocUnsafe(keylen)
            var block1 = Buffer.allocUnsafe(salt.length + 4)
            salt.copy(block1, 0, 0, salt.length)

            var destPos = 0
            var hLen = sizes[digest]
            var l = Math.ceil(keylen / hLen)

            for (var i = 1; i <= l; i++) {
                block1.writeUInt32BE(i, salt.length)

                var T = hmac.run(block1, hmac.ipad1)
                var U = T

                for (var j = 1; j < iterations; j++) {
                    U = hmac.run(U, hmac.ipad2)
                    for (var k = 0; k < hLen; k++) T[k] ^= U[k]
                }

                T.copy(DK, destPos)
                destPos += hLen
            }

            return DK
        }

        module.exports = pbkdf2

    }, {
        "./default-encoding": 166,
        "./precondition": 167,
        "create-hash/md5": 126,
        "ripemd160": 171,
        "safe-buffer": 172,
        "sha.js": 174
    }],
    169: [function (require, module, exports) {
        var OPS = require('bitcoin-ops')

        function encodingLength(i) {
            return i < OPS.OP_PUSHDATA1 ? 1
                : i <= 0xff ? 2
                    : i <= 0xffff ? 3
                        : 5
        }

        function encode(buffer, number, offset) {
            var size = encodingLength(number)

            // ~6 bit
            if (size === 1) {
                buffer.writeUInt8(number, offset)

                // 8 bit
            } else if (size === 2) {
                buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)
                buffer.writeUInt8(number, offset + 1)

                // 16 bit
            } else if (size === 3) {
                buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)
                buffer.writeUInt16LE(number, offset + 1)

                // 32 bit
            } else {
                buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)
                buffer.writeUInt32LE(number, offset + 1)
            }

            return size
        }

        function decode(buffer, offset) {
            var opcode = buffer.readUInt8(offset)
            var number, size

            // ~6 bit
            if (opcode < OPS.OP_PUSHDATA1) {
                number = opcode
                size = 1

                // 8 bit
            } else if (opcode === OPS.OP_PUSHDATA1) {
                if (offset + 2 > buffer.length) return null
                number = buffer.readUInt8(offset + 1)
                size = 2

                // 16 bit
            } else if (opcode === OPS.OP_PUSHDATA2) {
                if (offset + 3 > buffer.length) return null
                number = buffer.readUInt16LE(offset + 1)
                size = 3

                // 32 bit
            } else {
                if (offset + 5 > buffer.length) return null
                if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')

                number = buffer.readUInt32LE(offset + 1)
                size = 5
            }

            return {
                opcode: opcode,
                number: number,
                size: size
            }
        }

        module.exports = {
            encodingLength: encodingLength,
            encode: encode,
            decode: decode
        }

    }, {"bitcoin-ops": 72}],
    170: [function (require, module, exports) {
        (function (process, global) {
            'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
            var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
            var MAX_UINT32 = 4294967295

            function oldBrowser() {
                throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
            }

            var Buffer = require('safe-buffer').Buffer
            var crypto = global.crypto || global.msCrypto

            if (crypto && crypto.getRandomValues) {
                module.exports = randomBytes
            } else {
                module.exports = oldBrowser
            }

            function randomBytes(size, cb) {
                // phantomjs needs to throw
                if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

                var bytes = Buffer.allocUnsafe(size)

                if (size > 0) {  // getRandomValues fails on IE if size == 0
                    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
                        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
                        for (var generated = 0; generated < size; generated += MAX_BYTES) {
                            // buffer.slice automatically checks if the end is past the end of
                            // the buffer so we don't have to here
                            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
                        }
                    } else {
                        crypto.getRandomValues(bytes)
                    }
                }

                if (typeof cb === 'function') {
                    return process.nextTick(function () {
                        cb(null, bytes)
                    })
                }

                return bytes
            }

        }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {"_process": 11, "safe-buffer": 172}],
    171: [function (require, module, exports) {
        'use strict'
        var Buffer = require('buffer').Buffer
        var inherits = require('inherits')
        var HashBase = require('hash-base')

        var ARRAY16 = new Array(16)

        var zl = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
            3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
            1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
            4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
        ]

        var zr = [
            5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
            6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
            15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
            8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
            12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
        ]

        var sl = [
            11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
            7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
            11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
            11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
            9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
        ]

        var sr = [
            8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
            9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
            9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
            15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
            8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
        ]

        var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
        var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

        function RIPEMD160() {
            HashBase.call(this, 64)

            // state
            this._a = 0x67452301
            this._b = 0xefcdab89
            this._c = 0x98badcfe
            this._d = 0x10325476
            this._e = 0xc3d2e1f0
        }

        inherits(RIPEMD160, HashBase)

        RIPEMD160.prototype._update = function () {
            var words = ARRAY16
            for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

            var al = this._a | 0
            var bl = this._b | 0
            var cl = this._c | 0
            var dl = this._d | 0
            var el = this._e | 0

            var ar = this._a | 0
            var br = this._b | 0
            var cr = this._c | 0
            var dr = this._d | 0
            var er = this._e | 0

            // computation
            for (var i = 0; i < 80; i += 1) {
                var tl
                var tr
                if (i < 16) {
                    tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
                    tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
                } else if (i < 32) {
                    tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
                    tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
                } else if (i < 48) {
                    tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
                    tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
                } else if (i < 64) {
                    tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
                    tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
                } else { // if (i<80) {
                    tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
                    tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
                }

                al = el
                el = dl
                dl = rotl(cl, 10)
                cl = bl
                bl = tl

                ar = er
                er = dr
                dr = rotl(cr, 10)
                cr = br
                br = tr
            }

            // update state
            var t = (this._b + cl + dr) | 0
            this._b = (this._c + dl + er) | 0
            this._c = (this._d + el + ar) | 0
            this._d = (this._e + al + br) | 0
            this._e = (this._a + bl + cr) | 0
            this._a = t
        }

        RIPEMD160.prototype._digest = function () {
            // create padding and handle blocks
            this._block[this._blockOffset++] = 0x80
            if (this._blockOffset > 56) {
                this._block.fill(0, this._blockOffset, 64)
                this._update()
                this._blockOffset = 0
            }

            this._block.fill(0, this._blockOffset, 56)
            this._block.writeUInt32LE(this._length[0], 56)
            this._block.writeUInt32LE(this._length[1], 60)
            this._update()

            // produce result
            var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
            buffer.writeInt32LE(this._a, 0)
            buffer.writeInt32LE(this._b, 4)
            buffer.writeInt32LE(this._c, 8)
            buffer.writeInt32LE(this._d, 12)
            buffer.writeInt32LE(this._e, 16)
            return buffer
        }

        function rotl(x, n) {
            return (x << n) | (x >>> (32 - n))
        }

        function fn1(a, b, c, d, e, m, k, s) {
            return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
        }

        function fn2(a, b, c, d, e, m, k, s) {
            return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
        }

        function fn3(a, b, c, d, e, m, k, s) {
            return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
        }

        function fn4(a, b, c, d, e, m, k, s) {
            return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
        }

        function fn5(a, b, c, d, e, m, k, s) {
            return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
        }

        module.exports = RIPEMD160

    }, {"buffer": 3, "hash-base": 145, "inherits": 159}],
    172: [function (require, module, exports) {
        arguments[4][21][0].apply(exports, arguments)
    }, {"buffer": 3, "dup": 21}],
    173: [function (require, module, exports) {
        var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
        function Hash(blockSize, finalSize) {
            this._block = Buffer.alloc(blockSize)
            this._finalSize = finalSize
            this._blockSize = blockSize
            this._len = 0
        }

        Hash.prototype.update = function (data, enc) {
            if (typeof data === 'string') {
                enc = enc || 'utf8'
                data = Buffer.from(data, enc)
            }

            var block = this._block
            var blockSize = this._blockSize
            var length = data.length
            var accum = this._len

            for (var offset = 0; offset < length;) {
                var assigned = accum % blockSize
                var remainder = Math.min(length - offset, blockSize - assigned)

                for (var i = 0; i < remainder; i++) {
                    block[assigned + i] = data[offset + i]
                }

                accum += remainder
                offset += remainder

                if ((accum % blockSize) === 0) {
                    this._update(block)
                }
            }

            this._len += length
            return this
        }

        Hash.prototype.digest = function (enc) {
            var rem = this._len % this._blockSize

            this._block[rem] = 0x80

            // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
            // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
            this._block.fill(0, rem + 1)

            if (rem >= this._finalSize) {
                this._update(this._block)
                this._block.fill(0)
            }

            var bits = this._len * 8

            // uint32
            if (bits <= 0xffffffff) {
                this._block.writeUInt32BE(bits, this._blockSize - 4)

                // uint64
            } else {
                var lowBits = (bits & 0xffffffff) >>> 0
                var highBits = (bits - lowBits) / 0x100000000

                this._block.writeUInt32BE(highBits, this._blockSize - 8)
                this._block.writeUInt32BE(lowBits, this._blockSize - 4)
            }

            this._update(this._block)
            var hash = this._hash()

            return enc ? hash.toString(enc) : hash
        }

        Hash.prototype._update = function () {
            throw new Error('_update must be implemented by subclass')
        }

        module.exports = Hash

    }, {"safe-buffer": 172}],
    174: [function (require, module, exports) {
        var exports = module.exports = function SHA(algorithm) {
            algorithm = algorithm.toLowerCase()

            var Algorithm = exports[algorithm]
            if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

            return new Algorithm()
        }

        exports.sha = require('./sha')
        exports.sha1 = require('./sha1')
        exports.sha224 = require('./sha224')
        exports.sha256 = require('./sha256')
        exports.sha384 = require('./sha384')
        exports.sha512 = require('./sha512')

    }, {"./sha": 175, "./sha1": 176, "./sha224": 177, "./sha256": 178, "./sha384": 179, "./sha512": 180}],
    175: [function (require, module, exports) {
        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
            0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
        ]

        var W = new Array(80)

        function Sha() {
            this.init()
            this._w = W

            Hash.call(this, 64, 56)
        }

        inherits(Sha, Hash)

        Sha.prototype.init = function () {
            this._a = 0x67452301
            this._b = 0xefcdab89
            this._c = 0x98badcfe
            this._d = 0x10325476
            this._e = 0xc3d2e1f0

            return this
        }

        function rotl5(num) {
            return (num << 5) | (num >>> 27)
        }

        function rotl30(num) {
            return (num << 30) | (num >>> 2)
        }

        function ft(s, b, c, d) {
            if (s === 0) return (b & c) | ((~b) & d)
            if (s === 2) return (b & c) | (b & d) | (c & d)
            return b ^ c ^ d
        }

        Sha.prototype._update = function (M) {
            var W = this._w

            var a = this._a | 0
            var b = this._b | 0
            var c = this._c | 0
            var d = this._d | 0
            var e = this._e | 0

            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
            for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

            for (var j = 0; j < 80; ++j) {
                var s = ~~(j / 20)
                var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

                e = d
                d = c
                c = rotl30(b)
                b = a
                a = t
            }

            this._a = (a + this._a) | 0
            this._b = (b + this._b) | 0
            this._c = (c + this._c) | 0
            this._d = (d + this._d) | 0
            this._e = (e + this._e) | 0
        }

        Sha.prototype._hash = function () {
            var H = Buffer.allocUnsafe(20)

            H.writeInt32BE(this._a | 0, 0)
            H.writeInt32BE(this._b | 0, 4)
            H.writeInt32BE(this._c | 0, 8)
            H.writeInt32BE(this._d | 0, 12)
            H.writeInt32BE(this._e | 0, 16)

            return H
        }

        module.exports = Sha

    }, {"./hash": 173, "inherits": 159, "safe-buffer": 172}],
    176: [function (require, module, exports) {
        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
            0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
        ]

        var W = new Array(80)

        function Sha1() {
            this.init()
            this._w = W

            Hash.call(this, 64, 56)
        }

        inherits(Sha1, Hash)

        Sha1.prototype.init = function () {
            this._a = 0x67452301
            this._b = 0xefcdab89
            this._c = 0x98badcfe
            this._d = 0x10325476
            this._e = 0xc3d2e1f0

            return this
        }

        function rotl1(num) {
            return (num << 1) | (num >>> 31)
        }

        function rotl5(num) {
            return (num << 5) | (num >>> 27)
        }

        function rotl30(num) {
            return (num << 30) | (num >>> 2)
        }

        function ft(s, b, c, d) {
            if (s === 0) return (b & c) | ((~b) & d)
            if (s === 2) return (b & c) | (b & d) | (c & d)
            return b ^ c ^ d
        }

        Sha1.prototype._update = function (M) {
            var W = this._w

            var a = this._a | 0
            var b = this._b | 0
            var c = this._c | 0
            var d = this._d | 0
            var e = this._e | 0

            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
            for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

            for (var j = 0; j < 80; ++j) {
                var s = ~~(j / 20)
                var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

                e = d
                d = c
                c = rotl30(b)
                b = a
                a = t
            }

            this._a = (a + this._a) | 0
            this._b = (b + this._b) | 0
            this._c = (c + this._c) | 0
            this._d = (d + this._d) | 0
            this._e = (e + this._e) | 0
        }

        Sha1.prototype._hash = function () {
            var H = Buffer.allocUnsafe(20)

            H.writeInt32BE(this._a | 0, 0)
            H.writeInt32BE(this._b | 0, 4)
            H.writeInt32BE(this._c | 0, 8)
            H.writeInt32BE(this._d | 0, 12)
            H.writeInt32BE(this._e | 0, 16)

            return H
        }

        module.exports = Sha1

    }, {"./hash": 173, "inherits": 159, "safe-buffer": 172}],
    177: [function (require, module, exports) {
        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('inherits')
        var Sha256 = require('./sha256')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var W = new Array(64)

        function Sha224() {
            this.init()

            this._w = W // new Array(64)

            Hash.call(this, 64, 56)
        }

        inherits(Sha224, Sha256)

        Sha224.prototype.init = function () {
            this._a = 0xc1059ed8
            this._b = 0x367cd507
            this._c = 0x3070dd17
            this._d = 0xf70e5939
            this._e = 0xffc00b31
            this._f = 0x68581511
            this._g = 0x64f98fa7
            this._h = 0xbefa4fa4

            return this
        }

        Sha224.prototype._hash = function () {
            var H = Buffer.allocUnsafe(28)

            H.writeInt32BE(this._a, 0)
            H.writeInt32BE(this._b, 4)
            H.writeInt32BE(this._c, 8)
            H.writeInt32BE(this._d, 12)
            H.writeInt32BE(this._e, 16)
            H.writeInt32BE(this._f, 20)
            H.writeInt32BE(this._g, 24)

            return H
        }

        module.exports = Sha224

    }, {"./hash": 173, "./sha256": 178, "inherits": 159, "safe-buffer": 172}],
    178: [function (require, module, exports) {
        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
            0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
            0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
            0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
            0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
            0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
            0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
            0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
            0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
            0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
            0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
            0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
            0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
            0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
            0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
            0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
            0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
        ]

        var W = new Array(64)

        function Sha256() {
            this.init()

            this._w = W // new Array(64)

            Hash.call(this, 64, 56)
        }

        inherits(Sha256, Hash)

        Sha256.prototype.init = function () {
            this._a = 0x6a09e667
            this._b = 0xbb67ae85
            this._c = 0x3c6ef372
            this._d = 0xa54ff53a
            this._e = 0x510e527f
            this._f = 0x9b05688c
            this._g = 0x1f83d9ab
            this._h = 0x5be0cd19

            return this
        }

        function ch(x, y, z) {
            return z ^ (x & (y ^ z))
        }

        function maj(x, y, z) {
            return (x & y) | (z & (x | y))
        }

        function sigma0(x) {
            return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
        }

        function sigma1(x) {
            return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
        }

        function gamma0(x) {
            return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
        }

        function gamma1(x) {
            return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
        }

        Sha256.prototype._update = function (M) {
            var W = this._w

            var a = this._a | 0
            var b = this._b | 0
            var c = this._c | 0
            var d = this._d | 0
            var e = this._e | 0
            var f = this._f | 0
            var g = this._g | 0
            var h = this._h | 0

            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
            for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

            for (var j = 0; j < 64; ++j) {
                var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
                var T2 = (sigma0(a) + maj(a, b, c)) | 0

                h = g
                g = f
                f = e
                e = (d + T1) | 0
                d = c
                c = b
                b = a
                a = (T1 + T2) | 0
            }

            this._a = (a + this._a) | 0
            this._b = (b + this._b) | 0
            this._c = (c + this._c) | 0
            this._d = (d + this._d) | 0
            this._e = (e + this._e) | 0
            this._f = (f + this._f) | 0
            this._g = (g + this._g) | 0
            this._h = (h + this._h) | 0
        }

        Sha256.prototype._hash = function () {
            var H = Buffer.allocUnsafe(32)

            H.writeInt32BE(this._a, 0)
            H.writeInt32BE(this._b, 4)
            H.writeInt32BE(this._c, 8)
            H.writeInt32BE(this._d, 12)
            H.writeInt32BE(this._e, 16)
            H.writeInt32BE(this._f, 20)
            H.writeInt32BE(this._g, 24)
            H.writeInt32BE(this._h, 28)

            return H
        }

        module.exports = Sha256

    }, {"./hash": 173, "inherits": 159, "safe-buffer": 172}],
    179: [function (require, module, exports) {
        var inherits = require('inherits')
        var SHA512 = require('./sha512')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var W = new Array(160)

        function Sha384() {
            this.init()
            this._w = W

            Hash.call(this, 128, 112)
        }

        inherits(Sha384, SHA512)

        Sha384.prototype.init = function () {
            this._ah = 0xcbbb9d5d
            this._bh = 0x629a292a
            this._ch = 0x9159015a
            this._dh = 0x152fecd8
            this._eh = 0x67332667
            this._fh = 0x8eb44a87
            this._gh = 0xdb0c2e0d
            this._hh = 0x47b5481d

            this._al = 0xc1059ed8
            this._bl = 0x367cd507
            this._cl = 0x3070dd17
            this._dl = 0xf70e5939
            this._el = 0xffc00b31
            this._fl = 0x68581511
            this._gl = 0x64f98fa7
            this._hl = 0xbefa4fa4

            return this
        }

        Sha384.prototype._hash = function () {
            var H = Buffer.allocUnsafe(48)

            function writeInt64BE(h, l, offset) {
                H.writeInt32BE(h, offset)
                H.writeInt32BE(l, offset + 4)
            }

            writeInt64BE(this._ah, this._al, 0)
            writeInt64BE(this._bh, this._bl, 8)
            writeInt64BE(this._ch, this._cl, 16)
            writeInt64BE(this._dh, this._dl, 24)
            writeInt64BE(this._eh, this._el, 32)
            writeInt64BE(this._fh, this._fl, 40)

            return H
        }

        module.exports = Sha384

    }, {"./hash": 173, "./sha512": 180, "inherits": 159, "safe-buffer": 172}],
    180: [function (require, module, exports) {
        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
            0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
            0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
            0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
            0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
            0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
            0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
            0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
            0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
            0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
            0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
            0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
            0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
            0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
            0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
            0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
            0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
            0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
            0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
            0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
            0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
            0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
            0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
            0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
            0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
            0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
            0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
            0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
            0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
            0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
            0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
            0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
            0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
            0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
            0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
            0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
            0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
            0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
            0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
            0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
            0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
        ]

        var W = new Array(160)

        function Sha512() {
            this.init()
            this._w = W

            Hash.call(this, 128, 112)
        }

        inherits(Sha512, Hash)

        Sha512.prototype.init = function () {
            this._ah = 0x6a09e667
            this._bh = 0xbb67ae85
            this._ch = 0x3c6ef372
            this._dh = 0xa54ff53a
            this._eh = 0x510e527f
            this._fh = 0x9b05688c
            this._gh = 0x1f83d9ab
            this._hh = 0x5be0cd19

            this._al = 0xf3bcc908
            this._bl = 0x84caa73b
            this._cl = 0xfe94f82b
            this._dl = 0x5f1d36f1
            this._el = 0xade682d1
            this._fl = 0x2b3e6c1f
            this._gl = 0xfb41bd6b
            this._hl = 0x137e2179

            return this
        }

        function Ch(x, y, z) {
            return z ^ (x & (y ^ z))
        }

        function maj(x, y, z) {
            return (x & y) | (z & (x | y))
        }

        function sigma0(x, xl) {
            return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
        }

        function sigma1(x, xl) {
            return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
        }

        function Gamma0(x, xl) {
            return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
        }

        function Gamma0l(x, xl) {
            return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
        }

        function Gamma1(x, xl) {
            return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
        }

        function Gamma1l(x, xl) {
            return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
        }

        function getCarry(a, b) {
            return (a >>> 0) < (b >>> 0) ? 1 : 0
        }

        Sha512.prototype._update = function (M) {
            var W = this._w

            var ah = this._ah | 0
            var bh = this._bh | 0
            var ch = this._ch | 0
            var dh = this._dh | 0
            var eh = this._eh | 0
            var fh = this._fh | 0
            var gh = this._gh | 0
            var hh = this._hh | 0

            var al = this._al | 0
            var bl = this._bl | 0
            var cl = this._cl | 0
            var dl = this._dl | 0
            var el = this._el | 0
            var fl = this._fl | 0
            var gl = this._gl | 0
            var hl = this._hl | 0

            for (var i = 0; i < 32; i += 2) {
                W[i] = M.readInt32BE(i * 4)
                W[i + 1] = M.readInt32BE(i * 4 + 4)
            }
            for (; i < 160; i += 2) {
                var xh = W[i - 15 * 2]
                var xl = W[i - 15 * 2 + 1]
                var gamma0 = Gamma0(xh, xl)
                var gamma0l = Gamma0l(xl, xh)

                xh = W[i - 2 * 2]
                xl = W[i - 2 * 2 + 1]
                var gamma1 = Gamma1(xh, xl)
                var gamma1l = Gamma1l(xl, xh)

                // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                var Wi7h = W[i - 7 * 2]
                var Wi7l = W[i - 7 * 2 + 1]

                var Wi16h = W[i - 16 * 2]
                var Wi16l = W[i - 16 * 2 + 1]

                var Wil = (gamma0l + Wi7l) | 0
                var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
                Wil = (Wil + gamma1l) | 0
                Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
                Wil = (Wil + Wi16l) | 0
                Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

                W[i] = Wih
                W[i + 1] = Wil
            }

            for (var j = 0; j < 160; j += 2) {
                Wih = W[j]
                Wil = W[j + 1]

                var majh = maj(ah, bh, ch)
                var majl = maj(al, bl, cl)

                var sigma0h = sigma0(ah, al)
                var sigma0l = sigma0(al, ah)
                var sigma1h = sigma1(eh, el)
                var sigma1l = sigma1(el, eh)

                // t1 = h + sigma1 + ch + K[j] + W[j]
                var Kih = K[j]
                var Kil = K[j + 1]

                var chh = Ch(eh, fh, gh)
                var chl = Ch(el, fl, gl)

                var t1l = (hl + sigma1l) | 0
                var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
                t1l = (t1l + chl) | 0
                t1h = (t1h + chh + getCarry(t1l, chl)) | 0
                t1l = (t1l + Kil) | 0
                t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
                t1l = (t1l + Wil) | 0
                t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

                // t2 = sigma0 + maj
                var t2l = (sigma0l + majl) | 0
                var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

                hh = gh
                hl = gl
                gh = fh
                gl = fl
                fh = eh
                fl = el
                el = (dl + t1l) | 0
                eh = (dh + t1h + getCarry(el, dl)) | 0
                dh = ch
                dl = cl
                ch = bh
                cl = bl
                bh = ah
                bl = al
                al = (t1l + t2l) | 0
                ah = (t1h + t2h + getCarry(al, t1l)) | 0
            }

            this._al = (this._al + al) | 0
            this._bl = (this._bl + bl) | 0
            this._cl = (this._cl + cl) | 0
            this._dl = (this._dl + dl) | 0
            this._el = (this._el + el) | 0
            this._fl = (this._fl + fl) | 0
            this._gl = (this._gl + gl) | 0
            this._hl = (this._hl + hl) | 0

            this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
            this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
            this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
            this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
            this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
            this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
            this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
            this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
        }

        Sha512.prototype._hash = function () {
            var H = Buffer.allocUnsafe(64)

            function writeInt64BE(h, l, offset) {
                H.writeInt32BE(h, offset)
                H.writeInt32BE(l, offset + 4)
            }

            writeInt64BE(this._ah, this._al, 0)
            writeInt64BE(this._bh, this._bl, 8)
            writeInt64BE(this._ch, this._cl, 16)
            writeInt64BE(this._dh, this._dl, 24)
            writeInt64BE(this._eh, this._el, 32)
            writeInt64BE(this._fh, this._fl, 40)
            writeInt64BE(this._gh, this._gl, 48)
            writeInt64BE(this._hh, this._hl, 56)

            return H
        }

        module.exports = Sha512

    }, {"./hash": 173, "inherits": 159, "safe-buffer": 172}],
    181: [function (require, module, exports) {
        (function (Buffer) {
            const BN = require('bn.js')
            const EC = require('elliptic').ec
            const secp256k1 = new EC('secp256k1')
            const deterministicGenerateK = require('./rfc6979')

            const ZERO32 = Buffer.alloc(32, 0)
            const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
            const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')

            const n = secp256k1.curve.n
            const nDiv2 = n.shrn(1)
            const G = secp256k1.curve.g

            const THROW_BAD_PRIVATE = 'Expected Private'
            const THROW_BAD_POINT = 'Expected Point'
            const THROW_BAD_TWEAK = 'Expected Tweak'
            const THROW_BAD_HASH = 'Expected Hash'
            const THROW_BAD_SIGNATURE = 'Expected Signature'
            const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'

            function isScalar(x) {
                return Buffer.isBuffer(x) && x.length === 32
            }

            function isOrderScalar(x) {
                if (!isScalar(x)) return false
                return x.compare(EC_GROUP_ORDER) < 0 // < G
            }

            function isPoint(p) {
                if (!Buffer.isBuffer(p)) return false
                if (p.length < 33) return false

                const t = p[0]
                const x = p.slice(1, 33)
                if (x.compare(ZERO32) === 0) return false
                if (x.compare(EC_P) >= 0) return false
                if ((t === 0x02 || t === 0x03) && p.length === 33) {
                    try {
                        decodeFrom(p)
                    } catch (e) {
                        return false
                    } // TODO: temporary
                    return true
                }

                const y = p.slice(33)
                if (y.compare(ZERO32) === 0) return false
                if (y.compare(EC_P) >= 0) return false
                if (t === 0x04 && p.length === 65) return true
                return false
            }

            function __isPointCompressed(p) {
                return p[0] !== 0x04
            }

            function isPointCompressed(p) {
                if (!isPoint(p)) return false
                return __isPointCompressed(p)
            }

            function isPrivate(x) {
                if (!isScalar(x)) return false
                return x.compare(ZERO32) > 0 && // > 0
                    x.compare(EC_GROUP_ORDER) < 0 // < G
            }

            function isSignature(value) {
                const r = value.slice(0, 32)
                const s = value.slice(32, 64)
                return Buffer.isBuffer(value) && value.length === 64 &&
                    r.compare(EC_GROUP_ORDER) < 0 &&
                    s.compare(EC_GROUP_ORDER) < 0
            }

            function assumeCompression(value, pubkey) {
                if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
                if (value === undefined) return true
                return value
            }

            function fromBuffer(d) {
                return new BN(d)
            }

            function toBuffer(d) {
                return d.toArrayLike(Buffer, 'be', 32)
            }

            function decodeFrom(P) {
                return secp256k1.curve.decodePoint(P)
            }

            function getEncoded(P, compressed) {
                return Buffer.from(P._encode(compressed))
            }

            function pointAdd(pA, pB, __compressed) {
                if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
                if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)

                const a = decodeFrom(pA)
                const b = decodeFrom(pB)
                const pp = a.add(b)
                if (pp.isInfinity()) return null

                const compressed = assumeCompression(__compressed, pA)
                return getEncoded(pp, compressed)
            }

            function pointAddScalar(p, tweak, __compressed) {
                if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
                if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

                const compressed = assumeCompression(__compressed, p)
                const pp = decodeFrom(p)
                if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)

                const tt = fromBuffer(tweak)
                const qq = G.mul(tt)
                const uu = pp.add(qq)
                if (uu.isInfinity()) return null

                return getEncoded(uu, compressed)
            }

            function pointCompress(p, compressed) {
                if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)

                const pp = decodeFrom(p)
                if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)

                return getEncoded(pp, compressed)
            }

            function pointFromScalar(d, __compressed) {
                if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)

                const dd = fromBuffer(d)
                const pp = G.mul(dd)
                if (pp.isInfinity()) return null

                const compressed = assumeCompression(__compressed)
                return getEncoded(pp, compressed)
            }

            function pointMultiply(p, tweak, __compressed) {
                if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
                if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

                const compressed = assumeCompression(__compressed, p)
                const pp = decodeFrom(p)
                const tt = fromBuffer(tweak)
                const qq = pp.mul(tt)
                if (qq.isInfinity()) return null

                return getEncoded(qq, compressed)
            }

            function privateAdd(d, tweak) {
                if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
                if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

                const dd = fromBuffer(d)
                const tt = fromBuffer(tweak)
                const dt = toBuffer(dd.add(tt).umod(n))
                if (!isPrivate(dt)) return null

                return dt
            }

            function privateSub(d, tweak) {
                if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
                if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

                const dd = fromBuffer(d)
                const tt = fromBuffer(tweak)
                const dt = toBuffer(dd.sub(tt).umod(n))
                if (!isPrivate(dt)) return null

                return dt
            }

            function sign(hash, x) {
                return __sign(hash, x)
            }

            function signWithEntropy(hash, x, addData) {
                return __sign(hash, x, addData)
            }

            function __sign(hash, x, addData) {
                if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
                if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
                if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)

                const d = fromBuffer(x)
                const e = fromBuffer(hash)

                let r, s
                const checkSig = function (k) {
                    const kI = fromBuffer(k)
                    const Q = G.mul(kI)

                    if (Q.isInfinity()) return false

                    r = Q.x.umod(n)
                    if (r.isZero() === 0) return false

                    s = kI
                        .invm(n)
                        .mul(e.add(d.mul(r)))
                        .umod(n)
                    if (s.isZero() === 0) return false

                    return true
                }

                deterministicGenerateK(hash, x, checkSig, isPrivate, addData)

                // enforce low S values, see bip62: 'low s values in signatures'
                if (s.cmp(nDiv2) > 0) {
                    s = n.sub(s)
                }

                const buffer = Buffer.allocUnsafe(64)
                toBuffer(r).copy(buffer, 0)
                toBuffer(s).copy(buffer, 32)
                return buffer
            }

            function verify(hash, q, signature) {
                if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
                if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)

                // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')
                if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)

                const Q = decodeFrom(q)
                const r = fromBuffer(signature.slice(0, 32))
                const s = fromBuffer(signature.slice(32, 64))

                // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')
                if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
                if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false

                // 1.4.2 H = Hash(M), already done by the user
                // 1.4.3 e = H
                const e = fromBuffer(hash)

                // Compute s^-1
                const sInv = s.invm(n)

                // 1.4.4 Compute u1 = es^−1 mod n
                //               u2 = rs^−1 mod n
                const u1 = e.mul(sInv).umod(n)
                const u2 = r.mul(sInv).umod(n)

                // 1.4.5 Compute R = (xR, yR)
                //               R = u1G + u2Q
                const R = G.mulAdd(u1, Q, u2)

                // 1.4.5 (cont.) Enforce R is not at infinity
                if (R.isInfinity()) return false

                // 1.4.6 Convert the field element R.x to an integer
                const xR = R.x

                // 1.4.7 Set v = xR mod n
                const v = xR.umod(n)

                // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
                return v.eq(r)
            }

            module.exports = {
                isPoint,
                isPointCompressed,
                isPrivate,
                pointAdd,
                pointAddScalar,
                pointCompress,
                pointFromScalar,
                pointMultiply,
                privateAdd,
                privateSub,
                sign,
                signWithEntropy,
                verify
            }

        }).call(this, require("buffer").Buffer)

    }, {"./rfc6979": 182, "bn.js": 119, "buffer": 3, "elliptic": 129}],
    182: [function (require, module, exports) {
        (function (Buffer) {
            const createHmac = require('create-hmac')

            const ONE1 = Buffer.alloc(1, 1)
            const ZERO1 = Buffer.alloc(1, 0)

// https://tools.ietf.org/html/rfc6979#section-3.2
            function deterministicGenerateK(hash, x, checkSig, isPrivate, extraEntropy) {
                // Step A, ignored as hash already provided
                // Step B
                // Step C
                let k = Buffer.alloc(32, 0)
                let v = Buffer.alloc(32, 1)

                // Step D
                k = createHmac('sha256', k)
                    .update(v)
                    .update(ZERO1)
                    .update(x)
                    .update(hash)
                    .update(extraEntropy || '')
                    .digest()

                // Step E
                v = createHmac('sha256', k).update(v).digest()

                // Step F
                k = createHmac('sha256', k)
                    .update(v)
                    .update(ONE1)
                    .update(x)
                    .update(hash)
                    .update(extraEntropy || '')
                    .digest()

                // Step G
                v = createHmac('sha256', k).update(v).digest()

                // Step H1/H2a, ignored as tlen === qlen (256 bit)
                // Step H2b
                v = createHmac('sha256', k).update(v).digest()

                let T = v

                // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
                while (!isPrivate(T) || !checkSig(T)) {
                    k = createHmac('sha256', k)
                        .update(v)
                        .update(ZERO1)
                        .digest()

                    v = createHmac('sha256', k).update(v).digest()

                    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
                    // Step H2b again
                    v = createHmac('sha256', k).update(v).digest()
                    T = v
                }

                return T
            }

            module.exports = deterministicGenerateK

        }).call(this, require("buffer").Buffer)

    }, {"buffer": 3, "create-hmac": 127}],
    183: [function (require, module, exports) {
        var native = require('./native')

        function getTypeName(fn) {
            return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
        }

        function getValueTypeName(value) {
            return native.Nil(value) ? '' : getTypeName(value.constructor)
        }

        function getValue(value) {
            if (native.Function(value)) return ''
            if (native.String(value)) return JSON.stringify(value)
            if (value && native.Object(value)) return ''
            return value
        }

        function captureStackTrace(e, t) {
            if (Error.captureStackTrace) {
                Error.captureStackTrace(e, t)
            }
        }

        function tfJSON(type) {
            if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
            if (native.Array(type)) return 'Array'
            if (type && native.Object(type)) return 'Object'

            return type !== undefined ? type : ''
        }

        function tfErrorString(type, value, valueTypeName) {
            var valueJson = getValue(value)

            return 'Expected ' + tfJSON(type) + ', got' +
                (valueTypeName !== '' ? ' ' + valueTypeName : '') +
                (valueJson !== '' ? ' ' + valueJson : '')
        }

        function TfTypeError(type, value, valueTypeName) {
            valueTypeName = valueTypeName || getValueTypeName(value)
            this.message = tfErrorString(type, value, valueTypeName)

            captureStackTrace(this, TfTypeError)
            this.__type = type
            this.__value = value
            this.__valueTypeName = valueTypeName
        }

        TfTypeError.prototype = Object.create(Error.prototype)
        TfTypeError.prototype.constructor = TfTypeError

        function tfPropertyErrorString(type, label, name, value, valueTypeName) {
            var description = '" of type '
            if (label === 'key') description = '" with key type '

            return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
        }

        function TfPropertyTypeError(type, property, label, value, valueTypeName) {
            if (type) {
                valueTypeName = valueTypeName || getValueTypeName(value)
                this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
            } else {
                this.message = 'Unexpected property "' + property + '"'
            }

            captureStackTrace(this, TfTypeError)
            this.__label = label
            this.__property = property
            this.__type = type
            this.__value = value
            this.__valueTypeName = valueTypeName
        }

        TfPropertyTypeError.prototype = Object.create(Error.prototype)
        TfPropertyTypeError.prototype.constructor = TfTypeError

        function tfCustomError(expected, actual) {
            return new TfTypeError(expected, {}, actual)
        }

        function tfSubError(e, property, label) {
            // sub child?
            if (e instanceof TfPropertyTypeError) {
                property = property + '.' + e.__property

                e = new TfPropertyTypeError(
                    e.__type, property, e.__label, e.__value, e.__valueTypeName
                )

                // child?
            } else if (e instanceof TfTypeError) {
                e = new TfPropertyTypeError(
                    e.__type, property, label, e.__value, e.__valueTypeName
                )
            }

            captureStackTrace(e)
            return e
        }

        module.exports = {
            TfTypeError: TfTypeError,
            TfPropertyTypeError: TfPropertyTypeError,
            tfCustomError: tfCustomError,
            tfSubError: tfSubError,
            tfJSON: tfJSON,
            getValueTypeName: getValueTypeName
        }

    }, {"./native": 186}],
    184: [function (require, module, exports) {
        (function (Buffer) {
            var NATIVE = require('./native')
            var ERRORS = require('./errors')

            function _Buffer(value) {
                return Buffer.isBuffer(value)
            }

            function Hex(value) {
                return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
            }

            function _LengthN(type, length) {
                var name = type.toJSON()

                function Length(value) {
                    if (!type(value)) return false
                    if (value.length === length) return true

                    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
                }

                Length.toJSON = function () {
                    return name
                }

                return Length
            }

            var _ArrayN = _LengthN.bind(null, NATIVE.Array)
            var _BufferN = _LengthN.bind(null, _Buffer)
            var _HexN = _LengthN.bind(null, Hex)
            var _StringN = _LengthN.bind(null, NATIVE.String)

            function Range(a, b, f) {
                f = f || NATIVE.Number

                function _range(value, strict) {
                    return f(value, strict) && (value > a) && (value < b)
                }

                _range.toJSON = function () {
                    return `${f.toJSON()} between [${a}, ${b}]`
                }
                return _range
            }

            var INT53_MAX = Math.pow(2, 53) - 1

            function Finite(value) {
                return typeof value === 'number' && isFinite(value)
            }

            function Int8(value) {
                return ((value << 24) >> 24) === value
            }

            function Int16(value) {
                return ((value << 16) >> 16) === value
            }

            function Int32(value) {
                return (value | 0) === value
            }

            function Int53(value) {
                return typeof value === 'number' &&
                    value >= -INT53_MAX &&
                    value <= INT53_MAX &&
                    Math.floor(value) === value
            }

            function UInt8(value) {
                return (value & 0xff) === value
            }

            function UInt16(value) {
                return (value & 0xffff) === value
            }

            function UInt32(value) {
                return (value >>> 0) === value
            }

            function UInt53(value) {
                return typeof value === 'number' &&
                    value >= 0 &&
                    value <= INT53_MAX &&
                    Math.floor(value) === value
            }

            var types = {
                ArrayN: _ArrayN,
                Buffer: _Buffer,
                BufferN: _BufferN,
                Finite: Finite,
                Hex: Hex,
                HexN: _HexN,
                Int8: Int8,
                Int16: Int16,
                Int32: Int32,
                Int53: Int53,
                Range: Range,
                StringN: _StringN,
                UInt8: UInt8,
                UInt16: UInt16,
                UInt32: UInt32,
                UInt53: UInt53
            }

            for (var typeName in types) {
                types[typeName].toJSON = function (t) {
                    return t
                }.bind(null, typeName)
            }

            module.exports = types

        }).call(this, {"isBuffer": require("../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})

    }, {
        "../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js": 8,
        "./errors": 183,
        "./native": 186
    }],
    185: [function (require, module, exports) {
        var ERRORS = require('./errors')
        var NATIVE = require('./native')

// short-hand
        var tfJSON = ERRORS.tfJSON
        var TfTypeError = ERRORS.TfTypeError
        var TfPropertyTypeError = ERRORS.TfPropertyTypeError
        var tfSubError = ERRORS.tfSubError
        var getValueTypeName = ERRORS.getValueTypeName

        var TYPES = {
            arrayOf: function arrayOf(type, options) {
                type = compile(type)
                options = options || {}

                function _arrayOf(array, strict) {
                    if (!NATIVE.Array(array)) return false
                    if (NATIVE.Nil(array)) return false
                    if (options.minLength !== undefined && array.length < options.minLength) return false
                    if (options.maxLength !== undefined && array.length > options.maxLength) return false
                    if (options.length !== undefined && array.length !== options.length) return false

                    return array.every(function (value, i) {
                        try {
                            return typeforce(type, value, strict)
                        } catch (e) {
                            throw tfSubError(e, i)
                        }
                    })
                }

                _arrayOf.toJSON = function () {
                    var str = '[' + tfJSON(type) + ']'
                    if (options.length !== undefined) {
                        str += '{' + options.length + '}'
                    } else if (options.minLength !== undefined || options.maxLength !== undefined) {
                        str += '{' +
                            (options.minLength === undefined ? 0 : options.minLength) + ',' +
                            (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
                    }
                    return str
                }

                return _arrayOf
            },

            maybe: function maybe(type) {
                type = compile(type)

                function _maybe(value, strict) {
                    return NATIVE.Nil(value) || type(value, strict, maybe)
                }

                _maybe.toJSON = function () {
                    return '?' + tfJSON(type)
                }

                return _maybe
            },

            map: function map(propertyType, propertyKeyType) {
                propertyType = compile(propertyType)
                if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

                function _map(value, strict) {
                    if (!NATIVE.Object(value)) return false
                    if (NATIVE.Nil(value)) return false

                    for (var propertyName in value) {
                        try {
                            if (propertyKeyType) {
                                typeforce(propertyKeyType, propertyName, strict)
                            }
                        } catch (e) {
                            throw tfSubError(e, propertyName, 'key')
                        }

                        try {
                            var propertyValue = value[propertyName]
                            typeforce(propertyType, propertyValue, strict)
                        } catch (e) {
                            throw tfSubError(e, propertyName)
                        }
                    }

                    return true
                }

                if (propertyKeyType) {
                    _map.toJSON = function () {
                        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
                    }
                } else {
                    _map.toJSON = function () {
                        return '{' + tfJSON(propertyType) + '}'
                    }
                }

                return _map
            },

            object: function object(uncompiled) {
                var type = {}

                for (var typePropertyName in uncompiled) {
                    type[typePropertyName] = compile(uncompiled[typePropertyName])
                }

                function _object(value, strict) {
                    if (!NATIVE.Object(value)) return false
                    if (NATIVE.Nil(value)) return false

                    var propertyName

                    try {
                        for (propertyName in type) {
                            var propertyType = type[propertyName]
                            var propertyValue = value[propertyName]

                            typeforce(propertyType, propertyValue, strict)
                        }
                    } catch (e) {
                        throw tfSubError(e, propertyName)
                    }

                    if (strict) {
                        for (propertyName in value) {
                            if (type[propertyName]) continue

                            throw new TfPropertyTypeError(undefined, propertyName)
                        }
                    }

                    return true
                }

                _object.toJSON = function () {
                    return tfJSON(type)
                }

                return _object
            },

            anyOf: function anyOf() {
                var types = [].slice.call(arguments).map(compile)

                function _anyOf(value, strict) {
                    return types.some(function (type) {
                        try {
                            return typeforce(type, value, strict)
                        } catch (e) {
                            return false
                        }
                    })
                }

                _anyOf.toJSON = function () {
                    return types.map(tfJSON).join('|')
                }

                return _anyOf
            },

            allOf: function allOf() {
                var types = [].slice.call(arguments).map(compile)

                function _allOf(value, strict) {
                    return types.every(function (type) {
                        try {
                            return typeforce(type, value, strict)
                        } catch (e) {
                            return false
                        }
                    })
                }

                _allOf.toJSON = function () {
                    return types.map(tfJSON).join(' & ')
                }

                return _allOf
            },

            quacksLike: function quacksLike(type) {
                function _quacksLike(value) {
                    return type === getValueTypeName(value)
                }

                _quacksLike.toJSON = function () {
                    return type
                }

                return _quacksLike
            },

            tuple: function tuple() {
                var types = [].slice.call(arguments).map(compile)

                function _tuple(values, strict) {
                    if (NATIVE.Nil(values)) return false
                    if (NATIVE.Nil(values.length)) return false
                    if (strict && (values.length !== types.length)) return false

                    return types.every(function (type, i) {
                        try {
                            return typeforce(type, values[i], strict)
                        } catch (e) {
                            throw tfSubError(e, i)
                        }
                    })
                }

                _tuple.toJSON = function () {
                    return '(' + types.map(tfJSON).join(', ') + ')'
                }

                return _tuple
            },

            value: function value(expected) {
                function _value(actual) {
                    return actual === expected
                }

                _value.toJSON = function () {
                    return expected
                }

                return _value
            }
        }

// TODO: deprecate
        TYPES.oneOf = TYPES.anyOf

        function compile(type) {
            if (NATIVE.String(type)) {
                if (type[0] === '?') return TYPES.maybe(type.slice(1))

                return NATIVE[type] || TYPES.quacksLike(type)
            } else if (type && NATIVE.Object(type)) {
                if (NATIVE.Array(type)) {
                    if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
                    return TYPES.arrayOf(type[0])
                }

                return TYPES.object(type)
            } else if (NATIVE.Function(type)) {
                return type
            }

            return TYPES.value(type)
        }

        function typeforce(type, value, strict, surrogate) {
            if (NATIVE.Function(type)) {
                if (type(value, strict)) return true

                throw new TfTypeError(surrogate || type, value)
            }

            // JIT
            return typeforce(compile(type), value, strict)
        }

// assign types to typeforce function
        for (var typeName in NATIVE) {
            typeforce[typeName] = NATIVE[typeName]
        }

        for (typeName in TYPES) {
            typeforce[typeName] = TYPES[typeName]
        }

        var EXTRA = require('./extra')
        for (typeName in EXTRA) {
            typeforce[typeName] = EXTRA[typeName]
        }

        typeforce.compile = compile
        typeforce.TfTypeError = TfTypeError
        typeforce.TfPropertyTypeError = TfPropertyTypeError

        module.exports = typeforce

    }, {"./errors": 183, "./extra": 184, "./native": 186}],
    186: [function (require, module, exports) {
        var types = {
            Array: function (value) {
                return value !== null && value !== undefined && value.constructor === Array
            },
            Boolean: function (value) {
                return typeof value === 'boolean'
            },
            Function: function (value) {
                return typeof value === 'function'
            },
            Nil: function (value) {
                return value === undefined || value === null
            },
            Number: function (value) {
                return typeof value === 'number'
            },
            Object: function (value) {
                return typeof value === 'object'
            },
            String: function (value) {
                return typeof value === 'string'
            },
            '': function () {
                return true
            }
        }

// TODO: deprecate
        types.Null = types.Nil

        for (var typeName in types) {
            types[typeName].toJSON = function (t) {
                return t
            }.bind(null, typeName)
        }

        module.exports = types

    }, {}],
    187: [function (require, module, exports) {
        'use strict'
        var Buffer = require('safe-buffer').Buffer

// Number.MAX_SAFE_INTEGER
        var MAX_SAFE_INTEGER = 9007199254740991

        function checkUInt53(n) {
            if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
        }

        function encode(number, buffer, offset) {
            checkUInt53(number)

            if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
            if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
            if (!offset) offset = 0

            // 8 bit
            if (number < 0xfd) {
                buffer.writeUInt8(number, offset)
                encode.bytes = 1

                // 16 bit
            } else if (number <= 0xffff) {
                buffer.writeUInt8(0xfd, offset)
                buffer.writeUInt16LE(number, offset + 1)
                encode.bytes = 3

                // 32 bit
            } else if (number <= 0xffffffff) {
                buffer.writeUInt8(0xfe, offset)
                buffer.writeUInt32LE(number, offset + 1)
                encode.bytes = 5

                // 64 bit
            } else {
                buffer.writeUInt8(0xff, offset)
                buffer.writeUInt32LE(number >>> 0, offset + 1)
                buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
                encode.bytes = 9
            }

            return buffer
        }

        function decode(buffer, offset) {
            if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
            if (!offset) offset = 0

            var first = buffer.readUInt8(offset)

            // 8 bit
            if (first < 0xfd) {
                decode.bytes = 1
                return first

                // 16 bit
            } else if (first === 0xfd) {
                decode.bytes = 3
                return buffer.readUInt16LE(offset + 1)

                // 32 bit
            } else if (first === 0xfe) {
                decode.bytes = 5
                return buffer.readUInt32LE(offset + 1)

                // 64 bit
            } else {
                decode.bytes = 9
                var lo = buffer.readUInt32LE(offset + 1)
                var hi = buffer.readUInt32LE(offset + 5)
                var number = hi * 0x0100000000 + lo
                checkUInt53(number)

                return number
            }
        }

        function encodingLength(number) {
            checkUInt53(number)

            return (
                number < 0xfd ? 1
                    : number <= 0xffff ? 3
                    : number <= 0xffffffff ? 5
                        : 9
            )
        }

        module.exports = {encode: encode, decode: decode, encodingLength: encodingLength}

    }, {"safe-buffer": 172}],
    188: [function (require, module, exports) {
        (function (Buffer) {
            var bs58check = require('bs58check')

            function decodeRaw(buffer, version) {
                // check version only if defined
                if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

                // uncompressed
                if (buffer.length === 33) {
                    return {
                        version: buffer[0],
                        privateKey: buffer.slice(1, 33),
                        compressed: false
                    }
                }

                // invalid length
                if (buffer.length !== 34) throw new Error('Invalid WIF length')

                // invalid compression flag
                if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

                return {
                    version: buffer[0],
                    privateKey: buffer.slice(1, 33),
                    compressed: true
                }
            }

            function encodeRaw(version, privateKey, compressed) {
                var result = new Buffer(compressed ? 34 : 33)

                result.writeUInt8(version, 0)
                privateKey.copy(result, 1)

                if (compressed) {
                    result[33] = 0x01
                }

                return result
            }

            function decode(string, version) {
                return decodeRaw(bs58check.decode(string), version)
            }

            function encode(version, privateKey, compressed) {
                if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

                return bs58check.encode(
                    encodeRaw(
                        version.version,
                        version.privateKey,
                        version.compressed
                    )
                )
            }

            module.exports = {
                decode: decode,
                decodeRaw: decodeRaw,
                encode: encode,
                encodeRaw: encodeRaw
            }

        }).call(this, require("buffer").Buffer)

    }, {"bs58check": 123, "buffer": 3}]
}, {}, [32])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JlY2gzMi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb21iaW5lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvZ2xvYmFsL2dsb2JhbFhwdWIuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2dsb2JhbC91bnNpZ25lZFR4LmpzIiwibm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvZmluYWxTY3JpcHRTaWcuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0V2l0bmVzcy5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvbm9uV2l0bmVzc1V0eG8uanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3BhcnRpYWxTaWcuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3BvckNvbW1pdG1lbnQuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3NpZ2hhc2hUeXBlLmpzIiwibm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC93aXRuZXNzVXR4by5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvc2hhcmVkL2JpcDMyRGVyaXZhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvc2hhcmVkL2NoZWNrUHVia2V5LmpzIiwibm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9zaGFyZWQvcmVkZWVtU2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9zaGFyZWQvd2l0bmVzc1NjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdG9vbHMuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3ZhcmludC5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9wYXJzZXIvZnJvbUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL3RvQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL3BzYnQuanMiLCJub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvdHlwZUZpZWxkcy5qcyIsIm5vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9iaXAzMi9zcmMvYmlwMzIuanMiLCJub2RlX21vZHVsZXMvYmlwMzIvc3JjL2NyeXB0by5qcyIsIm5vZGVfbW9kdWxlcy9iaXAzMi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL193b3JkbGlzdHMuanMiLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvY2hpbmVzZV9zaW1wbGlmaWVkLmpzb24iLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9jaGluZXNlX3RyYWRpdGlvbmFsLmpzb24iLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9lbmdsaXNoLmpzb24iLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9mcmVuY2guanNvbiIsIm5vZGVfbW9kdWxlcy9iaXAzOS9zcmMvd29yZGxpc3RzL2l0YWxpYW4uanNvbiIsIm5vZGVfbW9kdWxlcy9iaXAzOS9zcmMvd29yZGxpc3RzL2phcGFuZXNlLmpzb24iLCJub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9rb3JlYW4uanNvbiIsIm5vZGVfbW9kdWxlcy9iaXAzOS9zcmMvd29yZGxpc3RzL3NwYW5pc2guanNvbiIsIm5vZGVfbW9kdWxlcy9iaXA2Ni9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luLW9wcy9pbmRleC5qc29uIiwibm9kZV9tb2R1bGVzL2JpdGNvaW4tb3BzL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2Jsb2NrLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2J1ZmZlcnV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2NsYXNzaWZ5LmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2NyeXB0by5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9lY3BhaXIuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbmV0d29ya3MuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvZW1iZWQuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvbGF6eS5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMm1zLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3AycGsuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJwa2guanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJzaC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMndwa2guanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3c2guanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHQuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0X251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RlbXBsYXRlcy9tdWx0aXNpZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvbXVsdGlzaWcvaW5wdXQuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdGVtcGxhdGVzL211bHRpc2lnL291dHB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvbnVsbGRhdGEuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdGVtcGxhdGVzL3B1YmtleS9pbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvcHVia2V5L291dHB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvcHVia2V5aGFzaC9pbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvcHVia2V5aGFzaC9vdXRwdXQuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdGVtcGxhdGVzL3NjcmlwdGhhc2gvaW5wdXQuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdGVtcGxhdGVzL3NjcmlwdGhhc2gvb3V0cHV0LmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RlbXBsYXRlcy93aXRuZXNzY29tbWl0bWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvd2l0bmVzc2NvbW1pdG1lbnQvb3V0cHV0LmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RlbXBsYXRlcy93aXRuZXNzcHVia2V5aGFzaC9pbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvd2l0bmVzc3B1YmtleWhhc2gvb3V0cHV0LmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RlbXBsYXRlcy93aXRuZXNzc2NyaXB0aGFzaC9pbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90ZW1wbGF0ZXMvd2l0bmVzc3NjcmlwdGhhc2gvb3V0cHV0LmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RyYW5zYWN0aW9uX2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iczU4Y2hlY2svYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9iczU4Y2hlY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9tZDUuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvc2hvcnQuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Eva2V5LmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzIyNC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yNTYuanMiLCJub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzUxMi5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS9jb21tb24uanMiLCJub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9obWFjLWRyYmcvbGliL2htYWMtZHJiZy5qcyIsIm5vZGVfbW9kdWxlcy9tZDUuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVya2xlLWxpYi9mYXN0Um9vdC5qcyIsIm5vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3Bia2RmMi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9kZWZhdWx0LWVuY29kaW5nLmpzIiwibm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvcHJlY29uZGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvc3luYy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1c2hkYXRhLWJpdGNvaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBlbWQxNjAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy90aW55LXNlY3AyNTZrMS9qcy5qcyIsIm5vZGVfbW9kdWxlcy90aW55LXNlY3AyNTZrMS9yZmM2OTc5LmpzIiwibm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvdHlwZWZvcmNlL2V4dHJhLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZm9yY2UvbmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3ZhcnVpbnQtYml0Y29pbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93aWYvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN3dEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ppQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcclxubGV0IGJpdGNvaW49cmVxdWlyZSgnYml0Y29pbmpzLWxpYicpXHJcbmxldCBiaXAzOT1yZXF1aXJlKCdiaXAzOScpXHJcblxyXG4gICAgIFxyXG4gICAgd2luZG93LmdldEFkZHJlc3M9IGZ1bmN0aW9uKHVzZXJBY2NvdW50KXtcclxuICAgICAgY29uc3Qgc2VlZCA9IGJpcDM5Lm1uZW1vbmljVG9TZWVkKHVzZXJBY2NvdW50KVxyXG4gICAgICBsZXQgcmVzdWx0PXt9XHJcbiAgICAgICAgcmV0dXJuIHNlZWQudGhlbihzZWVkPT57XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGJpdGNvaW5OZXR3b3JrID0gYml0Y29pbi5uZXR3b3Jrcy50ZXN0bmV0XHJcbiAgICAgICAgICBjb25zdCBoZE1hc3RlciA9IGJpdGNvaW4uYmlwMzIuZnJvbVNlZWQoc2VlZCwgYml0Y29pbk5ldHdvcmspIC8vIHNlZWQgZnJvbSBhYm92ZVxyXG4gICAgICAgICAgY29uc3Qga2V5UGFpciA9IGhkTWFzdGVyLmRlcml2ZVBhdGgoJ20vMCcpXHJcbiAgICAgICAgICAvLyB0cnkgdG8gZ2V0IHByaXZhdGUga2V5IGFzIHJlYWRhYmxlIHN0cmluZ1xyXG4gICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGtleVBhaXIucHJpdmF0ZUtleSlcclxuICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcml2YXRlS2V5QnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxyXG4gICAgICAgICAgcmVzdWx0LnByaXZhdGVLZXk9cHJpdmF0ZUtleTtcclxuICAgICAgICAgIHJlc3VsdC5wdWJsaWNLZXk9a2V5UGFpci5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpOyAgICAgIFxyXG4gICAgICAgICAgLy8gZmFpbCB0byBnZXQgcHJpdmF0ZSBrZXkgYXMgcmVhZGFibGUgc3RyaW5nXHJcbiAgICAgICAgICBjb25zdCB7IGFkZHJlc3MgfSA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goeyBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5IH0pXHJcbiAgICAgICAgICByZXN1bHQuYWRkcmVzcz1hZGRyZXNzO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICBcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5nZW5lcmF0ZU11bHRpQWRkciA9IGZ1bmN0aW9uKHB1YmxpY0tleTEscHVibGljS2V5MixuZXR3b3JrVHlwZSl7XHJcbiAgICAgICAgY29uc3QgcHVia2V5cyA9IFtwdWJsaWNLZXkxLHB1YmxpY0tleTJdLm1hcChoZXggPT4gQnVmZmVyLmZyb20oaGV4LCdoZXgnKSk7XHJcbiAgICAgICBpZihuZXR3b3JrVHlwZSA9PSBcInRlc3QzXCIpe1xyXG4gICAgICAgIGNvbnN0IHthZGRyZXNzfSA9IGJpdGNvaW4ucGF5bWVudHMucDJzaCh7XHJcbiAgICAgICAgICAgIHJlZGVlbTogYml0Y29pbi5wYXltZW50cy5wMndzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZWRlZW06IGJpdGNvaW4ucGF5bWVudHMucDJtcyh7bToyLHB1YmtleXMsbmV0d29yazpiaXRjb2luLm5ldHdvcmtzLnRlc3RuZXR9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xyXG4gICAgICAgfVxyXG4gICAgICAgZWxzZXtcclxuICAgICAgICBjb25zdCB7YWRkcmVzc30gPSBiaXRjb2luLnBheW1lbnRzLnAyc2goe1xyXG4gICAgICAgICAgICByZWRlZW06IGJpdGNvaW4ucGF5bWVudHMucDJ3c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVkZWVtOiBiaXRjb2luLnBheW1lbnRzLnAybXMoe206MixwdWJrZXlzfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYWRkcmVzcztcclxuICAgICAgIH1cclxuICAgICAgIFxyXG4gICAgfVxyXG4gICAgICIsIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgbGVhZGluZyBzcGFjZXMuXG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIHRyYWlsaW5nIHNwYWNlcy5cbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykgeyByZXR1cm4gfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IF9CdWZmZXIuYWxsb2NVbnNhZmUoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZjaC5maWxsKDB4MDAsIDAsIHplcm9lcylcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJ1xuXG4vLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbnZhciBBTFBIQUJFVF9NQVAgPSB7fVxuZm9yICh2YXIgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdCh6KVxuXG4gIGlmIChBTFBIQUJFVF9NQVBbeF0gIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKVxuICBBTFBIQUJFVF9NQVBbeF0gPSB6XG59XG5cbmZ1bmN0aW9uIHBvbHltb2RTdGVwIChwcmUpIHtcbiAgdmFyIGIgPSBwcmUgPj4gMjVcbiAgcmV0dXJuICgocHJlICYgMHgxRkZGRkZGKSA8PCA1KSBeXG4gICAgKC0oKGIgPj4gMCkgJiAxKSAmIDB4M2I2YTU3YjIpIF5cbiAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgKC0oKGIgPj4gMykgJiAxKSAmIDB4M2Q0MjMzZGQpIF5cbiAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMylcbn1cblxuZnVuY3Rpb24gcHJlZml4Q2hrIChwcmVmaXgpIHtcbiAgdmFyIGNoayA9IDFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknKVxuXG4gICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpXG4gIH1cbiAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdiA9IHByZWZpeC5jaGFyQ29kZUF0KGkpXG4gICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeICh2ICYgMHgxZilcbiAgfVxuICByZXR1cm4gY2hrXG59XG5cbmZ1bmN0aW9uIGVuY29kZSAocHJlZml4LCB3b3JkcywgTElNSVQpIHtcbiAgTElNSVQgPSBMSU1JVCB8fCA5MFxuICBpZiAoKHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoKSA+IExJTUlUKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNlZWRzIGxlbmd0aCBsaW1pdCcpXG5cbiAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKClcblxuICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuICB2YXIgY2hrID0gcHJlZml4Q2hrKHByZWZpeClcbiAgdmFyIHJlc3VsdCA9IHByZWZpeCArICcxJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHggPSB3b3Jkc1tpXVxuICAgIGlmICgoeCA+PiA1KSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpXG5cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4geFxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQoeClcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspXG4gIH1cbiAgY2hrIF49IDFcblxuICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgdmFyIHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZlxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChzdHIsIExJTUlUKSB7XG4gIExJTUlUID0gTElNSVQgfHwgOTBcbiAgaWYgKHN0ci5sZW5ndGggPCA4KSB0aHJvdyBuZXcgVHlwZUVycm9yKHN0ciArICcgdG9vIHNob3J0JylcbiAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVCkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKVxuXG4gIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgdmFyIGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKVxuICB2YXIgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpXG4gIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKSB0aHJvdyBuZXcgRXJyb3IoJ01peGVkLWNhc2Ugc3RyaW5nICcgKyBzdHIpXG4gIHN0ciA9IGxvd2VyZWRcblxuICB2YXIgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKVxuICBpZiAoc3BsaXQgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yICcgKyBzdHIpXG4gIGlmIChzcGxpdCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0cilcblxuICB2YXIgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KVxuICB2YXIgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSlcbiAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgdG9vIHNob3J0JylcblxuICB2YXIgY2hrID0gcHJlZml4Q2hrKHByZWZpeClcbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHdvcmRDaGFycy5jaGFyQXQoaSlcbiAgICB2YXIgdiA9IEFMUEhBQkVUX01BUFtjXVxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyYWN0ZXIgJyArIGMpXG4gICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHZcblxuICAgIC8vIG5vdCBpbiB0aGUgY2hlY2tzdW0/XG4gICAgaWYgKGkgKyA2ID49IHdvcmRDaGFycy5sZW5ndGgpIGNvbnRpbnVlXG4gICAgd29yZHMucHVzaCh2KVxuICB9XG5cbiAgaWYgKGNoayAhPT0gMSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtIGZvciAnICsgc3RyKVxuICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgd29yZHM6IHdvcmRzIH1cbn1cblxuZnVuY3Rpb24gY29udmVydCAoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcbiAgdmFyIHZhbHVlID0gMFxuICB2YXIgYml0cyA9IDBcbiAgdmFyIG1heFYgPSAoMSA8PCBvdXRCaXRzKSAtIDFcblxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPDwgaW5CaXRzKSB8IGRhdGFbaV1cbiAgICBiaXRzICs9IGluQml0c1xuXG4gICAgd2hpbGUgKGJpdHMgPj0gb3V0Qml0cykge1xuICAgICAgYml0cyAtPSBvdXRCaXRzXG4gICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYWQpIHtcbiAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChiaXRzID49IGluQml0cykgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpXG4gICAgaWYgKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gcGFkZGluZycpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvV29yZHMgKGJ5dGVzKSB7XG4gIHJldHVybiBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKVxufVxuXG5mdW5jdGlvbiBmcm9tV29yZHMgKHdvcmRzKSB7XG4gIHJldHVybiBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGU6IGVuY29kZSxcbiAgdG9Xb3JkczogdG9Xb3JkcyxcbiAgZnJvbVdvcmRzOiBmcm9tV29yZHNcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXJzZXJfMSA9IHJlcXVpcmUoJy4uL3BhcnNlcicpO1xuZnVuY3Rpb24gY29tYmluZShwc2J0cykge1xuICBjb25zdCBzZWxmID0gcHNidHNbMF07XG4gIGNvbnN0IHNlbGZLZXlWYWxzID0gcGFyc2VyXzEucHNidFRvS2V5VmFscyhzZWxmKTtcbiAgY29uc3Qgb3RoZXJzID0gcHNidHMuc2xpY2UoMSk7XG4gIGlmIChvdGhlcnMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmU6IE5vdGhpbmcgdG8gY29tYmluZScpO1xuICBjb25zdCBzZWxmVHggPSBnZXRUeChzZWxmKTtcbiAgaWYgKHNlbGZUeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBTZWxmIG1pc3NpbmcgdHJhbnNhY3Rpb24nKTtcbiAgfVxuICBjb25zdCBzZWxmR2xvYmFsU2V0ID0gZ2V0S2V5U2V0KHNlbGZLZXlWYWxzLmdsb2JhbEtleVZhbHMpO1xuICBjb25zdCBzZWxmSW5wdXRTZXRzID0gc2VsZktleVZhbHMuaW5wdXRLZXlWYWxzLm1hcChnZXRLZXlTZXQpO1xuICBjb25zdCBzZWxmT3V0cHV0U2V0cyA9IHNlbGZLZXlWYWxzLm91dHB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XG4gICAgY29uc3Qgb3RoZXJUeCA9IGdldFR4KG90aGVyKTtcbiAgICBpZiAoXG4gICAgICBvdGhlclR4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICFvdGhlclR4LnRvQnVmZmVyKCkuZXF1YWxzKHNlbGZUeC50b0J1ZmZlcigpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ29tYmluZTogT25lIG9mIHRoZSBQc2J0cyBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIHRyYW5zYWN0aW9uLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvdGhlcktleVZhbHMgPSBwYXJzZXJfMS5wc2J0VG9LZXlWYWxzKG90aGVyKTtcbiAgICBjb25zdCBvdGhlckdsb2JhbFNldCA9IGdldEtleVNldChvdGhlcktleVZhbHMuZ2xvYmFsS2V5VmFscyk7XG4gICAgb3RoZXJHbG9iYWxTZXQuZm9yRWFjaChcbiAgICAgIGtleVB1c2hlcihcbiAgICAgICAgc2VsZkdsb2JhbFNldCxcbiAgICAgICAgc2VsZktleVZhbHMuZ2xvYmFsS2V5VmFscyxcbiAgICAgICAgb3RoZXJLZXlWYWxzLmdsb2JhbEtleVZhbHMsXG4gICAgICApLFxuICAgICk7XG4gICAgY29uc3Qgb3RoZXJJbnB1dFNldHMgPSBvdGhlcktleVZhbHMuaW5wdXRLZXlWYWxzLm1hcChnZXRLZXlTZXQpO1xuICAgIG90aGVySW5wdXRTZXRzLmZvckVhY2goKGlucHV0U2V0LCBpZHgpID0+XG4gICAgICBpbnB1dFNldC5mb3JFYWNoKFxuICAgICAgICBrZXlQdXNoZXIoXG4gICAgICAgICAgc2VsZklucHV0U2V0c1tpZHhdLFxuICAgICAgICAgIHNlbGZLZXlWYWxzLmlucHV0S2V5VmFsc1tpZHhdLFxuICAgICAgICAgIG90aGVyS2V5VmFscy5pbnB1dEtleVZhbHNbaWR4XSxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgKTtcbiAgICBjb25zdCBvdGhlck91dHB1dFNldHMgPSBvdGhlcktleVZhbHMub3V0cHV0S2V5VmFscy5tYXAoZ2V0S2V5U2V0KTtcbiAgICBvdGhlck91dHB1dFNldHMuZm9yRWFjaCgob3V0cHV0U2V0LCBpZHgpID0+XG4gICAgICBvdXRwdXRTZXQuZm9yRWFjaChcbiAgICAgICAga2V5UHVzaGVyKFxuICAgICAgICAgIHNlbGZPdXRwdXRTZXRzW2lkeF0sXG4gICAgICAgICAgc2VsZktleVZhbHMub3V0cHV0S2V5VmFsc1tpZHhdLFxuICAgICAgICAgIG90aGVyS2V5VmFscy5vdXRwdXRLZXlWYWxzW2lkeF0sXG4gICAgICAgICksXG4gICAgICApLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcl8xLnBzYnRGcm9tS2V5VmFscyhzZWxmVHgsIHtcbiAgICBnbG9iYWxNYXBLZXlWYWxzOiBzZWxmS2V5VmFscy5nbG9iYWxLZXlWYWxzLFxuICAgIGlucHV0S2V5VmFsczogc2VsZktleVZhbHMuaW5wdXRLZXlWYWxzLFxuICAgIG91dHB1dEtleVZhbHM6IHNlbGZLZXlWYWxzLm91dHB1dEtleVZhbHMsXG4gIH0pO1xufVxuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTtcbmZ1bmN0aW9uIGtleVB1c2hlcihzZWxmU2V0LCBzZWxmS2V5VmFscywgb3RoZXJLZXlWYWxzKSB7XG4gIHJldHVybiBrZXkgPT4ge1xuICAgIGlmIChzZWxmU2V0LmhhcyhrZXkpKSByZXR1cm47XG4gICAgY29uc3QgbmV3S3YgPSBvdGhlcktleVZhbHMuZmlsdGVyKGt2ID0+IGt2LmtleS50b1N0cmluZygnaGV4JykgPT09IGtleSlbMF07XG4gICAgc2VsZktleVZhbHMucHVzaChuZXdLdik7XG4gICAgc2VsZlNldC5hZGQoa2V5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFR4KHBzYnQpIHtcbiAgcmV0dXJuIHBzYnQuZ2xvYmFsTWFwLnVuc2lnbmVkVHg7XG59XG5mdW5jdGlvbiBnZXRLZXlTZXQoa2V5VmFscykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGtleVZhbHMuZm9yRWFjaChrZXlWYWwgPT4ge1xuICAgIGNvbnN0IGhleCA9IGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChzZXQuaGFzKGhleCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmU6IEtleVZhbHVlIE1hcCBrZXlzIHNob3VsZCBiZSB1bmlxdWUnKTtcbiAgICBzZXQuYWRkKGhleCk7XG4gIH0pO1xuICByZXR1cm4gc2V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmNvbnN0IHJhbmdlID0gbiA9PiBbLi4uQXJyYXkobikua2V5cygpXTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5HTE9CQUxfWFBVQikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgZ2xvYmFsWHB1YiB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmIChrZXlWYWwua2V5Lmxlbmd0aCAhPT0gNzkgfHwgIVsyLCAzXS5pbmNsdWRlcyhrZXlWYWwua2V5WzQ2XSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBnbG9iYWxYcHViIGhhcyBpbnZhbGlkIGV4dGVuZGVkIHB1YmtleSBpbiBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoKGtleVZhbC52YWx1ZS5sZW5ndGggLyA0KSAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBHbG9iYWwgR0xPQkFMX1hQVUIgdmFsdWUgbGVuZ3RoIHNob3VsZCBiZSBtdWx0aXBsZSBvZiA0JyxcbiAgICApO1xuICB9XG4gIGNvbnN0IGV4dGVuZGVkUHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBtYXN0ZXJGaW5nZXJwcmludDoga2V5VmFsLnZhbHVlLnNsaWNlKDAsIDQpLFxuICAgIGV4dGVuZGVkUHVia2V5LFxuICAgIHBhdGg6ICdtJyxcbiAgfTtcbiAgZm9yIChjb25zdCBpIG9mIHJhbmdlKGtleVZhbC52YWx1ZS5sZW5ndGggLyA0IC0gMSkpIHtcbiAgICBjb25zdCB2YWwgPSBrZXlWYWwudmFsdWUucmVhZFVJbnQzMkxFKGkgKiA0ICsgNCk7XG4gICAgY29uc3QgaXNIYXJkID0gISEodmFsICYgMHg4MDAwMDAwMCk7XG4gICAgY29uc3QgaWR4ID0gdmFsICYgMHg3ZmZmZmZmZjtcbiAgICBkYXRhLnBhdGggKz0gJy8nICsgaWR4LnRvU3RyaW5nKDEwKSArIChpc0hhcmQgPyBcIidcIiA6ICcnKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuR0xPQkFMX1hQVUJdKTtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmNvbmNhdChbaGVhZCwgZGF0YS5leHRlbmRlZFB1YmtleV0pO1xuICBjb25zdCBzcGxpdFBhdGggPSBkYXRhLnBhdGguc3BsaXQoJy8nKTtcbiAgY29uc3QgdmFsdWUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc3BsaXRQYXRoLmxlbmd0aCAqIDQpO1xuICBkYXRhLm1hc3RlckZpbmdlcnByaW50LmNvcHkodmFsdWUsIDApO1xuICBsZXQgb2Zmc2V0ID0gNDtcbiAgc3BsaXRQYXRoLnNsaWNlKDEpLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgIGNvbnN0IGlzSGFyZCA9IGxldmVsLnNsaWNlKC0xKSA9PT0gXCInXCI7XG4gICAgbGV0IG51bSA9IDB4N2ZmZmZmZmYgJiBwYXJzZUludChpc0hhcmQgPyBsZXZlbC5zbGljZSgwLCAtMSkgOiBsZXZlbCwgMTApO1xuICAgIGlmIChpc0hhcmQpIG51bSArPSAweDgwMDAwMDAwO1xuICAgIHZhbHVlLndyaXRlVUludDMyTEUobnVtLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPVxuICAneyBtYXN0ZXJGaW5nZXJwcmludDogQnVmZmVyOyBleHRlbmRlZFB1YmtleTogQnVmZmVyOyBwYXRoOiBzdHJpbmc7IH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICBjb25zdCBlcGsgPSBkYXRhLmV4dGVuZGVkUHVia2V5O1xuICBjb25zdCBtZnAgPSBkYXRhLm1hc3RlckZpbmdlcnByaW50O1xuICBjb25zdCBwID0gZGF0YS5wYXRoO1xuICByZXR1cm4gKFxuICAgIEJ1ZmZlci5pc0J1ZmZlcihlcGspICYmXG4gICAgZXBrLmxlbmd0aCA9PT0gNzggJiZcbiAgICBbMiwgM10uaW5kZXhPZihlcGtbNDVdKSA+IC0xICYmXG4gICAgQnVmZmVyLmlzQnVmZmVyKG1mcCkgJiZcbiAgICBtZnAubGVuZ3RoID09PSA0ICYmXG4gICAgdHlwZW9mIHAgPT09ICdzdHJpbmcnICYmXG4gICAgISFwLm1hdGNoKC9ebShcXC9cXGQrJz8pKyQvKVxuICApO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkVG9BcnJheShhcnJheSwgaXRlbSwgZHVwZVNldCkge1xuICBjb25zdCBkdXBlU3RyaW5nID0gaXRlbS5leHRlbmRlZFB1YmtleS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgcmV0dXJuIChcbiAgICBhcnJheS5maWx0ZXIodiA9PiB2LmV4dGVuZGVkUHVia2V5LmVxdWFscyhpdGVtLmV4dGVuZGVkUHVia2V5KSkubGVuZ3RoID09PSAwXG4gICk7XG59XG5leHBvcnRzLmNhbkFkZFRvQXJyYXkgPSBjYW5BZGRUb0FycmF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIHJldHVybiB7XG4gICAga2V5OiBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLlVOU0lHTkVEX1RYXSksXG4gICAgdmFsdWU6IGRhdGEudG9CdWZmZXIoKSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uL3R5cGVGaWVsZHMnKTtcbmNvbnN0IGdsb2JhbFhwdWIgPSByZXF1aXJlKCcuL2dsb2JhbC9nbG9iYWxYcHViJyk7XG5jb25zdCB1bnNpZ25lZFR4ID0gcmVxdWlyZSgnLi9nbG9iYWwvdW5zaWduZWRUeCcpO1xuY29uc3QgZmluYWxTY3JpcHRTaWcgPSByZXF1aXJlKCcuL2lucHV0L2ZpbmFsU2NyaXB0U2lnJyk7XG5jb25zdCBmaW5hbFNjcmlwdFdpdG5lc3MgPSByZXF1aXJlKCcuL2lucHV0L2ZpbmFsU2NyaXB0V2l0bmVzcycpO1xuY29uc3Qgbm9uV2l0bmVzc1V0eG8gPSByZXF1aXJlKCcuL2lucHV0L25vbldpdG5lc3NVdHhvJyk7XG5jb25zdCBwYXJ0aWFsU2lnID0gcmVxdWlyZSgnLi9pbnB1dC9wYXJ0aWFsU2lnJyk7XG5jb25zdCBwb3JDb21taXRtZW50ID0gcmVxdWlyZSgnLi9pbnB1dC9wb3JDb21taXRtZW50Jyk7XG5jb25zdCBzaWdoYXNoVHlwZSA9IHJlcXVpcmUoJy4vaW5wdXQvc2lnaGFzaFR5cGUnKTtcbmNvbnN0IHdpdG5lc3NVdHhvID0gcmVxdWlyZSgnLi9pbnB1dC93aXRuZXNzVXR4bycpO1xuY29uc3QgYmlwMzJEZXJpdmF0aW9uID0gcmVxdWlyZSgnLi9zaGFyZWQvYmlwMzJEZXJpdmF0aW9uJyk7XG5jb25zdCBjaGVja1B1YmtleSA9IHJlcXVpcmUoJy4vc2hhcmVkL2NoZWNrUHVia2V5Jyk7XG5jb25zdCByZWRlZW1TY3JpcHQgPSByZXF1aXJlKCcuL3NoYXJlZC9yZWRlZW1TY3JpcHQnKTtcbmNvbnN0IHdpdG5lc3NTY3JpcHQgPSByZXF1aXJlKCcuL3NoYXJlZC93aXRuZXNzU2NyaXB0Jyk7XG5jb25zdCBnbG9iYWxzID0ge1xuICB1bnNpZ25lZFR4LFxuICBnbG9iYWxYcHViLFxuICAvLyBwYXNzIGFuIEFycmF5IG9mIGtleSBieXRlcyB0aGF0IHJlcXVpcmUgcHVia2V5IGJlc2lkZSB0aGUga2V5XG4gIGNoZWNrUHVia2V5OiBjaGVja1B1YmtleS5tYWtlQ2hlY2tlcihbXSksXG59O1xuZXhwb3J0cy5nbG9iYWxzID0gZ2xvYmFscztcbmNvbnN0IGlucHV0cyA9IHtcbiAgbm9uV2l0bmVzc1V0eG8sXG4gIHBhcnRpYWxTaWcsXG4gIHNpZ2hhc2hUeXBlLFxuICBmaW5hbFNjcmlwdFNpZyxcbiAgZmluYWxTY3JpcHRXaXRuZXNzLFxuICBwb3JDb21taXRtZW50LFxuICB3aXRuZXNzVXR4byxcbiAgYmlwMzJEZXJpdmF0aW9uOiBiaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICApLFxuICByZWRlZW1TY3JpcHQ6IHJlZGVlbVNjcmlwdC5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICksXG4gIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1NDUklQVCxcbiAgKSxcbiAgY2hlY2tQdWJrZXk6IGNoZWNrUHVia2V5Lm1ha2VDaGVja2VyKFtcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRyxcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICBdKSxcbn07XG5leHBvcnRzLmlucHV0cyA9IGlucHV0cztcbmNvbnN0IG91dHB1dHMgPSB7XG4gIGJpcDMyRGVyaXZhdGlvbjogYmlwMzJEZXJpdmF0aW9uLm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gICksXG4gIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICksXG4gIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQsXG4gICksXG4gIGNoZWNrUHVia2V5OiBjaGVja1B1YmtleS5tYWtlQ2hlY2tlcihbXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gIF0pLFxufTtcbmV4cG9ydHMub3V0cHV0cyA9IG91dHB1dHM7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBmaW5hbFNjcmlwdFNpZyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUddKTtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgdmFsdWU6IGRhdGEsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEuZmluYWxTY3JpcHRTaWcgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGZpbmFsU2NyaXB0V2l0bmVzcyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRXSVRORVNTXSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBkYXRhLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuIChcbiAgICAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5maW5hbFNjcmlwdFdpdG5lc3MgPT09IHVuZGVmaW5lZFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgbm9uV2l0bmVzc1V0eG8gd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE9dKSxcbiAgICB2YWx1ZTogZGF0YSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdCdWZmZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAoXG4gICAgISFjdXJyZW50RGF0YSAmJlxuICAgICEhbmV3RGF0YSAmJlxuICAgIGN1cnJlbnREYXRhLndpdG5lc3NVdHhvID09PSB1bmRlZmluZWQgJiZcbiAgICBjdXJyZW50RGF0YS5ub25XaXRuZXNzVXR4byA9PT0gdW5kZWZpbmVkXG4gICk7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgcGFydGlhbFNpZyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICAhKGtleVZhbC5rZXkubGVuZ3RoID09PSAzNCB8fCBrZXlWYWwua2V5Lmxlbmd0aCA9PT0gNjYpIHx8XG4gICAgIVsyLCAzLCA0XS5pbmNsdWRlcyhrZXlWYWwua2V5WzFdKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBwYXJ0aWFsU2lnIGhhcyBpbnZhbGlkIHB1YmtleSBpbiBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBjb25zdCBwdWJrZXkgPSBrZXlWYWwua2V5LnNsaWNlKDEpO1xuICByZXR1cm4ge1xuICAgIHB1YmtleSxcbiAgICBzaWduYXR1cmU6IGtleVZhbC52YWx1ZSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHBTaWcpIHtcbiAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJR10pO1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmNvbmNhdChbaGVhZCwgcFNpZy5wdWJrZXldKSxcbiAgICB2YWx1ZTogcFNpZy5zaWduYXR1cmUsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBwdWJrZXk6IEJ1ZmZlcjsgc2lnbmF0dXJlOiBCdWZmZXI7IH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gKFxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnB1YmtleSkgJiZcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5zaWduYXR1cmUpICYmXG4gICAgWzMzLCA2NV0uaW5jbHVkZXMoZGF0YS5wdWJrZXkubGVuZ3RoKSAmJlxuICAgIFsyLCAzLCA0XS5pbmNsdWRlcyhkYXRhLnB1YmtleVswXSkgJiZcbiAgICBpc0RlclNpZ1dpdGhTaWdoYXNoKGRhdGEuc2lnbmF0dXJlKVxuICApO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gaXNEZXJTaWdXaXRoU2lnaGFzaChidWYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSB8fCBidWYubGVuZ3RoIDwgOSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmWzBdICE9PSAweDMwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWYubGVuZ3RoICE9PSBidWZbMV0gKyAzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZbMl0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgckxlbiA9IGJ1ZlszXTtcbiAgaWYgKHJMZW4gPiAzMyB8fCByTGVuIDwgMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmWzMgKyByTGVuICsgMV0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc0xlbiA9IGJ1ZlszICsgckxlbiArIDJdO1xuICBpZiAoc0xlbiA+IDMzIHx8IHNMZW4gPCAxKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWYubGVuZ3RoICE9PSAzICsgckxlbiArIDIgKyBzTGVuICsgMikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0ucHVia2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgaWYgKGR1cGVTZXQuaGFzKGR1cGVTdHJpbmcpKSByZXR1cm4gZmFsc2U7XG4gIGR1cGVTZXQuYWRkKGR1cGVTdHJpbmcpO1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wdWJrZXkuZXF1YWxzKGl0ZW0ucHVia2V5KSkubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5jYW5BZGRUb0FycmF5ID0gY2FuQWRkVG9BcnJheTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QT1JfQ09NTUlUTUVOVCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgcG9yQ29tbWl0bWVudCB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBPUl9DT01NSVRNRU5UXSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ3N0cmluZyc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnBvckNvbW1pdG1lbnQgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgc2lnaGFzaFR5cGUgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRSgwKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRV0pO1xuICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgdmFsdWUud3JpdGVVSW50MzJMRShkYXRhLCAwKTtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnbnVtYmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEuc2lnaGFzaFR5cGUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmNvbnN0IHRvb2xzXzEgPSByZXF1aXJlKCcuLi90b29scycpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL3ZhcmludCcpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB3aXRuZXNzVXR4byB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gdG9vbHNfMS5yZWFkVUludDY0TEUoa2V5VmFsLnZhbHVlLCAwKTtcbiAgbGV0IF9vZmZzZXQgPSA4O1xuICBjb25zdCBzY3JpcHRMZW4gPSB2YXJ1aW50LmRlY29kZShrZXlWYWwudmFsdWUsIF9vZmZzZXQpO1xuICBfb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoc2NyaXB0TGVuKTtcbiAgY29uc3Qgc2NyaXB0ID0ga2V5VmFsLnZhbHVlLnNsaWNlKF9vZmZzZXQpO1xuICBpZiAoc2NyaXB0Lmxlbmd0aCAhPT0gc2NyaXB0TGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IFdJVE5FU1NfVVRYTyBzY3JpcHQgaXMgbm90IHByb3BlciBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcmlwdCxcbiAgICB2YWx1ZSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgeyBzY3JpcHQsIHZhbHVlIH0gPSBkYXRhO1xuICBjb25zdCB2YXJpbnRMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdC5sZW5ndGgpO1xuICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHZhcmludExlbiArIHNjcmlwdC5sZW5ndGgpO1xuICB0b29sc18xLndyaXRlVUludDY0TEUocmVzdWx0LCB2YWx1ZSwgMCk7XG4gIHZhcnVpbnQuZW5jb2RlKHNjcmlwdC5sZW5ndGgsIHJlc3VsdCwgOCk7XG4gIHNjcmlwdC5jb3B5KHJlc3VsdCwgOCArIHZhcmludExlbik7XG4gIHJldHVybiB7XG4gICAga2V5OiBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPXSksXG4gICAgdmFsdWU6IHJlc3VsdCxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICd7IHNjcmlwdDogQnVmZmVyOyB2YWx1ZTogbnVtYmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNjcmlwdCkgJiYgdHlwZW9mIGRhdGEudmFsdWUgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAoXG4gICAgISFjdXJyZW50RGF0YSAmJlxuICAgICEhbmV3RGF0YSAmJlxuICAgIGN1cnJlbnREYXRhLndpdG5lc3NVdHhvID09PSB1bmRlZmluZWQgJiZcbiAgICBjdXJyZW50RGF0YS5ub25XaXRuZXNzVXR4byA9PT0gdW5kZWZpbmVkXG4gICk7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByYW5nZSA9IG4gPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSkge1xuICBmdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IFRZUEVfQllURSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGJpcDMyRGVyaXZhdGlvbiB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIShrZXlWYWwua2V5Lmxlbmd0aCA9PT0gMzQgfHwga2V5VmFsLmtleS5sZW5ndGggPT09IDY2KSB8fFxuICAgICAgIVsyLCAzLCA0XS5pbmNsdWRlcyhrZXlWYWwua2V5WzFdKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBiaXAzMkRlcml2YXRpb24gaGFzIGludmFsaWQgcHVia2V5IGluIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKChrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCkgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IElucHV0IEJJUDMyX0RFUklWQVRJT04gdmFsdWUgbGVuZ3RoIHNob3VsZCBiZSBtdWx0aXBsZSBvZiA0JyxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG1hc3RlckZpbmdlcnByaW50OiBrZXlWYWwudmFsdWUuc2xpY2UoMCwgNCksXG4gICAgICBwdWJrZXksXG4gICAgICBwYXRoOiAnbScsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2Uoa2V5VmFsLnZhbHVlLmxlbmd0aCAvIDQgLSAxKSkge1xuICAgICAgY29uc3QgdmFsID0ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRShpICogNCArIDQpO1xuICAgICAgY29uc3QgaXNIYXJkID0gISEodmFsICYgMHg4MDAwMDAwMCk7XG4gICAgICBjb25zdCBpZHggPSB2YWwgJiAweDdmZmZmZmZmO1xuICAgICAgZGF0YS5wYXRoICs9ICcvJyArIGlkeC50b1N0cmluZygxMCkgKyAoaXNIYXJkID8gXCInXCIgOiAnJyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuY29uY2F0KFtoZWFkLCBkYXRhLnB1YmtleV0pO1xuICAgIGNvbnN0IHNwbGl0UGF0aCA9IGRhdGEucGF0aC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNwbGl0UGF0aC5sZW5ndGggKiA0KTtcbiAgICBkYXRhLm1hc3RlckZpbmdlcnByaW50LmNvcHkodmFsdWUsIDApO1xuICAgIGxldCBvZmZzZXQgPSA0O1xuICAgIHNwbGl0UGF0aC5zbGljZSgxKS5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIGNvbnN0IGlzSGFyZCA9IGxldmVsLnNsaWNlKC0xKSA9PT0gXCInXCI7XG4gICAgICBsZXQgbnVtID0gMHg3ZmZmZmZmZiAmIHBhcnNlSW50KGlzSGFyZCA/IGxldmVsLnNsaWNlKDAsIC0xKSA6IGxldmVsLCAxMCk7XG4gICAgICBpZiAoaXNIYXJkKSBudW0gKz0gMHg4MDAwMDAwMDtcbiAgICAgIHZhbHVlLndyaXRlVUludDMyTEUobnVtLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgY29uc3QgZXhwZWN0ZWQgPVxuICAgICd7IG1hc3RlckZpbmdlcnByaW50OiBCdWZmZXI7IHB1YmtleTogQnVmZmVyOyBwYXRoOiBzdHJpbmc7IH0nO1xuICBmdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnB1YmtleSkgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLm1hc3RlckZpbmdlcnByaW50KSAmJlxuICAgICAgdHlwZW9mIGRhdGEucGF0aCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIFszMywgNjVdLmluY2x1ZGVzKGRhdGEucHVia2V5Lmxlbmd0aCkgJiZcbiAgICAgIFsyLCAzLCA0XS5pbmNsdWRlcyhkYXRhLnB1YmtleVswXSkgJiZcbiAgICAgIGRhdGEubWFzdGVyRmluZ2VycHJpbnQubGVuZ3RoID09PSA0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gICAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0ucHVia2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wdWJrZXkuZXF1YWxzKGl0ZW0ucHVia2V5KSkubGVuZ3RoID09PSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZSxcbiAgICBjaGVjayxcbiAgICBleHBlY3RlZCxcbiAgICBjYW5BZGRUb0FycmF5LFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYWtlQ2hlY2tlcihwdWJrZXlUeXBlcykge1xuICByZXR1cm4gY2hlY2tQdWJrZXk7XG4gIGZ1bmN0aW9uIGNoZWNrUHVia2V5KGtleVZhbCkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHB1YmtleVR5cGVzLmluY2x1ZGVzKGtleVZhbC5rZXlbMF0pKSB7XG4gICAgICBwdWJrZXkgPSBrZXlWYWwua2V5LnNsaWNlKDEpO1xuICAgICAgaWYgKFxuICAgICAgICAhKHB1YmtleS5sZW5ndGggPT09IDMzIHx8IHB1YmtleS5sZW5ndGggPT09IDY1KSB8fFxuICAgICAgICAhWzIsIDMsIDRdLmluY2x1ZGVzKHB1YmtleVswXSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogaW52YWxpZCBwdWJrZXkgaW4ga2V5IDB4JyArIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHVia2V5O1xuICB9XG59XG5leHBvcnRzLm1ha2VDaGVja2VyID0gbWFrZUNoZWNrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUpIHtcbiAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSBUWVBFX0JZVEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSByZWRlZW1TY3JpcHQgd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBrZXlWYWwudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbVFlQRV9CWVRFXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgIH07XG4gIH1cbiAgY29uc3QgZXhwZWN0ZWQgPSAnQnVmZmVyJztcbiAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnJlZGVlbVNjcmlwdCA9PT0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZSxcbiAgICBjaGVjayxcbiAgICBleHBlY3RlZCxcbiAgICBjYW5BZGQsXG4gIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFKSB7XG4gIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgd2l0bmVzc1NjcmlwdCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfTtcbiAgfVxuICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICBmdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEud2l0bmVzc1NjcmlwdCA9PT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGUsXG4gICAgY2hlY2ssXG4gICAgZXhwZWN0ZWQsXG4gICAgY2FuQWRkLFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YXJ1aW50ID0gcmVxdWlyZSgnLi92YXJpbnQnKTtcbmV4cG9ydHMucmFuZ2UgPSBuID0+IFsuLi5BcnJheShuKS5rZXlzKCldO1xuZnVuY3Rpb24gcmV2ZXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gYnVmZmVyO1xuICBsZXQgaiA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICBsZXQgdG1wID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdG1wID0gYnVmZmVyW2ldO1xuICAgIGJ1ZmZlcltpXSA9IGJ1ZmZlcltqXTtcbiAgICBidWZmZXJbal0gPSB0bXA7XG4gICAgai0tO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLnJldmVyc2VCdWZmZXIgPSByZXZlcnNlQnVmZmVyO1xuZnVuY3Rpb24ga2V5VmFsc1RvQnVmZmVyKGtleVZhbHMpIHtcbiAgY29uc3QgYnVmZmVycyA9IGtleVZhbHMubWFwKGtleVZhbFRvQnVmZmVyKTtcbiAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKFswXSkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbn1cbmV4cG9ydHMua2V5VmFsc1RvQnVmZmVyID0ga2V5VmFsc1RvQnVmZmVyO1xuZnVuY3Rpb24ga2V5VmFsVG9CdWZmZXIoa2V5VmFsKSB7XG4gIGNvbnN0IGtleUxlbiA9IGtleVZhbC5rZXkubGVuZ3RoO1xuICBjb25zdCB2YWxMZW4gPSBrZXlWYWwudmFsdWUubGVuZ3RoO1xuICBjb25zdCBrZXlWYXJJbnRMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGtleUxlbik7XG4gIGNvbnN0IHZhbFZhckludExlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodmFsTGVuKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgIGtleVZhckludExlbiArIGtleUxlbiArIHZhbFZhckludExlbiArIHZhbExlbixcbiAgKTtcbiAgdmFydWludC5lbmNvZGUoa2V5TGVuLCBidWZmZXIsIDApO1xuICBrZXlWYWwua2V5LmNvcHkoYnVmZmVyLCBrZXlWYXJJbnRMZW4pO1xuICB2YXJ1aW50LmVuY29kZSh2YWxMZW4sIGJ1ZmZlciwga2V5VmFySW50TGVuICsga2V5TGVuKTtcbiAga2V5VmFsLnZhbHVlLmNvcHkoYnVmZmVyLCBrZXlWYXJJbnRMZW4gKyBrZXlMZW4gKyB2YWxWYXJJbnRMZW4pO1xuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5rZXlWYWxUb0J1ZmZlciA9IGtleVZhbFRvQnVmZmVyO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDExMjdcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICBpZiAodmFsdWUgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgaWYgKHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIGIgKj0gMHgxMDAwMDAwMDA7XG4gIHZlcmlmdWludChiICsgYSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICB2ZXJpZnVpbnQodmFsdWUsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gIGJ1ZmZlci53cml0ZUludDMyTEUodmFsdWUgJiAtMSwgb2Zmc2V0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWx1ZSAvIDB4MTAwMDAwMDAwKSwgb2Zmc2V0ICsgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA4O1xufVxuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBjaGVja1VJbnQ1MyhuKSB7XG4gIGlmIChuIDwgMCB8fCBuID4gTUFYX1NBRkVfSU5URUdFUiB8fCBuICUgMSAhPT0gMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgb3V0IG9mIHJhbmdlJyk7XG59XG5mdW5jdGlvbiBlbmNvZGUoX251bWJlciwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgY2hlY2tVSW50NTMoX251bWJlcik7XG4gIGlmICghYnVmZmVyKSBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgoX251bWJlcikpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwO1xuICAvLyA4IGJpdFxuICBpZiAoX251bWJlciA8IDB4ZmQpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChfbnVtYmVyLCBvZmZzZXQpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiAxIH0pO1xuICAgIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKF9udW1iZXIgPD0gMHhmZmZmKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MTZMRShfbnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICBPYmplY3QuYXNzaWduKGVuY29kZSwgeyBieXRlczogMyB9KTtcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChfbnVtYmVyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZlLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKF9udW1iZXIsIG9mZnNldCArIDEpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiA1IH0pO1xuICAgIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoX251bWJlciA+Pj4gMCwgb2Zmc2V0ICsgMSk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoKF9udW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KTtcbiAgICBPYmplY3QuYXNzaWduKGVuY29kZSwgeyBieXRlczogOSB9KTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmlyc3QgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIC8vIDggYml0XG4gIGlmIChmaXJzdCA8IDB4ZmQpIHtcbiAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMSB9KTtcbiAgICByZXR1cm4gZmlyc3Q7XG4gICAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAoZmlyc3QgPT09IDB4ZmQpIHtcbiAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMyB9KTtcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKTtcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZSkge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA1IH0pO1xuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpO1xuICAgIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA5IH0pO1xuICAgIGNvbnN0IGxvID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKTtcbiAgICBjb25zdCBoaSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNSk7XG4gICAgY29uc3QgX251bWJlciA9IGhpICogMHgwMTAwMDAwMDAwICsgbG87XG4gICAgY2hlY2tVSW50NTMoX251bWJlcik7XG4gICAgcmV0dXJuIF9udW1iZXI7XG4gIH1cbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGgoX251bWJlcikge1xuICBjaGVja1VJbnQ1MyhfbnVtYmVyKTtcbiAgcmV0dXJuIF9udW1iZXIgPCAweGZkXG4gICAgPyAxXG4gICAgOiBfbnVtYmVyIDw9IDB4ZmZmZlxuICAgID8gM1xuICAgIDogX251bWJlciA8PSAweGZmZmZmZmZmXG4gICAgPyA1XG4gICAgOiA5O1xufVxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKCcuLi9jb252ZXJ0ZXInKTtcbmNvbnN0IHRvb2xzXzEgPSByZXF1aXJlKCcuLi9jb252ZXJ0ZXIvdG9vbHMnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCcuLi9jb252ZXJ0ZXIvdmFyaW50Jyk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBwc2J0RnJvbUJ1ZmZlcihidWZmZXIsIHR4R2V0dGVyKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmdW5jdGlvbiB2YXJTbGljZSgpIHtcbiAgICBjb25zdCBrZXlMZW4gPSB2YXJ1aW50LmRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoa2V5TGVuKTtcbiAgICBjb25zdCBrZXkgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBrZXlMZW4pO1xuICAgIG9mZnNldCArPSBrZXlMZW47XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVUludDMyQkUoKSB7XG4gICAgY29uc3QgbnVtID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHJldHVybiBudW07XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFVJbnQ4KCkge1xuICAgIGNvbnN0IG51bSA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gbnVtO1xuICB9XG4gIGZ1bmN0aW9uIGdldEtleVZhbHVlKCkge1xuICAgIGNvbnN0IGtleSA9IHZhclNsaWNlKCk7XG4gICAgY29uc3QgdmFsdWUgPSB2YXJTbGljZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRW5kT2ZLZXlWYWxQYWlycygpIHtcbiAgICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBVbmV4cGVjdGVkIEVuZCBvZiBQU0JUJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzRW5kID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpID09PSAwO1xuICAgIGlmIChpc0VuZCkge1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBpc0VuZDtcbiAgfVxuICBpZiAocmVhZFVJbnQzMkJFKCkgIT09IDB4NzA3MzYyNzQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogSW52YWxpZCBNYWdpYyBOdW1iZXInKTtcbiAgfVxuICBpZiAocmVhZFVJbnQ4KCkgIT09IDB4ZmYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRm9ybWF0IEVycm9yOiBNYWdpYyBOdW1iZXIgbXVzdCBiZSBmb2xsb3dlZCBieSAweGZmIHNlcGFyYXRvcicsXG4gICAgKTtcbiAgfVxuICBjb25zdCBnbG9iYWxNYXBLZXlWYWxzID0gW107XG4gIGNvbnN0IGdsb2JhbEtleUluZGV4ID0ge307XG4gIHdoaWxlICghY2hlY2tFbmRPZktleVZhbFBhaXJzKCkpIHtcbiAgICBjb25zdCBrZXlWYWwgPSBnZXRLZXlWYWx1ZSgpO1xuICAgIGNvbnN0IGhleEtleSA9IGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChnbG9iYWxLZXlJbmRleFtoZXhLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGb3JtYXQgRXJyb3I6IEtleXMgbXVzdCBiZSB1bmlxdWUgZm9yIGdsb2JhbCBrZXltYXA6IGtleSAnICsgaGV4S2V5LFxuICAgICAgKTtcbiAgICB9XG4gICAgZ2xvYmFsS2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgZ2xvYmFsTWFwS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gIH1cbiAgY29uc3QgdW5zaWduZWRUeE1hcHMgPSBnbG9iYWxNYXBLZXlWYWxzLmZpbHRlcihcbiAgICBrZXlWYWwgPT4ga2V5VmFsLmtleVswXSA9PT0gdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLlVOU0lHTkVEX1RYLFxuICApO1xuICBpZiAodW5zaWduZWRUeE1hcHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IE9ubHkgb25lIFVOU0lHTkVEX1RYIGFsbG93ZWQnKTtcbiAgfVxuICBjb25zdCB1bnNpZ25lZFR4ID0gdHhHZXR0ZXIodW5zaWduZWRUeE1hcHNbMF0udmFsdWUpO1xuICAvLyBHZXQgaW5wdXQgYW5kIG91dHB1dCBjb3VudHMgdG8gbG9vcCB0aGUgcmVzcGVjdGl2ZSBmaWVsZHNcbiAgY29uc3QgeyBpbnB1dENvdW50LCBvdXRwdXRDb3VudCB9ID0gdW5zaWduZWRUeC5nZXRJbnB1dE91dHB1dENvdW50cygpO1xuICBjb25zdCBpbnB1dEtleVZhbHMgPSBbXTtcbiAgY29uc3Qgb3V0cHV0S2V5VmFscyA9IFtdO1xuICAvLyBHZXQgaW5wdXQgZmllbGRzXG4gIGZvciAoY29uc3QgaW5kZXggb2YgdG9vbHNfMS5yYW5nZShpbnB1dENvdW50KSkge1xuICAgIGNvbnN0IGlucHV0S2V5SW5kZXggPSB7fTtcbiAgICBjb25zdCBpbnB1dCA9IFtdO1xuICAgIHdoaWxlICghY2hlY2tFbmRPZktleVZhbFBhaXJzKCkpIHtcbiAgICAgIGNvbnN0IGtleVZhbCA9IGdldEtleVZhbHVlKCk7XG4gICAgICBjb25zdCBoZXhLZXkgPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGlmIChpbnB1dEtleUluZGV4W2hleEtleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdGb3JtYXQgRXJyb3I6IEtleXMgbXVzdCBiZSB1bmlxdWUgZm9yIGVhY2ggaW5wdXQ6ICcgK1xuICAgICAgICAgICAgJ2lucHV0IGluZGV4ICcgK1xuICAgICAgICAgICAgaW5kZXggK1xuICAgICAgICAgICAgJyBrZXkgJyArXG4gICAgICAgICAgICBoZXhLZXksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbnB1dEtleUluZGV4W2hleEtleV0gPSAxO1xuICAgICAgaW5wdXQucHVzaChrZXlWYWwpO1xuICAgIH1cbiAgICBpbnB1dEtleVZhbHMucHVzaChpbnB1dCk7XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKG91dHB1dENvdW50KSkge1xuICAgIGNvbnN0IG91dHB1dEtleUluZGV4ID0ge307XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKCFjaGVja0VuZE9mS2V5VmFsUGFpcnMoKSkge1xuICAgICAgY29uc3Qga2V5VmFsID0gZ2V0S2V5VmFsdWUoKTtcbiAgICAgIGNvbnN0IGhleEtleSA9IGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaWYgKG91dHB1dEtleUluZGV4W2hleEtleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdGb3JtYXQgRXJyb3I6IEtleXMgbXVzdCBiZSB1bmlxdWUgZm9yIGVhY2ggb3V0cHV0OiAnICtcbiAgICAgICAgICAgICdvdXRwdXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCArXG4gICAgICAgICAgICAnIGtleSAnICtcbiAgICAgICAgICAgIGhleEtleSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEtleUluZGV4W2hleEtleV0gPSAxO1xuICAgICAgb3V0cHV0LnB1c2goa2V5VmFsKTtcbiAgICB9XG4gICAgb3V0cHV0S2V5VmFscy5wdXNoKG91dHB1dCk7XG4gIH1cbiAgcmV0dXJuIHBzYnRGcm9tS2V5VmFscyh1bnNpZ25lZFR4LCB7XG4gICAgZ2xvYmFsTWFwS2V5VmFscyxcbiAgICBpbnB1dEtleVZhbHMsXG4gICAgb3V0cHV0S2V5VmFscyxcbiAgfSk7XG59XG5leHBvcnRzLnBzYnRGcm9tQnVmZmVyID0gcHNidEZyb21CdWZmZXI7XG5mdW5jdGlvbiBjaGVja0tleUJ1ZmZlcih0eXBlLCBrZXlCdWYsIGtleU51bSkge1xuICBpZiAoIWtleUJ1Zi5lcXVhbHMoQnVmZmVyLmZyb20oW2tleU51bV0pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBGb3JtYXQgRXJyb3I6IEludmFsaWQgJHt0eXBlfSBrZXk6ICR7a2V5QnVmLnRvU3RyaW5nKCdoZXgnKX1gLFxuICAgICk7XG4gIH1cbn1cbmV4cG9ydHMuY2hlY2tLZXlCdWZmZXIgPSBjaGVja0tleUJ1ZmZlcjtcbmZ1bmN0aW9uIHBzYnRGcm9tS2V5VmFscyhcbiAgdW5zaWduZWRUeCxcbiAgeyBnbG9iYWxNYXBLZXlWYWxzLCBpbnB1dEtleVZhbHMsIG91dHB1dEtleVZhbHMgfSxcbikge1xuICAvLyBUaGF0IHdhcyBlYXN5IDotKVxuICBjb25zdCBnbG9iYWxNYXAgPSB7XG4gICAgdW5zaWduZWRUeCxcbiAgfTtcbiAgbGV0IHR4Q291bnQgPSAwO1xuICBmb3IgKGNvbnN0IGtleVZhbCBvZiBnbG9iYWxNYXBLZXlWYWxzKSB7XG4gICAgLy8gSWYgYSBnbG9iYWxNYXAgaXRlbSBuZWVkcyBwdWJrZXksIHVuY29tbWVudFxuICAgIC8vIGNvbnN0IHB1YmtleSA9IGNvbnZlcnQuZ2xvYmFscy5jaGVja1B1YmtleShrZXlWYWwpO1xuICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgY2FzZSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFg6XG4gICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICdnbG9iYWwnLFxuICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLlVOU0lHTkVEX1RYLFxuICAgICAgICApO1xuICAgICAgICBpZiAodHhDb3VudCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogR2xvYmFsTWFwIGhhcyBtdWx0aXBsZSBVTlNJR05FRF9UWCcpO1xuICAgICAgICB9XG4gICAgICAgIHR4Q291bnQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHR5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5HTE9CQUxfWFBVQjpcbiAgICAgICAgaWYgKGdsb2JhbE1hcC5nbG9iYWxYcHViID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBnbG9iYWxNYXAuZ2xvYmFsWHB1YiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbE1hcC5nbG9iYWxYcHViLnB1c2goY29udmVydC5nbG9iYWxzLmdsb2JhbFhwdWIuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbGxvdyBpbmNsdXNpb24gZHVyaW5nIHNlcmlhbGl6YXRpb24uXG4gICAgICAgIGlmICghZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzKSBnbG9iYWxNYXAudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICAgICAgZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgICB9XG4gIH1cbiAgLy8gR2V0IGlucHV0IGFuZCBvdXRwdXQgY291bnRzIHRvIGxvb3AgdGhlIHJlc3BlY3RpdmUgZmllbGRzXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEtleVZhbHMubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEtleVZhbHMubGVuZ3RoO1xuICBjb25zdCBpbnB1dHMgPSBbXTtcbiAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAvLyBHZXQgaW5wdXQgZmllbGRzXG4gIGZvciAoY29uc3QgaW5kZXggb2YgdG9vbHNfMS5yYW5nZShpbnB1dENvdW50KSkge1xuICAgIGNvbnN0IGlucHV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXlWYWwgb2YgaW5wdXRLZXlWYWxzW2luZGV4XSkge1xuICAgICAgY29udmVydC5pbnB1dHMuY2hlY2tQdWJrZXkoa2V5VmFsKTtcbiAgICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE86XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE8sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnB1dC5ub25XaXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBbTk9OX11XSVRORVNTX1VUWE8nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQubm9uV2l0bmVzc1V0eG8gPSBjb252ZXJ0LmlucHV0cy5ub25XaXRuZXNzVXR4by5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1VUWE86XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfVVRYTyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3NVdHhvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogSW5wdXQgaGFzIG11bHRpcGxlIFtOT05fXVdJVE5FU1NfVVRYTycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC53aXRuZXNzVXR4byA9IGNvbnZlcnQuaW5wdXRzLndpdG5lc3NVdHhvLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBBUlRJQUxfU0lHOlxuICAgICAgICAgIGlmIChpbnB1dC5wYXJ0aWFsU2lnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnBhcnRpYWxTaWcgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQucGFydGlhbFNpZy5wdXNoKGNvbnZlcnQuaW5wdXRzLnBhcnRpYWxTaWcuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRTpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuU0lHSEFTSF9UWVBFLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlucHV0LnNpZ2hhc2hUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnB1dCBoYXMgbXVsdGlwbGUgU0lHSEFTSF9UWVBFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnNpZ2hhc2hUeXBlID0gY29udmVydC5pbnB1dHMuc2lnaGFzaFR5cGUuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUkVERUVNX1NDUklQVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUkVERUVNX1NDUklQVCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnB1dC5yZWRlZW1TY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBSRURFRU1fU0NSSVBUJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnJlZGVlbVNjcmlwdCA9IGNvbnZlcnQuaW5wdXRzLnJlZGVlbVNjcmlwdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1NDUklQVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5wdXQud2l0bmVzc1NjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogSW5wdXQgaGFzIG11bHRpcGxlIFdJVE5FU1NfU0NSSVBUJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LndpdG5lc3NTY3JpcHQgPSBjb252ZXJ0LmlucHV0cy53aXRuZXNzU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT046XG4gICAgICAgICAgaWYgKGlucHV0LmJpcDMyRGVyaXZhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnB1dC5iaXAzMkRlcml2YXRpb24gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQuYmlwMzJEZXJpdmF0aW9uLnB1c2goXG4gICAgICAgICAgICBjb252ZXJ0LmlucHV0cy5iaXAzMkRlcml2YXRpb24uZGVjb2RlKGtleVZhbCksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUc6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFNJRyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0LmZpbmFsU2NyaXB0U2lnID0gY29udmVydC5pbnB1dHMuZmluYWxTY3JpcHRTaWcuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUV0lUTkVTUzpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUV0lUTkVTUyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyA9IGNvbnZlcnQuaW5wdXRzLmZpbmFsU2NyaXB0V2l0bmVzcy5kZWNvZGUoXG4gICAgICAgICAgICBrZXlWYWwsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QT1JfQ09NTUlUTUVOVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC5wb3JDb21taXRtZW50ID0gY29udmVydC5pbnB1dHMucG9yQ29tbWl0bWVudC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgaW5jbHVzaW9uIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIGlmICghaW5wdXQudW5rbm93bktleVZhbHMpIGlucHV0LnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnB1dHMucHVzaChpbnB1dCk7XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKG91dHB1dENvdW50KSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5VmFsIG9mIG91dHB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICBjb252ZXJ0Lm91dHB1dHMuY2hlY2tQdWJrZXkoa2V5VmFsKTtcbiAgICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5SRURFRU1fU0NSSVBUOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob3V0cHV0LnJlZGVlbVNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBSRURFRU1fU0NSSVBUJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0Lm91dHB1dHMucmVkZWVtU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChvdXRwdXQud2l0bmVzc1NjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQud2l0bmVzc1NjcmlwdCA9IGNvbnZlcnQub3V0cHV0cy53aXRuZXNzU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChvdXRwdXQuYmlwMzJEZXJpdmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dHB1dC5iaXAzMkRlcml2YXRpb24gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5vdXRwdXRzLmJpcDMyRGVyaXZhdGlvbi5kZWNvZGUoa2V5VmFsKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghb3V0cHV0LnVua25vd25LZXlWYWxzKSBvdXRwdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICAgICAgICBvdXRwdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgfVxuICByZXR1cm4geyBnbG9iYWxNYXAsIGlucHV0cywgb3V0cHV0cyB9O1xufVxuZXhwb3J0cy5wc2J0RnJvbUtleVZhbHMgPSBwc2J0RnJvbUtleVZhbHM7XG4iLCIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL2Zyb21CdWZmZXInKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3RvQnVmZmVyJykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKCcuLi9jb252ZXJ0ZXInKTtcbmNvbnN0IHRvb2xzXzEgPSByZXF1aXJlKCcuLi9jb252ZXJ0ZXIvdG9vbHMnKTtcbmZ1bmN0aW9uIHBzYnRUb0J1ZmZlcih7IGdsb2JhbE1hcCwgaW5wdXRzLCBvdXRwdXRzIH0pIHtcbiAgY29uc3QgeyBnbG9iYWxLZXlWYWxzLCBpbnB1dEtleVZhbHMsIG91dHB1dEtleVZhbHMgfSA9IHBzYnRUb0tleVZhbHMoe1xuICAgIGdsb2JhbE1hcCxcbiAgICBpbnB1dHMsXG4gICAgb3V0cHV0cyxcbiAgfSk7XG4gIGNvbnN0IGdsb2JhbEJ1ZmZlciA9IHRvb2xzXzEua2V5VmFsc1RvQnVmZmVyKGdsb2JhbEtleVZhbHMpO1xuICBjb25zdCBrZXlWYWxzT3JFbXB0eVRvQnVmZmVyID0ga2V5VmFscyA9PlxuICAgIGtleVZhbHMubGVuZ3RoID09PSAwXG4gICAgICA/IFtCdWZmZXIuZnJvbShbMF0pXVxuICAgICAgOiBrZXlWYWxzLm1hcCh0b29sc18xLmtleVZhbHNUb0J1ZmZlcik7XG4gIGNvbnN0IGlucHV0QnVmZmVycyA9IGtleVZhbHNPckVtcHR5VG9CdWZmZXIoaW5wdXRLZXlWYWxzKTtcbiAgY29uc3Qgb3V0cHV0QnVmZmVycyA9IGtleVZhbHNPckVtcHR5VG9CdWZmZXIob3V0cHV0S2V5VmFscyk7XG4gIGNvbnN0IGhlYWRlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg1KTtcbiAgaGVhZGVyLndyaXRlVUludEJFKDB4NzA3MzYyNzRmZiwgMCwgNSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFxuICAgIFtoZWFkZXIsIGdsb2JhbEJ1ZmZlcl0uY29uY2F0KGlucHV0QnVmZmVycywgb3V0cHV0QnVmZmVycyksXG4gICk7XG59XG5leHBvcnRzLnBzYnRUb0J1ZmZlciA9IHBzYnRUb0J1ZmZlcjtcbmNvbnN0IHNvcnRLZXlWYWxzID0gKGEsIGIpID0+IHtcbiAgcmV0dXJuIGEua2V5LmNvbXBhcmUoYi5rZXkpO1xufTtcbmZ1bmN0aW9uIGtleVZhbHNGcm9tTWFwKGtleVZhbE1hcCwgY29udmVydGVyRmFjdG9yeSkge1xuICBjb25zdCBrZXlIZXhTZXQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGtleVZhbHMgPSBPYmplY3QuZW50cmllcyhrZXlWYWxNYXApLnJlZHVjZSgocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoa2V5ID09PSAndW5rbm93bktleVZhbHMnKSByZXR1cm4gcmVzdWx0O1xuICAgIC8vIFdlIGFyZSBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGFueXdheXMuIFNvIGlnbm9yZSBUUyBlcnJvclxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJGYWN0b3J5W2tleV07XG4gICAgaWYgKGNvbnZlcnRlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IGVuY29kZWRLZXlWYWxzID0gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKS5tYXAoXG4gICAgICBjb252ZXJ0ZXIuZW5jb2RlLFxuICAgICk7XG4gICAgY29uc3Qga2V5SGV4ZXMgPSBlbmNvZGVkS2V5VmFscy5tYXAoa3YgPT4ga3Yua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAga2V5SGV4ZXMuZm9yRWFjaChoZXggPT4ge1xuICAgICAgaWYgKGtleUhleFNldC5oYXMoaGV4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpYWxpemUgRXJyb3I6IER1cGxpY2F0ZSBrZXk6ICcgKyBoZXgpO1xuICAgICAga2V5SGV4U2V0LmFkZChoZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KGVuY29kZWRLZXlWYWxzKTtcbiAgfSwgW10pO1xuICAvLyBHZXQgb3RoZXIga2V5VmFscyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIGdvdHRlblxuICBjb25zdCBvdGhlcktleVZhbHMgPSBrZXlWYWxNYXAudW5rbm93bktleVZhbHNcbiAgICA/IGtleVZhbE1hcC51bmtub3duS2V5VmFscy5maWx0ZXIoa2V5VmFsID0+IHtcbiAgICAgICAgcmV0dXJuICFrZXlIZXhTZXQuaGFzKGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgIH0pXG4gICAgOiBbXTtcbiAgcmV0dXJuIGtleVZhbHMuY29uY2F0KG90aGVyS2V5VmFscykuc29ydChzb3J0S2V5VmFscyk7XG59XG5mdW5jdGlvbiBwc2J0VG9LZXlWYWxzKHsgZ2xvYmFsTWFwLCBpbnB1dHMsIG91dHB1dHMgfSkge1xuICAvLyBGaXJzdCBwYXJzZSB0aGUgZ2xvYmFsIGtleVZhbHNcbiAgLy8gR2V0IGFueSBleHRyYSBrZXl2YWxzIHRvIHBhc3MgYWxvbmdcbiAgcmV0dXJuIHtcbiAgICBnbG9iYWxLZXlWYWxzOiBrZXlWYWxzRnJvbU1hcChnbG9iYWxNYXAsIGNvbnZlcnQuZ2xvYmFscyksXG4gICAgaW5wdXRLZXlWYWxzOiBpbnB1dHMubWFwKGkgPT4ga2V5VmFsc0Zyb21NYXAoaSwgY29udmVydC5pbnB1dHMpKSxcbiAgICBvdXRwdXRLZXlWYWxzOiBvdXRwdXRzLm1hcChvID0+IGtleVZhbHNGcm9tTWFwKG8sIGNvbnZlcnQub3V0cHV0cykpLFxuICB9O1xufVxuZXhwb3J0cy5wc2J0VG9LZXlWYWxzID0gcHNidFRvS2V5VmFscztcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21iaW5lcl8xID0gcmVxdWlyZSgnLi9jb21iaW5lcicpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi90eXBlRmllbGRzJyk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xuY2xhc3MgUHNidCB7XG4gIGNvbnN0cnVjdG9yKHR4KSB7XG4gICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbE1hcCA9IHtcbiAgICAgIHVuc2lnbmVkVHg6IHR4LFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGZyb21CYXNlNjQoZGF0YSwgdHhGcm9tQnVmZmVyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCB0eEZyb21CdWZmZXIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGRhdGEsIHR4RnJvbUJ1ZmZlcikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgdHhGcm9tQnVmZmVyKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHR4RnJvbUJ1ZmZlcikge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBwYXJzZXJfMS5wc2J0RnJvbUJ1ZmZlcihidWZmZXIsIHR4RnJvbUJ1ZmZlcik7XG4gICAgY29uc3QgcHNidCA9IG5ldyB0aGlzKHJlc3VsdHMuZ2xvYmFsTWFwLnVuc2lnbmVkVHgpO1xuICAgIE9iamVjdC5hc3NpZ24ocHNidCwgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHBzYnQ7XG4gIH1cbiAgdG9CYXNlNjQoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICB0b0J1ZmZlcigpIHtcbiAgICByZXR1cm4gcGFyc2VyXzEucHNidFRvQnVmZmVyKHRoaXMpO1xuICB9XG4gIHVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKSB7XG4gICAgdXRpbHNfMS51cGRhdGVHbG9iYWwodXBkYXRlRGF0YSwgdGhpcy5nbG9iYWxNYXApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICBjb25zdCBpbnB1dCA9IHV0aWxzXzEuY2hlY2tGb3JJbnB1dCh0aGlzLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgdXRpbHNfMS51cGRhdGVJbnB1dCh1cGRhdGVEYXRhLCBpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdXRpbHNfMS5jaGVja0Zvck91dHB1dCh0aGlzLm91dHB1dHMsIG91dHB1dEluZGV4KTtcbiAgICB1dGlsc18xLnVwZGF0ZU91dHB1dCh1cGRhdGVEYXRhLCBvdXRwdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0dsb2JhbChrZXlWYWwpIHtcbiAgICB1dGlsc18xLmNoZWNrSGFzS2V5KFxuICAgICAga2V5VmFsLFxuICAgICAgdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzKSxcbiAgICApO1xuICAgIGlmICghdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMpIHRoaXMuZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzID0gW107XG4gICAgdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgIGNvbnN0IGlucHV0ID0gdXRpbHNfMS5jaGVja0ZvcklucHV0KHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICB1dGlsc18xLmNoZWNrSGFzS2V5KFxuICAgICAga2V5VmFsLFxuICAgICAgaW5wdXQudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLklucHV0VHlwZXMpLFxuICAgICk7XG4gICAgaWYgKCFpbnB1dC51bmtub3duS2V5VmFscykgaW5wdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICBpbnB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkVW5rbm93bktleVZhbFRvT3V0cHV0KG91dHB1dEluZGV4LCBrZXlWYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB1dGlsc18xLmNoZWNrRm9yT3V0cHV0KHRoaXMub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgIHV0aWxzXzEuY2hlY2tIYXNLZXkoXG4gICAgICBrZXlWYWwsXG4gICAgICBvdXRwdXQudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLk91dHB1dFR5cGVzKSxcbiAgICApO1xuICAgIGlmICghb3V0cHV0LnVua25vd25LZXlWYWxzKSBvdXRwdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICBvdXRwdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZElucHV0KGlucHV0RGF0YSkge1xuICAgIHRoaXMuZ2xvYmFsTWFwLnVuc2lnbmVkVHguYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICB0aGlzLmlucHV0cy5wdXNoKHtcbiAgICAgIHVua25vd25LZXlWYWxzOiBbXSxcbiAgICB9KTtcbiAgICBjb25zdCBhZGRLZXlWYWxzID0gaW5wdXREYXRhLnVua25vd25LZXlWYWxzIHx8IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmlucHV0cy5sZW5ndGggLSAxO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhZGRLZXlWYWxzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duS2V5VmFscyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgfVxuICAgIGFkZEtleVZhbHMuZm9yRWFjaChrZXlWYWwgPT5cbiAgICAgIHRoaXMuYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwga2V5VmFsKSxcbiAgICApO1xuICAgIHV0aWxzXzEuYWRkSW5wdXRBdHRyaWJ1dGVzKHRoaXMuaW5wdXRzLCBpbnB1dERhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZE91dHB1dChvdXRwdXREYXRhKSB7XG4gICAgdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgdW5rbm93bktleVZhbHM6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IGFkZEtleVZhbHMgPSBvdXRwdXREYXRhLnVua25vd25LZXlWYWxzIHx8IFtdO1xuICAgIGNvbnN0IG91dHB1dEluZGV4ID0gdGhpcy5vdXRwdXRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZEtleVZhbHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd25LZXlWYWxzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICB9XG4gICAgYWRkS2V5VmFscy5mb3JFYWNoKGtleVZhbCA9PlxuICAgICAgdGhpcy5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChvdXRwdXRJbmRleCwga2V5VmFsKSxcbiAgICApO1xuICAgIHV0aWxzXzEuYWRkT3V0cHV0QXR0cmlidXRlcyh0aGlzLm91dHB1dHMsIG91dHB1dERhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCkge1xuICAgIGNvbnN0IGlucHV0ID0gdXRpbHNfMS5jaGVja0ZvcklucHV0KHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICB1dGlsc18xLmlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkKGlucHV0SW5kZXgsIGlucHV0KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIVtcbiAgICAgICAgICAnd2l0bmVzc1V0eG8nLFxuICAgICAgICAgICdub25XaXRuZXNzVXR4bycsXG4gICAgICAgICAgJ2ZpbmFsU2NyaXB0U2lnJyxcbiAgICAgICAgICAnZmluYWxTY3JpcHRXaXRuZXNzJyxcbiAgICAgICAgICAndW5rbm93bktleVZhbHMnLFxuICAgICAgICBdLmluY2x1ZGVzKGtleSlcbiAgICAgICkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSBpbnB1dFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb21iaW5lKC4uLnRob3NlKSB7XG4gICAgLy8gQ29tYmluZSB0aGlzIHdpdGggdGhvc2UuXG4gICAgLy8gUmV0dXJuIHNlbGYgZm9yIGNoYWluaW5nLlxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbWJpbmVyXzEuY29tYmluZShbdGhpc10uY29uY2F0KHRob3NlKSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN1bHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbE1hcC51bnNpZ25lZFR4LnRvQnVmZmVyKCk7XG4gIH1cbn1cbmV4cG9ydHMuUHNidCA9IFBzYnQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEdsb2JhbFR5cGVzO1xuKGZ1bmN0aW9uKEdsb2JhbFR5cGVzKSB7XG4gIEdsb2JhbFR5cGVzWyhHbG9iYWxUeXBlc1snVU5TSUdORURfVFgnXSA9IDApXSA9ICdVTlNJR05FRF9UWCc7XG4gIEdsb2JhbFR5cGVzWyhHbG9iYWxUeXBlc1snR0xPQkFMX1hQVUInXSA9IDEpXSA9ICdHTE9CQUxfWFBVQic7XG59KSgoR2xvYmFsVHlwZXMgPSBleHBvcnRzLkdsb2JhbFR5cGVzIHx8IChleHBvcnRzLkdsb2JhbFR5cGVzID0ge30pKSk7XG5leHBvcnRzLkdMT0JBTF9UWVBFX05BTUVTID0gWyd1bnNpZ25lZFR4JywgJ2dsb2JhbFhwdWInXTtcbnZhciBJbnB1dFR5cGVzO1xuKGZ1bmN0aW9uKElucHV0VHlwZXMpIHtcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snTk9OX1dJVE5FU1NfVVRYTyddID0gMCldID0gJ05PTl9XSVRORVNTX1VUWE8nO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydXSVRORVNTX1VUWE8nXSA9IDEpXSA9ICdXSVRORVNTX1VUWE8nO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydQQVJUSUFMX1NJRyddID0gMildID0gJ1BBUlRJQUxfU0lHJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snU0lHSEFTSF9UWVBFJ10gPSAzKV0gPSAnU0lHSEFTSF9UWVBFJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snUkVERUVNX1NDUklQVCddID0gNCldID0gJ1JFREVFTV9TQ1JJUFQnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydXSVRORVNTX1NDUklQVCddID0gNSldID0gJ1dJVE5FU1NfU0NSSVBUJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snQklQMzJfREVSSVZBVElPTiddID0gNildID0gJ0JJUDMyX0RFUklWQVRJT04nO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydGSU5BTF9TQ1JJUFRTSUcnXSA9IDcpXSA9ICdGSU5BTF9TQ1JJUFRTSUcnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydGSU5BTF9TQ1JJUFRXSVRORVNTJ10gPSA4KV0gPSAnRklOQUxfU0NSSVBUV0lUTkVTUyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1BPUl9DT01NSVRNRU5UJ10gPSA5KV0gPSAnUE9SX0NPTU1JVE1FTlQnO1xufSkoKElucHV0VHlwZXMgPSBleHBvcnRzLklucHV0VHlwZXMgfHwgKGV4cG9ydHMuSW5wdXRUeXBlcyA9IHt9KSkpO1xuZXhwb3J0cy5JTlBVVF9UWVBFX05BTUVTID0gW1xuICAnbm9uV2l0bmVzc1V0eG8nLFxuICAnd2l0bmVzc1V0eG8nLFxuICAncGFydGlhbFNpZycsXG4gICdzaWdoYXNoVHlwZScsXG4gICdyZWRlZW1TY3JpcHQnLFxuICAnd2l0bmVzc1NjcmlwdCcsXG4gICdiaXAzMkRlcml2YXRpb24nLFxuICAnZmluYWxTY3JpcHRTaWcnLFxuICAnZmluYWxTY3JpcHRXaXRuZXNzJyxcbiAgJ3BvckNvbW1pdG1lbnQnLFxuXTtcbnZhciBPdXRwdXRUeXBlcztcbihmdW5jdGlvbihPdXRwdXRUeXBlcykge1xuICBPdXRwdXRUeXBlc1soT3V0cHV0VHlwZXNbJ1JFREVFTV9TQ1JJUFQnXSA9IDApXSA9ICdSRURFRU1fU0NSSVBUJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydXSVRORVNTX1NDUklQVCddID0gMSldID0gJ1dJVE5FU1NfU0NSSVBUJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydCSVAzMl9ERVJJVkFUSU9OJ10gPSAyKV0gPSAnQklQMzJfREVSSVZBVElPTic7XG59KSgoT3V0cHV0VHlwZXMgPSBleHBvcnRzLk91dHB1dFR5cGVzIHx8IChleHBvcnRzLk91dHB1dFR5cGVzID0ge30pKSk7XG5leHBvcnRzLk9VVFBVVF9UWVBFX05BTUVTID0gW1xuICAncmVkZWVtU2NyaXB0JyxcbiAgJ3dpdG5lc3NTY3JpcHQnLFxuICAnYmlwMzJEZXJpdmF0aW9uJyxcbl07XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi9jb252ZXJ0ZXInKTtcbmZ1bmN0aW9uIGNoZWNrRm9ySW5wdXQoaW5wdXRzLCBpbnB1dEluZGV4KSB7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRzW2lucHV0SW5kZXhdO1xuICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBObyBpbnB1dCAjJHtpbnB1dEluZGV4fWApO1xuICByZXR1cm4gaW5wdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9ySW5wdXQgPSBjaGVja0ZvcklucHV0O1xuZnVuY3Rpb24gY2hlY2tGb3JPdXRwdXQob3V0cHV0cywgb3V0cHV0SW5kZXgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1tvdXRwdXRJbmRleF07XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBObyBvdXRwdXQgIyR7b3V0cHV0SW5kZXh9YCk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9yT3V0cHV0ID0gY2hlY2tGb3JPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja0hhc0tleShjaGVja0tleVZhbCwga2V5VmFscywgZW51bUxlbmd0aCkge1xuICBpZiAoY2hlY2tLZXlWYWwua2V5WzBdIDwgZW51bUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVc2UgdGhlIG1ldGhvZCBmb3IgeW91ciBzcGVjaWZpYyBrZXkgaW5zdGVhZCBvZiBhZGRVbmtub3duS2V5VmFsKmAsXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAga2V5VmFscyAmJlxuICAgIGtleVZhbHMuZmlsdGVyKGt2ID0+IGt2LmtleS5lcXVhbHMoY2hlY2tLZXlWYWwua2V5KSkubGVuZ3RoICE9PSAwXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIEtleTogJHtjaGVja0tleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpfWApO1xuICB9XG59XG5leHBvcnRzLmNoZWNrSGFzS2V5ID0gY2hlY2tIYXNLZXk7XG5mdW5jdGlvbiBnZXRFbnVtTGVuZ3RoKG15ZW51bSkge1xuICBsZXQgY291bnQgPSAwO1xuICBPYmplY3Qua2V5cyhteWVudW0pLmZvckVhY2godmFsID0+IHtcbiAgICBpZiAoTnVtYmVyKGlzTmFOKE51bWJlcih2YWwpKSkpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvdW50O1xufVxuZXhwb3J0cy5nZXRFbnVtTGVuZ3RoID0gZ2V0RW51bUxlbmd0aDtcbmZ1bmN0aW9uIGlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkKGlucHV0SW5kZXgsIGlucHV0KSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKCFpbnB1dC5ub25XaXRuZXNzVXR4byAhPT0gIWlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgY29uc3QgbmVlZFNjcmlwdFNpZyA9ICEhaW5wdXQucmVkZWVtU2NyaXB0O1xuICAgIGNvbnN0IG5lZWRXaXRuZXNzU2NyaXB0ID0gISFpbnB1dC53aXRuZXNzU2NyaXB0O1xuICAgIGNvbnN0IHNjcmlwdFNpZ09LID0gIW5lZWRTY3JpcHRTaWcgfHwgISFpbnB1dC5maW5hbFNjcmlwdFNpZztcbiAgICBjb25zdCB3aXRuZXNzU2NyaXB0T0sgPSAhbmVlZFdpdG5lc3NTY3JpcHQgfHwgISFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3M7XG4gICAgY29uc3QgaGFzT25lRmluYWwgPSAhIWlucHV0LmZpbmFsU2NyaXB0U2lnIHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xuICAgIHJlc3VsdCA9IHNjcmlwdFNpZ09LICYmIHdpdG5lc3NTY3JpcHRPSyAmJiBoYXNPbmVGaW5hbDtcbiAgfVxuICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnB1dCAjJHtpbnB1dEluZGV4fSBoYXMgdG9vIG11Y2ggb3IgdG9vIGxpdHRsZSBkYXRhIHRvIGNsZWFuYCxcbiAgICApO1xuICB9XG59XG5leHBvcnRzLmlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkID0gaW5wdXRDaGVja1VuY2xlYW5GaW5hbGl6ZWQ7XG5mdW5jdGlvbiB0aHJvd0ZvclVwZGF0ZU1ha2VyKHR5cGVOYW1lLCBuYW1lLCBleHBlY3RlZCwgZGF0YSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYERhdGEgZm9yICR7dHlwZU5hbWV9IGtleSAke25hbWV9IGlzIGluY29ycmVjdDogRXhwZWN0ZWQgYCArXG4gICAgICBgJHtleHBlY3RlZH0gYW5kIGdvdCAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWAsXG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYWtlcih0eXBlTmFtZSkge1xuICByZXR1cm4gKHVwZGF0ZURhdGEsIG1haW5EYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHVwZGF0ZURhdGEpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBkYXRhID0gdXBkYXRlRGF0YVtuYW1lXTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHsgY2FuQWRkLCBjYW5BZGRUb0FycmF5LCBjaGVjaywgZXhwZWN0ZWQgfSA9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29udmVydGVyW3R5cGVOYW1lICsgJ3MnXVtuYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IGlzQXJyYXkgPSAhIWNhbkFkZFRvQXJyYXk7XG4gICAgICAvLyBJZiB1bmtub3duIGRhdGEuIGlnbm9yZSBhbmQgZG8gbm90IGFkZFxuICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChtYWluRGF0YVtuYW1lXSAmJiAhQXJyYXkuaXNBcnJheShtYWluRGF0YVtuYW1lXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSB0eXBlICR7bmFtZX0gbXVzdCBiZSBhbiBhcnJheWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRhdGEuZXZlcnkoY2hlY2spKSB7XG4gICAgICAgICAgICB0aHJvd0ZvclVwZGF0ZU1ha2VyKHR5cGVOYW1lLCBuYW1lLCBleHBlY3RlZCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdCBhcnIgPSBtYWluRGF0YVtuYW1lXSB8fCBbXTtcbiAgICAgICAgICBjb25zdCBkdXBlQ2hlY2tTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgaWYgKCFkYXRhLmV2ZXJ5KHYgPT4gY2FuQWRkVG9BcnJheShhcnIsIHYsIGR1cGVDaGVja1NldCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWRkIGR1cGxpY2F0ZSBkYXRhIHRvIGFycmF5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBtYWluRGF0YVtuYW1lXSA9IGFyci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbkFkZChtYWluRGF0YSwgZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBhZGQgZHVwbGljYXRlIGRhdGEgdG8gJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIG1haW5EYXRhW25hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydHMudXBkYXRlR2xvYmFsID0gdXBkYXRlTWFrZXIoJ2dsb2JhbCcpO1xuZXhwb3J0cy51cGRhdGVJbnB1dCA9IHVwZGF0ZU1ha2VyKCdpbnB1dCcpO1xuZXhwb3J0cy51cGRhdGVPdXRwdXQgPSB1cGRhdGVNYWtlcignb3V0cHV0Jyk7XG5mdW5jdGlvbiBhZGRJbnB1dEF0dHJpYnV0ZXMoaW5wdXRzLCBkYXRhKSB7XG4gIGNvbnN0IGluZGV4ID0gaW5wdXRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dChpbnB1dHMsIGluZGV4KTtcbiAgZXhwb3J0cy51cGRhdGVJbnB1dChkYXRhLCBpbnB1dCk7XG59XG5leHBvcnRzLmFkZElucHV0QXR0cmlidXRlcyA9IGFkZElucHV0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGFkZE91dHB1dEF0dHJpYnV0ZXMob3V0cHV0cywgZGF0YSkge1xuICBjb25zdCBpbmRleCA9IG91dHB1dHMubGVuZ3RoIC0gMTtcbiAgY29uc3Qgb3V0cHV0ID0gY2hlY2tGb3JJbnB1dChvdXRwdXRzLCBpbmRleCk7XG4gIGV4cG9ydHMudXBkYXRlT3V0cHV0KGRhdGEsIG91dHB1dCk7XG59XG5leHBvcnRzLmFkZE91dHB1dEF0dHJpYnV0ZXMgPSBhZGRPdXRwdXRBdHRyaWJ1dGVzO1xuZnVuY3Rpb24gZGVmYXVsdFZlcnNpb25TZXR0ZXIodmVyc2lvbiwgdHhCdWYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodHhCdWYpIHx8IHR4QnVmLmxlbmd0aCA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBWZXJzaW9uOiBJbnZhbGlkIFRyYW5zYWN0aW9uJyk7XG4gIH1cbiAgdHhCdWYud3JpdGVVSW50MzJMRSh2ZXJzaW9uLCAwKTtcbiAgcmV0dXJuIHR4QnVmO1xufVxuZXhwb3J0cy5kZWZhdWx0VmVyc2lvblNldHRlciA9IGRlZmF1bHRWZXJzaW9uU2V0dGVyO1xuZnVuY3Rpb24gZGVmYXVsdExvY2t0aW1lU2V0dGVyKGxvY2t0aW1lLCB0eEJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0eEJ1ZikgfHwgdHhCdWYubGVuZ3RoIDwgNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2V0IExvY2t0aW1lOiBJbnZhbGlkIFRyYW5zYWN0aW9uJyk7XG4gIH1cbiAgdHhCdWYud3JpdGVVSW50MzJMRShsb2NrdGltZSwgdHhCdWYubGVuZ3RoIC0gNCk7XG4gIHJldHVybiB0eEJ1Zjtcbn1cbmV4cG9ydHMuZGVmYXVsdExvY2t0aW1lU2V0dGVyID0gZGVmYXVsdExvY2t0aW1lU2V0dGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiLi9jcnlwdG9cIik7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IGVjYyA9IHJlcXVpcmUoJ3Rpbnktc2VjcDI1NmsxJyk7XG5jb25zdCB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IHdpZiA9IHJlcXVpcmUoJ3dpZicpO1xuY29uc3QgVUlOVDI1Nl9UWVBFID0gdHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuY29uc3QgTkVUV09SS19UWVBFID0gdHlwZWZvcmNlLmNvbXBpbGUoe1xuICAgIHdpZjogdHlwZWZvcmNlLlVJbnQ4LFxuICAgIGJpcDMyOiB7XG4gICAgICAgIHB1YmxpYzogdHlwZWZvcmNlLlVJbnQzMixcbiAgICAgICAgcHJpdmF0ZTogdHlwZWZvcmNlLlVJbnQzMixcbiAgICB9LFxufSk7XG5jb25zdCBCSVRDT0lOID0ge1xuICAgIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgICBiZWNoMzI6ICdiYycsXG4gICAgYmlwMzI6IHtcbiAgICAgICAgcHVibGljOiAweDA0ODhiMjFlLFxuICAgICAgICBwcml2YXRlOiAweDA0ODhhZGU0LFxuICAgIH0sXG4gICAgcHViS2V5SGFzaDogMHgwMCxcbiAgICBzY3JpcHRIYXNoOiAweDA1LFxuICAgIHdpZjogMHg4MCxcbn07XG5jb25zdCBISUdIRVNUX0JJVCA9IDB4ODAwMDAwMDA7XG5jb25zdCBVSU5UMzFfTUFYID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcbmZ1bmN0aW9uIEJJUDMyUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZWZvcmNlLlN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubWF0Y2goL14obVxcLyk/KFxcZCsnP1xcLykqXFxkKyc/JC8pICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIFVJbnQzMSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlZm9yY2UuVUludDMyKHZhbHVlKSAmJiB2YWx1ZSA8PSBVSU5UMzFfTUFYO1xufVxuY2xhc3MgQklQMzIge1xuICAgIGNvbnN0cnVjdG9yKF9fRCwgX19RLCBjaGFpbkNvZGUsIG5ldHdvcmssIF9fREVQVEggPSAwLCBfX0lOREVYID0gMCwgX19QQVJFTlRfRklOR0VSUFJJTlQgPSAweDAwMDAwMDAwKSB7XG4gICAgICAgIHRoaXMuX19EID0gX19EO1xuICAgICAgICB0aGlzLl9fUSA9IF9fUTtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBjaGFpbkNvZGU7XG4gICAgICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIHRoaXMuX19ERVBUSCA9IF9fREVQVEg7XG4gICAgICAgIHRoaXMuX19JTkRFWCA9IF9fSU5ERVg7XG4gICAgICAgIHRoaXMuX19QQVJFTlRfRklOR0VSUFJJTlQgPSBfX1BBUkVOVF9GSU5HRVJQUklOVDtcbiAgICAgICAgdHlwZWZvcmNlKE5FVFdPUktfVFlQRSwgbmV0d29yayk7XG4gICAgICAgIHRoaXMubG93UiA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fREVQVEg7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19JTkRFWDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX1BBUkVOVF9GSU5HRVJQUklOVDtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19RID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9fUSA9IGVjYy5wb2ludEZyb21TY2FsYXIodGhpcy5fX0QsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fX1E7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0Q7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmhhc2gxNjAodGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICBnZXQgZmluZ2VycHJpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIuc2xpY2UoMCwgNCk7XG4gICAgfVxuICAgIC8vIFByaXZhdGUgPT09IG5vdCBuZXV0ZXJlZFxuICAgIC8vIFB1YmxpYyA9PT0gbmV1dGVyZWRcbiAgICBpc05ldXRlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0QgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbmV1dGVyZWQoKSB7XG4gICAgICAgIHJldHVybiBmcm9tUHVibGljS2V5TG9jYWwodGhpcy5wdWJsaWNLZXksIHRoaXMuY2hhaW5Db2RlLCB0aGlzLm5ldHdvcmssIHRoaXMuZGVwdGgsIHRoaXMuaW5kZXgsIHRoaXMucGFyZW50RmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICB0b0Jhc2U1OCgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICF0aGlzLmlzTmV1dGVyZWQoKVxuICAgICAgICAgICAgPyBuZXR3b3JrLmJpcDMyLnByaXZhdGVcbiAgICAgICAgICAgIDogbmV0d29yay5iaXAzMi5wdWJsaWM7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg3OCk7XG4gICAgICAgIC8vIDQgYnl0ZXM6IHZlcnNpb24gYnl0ZXNcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodmVyc2lvbiwgMCk7XG4gICAgICAgIC8vIDEgYnl0ZTogZGVwdGg6IDB4MDAgZm9yIG1hc3RlciBub2RlcywgMHgwMSBmb3IgbGV2ZWwtMSBkZXNjZW5kYW50cywgLi4uLlxuICAgICAgICBidWZmZXIud3JpdGVVSW50OCh0aGlzLmRlcHRoLCA0KTtcbiAgICAgICAgLy8gNCBieXRlczogdGhlIGZpbmdlcnByaW50IG9mIHRoZSBwYXJlbnQncyBrZXkgKDB4MDAwMDAwMDAgaWYgbWFzdGVyIGtleSlcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5wYXJlbnRGaW5nZXJwcmludCwgNSk7XG4gICAgICAgIC8vIDQgYnl0ZXM6IGNoaWxkIG51bWJlci4gVGhpcyBpcyB0aGUgbnVtYmVyIGkgaW4geGkgPSB4cGFyL2ksIHdpdGggeGkgdGhlIGtleSBiZWluZyBzZXJpYWxpemVkLlxuICAgICAgICAvLyBUaGlzIGlzIGVuY29kZWQgaW4gYmlnIGVuZGlhbi4gKDB4MDAwMDAwMDAgaWYgbWFzdGVyIGtleSlcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5pbmRleCwgOSk7XG4gICAgICAgIC8vIDMyIGJ5dGVzOiB0aGUgY2hhaW4gY29kZVxuICAgICAgICB0aGlzLmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpO1xuICAgICAgICAvLyAzMyBieXRlczogdGhlIHB1YmxpYyBrZXkgb3IgcHJpdmF0ZSBrZXkgZGF0YVxuICAgICAgICBpZiAoIXRoaXMuaXNOZXV0ZXJlZCgpKSB7XG4gICAgICAgICAgICAvLyAweDAwICsgayBmb3IgcHJpdmF0ZSBrZXlzXG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50OCgwLCA0NSk7XG4gICAgICAgICAgICB0aGlzLnByaXZhdGVLZXkuY29weShidWZmZXIsIDQ2KTtcbiAgICAgICAgICAgIC8vIDMzIGJ5dGVzOiB0aGUgcHVibGljIGtleVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gWDkuNjIgZW5jb2RpbmcgZm9yIHB1YmxpYyBrZXlzXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleS5jb3B5KGJ1ZmZlciwgNDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRvV0lGKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgcmV0dXJuIHdpZi5lbmNvZGUodGhpcy5uZXR3b3JrLndpZiwgdGhpcy5wcml2YXRlS2V5LCB0cnVlKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzMi5tZWRpYXdpa2kjY2hpbGQta2V5LWRlcml2YXRpb24tY2tkLWZ1bmN0aW9uc1xuICAgIGRlcml2ZShpbmRleCkge1xuICAgICAgICB0eXBlZm9yY2UodHlwZWZvcmNlLlVJbnQzMiwgaW5kZXgpO1xuICAgICAgICBjb25zdCBpc0hhcmRlbmVkID0gaW5kZXggPj0gSElHSEVTVF9CSVQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzcpO1xuICAgICAgICAvLyBIYXJkZW5lZCBjaGlsZFxuICAgICAgICBpZiAoaXNIYXJkZW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXV0ZXJlZCgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXkgZm9yIGhhcmRlbmVkIGNoaWxkIGtleScpO1xuICAgICAgICAgICAgLy8gZGF0YSA9IDB4MDAgfHwgc2VyMjU2KGtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgICAgICAgICAgZGF0YVswXSA9IDB4MDA7XG4gICAgICAgICAgICB0aGlzLnByaXZhdGVLZXkuY29weShkYXRhLCAxKTtcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJCRShpbmRleCwgMzMpO1xuICAgICAgICAgICAgLy8gTm9ybWFsIGNoaWxkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkYXRhID0gc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgICAgICAgICAvLyAgICAgID0gc2VyUChLcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIHRoaXMucHVibGljS2V5LmNvcHkoZGF0YSwgMCk7XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyQkUoaW5kZXgsIDMzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gY3J5cHRvLmhtYWNTSEE1MTIodGhpcy5jaGFpbkNvZGUsIGRhdGEpO1xuICAgICAgICBjb25zdCBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuICAgICAgICBjb25zdCBJUiA9IEkuc2xpY2UoMzIpO1xuICAgICAgICAvLyBpZiBwYXJzZTI1NihJTCkgPj0gbiwgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICAgIGlmICghZWNjLmlzUHJpdmF0ZShJTCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgLy8gUHJpdmF0ZSBwYXJlbnQga2V5IC0+IHByaXZhdGUgY2hpbGQga2V5XG4gICAgICAgIGxldCBoZDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmV1dGVyZWQoKSkge1xuICAgICAgICAgICAgLy8ga2kgPSBwYXJzZTI1NihJTCkgKyBrcGFyIChtb2QgbilcbiAgICAgICAgICAgIGNvbnN0IGtpID0gZWNjLnByaXZhdGVBZGQodGhpcy5wcml2YXRlS2V5LCBJTCk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGtpID09IDAsIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgICAgICAgaWYgKGtpID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICBoZCA9IGZyb21Qcml2YXRlS2V5TG9jYWwoa2ksIElSLCB0aGlzLm5ldHdvcmssIHRoaXMuZGVwdGggKyAxLCBpbmRleCwgdGhpcy5maW5nZXJwcmludC5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICAgICAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gS2kgPSBwb2ludChwYXJzZTI1NihJTCkpICsgS3BhclxuICAgICAgICAgICAgLy8gICAgPSBHKklMICsgS3BhclxuICAgICAgICAgICAgY29uc3QgS2kgPSBlY2MucG9pbnRBZGRTY2FsYXIodGhpcy5wdWJsaWNLZXksIElMLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgS2kgaXMgdGhlIHBvaW50IGF0IGluZmluaXR5LCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgICAgICAgIGlmIChLaSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGhkID0gZnJvbVB1YmxpY0tleUxvY2FsKEtpLCBJUiwgdGhpcy5uZXR3b3JrLCB0aGlzLmRlcHRoICsgMSwgaW5kZXgsIHRoaXMuZmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGQ7XG4gICAgfVxuICAgIGRlcml2ZUhhcmRlbmVkKGluZGV4KSB7XG4gICAgICAgIHR5cGVmb3JjZShVSW50MzEsIGluZGV4KTtcbiAgICAgICAgLy8gT25seSBkZXJpdmVzIGhhcmRlbmVkIHByaXZhdGUga2V5cyBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIEhJR0hFU1RfQklUKTtcbiAgICB9XG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHR5cGVmb3JjZShCSVAzMlBhdGgsIHBhdGgpO1xuICAgICAgICBsZXQgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoc3BsaXRQYXRoWzBdID09PSAnbScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudEZpbmdlcnByaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG1hc3RlciwgZ290IGNoaWxkJyk7XG4gICAgICAgICAgICBzcGxpdFBhdGggPSBzcGxpdFBhdGguc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aC5yZWR1Y2UoKHByZXZIZCwgaW5kZXhTdHIpID0+IHtcbiAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgIGlmIChpbmRleFN0ci5zbGljZSgtMSkgPT09IGAnYCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIuc2xpY2UoMCwgLTEpLCAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIZC5kZXJpdmVIYXJkZW5lZChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIZC5kZXJpdmUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgc2lnbihoYXNoLCBsb3dSKSB7XG4gICAgICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmIChsb3dSID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBsb3dSID0gdGhpcy5sb3dSO1xuICAgICAgICBpZiAobG93UiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBlY2Muc2lnbihoYXNoLCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNpZyA9IGVjYy5zaWduKGhhc2gsIHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYURhdGEgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gaWYgZmlyc3QgdHJ5IGlzIGxvd1IsIHNraXAgdGhlIGxvb3BcbiAgICAgICAgICAgIC8vIGZvciBzZWNvbmQgdHJ5IGFuZCBvbiwgYWRkIGV4dHJhIGVudHJvcHkgY291bnRpbmcgdXBcbiAgICAgICAgICAgIHdoaWxlIChzaWdbMF0gPiAweDdmKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgICAgIGV4dHJhRGF0YS53cml0ZVVJbnRMRShjb3VudGVyLCAwLCA2KTtcbiAgICAgICAgICAgICAgICBzaWcgPSBlY2Muc2lnbldpdGhFbnRyb3B5KGhhc2gsIHRoaXMucHJpdmF0ZUtleSwgZXh0cmFEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gZWNjLnZlcmlmeShoYXNoLCB0aGlzLnB1YmxpY0tleSwgc2lnbmF0dXJlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQmFzZTU4KGluU3RyaW5nLCBuZXR3b3JrKSB7XG4gICAgY29uc3QgYnVmZmVyID0gYnM1OGNoZWNrLmRlY29kZShpblN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDc4KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBCSVRDT0lOO1xuICAgIC8vIDQgYnl0ZXM6IHZlcnNpb24gYnl0ZXNcbiAgICBjb25zdCB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKTtcbiAgICBpZiAodmVyc2lvbiAhPT0gbmV0d29yay5iaXAzMi5wcml2YXRlICYmIHZlcnNpb24gIT09IG5ldHdvcmsuYmlwMzIucHVibGljKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5ldHdvcmsgdmVyc2lvbicpO1xuICAgIC8vIDEgYnl0ZTogZGVwdGg6IDB4MDAgZm9yIG1hc3RlciBub2RlcywgMHgwMSBmb3IgbGV2ZWwtMSBkZXNjZW5kYW50cywgLi4uXG4gICAgY29uc3QgZGVwdGggPSBidWZmZXJbNF07XG4gICAgLy8gNCBieXRlczogdGhlIGZpbmdlcnByaW50IG9mIHRoZSBwYXJlbnQncyBrZXkgKDB4MDAwMDAwMDAgaWYgbWFzdGVyIGtleSlcbiAgICBjb25zdCBwYXJlbnRGaW5nZXJwcmludCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoNSk7XG4gICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgIGlmIChwYXJlbnRGaW5nZXJwcmludCAhPT0gMHgwMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyZW50IGZpbmdlcnByaW50Jyk7XG4gICAgfVxuICAgIC8vIDQgYnl0ZXM6IGNoaWxkIG51bWJlci4gVGhpcyBpcyB0aGUgbnVtYmVyIGkgaW4geGkgPSB4cGFyL2ksIHdpdGggeGkgdGhlIGtleSBiZWluZyBzZXJpYWxpemVkLlxuICAgIC8vIFRoaXMgaXMgZW5jb2RlZCBpbiBNU0Igb3JkZXIuICgweDAwMDAwMDAwIGlmIG1hc3RlciBrZXkpXG4gICAgY29uc3QgaW5kZXggPSBidWZmZXIucmVhZFVJbnQzMkJFKDkpO1xuICAgIGlmIChkZXB0aCA9PT0gMCAmJiBpbmRleCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbmRleCcpO1xuICAgIC8vIDMyIGJ5dGVzOiB0aGUgY2hhaW4gY29kZVxuICAgIGNvbnN0IGNoYWluQ29kZSA9IGJ1ZmZlci5zbGljZSgxMywgNDUpO1xuICAgIGxldCBoZDtcbiAgICAvLyAzMyBieXRlczogcHJpdmF0ZSBrZXkgZGF0YSAoMHgwMCArIGspXG4gICAgaWYgKHZlcnNpb24gPT09IG5ldHdvcmsuYmlwMzIucHJpdmF0ZSkge1xuICAgICAgICBpZiAoYnVmZmVyLnJlYWRVSW50OCg0NSkgIT09IDB4MDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGNvbnN0IGsgPSBidWZmZXIuc2xpY2UoNDYsIDc4KTtcbiAgICAgICAgaGQgPSBmcm9tUHJpdmF0ZUtleUxvY2FsKGssIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCk7XG4gICAgICAgIC8vIDMzIGJ5dGVzOiBwdWJsaWMga2V5IGRhdGEgKDB4MDIgKyBYIG9yIDB4MDMgKyBYKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgWCA9IGJ1ZmZlci5zbGljZSg0NSwgNzgpO1xuICAgICAgICBoZCA9IGZyb21QdWJsaWNLZXlMb2NhbChYLCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICByZXR1cm4gaGQ7XG59XG5leHBvcnRzLmZyb21CYXNlNTggPSBmcm9tQmFzZTU4O1xuZnVuY3Rpb24gZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrKSB7XG4gICAgcmV0dXJuIGZyb21Qcml2YXRlS2V5TG9jYWwocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrKTtcbn1cbmV4cG9ydHMuZnJvbVByaXZhdGVLZXkgPSBmcm9tUHJpdmF0ZUtleTtcbmZ1bmN0aW9uIGZyb21Qcml2YXRlS2V5TG9jYWwocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrLCBkZXB0aCwgaW5kZXgsIHBhcmVudEZpbmdlcnByaW50KSB7XG4gICAgdHlwZWZvcmNlKHtcbiAgICAgICAgcHJpdmF0ZUtleTogVUlOVDI1Nl9UWVBFLFxuICAgICAgICBjaGFpbkNvZGU6IFVJTlQyNTZfVFlQRSxcbiAgICB9LCB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9KTtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBCSVRDT0lOO1xuICAgIGlmICghZWNjLmlzUHJpdmF0ZShwcml2YXRlS2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBrZXkgbm90IGluIHJhbmdlIFsxLCBuKScpO1xuICAgIHJldHVybiBuZXcgQklQMzIocHJpdmF0ZUtleSwgdW5kZWZpbmVkLCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xufVxuZnVuY3Rpb24gZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yaykge1xuICAgIHJldHVybiBmcm9tUHVibGljS2V5TG9jYWwocHVibGljS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmspO1xufVxuZXhwb3J0cy5mcm9tUHVibGljS2V5ID0gZnJvbVB1YmxpY0tleTtcbmZ1bmN0aW9uIGZyb21QdWJsaWNLZXlMb2NhbChwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCkge1xuICAgIHR5cGVmb3JjZSh7XG4gICAgICAgIHB1YmxpY0tleTogdHlwZWZvcmNlLkJ1ZmZlck4oMzMpLFxuICAgICAgICBjaGFpbkNvZGU6IFVJTlQyNTZfVFlQRSxcbiAgICB9LCB7IHB1YmxpY0tleSwgY2hhaW5Db2RlIH0pO1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IEJJVENPSU47XG4gICAgLy8gdmVyaWZ5IHRoZSBYIGNvb3JkaW5hdGUgaXMgYSBwb2ludCBvbiB0aGUgY3VydmVcbiAgICBpZiAoIWVjYy5pc1BvaW50KHB1YmxpY0tleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiB0aGUgY3VydmUnKTtcbiAgICByZXR1cm4gbmV3IEJJUDMyKHVuZGVmaW5lZCwgcHVibGljS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xufVxuZnVuY3Rpb24gZnJvbVNlZWQoc2VlZCwgbmV0d29yaykge1xuICAgIHR5cGVmb3JjZSh0eXBlZm9yY2UuQnVmZmVyLCBzZWVkKTtcbiAgICBpZiAoc2VlZC5sZW5ndGggPCAxNilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VlZCBzaG91bGQgYmUgYXQgbGVhc3QgMTI4IGJpdHMnKTtcbiAgICBpZiAoc2VlZC5sZW5ndGggPiA2NClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VlZCBzaG91bGQgYmUgYXQgbW9zdCA1MTIgYml0cycpO1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IEJJVENPSU47XG4gICAgY29uc3QgSSA9IGNyeXB0by5obWFjU0hBNTEyKEJ1ZmZlci5mcm9tKCdCaXRjb2luIHNlZWQnLCAndXRmOCcpLCBzZWVkKTtcbiAgICBjb25zdCBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuICAgIGNvbnN0IElSID0gSS5zbGljZSgzMik7XG4gICAgcmV0dXJuIGZyb21Qcml2YXRlS2V5KElMLCBJUiwgbmV0d29yayk7XG59XG5leHBvcnRzLmZyb21TZWVkID0gZnJvbVNlZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xuY29uc3QgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJyk7XG5mdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuICAgIGNvbnN0IHNoYTI1Nkhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGJ1ZmZlcilcbiAgICAgICAgLmRpZ2VzdCgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKCdybWQxNjAnKVxuICAgICAgICAgICAgLnVwZGF0ZShzaGEyNTZIYXNoKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKCdyaXBlbWQxNjAnKVxuICAgICAgICAgICAgLnVwZGF0ZShzaGEyNTZIYXNoKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuaGFzaDE2MCA9IGhhc2gxNjA7XG5mdW5jdGlvbiBobWFjU0hBNTEyKGtleSwgZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIbWFjKCdzaGE1MTInLCBrZXkpXG4gICAgICAgIC51cGRhdGUoZGF0YSlcbiAgICAgICAgLmRpZ2VzdCgpO1xufVxuZXhwb3J0cy5obWFjU0hBNTEyID0gaG1hY1NIQTUxMjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpcDMyXzEgPSByZXF1aXJlKFwiLi9iaXAzMlwiKTtcbmV4cG9ydHMuZnJvbVNlZWQgPSBiaXAzMl8xLmZyb21TZWVkO1xuZXhwb3J0cy5mcm9tQmFzZTU4ID0gYmlwMzJfMS5mcm9tQmFzZTU4O1xuZXhwb3J0cy5mcm9tUHVibGljS2V5ID0gYmlwMzJfMS5mcm9tUHVibGljS2V5O1xuZXhwb3J0cy5mcm9tUHJpdmF0ZUtleSA9IGJpcDMyXzEuZnJvbVByaXZhdGVLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGJyb3dzZXJpZnkgYnkgZGVmYXVsdCBvbmx5IHB1bGxzIGluIGZpbGVzIHRoYXQgYXJlIGhhcmQgY29kZWQgaW4gcmVxdWlyZXNcbi8vIEluIG9yZGVyIG9mIGxhc3QgdG8gZmlyc3QgaW4gdGhpcyBmaWxlLCB0aGUgZGVmYXVsdCB3b3JkbGlzdCB3aWxsIGJlIGNob3NlblxuLy8gYmFzZWQgb24gd2hhdCBpcyBwcmVzZW50LiAoQnVuZGxlcyBtYXkgcmVtb3ZlIHdvcmRsaXN0cyB0aGV5IGRvbid0IG5lZWQpXG5jb25zdCB3b3JkbGlzdHMgPSB7fTtcbmV4cG9ydHMud29yZGxpc3RzID0gd29yZGxpc3RzO1xubGV0IF9kZWZhdWx0O1xuZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0O1xudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jaGluZXNlX3NpbXBsaWZpZWQuanNvbicpO1xuICAgIHdvcmRsaXN0cy5jaGluZXNlX3NpbXBsaWZpZWQgPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jaGluZXNlX3RyYWRpdGlvbmFsLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuY2hpbmVzZV90cmFkaXRpb25hbCA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2tvcmVhbi5qc29uJyk7XG4gICAgd29yZGxpc3RzLmtvcmVhbiA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2ZyZW5jaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmZyZW5jaCA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2l0YWxpYW4uanNvbicpO1xuICAgIHdvcmRsaXN0cy5pdGFsaWFuID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvc3BhbmlzaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLnNwYW5pc2ggPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9qYXBhbmVzZS5qc29uJyk7XG4gICAgd29yZGxpc3RzLmphcGFuZXNlID0gX2RlZmF1bHQ7XG4gICAgd29yZGxpc3RzLkpBID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvZW5nbGlzaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmVuZ2xpc2ggPSBfZGVmYXVsdDtcbiAgICB3b3JkbGlzdHMuRU4gPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xuY29uc3QgcGJrZGYyXzEgPSByZXF1aXJlKFwicGJrZGYyXCIpO1xuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIik7XG5jb25zdCBfd29yZGxpc3RzXzEgPSByZXF1aXJlKFwiLi9fd29yZGxpc3RzXCIpO1xubGV0IERFRkFVTFRfV09SRExJU1QgPSBfd29yZGxpc3RzXzEuX2RlZmF1bHQ7XG5jb25zdCBJTlZBTElEX01ORU1PTklDID0gJ0ludmFsaWQgbW5lbW9uaWMnO1xuY29uc3QgSU5WQUxJRF9FTlRST1BZID0gJ0ludmFsaWQgZW50cm9weSc7XG5jb25zdCBJTlZBTElEX0NIRUNLU1VNID0gJ0ludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW0nO1xuY29uc3QgV09SRExJU1RfUkVRVUlSRUQgPSAnQSB3b3JkbGlzdCBpcyByZXF1aXJlZCBidXQgYSBkZWZhdWx0IGNvdWxkIG5vdCBiZSBmb3VuZC5cXG4nICtcbiAgICAnUGxlYXNlIGV4cGxpY2l0bHkgcGFzcyBhIDIwNDggd29yZCBhcnJheSBleHBsaWNpdGx5Lic7XG5mdW5jdGlvbiBscGFkKHN0ciwgcGFkU3RyaW5nLCBsZW5ndGgpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgc3RyID0gcGFkU3RyaW5nICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBiaW5hcnlUb0J5dGUoYmluKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGJpbiwgMik7XG59XG5mdW5jdGlvbiBieXRlc1RvQmluYXJ5KGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzLm1hcCh4ID0+IGxwYWQoeC50b1N0cmluZygyKSwgJzAnLCA4KSkuam9pbignJyk7XG59XG5mdW5jdGlvbiBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weUJ1ZmZlcikge1xuICAgIGNvbnN0IEVOVCA9IGVudHJvcHlCdWZmZXIubGVuZ3RoICogODtcbiAgICBjb25zdCBDUyA9IEVOVCAvIDMyO1xuICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGVudHJvcHlCdWZmZXIpXG4gICAgICAgIC5kaWdlc3QoKTtcbiAgICByZXR1cm4gYnl0ZXNUb0JpbmFyeShbLi4uaGFzaF0pLnNsaWNlKDAsIENTKTtcbn1cbmZ1bmN0aW9uIHNhbHQocGFzc3dvcmQpIHtcbiAgICByZXR1cm4gJ21uZW1vbmljJyArIChwYXNzd29yZCB8fCAnJyk7XG59XG5mdW5jdGlvbiBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWMsIHBhc3N3b3JkKSB7XG4gICAgY29uc3QgbW5lbW9uaWNCdWZmZXIgPSBCdWZmZXIuZnJvbSgobW5lbW9uaWMgfHwgJycpLm5vcm1hbGl6ZSgnTkZLRCcpLCAndXRmOCcpO1xuICAgIGNvbnN0IHNhbHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzYWx0KChwYXNzd29yZCB8fCAnJykubm9ybWFsaXplKCdORktEJykpLCAndXRmOCcpO1xuICAgIHJldHVybiBwYmtkZjJfMS5wYmtkZjJTeW5jKG1uZW1vbmljQnVmZmVyLCBzYWx0QnVmZmVyLCAyMDQ4LCA2NCwgJ3NoYTUxMicpO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBtbmVtb25pY1RvU2VlZFN5bmM7XG5mdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3dvcmQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWNCdWZmZXIgPSBCdWZmZXIuZnJvbSgobW5lbW9uaWMgfHwgJycpLm5vcm1hbGl6ZSgnTkZLRCcpLCAndXRmOCcpO1xuICAgICAgICAgICAgY29uc3Qgc2FsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNhbHQoKHBhc3N3b3JkIHx8ICcnKS5ub3JtYWxpemUoJ05GS0QnKSksICd1dGY4Jyk7XG4gICAgICAgICAgICBwYmtkZjJfMS5wYmtkZjIobW5lbW9uaWNCdWZmZXIsIHNhbHRCdWZmZXIsIDIwNDgsIDY0LCAnc2hhNTEyJywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZCA9IG1uZW1vbmljVG9TZWVkO1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgd29yZGxpc3QgPSB3b3JkbGlzdCB8fCBERUZBVUxUX1dPUkRMSVNUO1xuICAgIGlmICghd29yZGxpc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFdPUkRMSVNUX1JFUVVJUkVEKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSAobW5lbW9uaWMgfHwgJycpLm5vcm1hbGl6ZSgnTkZLRCcpLnNwbGl0KCcgJyk7XG4gICAgaWYgKHdvcmRzLmxlbmd0aCAlIDMgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX01ORU1PTklDKTtcbiAgICAvLyBjb252ZXJ0IHdvcmQgaW5kaWNlcyB0byAxMSBiaXQgYmluYXJ5IHN0cmluZ3NcbiAgICBjb25zdCBiaXRzID0gd29yZHNcbiAgICAgICAgLm1hcCh3b3JkID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB3b3JkbGlzdC5pbmRleE9mKHdvcmQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpO1xuICAgICAgICByZXR1cm4gbHBhZChpbmRleC50b1N0cmluZygyKSwgJzAnLCAxMSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIC8vIHNwbGl0IHRoZSBiaW5hcnkgc3RyaW5nIGludG8gRU5UL0NTXG4gICAgY29uc3QgZGl2aWRlckluZGV4ID0gTWF0aC5mbG9vcihiaXRzLmxlbmd0aCAvIDMzKSAqIDMyO1xuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gYml0cy5zbGljZSgwLCBkaXZpZGVySW5kZXgpO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGJpdHMuc2xpY2UoZGl2aWRlckluZGV4KTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGNoZWNrc3VtIGFuZCBjb21wYXJlXG4gICAgY29uc3QgZW50cm9weUJ5dGVzID0gZW50cm9weUJpdHMubWF0Y2goLyguezEsOH0pL2cpLm1hcChiaW5hcnlUb0J5dGUpO1xuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoIDwgMTYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoICUgNCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgY29uc3QgZW50cm9weSA9IEJ1ZmZlci5mcm9tKGVudHJvcHlCeXRlcyk7XG4gICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSk7XG4gICAgaWYgKG5ld0NoZWNrc3VtICE9PSBjaGVja3N1bUJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0NIRUNLU1VNKTtcbiAgICByZXR1cm4gZW50cm9weS50b1N0cmluZygnaGV4Jyk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGVudHJvcHkpKVxuICAgICAgICBlbnRyb3B5ID0gQnVmZmVyLmZyb20oZW50cm9weSwgJ2hleCcpO1xuICAgIHdvcmRsaXN0ID0gd29yZGxpc3QgfHwgREVGQVVMVF9XT1JETElTVDtcbiAgICBpZiAoIXdvcmRsaXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihXT1JETElTVF9SRVFVSVJFRCk7XG4gICAgfVxuICAgIC8vIDEyOCA8PSBFTlQgPD0gMjU2XG4gICAgaWYgKGVudHJvcHkubGVuZ3RoIDwgMTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICBpZiAoZW50cm9weS5sZW5ndGggPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCAlIDQgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICBjb25zdCBlbnRyb3B5Qml0cyA9IGJ5dGVzVG9CaW5hcnkoWy4uLmVudHJvcHldKTtcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSk7XG4gICAgY29uc3QgYml0cyA9IGVudHJvcHlCaXRzICsgY2hlY2tzdW1CaXRzO1xuICAgIGNvbnN0IGNodW5rcyA9IGJpdHMubWF0Y2goLyguezEsMTF9KS9nKTtcbiAgICBjb25zdCB3b3JkcyA9IGNodW5rcy5tYXAoYmluYXJ5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiaW5hcnlUb0J5dGUoYmluYXJ5KTtcbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0W2luZGV4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnIC8vIEphcGFuZXNlIHdvcmRsaXN0XG4gICAgICAgID8gd29yZHMuam9pbignXFx1MzAwMCcpXG4gICAgICAgIDogd29yZHMuam9pbignICcpO1xufVxuZXhwb3J0cy5lbnRyb3B5VG9NbmVtb25pYyA9IGVudHJvcHlUb01uZW1vbmljO1xuZnVuY3Rpb24gZ2VuZXJhdGVNbmVtb25pYyhzdHJlbmd0aCwgcm5nLCB3b3JkbGlzdCkge1xuICAgIHN0cmVuZ3RoID0gc3RyZW5ndGggfHwgMTI4O1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgcm5nID0gcm5nIHx8IHJhbmRvbUJ5dGVzO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhybmcoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1uZW1vbmljID0gZ2VuZXJhdGVNbmVtb25pYztcbmZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNbmVtb25pYyA9IHZhbGlkYXRlTW5lbW9uaWM7XG5mdW5jdGlvbiBzZXREZWZhdWx0V29yZGxpc3QobGFuZ3VhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfd29yZGxpc3RzXzEud29yZGxpc3RzW2xhbmd1YWdlXTtcbiAgICBpZiAocmVzdWx0KVxuICAgICAgICBERUZBVUxUX1dPUkRMSVNUID0gcmVzdWx0O1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB3b3JkbGlzdCBmb3IgbGFuZ3VhZ2UgXCInICsgbGFuZ3VhZ2UgKyAnXCInKTtcbn1cbmV4cG9ydHMuc2V0RGVmYXVsdFdvcmRsaXN0ID0gc2V0RGVmYXVsdFdvcmRsaXN0O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFdvcmRsaXN0KCkge1xuICAgIGlmICghREVGQVVMVF9XT1JETElTVClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBEZWZhdWx0IFdvcmRsaXN0IHNldCcpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhfd29yZGxpc3RzXzEud29yZGxpc3RzKS5maWx0ZXIobGFuZyA9PiB7XG4gICAgICAgIGlmIChsYW5nID09PSAnSkEnIHx8IGxhbmcgPT09ICdFTicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBfd29yZGxpc3RzXzEud29yZGxpc3RzW2xhbmddLmV2ZXJ5KCh3b3JkLCBpbmRleCkgPT4gd29yZCA9PT0gREVGQVVMVF9XT1JETElTVFtpbmRleF0pO1xuICAgIH0pWzBdO1xufVxuZXhwb3J0cy5nZXREZWZhdWx0V29yZGxpc3QgPSBnZXREZWZhdWx0V29yZGxpc3Q7XG52YXIgX3dvcmRsaXN0c18yID0gcmVxdWlyZShcIi4vX3dvcmRsaXN0c1wiKTtcbmV4cG9ydHMud29yZGxpc3RzID0gX3dvcmRsaXN0c18yLndvcmRsaXN0cztcbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcIueahFwiLFxuICAgIFwi5LiAXCIsXG4gICAgXCLmmK9cIixcbiAgICBcIuWcqFwiLFxuICAgIFwi5LiNXCIsXG4gICAgXCLkuoZcIixcbiAgICBcIuaciVwiLFxuICAgIFwi5ZKMXCIsXG4gICAgXCLkurpcIixcbiAgICBcIui/mVwiLFxuICAgIFwi5LitXCIsXG4gICAgXCLlpKdcIixcbiAgICBcIuS4ulwiLFxuICAgIFwi5LiKXCIsXG4gICAgXCLkuKpcIixcbiAgICBcIuWbvVwiLFxuICAgIFwi5oiRXCIsXG4gICAgXCLku6VcIixcbiAgICBcIuimgVwiLFxuICAgIFwi5LuWXCIsXG4gICAgXCLml7ZcIixcbiAgICBcIuadpVwiLFxuICAgIFwi55SoXCIsXG4gICAgXCLku6xcIixcbiAgICBcIueUn1wiLFxuICAgIFwi5YiwXCIsXG4gICAgXCLkvZxcIixcbiAgICBcIuWcsFwiLFxuICAgIFwi5LqOXCIsXG4gICAgXCLlh7pcIixcbiAgICBcIuWwsVwiLFxuICAgIFwi5YiGXCIsXG4gICAgXCLlr7lcIixcbiAgICBcIuaIkFwiLFxuICAgIFwi5LyaXCIsXG4gICAgXCLlj69cIixcbiAgICBcIuS4u1wiLFxuICAgIFwi5Y+RXCIsXG4gICAgXCLlubRcIixcbiAgICBcIuWKqFwiLFxuICAgIFwi5ZCMXCIsXG4gICAgXCLlt6VcIixcbiAgICBcIuS5n1wiLFxuICAgIFwi6IO9XCIsXG4gICAgXCLkuItcIixcbiAgICBcIui/h1wiLFxuICAgIFwi5a2QXCIsXG4gICAgXCLor7RcIixcbiAgICBcIuS6p1wiLFxuICAgIFwi56eNXCIsXG4gICAgXCLpnaJcIixcbiAgICBcIuiAjFwiLFxuICAgIFwi5pa5XCIsXG4gICAgXCLlkI5cIixcbiAgICBcIuWkmlwiLFxuICAgIFwi5a6aXCIsXG4gICAgXCLooYxcIixcbiAgICBcIuWtplwiLFxuICAgIFwi5rOVXCIsXG4gICAgXCLmiYBcIixcbiAgICBcIuawkVwiLFxuICAgIFwi5b6XXCIsXG4gICAgXCLnu49cIixcbiAgICBcIuWNgVwiLFxuICAgIFwi5LiJXCIsXG4gICAgXCLkuYtcIixcbiAgICBcIui/m1wiLFxuICAgIFwi552AXCIsXG4gICAgXCLnrYlcIixcbiAgICBcIumDqFwiLFxuICAgIFwi5bqmXCIsXG4gICAgXCLlrrZcIixcbiAgICBcIueUtVwiLFxuICAgIFwi5YqbXCIsXG4gICAgXCLph4xcIixcbiAgICBcIuWmglwiLFxuICAgIFwi5rC0XCIsXG4gICAgXCLljJZcIixcbiAgICBcIumrmFwiLFxuICAgIFwi6IeqXCIsXG4gICAgXCLkuoxcIixcbiAgICBcIueQhlwiLFxuICAgIFwi6LW3XCIsXG4gICAgXCLlsI9cIixcbiAgICBcIueJqVwiLFxuICAgIFwi546wXCIsXG4gICAgXCLlrp5cIixcbiAgICBcIuWKoFwiLFxuICAgIFwi6YePXCIsXG4gICAgXCLpg71cIixcbiAgICBcIuS4pFwiLFxuICAgIFwi5L2TXCIsXG4gICAgXCLliLZcIixcbiAgICBcIuaculwiLFxuICAgIFwi5b2TXCIsXG4gICAgXCLkvb9cIixcbiAgICBcIueCuVwiLFxuICAgIFwi5LuOXCIsXG4gICAgXCLkuJpcIixcbiAgICBcIuacrFwiLFxuICAgIFwi5Y67XCIsXG4gICAgXCLmiopcIixcbiAgICBcIuaAp1wiLFxuICAgIFwi5aW9XCIsXG4gICAgXCLlupRcIixcbiAgICBcIuW8gFwiLFxuICAgIFwi5a6DXCIsXG4gICAgXCLlkIhcIixcbiAgICBcIui/mFwiLFxuICAgIFwi5ZugXCIsXG4gICAgXCLnlLFcIixcbiAgICBcIuWFtlwiLFxuICAgIFwi5LqbXCIsXG4gICAgXCLnhLZcIixcbiAgICBcIuWJjVwiLFxuICAgIFwi5aSWXCIsXG4gICAgXCLlpKlcIixcbiAgICBcIuaUv1wiLFxuICAgIFwi5ZubXCIsXG4gICAgXCLml6VcIixcbiAgICBcIumCo1wiLFxuICAgIFwi56S+XCIsXG4gICAgXCLkuYlcIixcbiAgICBcIuS6i1wiLFxuICAgIFwi5bmzXCIsXG4gICAgXCLlvaJcIixcbiAgICBcIuebuFwiLFxuICAgIFwi5YWoXCIsXG4gICAgXCLooahcIixcbiAgICBcIumXtFwiLFxuICAgIFwi5qC3XCIsXG4gICAgXCLkuI5cIixcbiAgICBcIuWFs1wiLFxuICAgIFwi5ZCEXCIsXG4gICAgXCLph41cIixcbiAgICBcIuaWsFwiLFxuICAgIFwi57q/XCIsXG4gICAgXCLlhoVcIixcbiAgICBcIuaVsFwiLFxuICAgIFwi5q2jXCIsXG4gICAgXCLlv4NcIixcbiAgICBcIuWPjVwiLFxuICAgIFwi5L2gXCIsXG4gICAgXCLmmI5cIixcbiAgICBcIueci1wiLFxuICAgIFwi5Y6fXCIsXG4gICAgXCLlj4hcIixcbiAgICBcIuS5iFwiLFxuICAgIFwi5YipXCIsXG4gICAgXCLmr5RcIixcbiAgICBcIuaIllwiLFxuICAgIFwi5L2GXCIsXG4gICAgXCLotKhcIixcbiAgICBcIuawlFwiLFxuICAgIFwi56ysXCIsXG4gICAgXCLlkJFcIixcbiAgICBcIumBk1wiLFxuICAgIFwi5ZG9XCIsXG4gICAgXCLmraRcIixcbiAgICBcIuWPmFwiLFxuICAgIFwi5p2hXCIsXG4gICAgXCLlj6pcIixcbiAgICBcIuayoVwiLFxuICAgIFwi57uTXCIsXG4gICAgXCLop6NcIixcbiAgICBcIumXrlwiLFxuICAgIFwi5oSPXCIsXG4gICAgXCLlu7pcIixcbiAgICBcIuaciFwiLFxuICAgIFwi5YWsXCIsXG4gICAgXCLml6BcIixcbiAgICBcIuezu1wiLFxuICAgIFwi5YabXCIsXG4gICAgXCLlvohcIixcbiAgICBcIuaDhVwiLFxuICAgIFwi6ICFXCIsXG4gICAgXCLmnIBcIixcbiAgICBcIueri1wiLFxuICAgIFwi5LujXCIsXG4gICAgXCLmg7NcIixcbiAgICBcIuW3slwiLFxuICAgIFwi6YCaXCIsXG4gICAgXCLlubZcIixcbiAgICBcIuaPkFwiLFxuICAgIFwi55u0XCIsXG4gICAgXCLpophcIixcbiAgICBcIuWFmlwiLFxuICAgIFwi56iLXCIsXG4gICAgXCLlsZVcIixcbiAgICBcIuS6lFwiLFxuICAgIFwi5p6cXCIsXG4gICAgXCLmlplcIixcbiAgICBcIuixoVwiLFxuICAgIFwi5ZGYXCIsXG4gICAgXCLpnalcIixcbiAgICBcIuS9jVwiLFxuICAgIFwi5YWlXCIsXG4gICAgXCLluLhcIixcbiAgICBcIuaWh1wiLFxuICAgIFwi5oC7XCIsXG4gICAgXCLmrKFcIixcbiAgICBcIuWTgVwiLFxuICAgIFwi5byPXCIsXG4gICAgXCLmtLtcIixcbiAgICBcIuiuvlwiLFxuICAgIFwi5Y+KXCIsXG4gICAgXCLnrqFcIixcbiAgICBcIueJuVwiLFxuICAgIFwi5Lu2XCIsXG4gICAgXCLplb9cIixcbiAgICBcIuaxglwiLFxuICAgIFwi6ICBXCIsXG4gICAgXCLlpLRcIixcbiAgICBcIuWfulwiLFxuICAgIFwi6LWEXCIsXG4gICAgXCLovrlcIixcbiAgICBcIua1gVwiLFxuICAgIFwi6LevXCIsXG4gICAgXCLnuqdcIixcbiAgICBcIuWwkVwiLFxuICAgIFwi5Zu+XCIsXG4gICAgXCLlsbFcIixcbiAgICBcIue7n1wiLFxuICAgIFwi5o6lXCIsXG4gICAgXCLnn6VcIixcbiAgICBcIui+g1wiLFxuICAgIFwi5bCGXCIsXG4gICAgXCLnu4RcIixcbiAgICBcIuingVwiLFxuICAgIFwi6K6hXCIsXG4gICAgXCLliKtcIixcbiAgICBcIuWluVwiLFxuICAgIFwi5omLXCIsXG4gICAgXCLop5JcIixcbiAgICBcIuacn1wiLFxuICAgIFwi5qC5XCIsXG4gICAgXCLorrpcIixcbiAgICBcIui/kFwiLFxuICAgIFwi5YacXCIsXG4gICAgXCLmjIdcIixcbiAgICBcIuWHoFwiLFxuICAgIFwi5LmdXCIsXG4gICAgXCLljLpcIixcbiAgICBcIuW8ulwiLFxuICAgIFwi5pS+XCIsXG4gICAgXCLlhrNcIixcbiAgICBcIuilv1wiLFxuICAgIFwi6KKrXCIsXG4gICAgXCLlubJcIixcbiAgICBcIuWBmlwiLFxuICAgIFwi5b+FXCIsXG4gICAgXCLmiJhcIixcbiAgICBcIuWFiFwiLFxuICAgIFwi5ZueXCIsXG4gICAgXCLliJlcIixcbiAgICBcIuS7u1wiLFxuICAgIFwi5Y+WXCIsXG4gICAgXCLmja5cIixcbiAgICBcIuWkhFwiLFxuICAgIFwi6ZifXCIsXG4gICAgXCLljZdcIixcbiAgICBcIue7mVwiLFxuICAgIFwi6ImyXCIsXG4gICAgXCLlhYlcIixcbiAgICBcIumXqFwiLFxuICAgIFwi5Y2zXCIsXG4gICAgXCLkv51cIixcbiAgICBcIuayu1wiLFxuICAgIFwi5YyXXCIsXG4gICAgXCLpgKBcIixcbiAgICBcIueZvlwiLFxuICAgIFwi6KeEXCIsXG4gICAgXCLng61cIixcbiAgICBcIumihlwiLFxuICAgIFwi5LiDXCIsXG4gICAgXCLmtbdcIixcbiAgICBcIuWPo1wiLFxuICAgIFwi5LicXCIsXG4gICAgXCLlr7xcIixcbiAgICBcIuWZqFwiLFxuICAgIFwi5Y6LXCIsXG4gICAgXCLlv5dcIixcbiAgICBcIuS4llwiLFxuICAgIFwi6YeRXCIsXG4gICAgXCLlop5cIixcbiAgICBcIuS6iVwiLFxuICAgIFwi5rWOXCIsXG4gICAgXCLpmLZcIixcbiAgICBcIuayuVwiLFxuICAgIFwi5oCdXCIsXG4gICAgXCLmnK9cIixcbiAgICBcIuaegVwiLFxuICAgIFwi5LqkXCIsXG4gICAgXCLlj5dcIixcbiAgICBcIuiBlFwiLFxuICAgIFwi5LuAXCIsXG4gICAgXCLorqRcIixcbiAgICBcIuWFrVwiLFxuICAgIFwi5YWxXCIsXG4gICAgXCLmnYNcIixcbiAgICBcIuaUtlwiLFxuICAgIFwi6K+BXCIsXG4gICAgXCLmlLlcIixcbiAgICBcIua4hVwiLFxuICAgIFwi576OXCIsXG4gICAgXCLlho1cIixcbiAgICBcIumHh1wiLFxuICAgIFwi6L2sXCIsXG4gICAgXCLmm7RcIixcbiAgICBcIuWNlVwiLFxuICAgIFwi6aOOXCIsXG4gICAgXCLliIdcIixcbiAgICBcIuaJk1wiLFxuICAgIFwi55m9XCIsXG4gICAgXCLmlZlcIixcbiAgICBcIumAn1wiLFxuICAgIFwi6IqxXCIsXG4gICAgXCLluKZcIixcbiAgICBcIuWuiVwiLFxuICAgIFwi5Zy6XCIsXG4gICAgXCLouqtcIixcbiAgICBcIui9plwiLFxuICAgIFwi5L6LXCIsXG4gICAgXCLnnJ9cIixcbiAgICBcIuWKoVwiLFxuICAgIFwi5YW3XCIsXG4gICAgXCLkuIdcIixcbiAgICBcIuavj1wiLFxuICAgIFwi55uuXCIsXG4gICAgXCLoh7NcIixcbiAgICBcIui+vlwiLFxuICAgIFwi6LWwXCIsXG4gICAgXCLnp69cIixcbiAgICBcIuekulwiLFxuICAgIFwi6K6uXCIsXG4gICAgXCLlo7BcIixcbiAgICBcIuaKpVwiLFxuICAgIFwi5paXXCIsXG4gICAgXCLlroxcIixcbiAgICBcIuexu1wiLFxuICAgIFwi5YWrXCIsXG4gICAgXCLnprtcIixcbiAgICBcIuWNjlwiLFxuICAgIFwi5ZCNXCIsXG4gICAgXCLnoa5cIixcbiAgICBcIuaJjVwiLFxuICAgIFwi56eRXCIsXG4gICAgXCLlvKBcIixcbiAgICBcIuS/oVwiLFxuICAgIFwi6amsXCIsXG4gICAgXCLoioJcIixcbiAgICBcIuivnVwiLFxuICAgIFwi57GzXCIsXG4gICAgXCLmlbRcIixcbiAgICBcIuepulwiLFxuICAgIFwi5YWDXCIsXG4gICAgXCLlhrVcIixcbiAgICBcIuS7ilwiLFxuICAgIFwi6ZuGXCIsXG4gICAgXCLmuKlcIixcbiAgICBcIuS8oFwiLFxuICAgIFwi5ZyfXCIsXG4gICAgXCLorrhcIixcbiAgICBcIuatpVwiLFxuICAgIFwi576kXCIsXG4gICAgXCLlub9cIixcbiAgICBcIuefs1wiLFxuICAgIFwi6K6wXCIsXG4gICAgXCLpnIBcIixcbiAgICBcIuautVwiLFxuICAgIFwi56CUXCIsXG4gICAgXCLnlYxcIixcbiAgICBcIuaLiVwiLFxuICAgIFwi5p6XXCIsXG4gICAgXCLlvotcIixcbiAgICBcIuWPq1wiLFxuICAgIFwi5LiUXCIsXG4gICAgXCLnqbZcIixcbiAgICBcIuinglwiLFxuICAgIFwi6LaKXCIsXG4gICAgXCLnu4dcIixcbiAgICBcIuijhVwiLFxuICAgIFwi5b2xXCIsXG4gICAgXCLnrpdcIixcbiAgICBcIuS9jlwiLFxuICAgIFwi5oyBXCIsXG4gICAgXCLpn7NcIixcbiAgICBcIuS8l1wiLFxuICAgIFwi5LmmXCIsXG4gICAgXCLluINcIixcbiAgICBcIuWkjVwiLFxuICAgIFwi5a65XCIsXG4gICAgXCLlhL9cIixcbiAgICBcIumhu1wiLFxuICAgIFwi6ZmFXCIsXG4gICAgXCLllYZcIixcbiAgICBcIumdnlwiLFxuICAgIFwi6aqMXCIsXG4gICAgXCLov55cIixcbiAgICBcIuaWrVwiLFxuICAgIFwi5rexXCIsXG4gICAgXCLpmr5cIixcbiAgICBcIui/kVwiLFxuICAgIFwi55+/XCIsXG4gICAgXCLljYNcIixcbiAgICBcIuWRqFwiLFxuICAgIFwi5aeUXCIsXG4gICAgXCLntKBcIixcbiAgICBcIuaKgFwiLFxuICAgIFwi5aSHXCIsXG4gICAgXCLljYpcIixcbiAgICBcIuWKnlwiLFxuICAgIFwi6Z2SXCIsXG4gICAgXCLnnIFcIixcbiAgICBcIuWIl1wiLFxuICAgIFwi5LmgXCIsXG4gICAgXCLlk41cIixcbiAgICBcIue6plwiLFxuICAgIFwi5pSvXCIsXG4gICAgXCLoiKxcIixcbiAgICBcIuWPslwiLFxuICAgIFwi5oSfXCIsXG4gICAgXCLlirNcIixcbiAgICBcIuS+v1wiLFxuICAgIFwi5ZuiXCIsXG4gICAgXCLlvoBcIixcbiAgICBcIumFuFwiLFxuICAgIFwi5Y6GXCIsXG4gICAgXCLluIJcIixcbiAgICBcIuWFi1wiLFxuICAgIFwi5L2VXCIsXG4gICAgXCLpmaRcIixcbiAgICBcIua2iFwiLFxuICAgIFwi5p6EXCIsXG4gICAgXCLlupxcIixcbiAgICBcIuensFwiLFxuICAgIFwi5aSqXCIsXG4gICAgXCLlh4ZcIixcbiAgICBcIueyvlwiLFxuICAgIFwi5YC8XCIsXG4gICAgXCLlj7dcIixcbiAgICBcIueOh1wiLFxuICAgIFwi5pePXCIsXG4gICAgXCLnu7RcIixcbiAgICBcIuWIklwiLFxuICAgIFwi6YCJXCIsXG4gICAgXCLmoIdcIixcbiAgICBcIuWGmVwiLFxuICAgIFwi5a2YXCIsXG4gICAgXCLlgJlcIixcbiAgICBcIuavm1wiLFxuICAgIFwi5LqyXCIsXG4gICAgXCLlv6tcIixcbiAgICBcIuaViFwiLFxuICAgIFwi5pavXCIsXG4gICAgXCLpmaJcIixcbiAgICBcIuafpVwiLFxuICAgIFwi5rGfXCIsXG4gICAgXCLlnotcIixcbiAgICBcIuecvFwiLFxuICAgIFwi546LXCIsXG4gICAgXCLmjIlcIixcbiAgICBcIuagvFwiLFxuICAgIFwi5YW7XCIsXG4gICAgXCLmmJNcIixcbiAgICBcIue9rlwiLFxuICAgIFwi5rS+XCIsXG4gICAgXCLlsYJcIixcbiAgICBcIueJh1wiLFxuICAgIFwi5aeLXCIsXG4gICAgXCLljbRcIixcbiAgICBcIuS4k1wiLFxuICAgIFwi54q2XCIsXG4gICAgXCLogrJcIixcbiAgICBcIuWOglwiLFxuICAgIFwi5LqsXCIsXG4gICAgXCLor4ZcIixcbiAgICBcIumAglwiLFxuICAgIFwi5bGeXCIsXG4gICAgXCLlnIZcIixcbiAgICBcIuWMhVwiLFxuICAgIFwi54GrXCIsXG4gICAgXCLkvY9cIixcbiAgICBcIuiwg1wiLFxuICAgIFwi5ruhXCIsXG4gICAgXCLljr9cIixcbiAgICBcIuWxgFwiLFxuICAgIFwi54WnXCIsXG4gICAgXCLlj4JcIixcbiAgICBcIue6olwiLFxuICAgIFwi57uGXCIsXG4gICAgXCLlvJVcIixcbiAgICBcIuWQrFwiLFxuICAgIFwi6K+lXCIsXG4gICAgXCLpk4FcIixcbiAgICBcIuS7t1wiLFxuICAgIFwi5LilXCIsXG4gICAgXCLpppZcIixcbiAgICBcIuW6lVwiLFxuICAgIFwi5rayXCIsXG4gICAgXCLlrphcIixcbiAgICBcIuW+t1wiLFxuICAgIFwi6ZqPXCIsXG4gICAgXCLnl4VcIixcbiAgICBcIuiLj1wiLFxuICAgIFwi5aSxXCIsXG4gICAgXCLlsJRcIixcbiAgICBcIuatu1wiLFxuICAgIFwi6K6yXCIsXG4gICAgXCLphY1cIixcbiAgICBcIuWls1wiLFxuICAgIFwi6buEXCIsXG4gICAgXCLmjqhcIixcbiAgICBcIuaYvlwiLFxuICAgIFwi6LCIXCIsXG4gICAgXCLnvapcIixcbiAgICBcIuelnlwiLFxuICAgIFwi6Im6XCIsXG4gICAgXCLlkaJcIixcbiAgICBcIuW4rVwiLFxuICAgIFwi5ZCrXCIsXG4gICAgXCLkvIFcIixcbiAgICBcIuacm1wiLFxuICAgIFwi5a+GXCIsXG4gICAgXCLmiblcIixcbiAgICBcIuiQpVwiLFxuICAgIFwi6aG5XCIsXG4gICAgXCLpmLJcIixcbiAgICBcIuS4vlwiLFxuICAgIFwi55CDXCIsXG4gICAgXCLoi7FcIixcbiAgICBcIuawp1wiLFxuICAgIFwi5Yq/XCIsXG4gICAgXCLlkYpcIixcbiAgICBcIuadjlwiLFxuICAgIFwi5Y+wXCIsXG4gICAgXCLokL1cIixcbiAgICBcIuacqFwiLFxuICAgIFwi5biuXCIsXG4gICAgXCLova5cIixcbiAgICBcIuegtFwiLFxuICAgIFwi5LqaXCIsXG4gICAgXCLluIhcIixcbiAgICBcIuWbtFwiLFxuICAgIFwi5rOoXCIsXG4gICAgXCLov5xcIixcbiAgICBcIuWtl1wiLFxuICAgIFwi5p2QXCIsXG4gICAgXCLmjpJcIixcbiAgICBcIuS+m1wiLFxuICAgIFwi5rKzXCIsXG4gICAgXCLmgIFcIixcbiAgICBcIuWwgVwiLFxuICAgIFwi5Y+mXCIsXG4gICAgXCLmlr1cIixcbiAgICBcIuWHj1wiLFxuICAgIFwi5qCRXCIsXG4gICAgXCLmurZcIixcbiAgICBcIuaAjlwiLFxuICAgIFwi5q2iXCIsXG4gICAgXCLmoYhcIixcbiAgICBcIuiogFwiLFxuICAgIFwi5aOrXCIsXG4gICAgXCLlnYdcIixcbiAgICBcIuatplwiLFxuICAgIFwi5Zu6XCIsXG4gICAgXCLlj7ZcIixcbiAgICBcIumxvFwiLFxuICAgIFwi5rOiXCIsXG4gICAgXCLop4ZcIixcbiAgICBcIuS7hVwiLFxuICAgIFwi6LS5XCIsXG4gICAgXCLntKdcIixcbiAgICBcIueIsVwiLFxuICAgIFwi5bemXCIsXG4gICAgXCLnq6BcIixcbiAgICBcIuaXqVwiLFxuICAgIFwi5pydXCIsXG4gICAgXCLlrrNcIixcbiAgICBcIue7rVwiLFxuICAgIFwi6L27XCIsXG4gICAgXCLmnI1cIixcbiAgICBcIuivlVwiLFxuICAgIFwi6aOfXCIsXG4gICAgXCLlhYVcIixcbiAgICBcIuWFtVwiLFxuICAgIFwi5rqQXCIsXG4gICAgXCLliKRcIixcbiAgICBcIuaKpFwiLFxuICAgIFwi5Y+4XCIsXG4gICAgXCLotrNcIixcbiAgICBcIuafkFwiLFxuICAgIFwi57uDXCIsXG4gICAgXCLlt65cIixcbiAgICBcIuiHtFwiLFxuICAgIFwi5p2/XCIsXG4gICAgXCLnlLBcIixcbiAgICBcIumZjVwiLFxuICAgIFwi6buRXCIsXG4gICAgXCLniq9cIixcbiAgICBcIui0n1wiLFxuICAgIFwi5Ye7XCIsXG4gICAgXCLojINcIixcbiAgICBcIue7p1wiLFxuICAgIFwi5YW0XCIsXG4gICAgXCLkvLxcIixcbiAgICBcIuS9mVwiLFxuICAgIFwi5Z2aXCIsXG4gICAgXCLmm7JcIixcbiAgICBcIui+k1wiLFxuICAgIFwi5L+uXCIsXG4gICAgXCLmlYVcIixcbiAgICBcIuWfjlwiLFxuICAgIFwi5aSrXCIsXG4gICAgXCLlpJ9cIixcbiAgICBcIumAgVwiLFxuICAgIFwi56yUXCIsXG4gICAgXCLoiLlcIixcbiAgICBcIuWNoFwiLFxuICAgIFwi5Y+zXCIsXG4gICAgXCLotKJcIixcbiAgICBcIuWQg1wiLFxuICAgIFwi5a+MXCIsXG4gICAgXCLmmKVcIixcbiAgICBcIuiBjFwiLFxuICAgIFwi6KeJXCIsXG4gICAgXCLmsYlcIixcbiAgICBcIueUu1wiLFxuICAgIFwi5YqfXCIsXG4gICAgXCLlt7RcIixcbiAgICBcIui3n1wiLFxuICAgIFwi6Jm9XCIsXG4gICAgXCLmnYJcIixcbiAgICBcIumjnlwiLFxuICAgIFwi5qOAXCIsXG4gICAgXCLlkLhcIixcbiAgICBcIuWKqVwiLFxuICAgIFwi5Y2HXCIsXG4gICAgXCLpmLNcIixcbiAgICBcIuS6klwiLFxuICAgIFwi5YidXCIsXG4gICAgXCLliJtcIixcbiAgICBcIuaKl1wiLFxuICAgIFwi6ICDXCIsXG4gICAgXCLmipVcIixcbiAgICBcIuWdj1wiLFxuICAgIFwi562WXCIsXG4gICAgXCLlj6RcIixcbiAgICBcIuW+hFwiLFxuICAgIFwi5o2iXCIsXG4gICAgXCLmnKpcIixcbiAgICBcIui3kVwiLFxuICAgIFwi55WZXCIsXG4gICAgXCLpkqJcIixcbiAgICBcIuabvlwiLFxuICAgIFwi56uvXCIsXG4gICAgXCLotKNcIixcbiAgICBcIuermVwiLFxuICAgIFwi566AXCIsXG4gICAgXCLov7BcIixcbiAgICBcIumSsVwiLFxuICAgIFwi5YmvXCIsXG4gICAgXCLlsL1cIixcbiAgICBcIuW4nVwiLFxuICAgIFwi5bCEXCIsXG4gICAgXCLojYlcIixcbiAgICBcIuWGslwiLFxuICAgIFwi5om/XCIsXG4gICAgXCLni6xcIixcbiAgICBcIuS7pFwiLFxuICAgIFwi6ZmQXCIsXG4gICAgXCLpmL9cIixcbiAgICBcIuWuo1wiLFxuICAgIFwi546vXCIsXG4gICAgXCLlj4xcIixcbiAgICBcIuivt1wiLFxuICAgIFwi6LaFXCIsXG4gICAgXCLlvq5cIixcbiAgICBcIuiuqVwiLFxuICAgIFwi5o6nXCIsXG4gICAgXCLlt55cIixcbiAgICBcIuiJr1wiLFxuICAgIFwi6L20XCIsXG4gICAgXCLmib5cIixcbiAgICBcIuWQplwiLFxuICAgIFwi57qqXCIsXG4gICAgXCLnm4pcIixcbiAgICBcIuS+nVwiLFxuICAgIFwi5LyYXCIsXG4gICAgXCLpobZcIixcbiAgICBcIuehgFwiLFxuICAgIFwi6L29XCIsXG4gICAgXCLlgJJcIixcbiAgICBcIuaIv1wiLFxuICAgIFwi56qBXCIsXG4gICAgXCLlnZBcIixcbiAgICBcIueyiVwiLFxuICAgIFwi5pWMXCIsXG4gICAgXCLnlaVcIixcbiAgICBcIuWuolwiLFxuICAgIFwi6KKBXCIsXG4gICAgXCLlhrdcIixcbiAgICBcIuiDnFwiLFxuICAgIFwi57udXCIsXG4gICAgXCLmnpBcIixcbiAgICBcIuWdl1wiLFxuICAgIFwi5YmCXCIsXG4gICAgXCLmtYtcIixcbiAgICBcIuS4nVwiLFxuICAgIFwi5Y2PXCIsXG4gICAgXCLor4lcIixcbiAgICBcIuW/tVwiLFxuICAgIFwi6ZmIXCIsXG4gICAgXCLku41cIixcbiAgICBcIue9l1wiLFxuICAgIFwi55uQXCIsXG4gICAgXCLlj4tcIixcbiAgICBcIua0i1wiLFxuICAgIFwi6ZSZXCIsXG4gICAgXCLoi6ZcIixcbiAgICBcIuWknFwiLFxuICAgIFwi5YiRXCIsXG4gICAgXCLnp7tcIixcbiAgICBcIumikVwiLFxuICAgIFwi6YCQXCIsXG4gICAgXCLpnaBcIixcbiAgICBcIua3t1wiLFxuICAgIFwi5q+NXCIsXG4gICAgXCLnn61cIixcbiAgICBcIuearlwiLFxuICAgIFwi57uIXCIsXG4gICAgXCLogZpcIixcbiAgICBcIuaxvVwiLFxuICAgIFwi5p2RXCIsXG4gICAgXCLkupFcIixcbiAgICBcIuWTqlwiLFxuICAgIFwi5peiXCIsXG4gICAgXCLot51cIixcbiAgICBcIuWNq1wiLFxuICAgIFwi5YGcXCIsXG4gICAgXCLng4hcIixcbiAgICBcIuWkrlwiLFxuICAgIFwi5a+fXCIsXG4gICAgXCLng6dcIixcbiAgICBcIui/hVwiLFxuICAgIFwi5aKDXCIsXG4gICAgXCLoi6VcIixcbiAgICBcIuWNsFwiLFxuICAgIFwi5rSyXCIsXG4gICAgXCLliLtcIixcbiAgICBcIuaLrFwiLFxuICAgIFwi5r+AXCIsXG4gICAgXCLlrZRcIixcbiAgICBcIuaQnlwiLFxuICAgIFwi55SaXCIsXG4gICAgXCLlrqRcIixcbiAgICBcIuW+hVwiLFxuICAgIFwi5qC4XCIsXG4gICAgXCLmoKFcIixcbiAgICBcIuaVo1wiLFxuICAgIFwi5L61XCIsXG4gICAgXCLlkKdcIixcbiAgICBcIueUslwiLFxuICAgIFwi5ri4XCIsXG4gICAgXCLkuYVcIixcbiAgICBcIuiPnFwiLFxuICAgIFwi5ZGzXCIsXG4gICAgXCLml6dcIixcbiAgICBcIuaooVwiLFxuICAgIFwi5rmWXCIsXG4gICAgXCLotKdcIixcbiAgICBcIuaNn1wiLFxuICAgIFwi6aKEXCIsXG4gICAgXCLpmLtcIixcbiAgICBcIuavq1wiLFxuICAgIFwi5pmuXCIsXG4gICAgXCLnqLNcIixcbiAgICBcIuS5mVwiLFxuICAgIFwi5aaIXCIsXG4gICAgXCLmpI1cIixcbiAgICBcIuaBr1wiLFxuICAgIFwi5ompXCIsXG4gICAgXCLpk7ZcIixcbiAgICBcIuivrVwiLFxuICAgIFwi5oylXCIsXG4gICAgXCLphZJcIixcbiAgICBcIuWuiFwiLFxuICAgIFwi5ou/XCIsXG4gICAgXCLluo9cIixcbiAgICBcIue6uFwiLFxuICAgIFwi5Yy7XCIsXG4gICAgXCLnvLpcIixcbiAgICBcIumbqFwiLFxuICAgIFwi5ZCXXCIsXG4gICAgXCLpkohcIixcbiAgICBcIuWImFwiLFxuICAgIFwi5ZWKXCIsXG4gICAgXCLmgKVcIixcbiAgICBcIuWUsVwiLFxuICAgIFwi6K+vXCIsXG4gICAgXCLorq1cIixcbiAgICBcIuaEv1wiLFxuICAgIFwi5a6hXCIsXG4gICAgXCLpmYRcIixcbiAgICBcIuiOt1wiLFxuICAgIFwi6Iy2XCIsXG4gICAgXCLpspxcIixcbiAgICBcIueyrlwiLFxuICAgIFwi5pakXCIsXG4gICAgXCLlralcIixcbiAgICBcIuiEsVwiLFxuICAgIFwi56GrXCIsXG4gICAgXCLogqVcIixcbiAgICBcIuWWhFwiLFxuICAgIFwi6b6ZXCIsXG4gICAgXCLmvJRcIixcbiAgICBcIueItlwiLFxuICAgIFwi5riQXCIsXG4gICAgXCLooYBcIixcbiAgICBcIuasolwiLFxuICAgIFwi5qKwXCIsXG4gICAgXCLmjoxcIixcbiAgICBcIuatjFwiLFxuICAgIFwi5rKZXCIsXG4gICAgXCLliJpcIixcbiAgICBcIuaUu1wiLFxuICAgIFwi6LCTXCIsXG4gICAgXCLnm75cIixcbiAgICBcIuiuqFwiLFxuICAgIFwi5pmaXCIsXG4gICAgXCLnspJcIixcbiAgICBcIuS5sVwiLFxuICAgIFwi54eDXCIsXG4gICAgXCLnn5tcIixcbiAgICBcIuS5jlwiLFxuICAgIFwi5p2AXCIsXG4gICAgXCLoja9cIixcbiAgICBcIuWugVwiLFxuICAgIFwi6bKBXCIsXG4gICAgXCLotLVcIixcbiAgICBcIumSn1wiLFxuICAgIFwi54WkXCIsXG4gICAgXCLor7tcIixcbiAgICBcIuePrVwiLFxuICAgIFwi5LyvXCIsXG4gICAgXCLppplcIixcbiAgICBcIuS7i1wiLFxuICAgIFwi6L+rXCIsXG4gICAgXCLlj6VcIixcbiAgICBcIuS4sFwiLFxuICAgIFwi5Z+5XCIsXG4gICAgXCLmj6FcIixcbiAgICBcIuWFsFwiLFxuICAgIFwi5ouFXCIsXG4gICAgXCLlvKZcIixcbiAgICBcIuibi1wiLFxuICAgIFwi5rKJXCIsXG4gICAgXCLlgYdcIixcbiAgICBcIuepv1wiLFxuICAgIFwi5omnXCIsXG4gICAgXCLnrZRcIixcbiAgICBcIuS5kFwiLFxuICAgIFwi6LCBXCIsXG4gICAgXCLpobpcIixcbiAgICBcIueDn1wiLFxuICAgIFwi57ypXCIsXG4gICAgXCLlvoFcIixcbiAgICBcIuiEuFwiLFxuICAgIFwi5ZacXCIsXG4gICAgXCLmnb5cIixcbiAgICBcIuiEmlwiLFxuICAgIFwi5ZuwXCIsXG4gICAgXCLlvIJcIixcbiAgICBcIuWFjVwiLFxuICAgIFwi6IOMXCIsXG4gICAgXCLmmJ9cIixcbiAgICBcIuemj1wiLFxuICAgIFwi5LmwXCIsXG4gICAgXCLmn5NcIixcbiAgICBcIuS6lVwiLFxuICAgIFwi5qaCXCIsXG4gICAgXCLmhaJcIixcbiAgICBcIuaAlVwiLFxuICAgIFwi56OBXCIsXG4gICAgXCLlgI1cIixcbiAgICBcIuelllwiLFxuICAgIFwi55qHXCIsXG4gICAgXCLkv4NcIixcbiAgICBcIumdmVwiLFxuICAgIFwi6KGlXCIsXG4gICAgXCLor4RcIixcbiAgICBcIue/u1wiLFxuICAgIFwi6IKJXCIsXG4gICAgXCLot7VcIixcbiAgICBcIuWwvFwiLFxuICAgIFwi6KGjXCIsXG4gICAgXCLlrr1cIixcbiAgICBcIuaJrFwiLFxuICAgIFwi5qOJXCIsXG4gICAgXCLluIxcIixcbiAgICBcIuS8pFwiLFxuICAgIFwi5pONXCIsXG4gICAgXCLlnoJcIixcbiAgICBcIueni1wiLFxuICAgIFwi5a6cXCIsXG4gICAgXCLmsKJcIixcbiAgICBcIuWll1wiLFxuICAgIFwi552jXCIsXG4gICAgXCLmjK9cIixcbiAgICBcIuaetlwiLFxuICAgIFwi5LquXCIsXG4gICAgXCLmnKtcIixcbiAgICBcIuWuqlwiLFxuICAgIFwi5bqGXCIsXG4gICAgXCLnvJZcIixcbiAgICBcIueJm1wiLFxuICAgIFwi6KemXCIsXG4gICAgXCLmmKBcIixcbiAgICBcIumbt1wiLFxuICAgIFwi6ZSAXCIsXG4gICAgXCLor5dcIixcbiAgICBcIuW6p1wiLFxuICAgIFwi5bGFXCIsXG4gICAgXCLmipNcIixcbiAgICBcIuijglwiLFxuICAgIFwi6IOeXCIsXG4gICAgXCLlkbxcIixcbiAgICBcIuWomFwiLFxuICAgIFwi5pmvXCIsXG4gICAgXCLlqIFcIixcbiAgICBcIue7v1wiLFxuICAgIFwi5pm2XCIsXG4gICAgXCLljppcIixcbiAgICBcIuebn1wiLFxuICAgIFwi6KGhXCIsXG4gICAgXCLpuKFcIixcbiAgICBcIuWtmVwiLFxuICAgIFwi5bu2XCIsXG4gICAgXCLljbFcIixcbiAgICBcIuiDtlwiLFxuICAgIFwi5bGLXCIsXG4gICAgXCLkuaFcIixcbiAgICBcIuS4tFwiLFxuICAgIFwi6ZmGXCIsXG4gICAgXCLpob5cIixcbiAgICBcIuaOiVwiLFxuICAgIFwi5ZGAXCIsXG4gICAgXCLnga9cIixcbiAgICBcIuWygVwiLFxuICAgIFwi5o6qXCIsXG4gICAgXCLmnZ9cIixcbiAgICBcIuiAkFwiLFxuICAgIFwi5YmnXCIsXG4gICAgXCLnjolcIixcbiAgICBcIui1tVwiLFxuICAgIFwi6LezXCIsXG4gICAgXCLlk6VcIixcbiAgICBcIuWto1wiLFxuICAgIFwi6K++XCIsXG4gICAgXCLlh69cIixcbiAgICBcIuiDoVwiLFxuICAgIFwi6aKdXCIsXG4gICAgXCLmrL5cIixcbiAgICBcIue7jVwiLFxuICAgIFwi5Y23XCIsXG4gICAgXCLpvZBcIixcbiAgICBcIuS8n1wiLFxuICAgIFwi6JK4XCIsXG4gICAgXCLmrpZcIixcbiAgICBcIuawuFwiLFxuICAgIFwi5a6XXCIsXG4gICAgXCLoi5dcIixcbiAgICBcIuW3nVwiLFxuICAgIFwi54KJXCIsXG4gICAgXCLlsqlcIixcbiAgICBcIuW8sVwiLFxuICAgIFwi6Zu2XCIsXG4gICAgXCLmnahcIixcbiAgICBcIuWlj1wiLFxuICAgIFwi5rK/XCIsXG4gICAgXCLpnLJcIixcbiAgICBcIuadhlwiLFxuICAgIFwi5o6iXCIsXG4gICAgXCLmu5FcIixcbiAgICBcIumVh1wiLFxuICAgIFwi6aWtXCIsXG4gICAgXCLmtZNcIixcbiAgICBcIuiIqlwiLFxuICAgIFwi5oCAXCIsXG4gICAgXCLotbZcIixcbiAgICBcIuW6k1wiLFxuICAgIFwi5aS6XCIsXG4gICAgXCLkvIpcIixcbiAgICBcIueBtVwiLFxuICAgIFwi56iOXCIsXG4gICAgXCLpgJRcIixcbiAgICBcIueBrVwiLFxuICAgIFwi6LWbXCIsXG4gICAgXCLlvZJcIixcbiAgICBcIuWPrFwiLFxuICAgIFwi6byTXCIsXG4gICAgXCLmkq1cIixcbiAgICBcIuebmFwiLFxuICAgIFwi6KOBXCIsXG4gICAgXCLpmalcIixcbiAgICBcIuW6t1wiLFxuICAgIFwi5ZSvXCIsXG4gICAgXCLlvZVcIixcbiAgICBcIuiPjFwiLFxuICAgIFwi57qvXCIsXG4gICAgXCLlgJ9cIixcbiAgICBcIuezllwiLFxuICAgIFwi55uWXCIsXG4gICAgXCLmqKpcIixcbiAgICBcIuesplwiLFxuICAgIFwi56eBXCIsXG4gICAgXCLliqpcIixcbiAgICBcIuWgglwiLFxuICAgIFwi5Z+fXCIsXG4gICAgXCLmnqpcIixcbiAgICBcIua2plwiLFxuICAgIFwi5bmFXCIsXG4gICAgXCLlk4hcIixcbiAgICBcIuern1wiLFxuICAgIFwi54afXCIsXG4gICAgXCLomatcIixcbiAgICBcIuazvVwiLFxuICAgIFwi6ISRXCIsXG4gICAgXCLlo6RcIixcbiAgICBcIueis1wiLFxuICAgIFwi5qynXCIsXG4gICAgXCLpgY1cIixcbiAgICBcIuS+p1wiLFxuICAgIFwi5a+oXCIsXG4gICAgXCLmlaJcIixcbiAgICBcIuW9u1wiLFxuICAgIFwi6JmRXCIsXG4gICAgXCLmlpxcIixcbiAgICBcIuiWhFwiLFxuICAgIFwi5bqtXCIsXG4gICAgXCLnurNcIixcbiAgICBcIuW8uVwiLFxuICAgIFwi6aWyXCIsXG4gICAgXCLkvLhcIixcbiAgICBcIuaKmFwiLFxuICAgIFwi6bqmXCIsXG4gICAgXCLmub9cIixcbiAgICBcIuaal1wiLFxuICAgIFwi6I23XCIsXG4gICAgXCLnk6ZcIixcbiAgICBcIuWhnlwiLFxuICAgIFwi5bqKXCIsXG4gICAgXCLnrZFcIixcbiAgICBcIuaBtlwiLFxuICAgIFwi5oi3XCIsXG4gICAgXCLorr9cIixcbiAgICBcIuWhlFwiLFxuICAgIFwi5aWHXCIsXG4gICAgXCLpgI9cIixcbiAgICBcIuaigVwiLFxuICAgIFwi5YiAXCIsXG4gICAgXCLml4tcIixcbiAgICBcIui/uVwiLFxuICAgIFwi5Y2hXCIsXG4gICAgXCLmsK9cIixcbiAgICBcIumBh1wiLFxuICAgIFwi5Lu9XCIsXG4gICAgXCLmr5JcIixcbiAgICBcIuazpVwiLFxuICAgIFwi6YCAXCIsXG4gICAgXCLmtJdcIixcbiAgICBcIuaRhlwiLFxuICAgIFwi54GwXCIsXG4gICAgXCLlvalcIixcbiAgICBcIuWNllwiLFxuICAgIFwi6ICXXCIsXG4gICAgXCLlpI9cIixcbiAgICBcIuaLqVwiLFxuICAgIFwi5b+ZXCIsXG4gICAgXCLpk5xcIixcbiAgICBcIueMrlwiLFxuICAgIFwi56GsXCIsXG4gICAgXCLkuohcIixcbiAgICBcIue5gVwiLFxuICAgIFwi5ZyIXCIsXG4gICAgXCLpm6pcIixcbiAgICBcIuWHvVwiLFxuICAgIFwi5LqmXCIsXG4gICAgXCLmir1cIixcbiAgICBcIuevh1wiLFxuICAgIFwi6Zi1XCIsXG4gICAgXCLpmLRcIixcbiAgICBcIuS4gVwiLFxuICAgIFwi5bC6XCIsXG4gICAgXCLov71cIixcbiAgICBcIuWghlwiLFxuICAgIFwi6ZuEXCIsXG4gICAgXCLov45cIixcbiAgICBcIuazm1wiLFxuICAgIFwi54i4XCIsXG4gICAgXCLmpbxcIixcbiAgICBcIumBv1wiLFxuICAgIFwi6LCLXCIsXG4gICAgXCLlkKhcIixcbiAgICBcIumHjlwiLFxuICAgIFwi54yqXCIsXG4gICAgXCLml5dcIixcbiAgICBcIue0r1wiLFxuICAgIFwi5YGPXCIsXG4gICAgXCLlhbhcIixcbiAgICBcIummhlwiLFxuICAgIFwi57SiXCIsXG4gICAgXCLnp6ZcIixcbiAgICBcIuiEglwiLFxuICAgIFwi5r2uXCIsXG4gICAgXCLniLdcIixcbiAgICBcIuixhlwiLFxuICAgIFwi5b+9XCIsXG4gICAgXCLmiZhcIixcbiAgICBcIuaDilwiLFxuICAgIFwi5aGRXCIsXG4gICAgXCLpgZdcIixcbiAgICBcIuaEiFwiLFxuICAgIFwi5pyxXCIsXG4gICAgXCLmm79cIixcbiAgICBcIue6pFwiLFxuICAgIFwi57KXXCIsXG4gICAgXCLlgL5cIixcbiAgICBcIuWwmlwiLFxuICAgIFwi55ebXCIsXG4gICAgXCLmpZpcIixcbiAgICBcIuiwolwiLFxuICAgIFwi5aWLXCIsXG4gICAgXCLotK1cIixcbiAgICBcIuejqFwiLFxuICAgIFwi5ZCbXCIsXG4gICAgXCLmsaBcIixcbiAgICBcIuaXgVwiLFxuICAgIFwi56KOXCIsXG4gICAgXCLpqqhcIixcbiAgICBcIuebkVwiLFxuICAgIFwi5o2VXCIsXG4gICAgXCLlvJ9cIixcbiAgICBcIuaatFwiLFxuICAgIFwi5YmyXCIsXG4gICAgXCLotK9cIixcbiAgICBcIuauilwiLFxuICAgIFwi6YeKXCIsXG4gICAgXCLor41cIixcbiAgICBcIuS6oVwiLFxuICAgIFwi5aOBXCIsXG4gICAgXCLpob9cIixcbiAgICBcIuWunVwiLFxuICAgIFwi5Y2IXCIsXG4gICAgXCLlsJhcIixcbiAgICBcIumXu1wiLFxuICAgIFwi5o+tXCIsXG4gICAgXCLngq5cIixcbiAgICBcIuaui1wiLFxuICAgIFwi5YasXCIsXG4gICAgXCLmoaVcIixcbiAgICBcIuWmh1wiLFxuICAgIFwi6K2mXCIsXG4gICAgXCLnu7xcIixcbiAgICBcIuaLm1wiLFxuICAgIFwi5ZC0XCIsXG4gICAgXCLku5hcIixcbiAgICBcIua1rlwiLFxuICAgIFwi6YGtXCIsXG4gICAgXCLlvpBcIixcbiAgICBcIuaCqFwiLFxuICAgIFwi5pGHXCIsXG4gICAgXCLosLdcIixcbiAgICBcIui1nlwiLFxuICAgIFwi566xXCIsXG4gICAgXCLpmpRcIixcbiAgICBcIuiuolwiLFxuICAgIFwi55S3XCIsXG4gICAgXCLlkLlcIixcbiAgICBcIuWbrVwiLFxuICAgIFwi57q3XCIsXG4gICAgXCLllJBcIixcbiAgICBcIui0pVwiLFxuICAgIFwi5a6LXCIsXG4gICAgXCLnjrtcIixcbiAgICBcIuW3qFwiLFxuICAgIFwi6ICVXCIsXG4gICAgXCLlnaZcIixcbiAgICBcIuiNo1wiLFxuICAgIFwi6ZetXCIsXG4gICAgXCLmub5cIixcbiAgICBcIumUrlwiLFxuICAgIFwi5YehXCIsXG4gICAgXCLpqbtcIixcbiAgICBcIumUhVwiLFxuICAgIFwi5pWRXCIsXG4gICAgXCLmgalcIixcbiAgICBcIuWJpVwiLFxuICAgIFwi5YedXCIsXG4gICAgXCLnorFcIixcbiAgICBcIum9v1wiLFxuICAgIFwi5oiqXCIsXG4gICAgXCLngrxcIixcbiAgICBcIum6u1wiLFxuICAgIFwi57q6XCIsXG4gICAgXCLnpoFcIixcbiAgICBcIuW6n1wiLFxuICAgIFwi55ubXCIsXG4gICAgXCLniYhcIixcbiAgICBcIue8k1wiLFxuICAgIFwi5YeAXCIsXG4gICAgXCLnnZtcIixcbiAgICBcIuaYjFwiLFxuICAgIFwi5amaXCIsXG4gICAgXCLmtolcIixcbiAgICBcIuetklwiLFxuICAgIFwi5Zi0XCIsXG4gICAgXCLmj5JcIixcbiAgICBcIuWyuFwiLFxuICAgIFwi5pyXXCIsXG4gICAgXCLluoRcIixcbiAgICBcIuihl1wiLFxuICAgIFwi6JePXCIsXG4gICAgXCLlp5FcIixcbiAgICBcIui0uFwiLFxuICAgIFwi6IWQXCIsXG4gICAgXCLlpbRcIixcbiAgICBcIuWVplwiLFxuICAgIFwi5oOvXCIsXG4gICAgXCLkuZhcIixcbiAgICBcIuS8mVwiLFxuICAgIFwi5oGiXCIsXG4gICAgXCLljIBcIixcbiAgICBcIue6sVwiLFxuICAgIFwi5omOXCIsXG4gICAgXCLovqlcIixcbiAgICBcIuiAs1wiLFxuICAgIFwi5b2qXCIsXG4gICAgXCLoh6NcIixcbiAgICBcIuS6v1wiLFxuICAgIFwi55KDXCIsXG4gICAgXCLmirVcIixcbiAgICBcIuiEiVwiLFxuICAgIFwi56eAXCIsXG4gICAgXCLokKhcIixcbiAgICBcIuS/hFwiLFxuICAgIFwi572RXCIsXG4gICAgXCLoiJ5cIixcbiAgICBcIuW6l1wiLFxuICAgIFwi5Za3XCIsXG4gICAgXCLnurVcIixcbiAgICBcIuWvuFwiLFxuICAgIFwi5rGXXCIsXG4gICAgXCLmjIJcIixcbiAgICBcIua0qlwiLFxuICAgIFwi6LS6XCIsXG4gICAgXCLpl6pcIixcbiAgICBcIuafrFwiLFxuICAgIFwi54iGXCIsXG4gICAgXCLng69cIixcbiAgICBcIua0pVwiLFxuICAgIFwi56i7XCIsXG4gICAgXCLloplcIixcbiAgICBcIui9r1wiLFxuICAgIFwi5YuHXCIsXG4gICAgXCLlg49cIixcbiAgICBcIua7mlwiLFxuICAgIFwi5Y6YXCIsXG4gICAgXCLokplcIixcbiAgICBcIuiKs1wiLFxuICAgIFwi6IKvXCIsXG4gICAgXCLlnaFcIixcbiAgICBcIuafsVwiLFxuICAgIFwi6I2hXCIsXG4gICAgXCLohb9cIixcbiAgICBcIuS7qlwiLFxuICAgIFwi5peFXCIsXG4gICAgXCLlsL5cIixcbiAgICBcIui9p1wiLFxuICAgIFwi5YawXCIsXG4gICAgXCLotKFcIixcbiAgICBcIueZu1wiLFxuICAgIFwi6buOXCIsXG4gICAgXCLliYpcIixcbiAgICBcIumSu1wiLFxuICAgIFwi5YuSXCIsXG4gICAgXCLpgINcIixcbiAgICBcIumanFwiLFxuICAgIFwi5rCoXCIsXG4gICAgXCLpg61cIixcbiAgICBcIuWzsFwiLFxuICAgIFwi5biBXCIsXG4gICAgXCLmuK9cIixcbiAgICBcIuS8j1wiLFxuICAgIFwi6L2oXCIsXG4gICAgXCLkuqlcIixcbiAgICBcIuavlVwiLFxuICAgIFwi5pOmXCIsXG4gICAgXCLojqtcIixcbiAgICBcIuWIulwiLFxuICAgIFwi5rWqXCIsXG4gICAgXCLnp5hcIixcbiAgICBcIuaPtFwiLFxuICAgIFwi5qCqXCIsXG4gICAgXCLlgaVcIixcbiAgICBcIuWUrlwiLFxuICAgIFwi6IKhXCIsXG4gICAgXCLlsptcIixcbiAgICBcIueUmFwiLFxuICAgIFwi5rOhXCIsXG4gICAgXCLnnaFcIixcbiAgICBcIuerpVwiLFxuICAgIFwi6ZO4XCIsXG4gICAgXCLmsaRcIixcbiAgICBcIumYgFwiLFxuICAgIFwi5LyRXCIsXG4gICAgXCLmsYdcIixcbiAgICBcIuiIjVwiLFxuICAgIFwi54mnXCIsXG4gICAgXCLnu5VcIixcbiAgICBcIueCuFwiLFxuICAgIFwi5ZOyXCIsXG4gICAgXCLno7dcIixcbiAgICBcIue7qVwiLFxuICAgIFwi5pyLXCIsXG4gICAgXCLmt6FcIixcbiAgICBcIuWwllwiLFxuICAgIFwi5ZCvXCIsXG4gICAgXCLpmbdcIixcbiAgICBcIuaftFwiLFxuICAgIFwi5ZGIXCIsXG4gICAgXCLlvpJcIixcbiAgICBcIuminFwiLFxuICAgIFwi5rOqXCIsXG4gICAgXCLnqI1cIixcbiAgICBcIuW/mFwiLFxuICAgIFwi5rO1XCIsXG4gICAgXCLok51cIixcbiAgICBcIuaLllwiLFxuICAgIFwi5rSeXCIsXG4gICAgXCLmjohcIixcbiAgICBcIumVnFwiLFxuICAgIFwi6L6bXCIsXG4gICAgXCLlo65cIixcbiAgICBcIumUi1wiLFxuICAgIFwi6LSrXCIsXG4gICAgXCLomZpcIixcbiAgICBcIuW8r1wiLFxuICAgIFwi5pGpXCIsXG4gICAgXCLms7BcIixcbiAgICBcIuW5vFwiLFxuICAgIFwi5bu3XCIsXG4gICAgXCLlsIpcIixcbiAgICBcIueql1wiLFxuICAgIFwi57qyXCIsXG4gICAgXCLlvIRcIixcbiAgICBcIumatlwiLFxuICAgIFwi55aRXCIsXG4gICAgXCLmsI9cIixcbiAgICBcIuWuq1wiLFxuICAgIFwi5aeQXCIsXG4gICAgXCLpnIdcIixcbiAgICBcIueRnlwiLFxuICAgIFwi5oCqXCIsXG4gICAgXCLlsKRcIixcbiAgICBcIueQtFwiLFxuICAgIFwi5b6qXCIsXG4gICAgXCLmj49cIixcbiAgICBcIuiGnFwiLFxuICAgIFwi6L+dXCIsXG4gICAgXCLlpLlcIixcbiAgICBcIuiFsFwiLFxuICAgIFwi57yYXCIsXG4gICAgXCLnj6BcIixcbiAgICBcIuept1wiLFxuICAgIFwi5qOuXCIsXG4gICAgXCLmnp1cIixcbiAgICBcIueruVwiLFxuICAgIFwi5rKfXCIsXG4gICAgXCLlgqxcIixcbiAgICBcIue7s1wiLFxuICAgIFwi5b+GXCIsXG4gICAgXCLpgqZcIixcbiAgICBcIuWJqVwiLFxuICAgIFwi5bm4XCIsXG4gICAgXCLmtYZcIixcbiAgICBcIuagj1wiLFxuICAgIFwi5oulXCIsXG4gICAgXCLniZlcIixcbiAgICBcIui0rlwiLFxuICAgIFwi56S8XCIsXG4gICAgXCLmu6RcIixcbiAgICBcIumSoFwiLFxuICAgIFwi57q5XCIsXG4gICAgXCLnvaJcIixcbiAgICBcIuaLjVwiLFxuICAgIFwi5ZKxXCIsXG4gICAgXCLllopcIixcbiAgICBcIuiillwiLFxuICAgIFwi5Z+DXCIsXG4gICAgXCLli6RcIixcbiAgICBcIue9mlwiLFxuICAgIFwi54SmXCIsXG4gICAgXCLmvZxcIixcbiAgICBcIuS8jVwiLFxuICAgIFwi5aKoXCIsXG4gICAgXCLmrLJcIixcbiAgICBcIue8nVwiLFxuICAgIFwi5aeTXCIsXG4gICAgXCLliIpcIixcbiAgICBcIumlsVwiLFxuICAgIFwi5Lu/XCIsXG4gICAgXCLlpZZcIixcbiAgICBcIumTnVwiLFxuICAgIFwi6ay8XCIsXG4gICAgXCLkuL1cIixcbiAgICBcIui3qFwiLFxuICAgIFwi6buYXCIsXG4gICAgXCLmjJZcIixcbiAgICBcIumTvlwiLFxuICAgIFwi5omrXCIsXG4gICAgXCLllp1cIixcbiAgICBcIuiii1wiLFxuICAgIFwi54KtXCIsXG4gICAgXCLmsaFcIixcbiAgICBcIuW5lVwiLFxuICAgIFwi6K+4XCIsXG4gICAgXCLlvKdcIixcbiAgICBcIuWKsVwiLFxuICAgIFwi5qKFXCIsXG4gICAgXCLlpbZcIixcbiAgICBcIua0gVwiLFxuICAgIFwi54G+XCIsXG4gICAgXCLoiJ9cIixcbiAgICBcIumJtFwiLFxuICAgIFwi6IuvXCIsXG4gICAgXCLorrxcIixcbiAgICBcIuaKsVwiLFxuICAgIFwi5q+BXCIsXG4gICAgXCLmh4JcIixcbiAgICBcIuWvklwiLFxuICAgIFwi5pm6XCIsXG4gICAgXCLln5RcIixcbiAgICBcIuWvhFwiLFxuICAgIFwi5bGKXCIsXG4gICAgXCLot4NcIixcbiAgICBcIua4oVwiLFxuICAgIFwi5oyRXCIsXG4gICAgXCLkuLlcIixcbiAgICBcIuiJsFwiLFxuICAgIFwi6LSdXCIsXG4gICAgXCLnorBcIixcbiAgICBcIuaLlFwiLFxuICAgIFwi54i5XCIsXG4gICAgXCLmiLRcIixcbiAgICBcIueggVwiLFxuICAgIFwi5qKmXCIsXG4gICAgXCLoir1cIixcbiAgICBcIueGlFwiLFxuICAgIFwi6LWkXCIsXG4gICAgXCLmuJRcIixcbiAgICBcIuWTrVwiLFxuICAgIFwi5pWsXCIsXG4gICAgXCLpopdcIixcbiAgICBcIuWllFwiLFxuICAgIFwi6ZOFXCIsXG4gICAgXCLku7JcIixcbiAgICBcIuiZjlwiLFxuICAgIFwi56iAXCIsXG4gICAgXCLlprlcIixcbiAgICBcIuS5j1wiLFxuICAgIFwi54+NXCIsXG4gICAgXCLnlLNcIixcbiAgICBcIuahjFwiLFxuICAgIFwi6YG1XCIsXG4gICAgXCLlhYFcIixcbiAgICBcIumahlwiLFxuICAgIFwi6J66XCIsXG4gICAgXCLku5NcIixcbiAgICBcIumtj1wiLFxuICAgIFwi6ZSQXCIsXG4gICAgXCLmmZNcIixcbiAgICBcIuawrlwiLFxuICAgIFwi5YW8XCIsXG4gICAgXCLpmpBcIixcbiAgICBcIueijVwiLFxuICAgIFwi6LWrXCIsXG4gICAgXCLmi6hcIixcbiAgICBcIuW/oFwiLFxuICAgIFwi6IKDXCIsXG4gICAgXCLnvLhcIixcbiAgICBcIueJtVwiLFxuICAgIFwi5oqiXCIsXG4gICAgXCLljZpcIixcbiAgICBcIuW3p1wiLFxuICAgIFwi5aOzXCIsXG4gICAgXCLlhYRcIixcbiAgICBcIuadnFwiLFxuICAgIFwi6K6vXCIsXG4gICAgXCLor5pcIixcbiAgICBcIueip1wiLFxuICAgIFwi56WlXCIsXG4gICAgXCLmn69cIixcbiAgICBcIumhtVwiLFxuICAgIFwi5behXCIsXG4gICAgXCLnn6lcIixcbiAgICBcIuaCslwiLFxuICAgIFwi54GMXCIsXG4gICAgXCLpvoRcIixcbiAgICBcIuS8plwiLFxuICAgIFwi56WoXCIsXG4gICAgXCLlr7tcIixcbiAgICBcIuahglwiLFxuICAgIFwi6ZO6XCIsXG4gICAgXCLlnKNcIixcbiAgICBcIuaBkFwiLFxuICAgIFwi5oGwXCIsXG4gICAgXCLpg5FcIixcbiAgICBcIui2o1wiLFxuICAgIFwi5oqsXCIsXG4gICAgXCLojZJcIixcbiAgICBcIuiFvlwiLFxuICAgIFwi6LS0XCIsXG4gICAgXCLmn5RcIixcbiAgICBcIua7tFwiLFxuICAgIFwi54ybXCIsXG4gICAgXCLpmJRcIixcbiAgICBcIui+hlwiLFxuICAgIFwi5aa7XCIsXG4gICAgXCLloatcIixcbiAgICBcIuaSpFwiLFxuICAgIFwi5YKoXCIsXG4gICAgXCLnrb5cIixcbiAgICBcIumXuVwiLFxuICAgIFwi5omwXCIsXG4gICAgXCLntKtcIixcbiAgICBcIuegglwiLFxuICAgIFwi6YCSXCIsXG4gICAgXCLmiI9cIixcbiAgICBcIuWQilwiLFxuICAgIFwi6Zm2XCIsXG4gICAgXCLkvJBcIixcbiAgICBcIuWWglwiLFxuICAgIFwi55aXXCIsXG4gICAgXCLnk7ZcIixcbiAgICBcIuWphlwiLFxuICAgIFwi5oqaXCIsXG4gICAgXCLoh4JcIixcbiAgICBcIuaRuFwiLFxuICAgIFwi5b+NXCIsXG4gICAgXCLomb5cIixcbiAgICBcIuicoVwiLFxuICAgIFwi6YK7XCIsXG4gICAgXCLog7hcIixcbiAgICBcIuW3qVwiLFxuICAgIFwi5oykXCIsXG4gICAgXCLlgbZcIixcbiAgICBcIuW8g1wiLFxuICAgIFwi5qe9XCIsXG4gICAgXCLlirJcIixcbiAgICBcIuS5s1wiLFxuICAgIFwi6YKTXCIsXG4gICAgXCLlkIlcIixcbiAgICBcIuS7gVwiLFxuICAgIFwi54OCXCIsXG4gICAgXCLnoJZcIixcbiAgICBcIuenn1wiLFxuICAgIFwi5LmMXCIsXG4gICAgXCLoiLBcIixcbiAgICBcIuS8tFwiLFxuICAgIFwi55OcXCIsXG4gICAgXCLmtYVcIixcbiAgICBcIuS4mVwiLFxuICAgIFwi5pqCXCIsXG4gICAgXCLnh6VcIixcbiAgICBcIuapoVwiLFxuICAgIFwi5p+zXCIsXG4gICAgXCLov7dcIixcbiAgICBcIuaallwiLFxuICAgIFwi54mMXCIsXG4gICAgXCLnp6dcIixcbiAgICBcIuiDhlwiLFxuICAgIFwi6K+mXCIsXG4gICAgXCLnsKdcIixcbiAgICBcIui4j1wiLFxuICAgIFwi55O3XCIsXG4gICAgXCLosLFcIixcbiAgICBcIuWRhlwiLFxuICAgIFwi5a6+XCIsXG4gICAgXCLns4pcIixcbiAgICBcIua0m1wiLFxuICAgIFwi6L6JXCIsXG4gICAgXCLmhKRcIixcbiAgICBcIuernlwiLFxuICAgIFwi6ZqZXCIsXG4gICAgXCLmgJJcIixcbiAgICBcIueymFwiLFxuICAgIFwi5LmDXCIsXG4gICAgXCLnu6pcIixcbiAgICBcIuiCqVwiLFxuICAgIFwi57GNXCIsXG4gICAgXCLmlY9cIixcbiAgICBcIua2glwiLFxuICAgIFwi54aZXCIsXG4gICAgXCLnmoZcIixcbiAgICBcIuS+plwiLFxuICAgIFwi5oKsXCIsXG4gICAgXCLmjphcIixcbiAgICBcIuS6q1wiLFxuICAgIFwi57qgXCIsXG4gICAgXCLphpJcIixcbiAgICBcIueLglwiLFxuICAgIFwi6ZSBXCIsXG4gICAgXCLmt4BcIixcbiAgICBcIuaBqFwiLFxuICAgIFwi54myXCIsXG4gICAgXCLpnLhcIixcbiAgICBcIueIrFwiLFxuICAgIFwi6LWPXCIsXG4gICAgXCLpgIZcIixcbiAgICBcIueOqVwiLFxuICAgIFwi6Zm1XCIsXG4gICAgXCLnpZ1cIixcbiAgICBcIuenklwiLFxuICAgIFwi5rWZXCIsXG4gICAgXCLosoxcIixcbiAgICBcIuW9uVwiLFxuICAgIFwi5b28XCIsXG4gICAgXCLmgolcIixcbiAgICBcIum4rVwiLFxuICAgIFwi6LaLXCIsXG4gICAgXCLlh6RcIixcbiAgICBcIuaZqFwiLFxuICAgIFwi55WcXCIsXG4gICAgXCLovohcIixcbiAgICBcIuenqVwiLFxuICAgIFwi5Y21XCIsXG4gICAgXCLnvbJcIixcbiAgICBcIuair1wiLFxuICAgIFwi54KOXCIsXG4gICAgXCLmu6lcIixcbiAgICBcIuaji1wiLFxuICAgIFwi6amxXCIsXG4gICAgXCLnrZtcIixcbiAgICBcIuWzoVwiLFxuICAgIFwi5YaSXCIsXG4gICAgXCLllaVcIixcbiAgICBcIuWvv1wiLFxuICAgIFwi6K+RXCIsXG4gICAgXCLmtbhcIixcbiAgICBcIuaziVwiLFxuICAgIFwi5bi9XCIsXG4gICAgXCLov59cIixcbiAgICBcIuehhVwiLFxuICAgIFwi55aGXCIsXG4gICAgXCLotLdcIixcbiAgICBcIua8j1wiLFxuICAgIFwi56i/XCIsXG4gICAgXCLlhqBcIixcbiAgICBcIuWrqVwiLFxuICAgIFwi6IOBXCIsXG4gICAgXCLoiq9cIixcbiAgICBcIueJolwiLFxuICAgIFwi5Y+bXCIsXG4gICAgXCLomoBcIixcbiAgICBcIuWlpVwiLFxuICAgIFwi6bijXCIsXG4gICAgXCLlsq1cIixcbiAgICBcIue+ilwiLFxuICAgIFwi5YetXCIsXG4gICAgXCLkuLJcIixcbiAgICBcIuWhmFwiLFxuICAgIFwi57uYXCIsXG4gICAgXCLphbVcIixcbiAgICBcIuiejVwiLFxuICAgIFwi55uGXCIsXG4gICAgXCLplKFcIixcbiAgICBcIuW6mVwiLFxuICAgIFwi5625XCIsXG4gICAgXCLlhrtcIixcbiAgICBcIui+hVwiLFxuICAgIFwi5pGEXCIsXG4gICAgXCLooq1cIixcbiAgICBcIueti1wiLFxuICAgIFwi5ouSXCIsXG4gICAgXCLlg5pcIixcbiAgICBcIuaXsVwiLFxuICAgIFwi6ZK+XCIsXG4gICAgXCLpuJ9cIixcbiAgICBcIua8hlwiLFxuICAgIFwi5rKIXCIsXG4gICAgXCLnnIlcIixcbiAgICBcIueWj1wiLFxuICAgIFwi5re7XCIsXG4gICAgXCLmo5JcIixcbiAgICBcIuepl1wiLFxuICAgIFwi56GdXCIsXG4gICAgXCLpn6lcIixcbiAgICBcIumAvFwiLFxuICAgIFwi5omtXCIsXG4gICAgXCLkvqhcIixcbiAgICBcIuWHiVwiLFxuICAgIFwi5oy6XCIsXG4gICAgXCLnopdcIixcbiAgICBcIuagvVwiLFxuICAgIFwi54KSXCIsXG4gICAgXCLmna9cIixcbiAgICBcIuaCo1wiLFxuICAgIFwi6aaPXCIsXG4gICAgXCLlip1cIixcbiAgICBcIuixqlwiLFxuICAgIFwi6L69XCIsXG4gICAgXCLli4NcIixcbiAgICBcIum4v1wiLFxuICAgIFwi5pemXCIsXG4gICAgXCLlkI9cIixcbiAgICBcIuaLnFwiLFxuICAgIFwi54uXXCIsXG4gICAgXCLln4tcIixcbiAgICBcIui+ilwiLFxuICAgIFwi5o6pXCIsXG4gICAgXCLppa5cIixcbiAgICBcIuaQrFwiLFxuICAgIFwi6aqCXCIsXG4gICAgXCLovp5cIixcbiAgICBcIuWLvlwiLFxuICAgIFwi5omjXCIsXG4gICAgXCLkvLBcIixcbiAgICBcIuiSi1wiLFxuICAgIFwi57uSXCIsXG4gICAgXCLpm75cIixcbiAgICBcIuS4iFwiLFxuICAgIFwi5py1XCIsXG4gICAgXCLlp4ZcIixcbiAgICBcIuaLn1wiLFxuICAgIFwi5a6HXCIsXG4gICAgXCLovpFcIixcbiAgICBcIumZlVwiLFxuICAgIFwi6ZuVXCIsXG4gICAgXCLlgb9cIixcbiAgICBcIuiThFwiLFxuICAgIFwi5bSHXCIsXG4gICAgXCLliapcIixcbiAgICBcIuWAoVwiLFxuICAgIFwi5Y6FXCIsXG4gICAgXCLlkqxcIixcbiAgICBcIumptlwiLFxuICAgIFwi6JavXCIsXG4gICAgXCLliLdcIixcbiAgICBcIuaWpVwiLFxuICAgIFwi55WqXCIsXG4gICAgXCLotYtcIixcbiAgICBcIuWliVwiLFxuICAgIFwi5L2bXCIsXG4gICAgXCLmtYdcIixcbiAgICBcIua8q1wiLFxuICAgIFwi5pu8XCIsXG4gICAgXCLmiYdcIixcbiAgICBcIumSmVwiLFxuICAgIFwi5qGDXCIsXG4gICAgXCLmibZcIixcbiAgICBcIuS7lFwiLFxuICAgIFwi6L+UXCIsXG4gICAgXCLkv5dcIixcbiAgICBcIuS6j1wiLFxuICAgIFwi6IWUXCIsXG4gICAgXCLpnotcIixcbiAgICBcIuajsVwiLFxuICAgIFwi6KaGXCIsXG4gICAgXCLmoYZcIixcbiAgICBcIuaChFwiLFxuICAgIFwi5Y+UXCIsXG4gICAgXCLmkp5cIixcbiAgICBcIumql1wiLFxuICAgIFwi5YuYXCIsXG4gICAgXCLml7pcIixcbiAgICBcIuayuFwiLFxuICAgIFwi5a2kXCIsXG4gICAgXCLlkJBcIixcbiAgICBcIuWtn1wiLFxuICAgIFwi5rigXCIsXG4gICAgXCLlsYhcIixcbiAgICBcIueWvlwiLFxuICAgIFwi5aaZXCIsXG4gICAgXCLmg5xcIixcbiAgICBcIuS7sFwiLFxuICAgIFwi54ugXCIsXG4gICAgXCLog4BcIixcbiAgICBcIuiwkFwiLFxuICAgIFwi5oqbXCIsXG4gICAgXCLpnIlcIixcbiAgICBcIuahkVwiLFxuICAgIFwi5bKXXCIsXG4gICAgXCLlmJtcIixcbiAgICBcIuihsFwiLFxuICAgIFwi55uXXCIsXG4gICAgXCLmuJdcIixcbiAgICBcIuiEj1wiLFxuICAgIFwi6LWWXCIsXG4gICAgXCLmtoxcIixcbiAgICBcIueUnFwiLFxuICAgIFwi5pu5XCIsXG4gICAgXCLpmIVcIixcbiAgICBcIuiCjFwiLFxuICAgIFwi5ZOpXCIsXG4gICAgXCLljolcIixcbiAgICBcIueDg1wiLFxuICAgIFwi57qsXCIsXG4gICAgXCLmr4VcIixcbiAgICBcIuaYqFwiLFxuICAgIFwi5LyqXCIsXG4gICAgXCLnl4dcIixcbiAgICBcIueFrlwiLFxuICAgIFwi5Y+5XCIsXG4gICAgXCLpkolcIixcbiAgICBcIuaQrVwiLFxuICAgIFwi6IyOXCIsXG4gICAgXCLnrLxcIixcbiAgICBcIumFt1wiLFxuICAgIFwi5YG3XCIsXG4gICAgXCLlvJNcIixcbiAgICBcIumUpVwiLFxuICAgIFwi5oGSXCIsXG4gICAgXCLmnbBcIixcbiAgICBcIuWdkVwiLFxuICAgIFwi6by7XCIsXG4gICAgXCLnv7xcIixcbiAgICBcIue6tlwiLFxuICAgIFwi5Y+ZXCIsXG4gICAgXCLni7FcIixcbiAgICBcIumArlwiLFxuICAgIFwi572QXCIsXG4gICAgXCLnu5xcIixcbiAgICBcIuajmlwiLFxuICAgIFwi5oqRXCIsXG4gICAgXCLohqhcIixcbiAgICBcIuiUrFwiLFxuICAgIFwi5a+6XCIsXG4gICAgXCLpqqRcIixcbiAgICBcIuephlwiLFxuICAgIFwi5Ya2XCIsXG4gICAgXCLmnq9cIixcbiAgICBcIuWGjFwiLFxuICAgIFwi5bC4XCIsXG4gICAgXCLlh7hcIixcbiAgICBcIue7hVwiLFxuICAgIFwi5Z2vXCIsXG4gICAgXCLnibpcIixcbiAgICBcIueEsFwiLFxuICAgIFwi6L2wXCIsXG4gICAgXCLmrKNcIixcbiAgICBcIuaZi1wiLFxuICAgIFwi55imXCIsXG4gICAgXCLlvqFcIixcbiAgICBcIumUrVwiLFxuICAgIFwi6ZSmXCIsXG4gICAgXCLkuKdcIixcbiAgICBcIuaXrFwiLFxuICAgIFwi6ZS7XCIsXG4gICAgXCLlnoRcIixcbiAgICBcIuaQnFwiLFxuICAgIFwi5omRXCIsXG4gICAgXCLpgoBcIixcbiAgICBcIuS6rVwiLFxuICAgIFwi6YWvXCIsXG4gICAgXCLov4hcIixcbiAgICBcIuiIklwiLFxuICAgIFwi6ISGXCIsXG4gICAgXCLphbZcIixcbiAgICBcIumXslwiLFxuICAgIFwi5b+nXCIsXG4gICAgXCLphZpcIixcbiAgICBcIumhvVwiLFxuICAgIFwi5769XCIsXG4gICAgXCLmtqhcIixcbiAgICBcIuWNuFwiLFxuICAgIFwi5LuXXCIsXG4gICAgXCLpmapcIixcbiAgICBcIui+n1wiLFxuICAgIFwi5oOpXCIsXG4gICAgXCLmna1cIixcbiAgICBcIuWnmlwiLFxuICAgIFwi6IKaXCIsXG4gICAgXCLmjYlcIixcbiAgICBcIumjmFwiLFxuICAgIFwi5ryCXCIsXG4gICAgXCLmmIZcIixcbiAgICBcIuasulwiLFxuICAgIFwi5ZC+XCIsXG4gICAgXCLpg45cIixcbiAgICBcIueDt1wiLFxuICAgIFwi5rGBXCIsXG4gICAgXCLlkbVcIixcbiAgICBcIumlsFwiLFxuICAgIFwi6JCnXCIsXG4gICAgXCLpm4VcIixcbiAgICBcIumCrlwiLFxuICAgIFwi6L+BXCIsXG4gICAgXCLnh5VcIixcbiAgICBcIuaSklwiLFxuICAgIFwi5ae7XCIsXG4gICAgXCLotbRcIixcbiAgICBcIuWutFwiLFxuICAgIFwi54OmXCIsXG4gICAgXCLlgLpcIixcbiAgICBcIuW4kFwiLFxuICAgIFwi5paRXCIsXG4gICAgXCLpk4NcIixcbiAgICBcIuaXqFwiLFxuICAgIFwi6YaHXCIsXG4gICAgXCLokaNcIixcbiAgICBcIumlvFwiLFxuICAgIFwi6ZuPXCIsXG4gICAgXCLlp79cIixcbiAgICBcIuaLjFwiLFxuICAgIFwi5YKFXCIsXG4gICAgXCLohblcIixcbiAgICBcIuWmpVwiLFxuICAgIFwi5o+JXCIsXG4gICAgXCLotKRcIixcbiAgICBcIuaLhlwiLFxuICAgIFwi5q2qXCIsXG4gICAgXCLokaFcIixcbiAgICBcIuiDulwiLFxuICAgIFwi5LiiXCIsXG4gICAgXCLmtalcIixcbiAgICBcIuW+vVwiLFxuICAgIFwi5piCXCIsXG4gICAgXCLlnqtcIixcbiAgICBcIuaMoVwiLFxuICAgIFwi6KeIXCIsXG4gICAgXCLotKpcIixcbiAgICBcIuaFsFwiLFxuICAgIFwi57y0XCIsXG4gICAgXCLmsapcIixcbiAgICBcIuaFjFwiLFxuICAgIFwi5YavXCIsXG4gICAgXCLor7pcIixcbiAgICBcIuWnnFwiLFxuICAgIFwi6LCKXCIsXG4gICAgXCLlh7ZcIixcbiAgICBcIuWKo1wiLFxuICAgIFwi6K+sXCIsXG4gICAgXCLogIBcIixcbiAgICBcIuaYj1wiLFxuICAgIFwi6Lq6XCIsXG4gICAgXCLnm4hcIixcbiAgICBcIumqkVwiLFxuICAgIFwi5LmUXCIsXG4gICAgXCLmuqpcIixcbiAgICBcIuS4m1wiLFxuICAgIFwi5Y2iXCIsXG4gICAgXCLmirlcIixcbiAgICBcIumXt1wiLFxuICAgIFwi5ZKoXCIsXG4gICAgXCLliK5cIixcbiAgICBcIumpvlwiLFxuICAgIFwi57yGXCIsXG4gICAgXCLmgp9cIixcbiAgICBcIuaRmFwiLFxuICAgIFwi6ZOSXCIsXG4gICAgXCLmjrdcIixcbiAgICBcIumih1wiLFxuICAgIFwi5bm7XCIsXG4gICAgXCLmn4RcIixcbiAgICBcIuaDoFwiLFxuICAgIFwi5oOoXCIsXG4gICAgXCLkvbNcIixcbiAgICBcIuS7h1wiLFxuICAgIFwi6IWKXCIsXG4gICAgXCLnqp1cIixcbiAgICBcIua2pFwiLFxuICAgIFwi5YmRXCIsXG4gICAgXCLnnqdcIixcbiAgICBcIuWgoVwiLFxuICAgIFwi5rO8XCIsXG4gICAgXCLokbFcIixcbiAgICBcIue9qVwiLFxuICAgIFwi6ZyNXCIsXG4gICAgXCLmjZ5cIixcbiAgICBcIuiDjlwiLFxuICAgIFwi6IuNXCIsXG4gICAgXCLmu6hcIixcbiAgICBcIuS/qVwiLFxuICAgIFwi5o2FXCIsXG4gICAgXCLmuZhcIixcbiAgICBcIuegjVwiLFxuICAgIFwi6ZyeXCIsXG4gICAgXCLpgrVcIixcbiAgICBcIuiQhFwiLFxuICAgIFwi55avXCIsXG4gICAgXCLmt65cIixcbiAgICBcIumBglwiLFxuICAgIFwi54aKXCIsXG4gICAgXCLnsqpcIixcbiAgICBcIueDmFwiLFxuICAgIFwi5a6/XCIsXG4gICAgXCLmoaNcIixcbiAgICBcIuaIiFwiLFxuICAgIFwi6amzXCIsXG4gICAgXCLlq4JcIixcbiAgICBcIuijlVwiLFxuICAgIFwi5b6ZXCIsXG4gICAgXCLnrq1cIixcbiAgICBcIuaNkFwiLFxuICAgIFwi6IKgXCIsXG4gICAgXCLmkpFcIixcbiAgICBcIuaZklwiLFxuICAgIFwi6L6oXCIsXG4gICAgXCLmrr9cIixcbiAgICBcIuiOslwiLFxuICAgIFwi5pGKXCIsXG4gICAgXCLmkIVcIixcbiAgICBcIumFsVwiLFxuICAgIFwi5bGPXCIsXG4gICAgXCLnlqtcIixcbiAgICBcIuWTgFwiLFxuICAgIFwi6JShXCIsXG4gICAgXCLloLVcIixcbiAgICBcIuayq1wiLFxuICAgIFwi55qxXCIsXG4gICAgXCLnlYVcIixcbiAgICBcIuWPoFwiLFxuICAgIFwi6ZiBXCIsXG4gICAgXCLojrFcIixcbiAgICBcIuaVslwiLFxuICAgIFwi6L6WXCIsXG4gICAgXCLpkqlcIixcbiAgICBcIueXlVwiLFxuICAgIFwi5Z2dXCIsXG4gICAgXCLlt7dcIixcbiAgICBcIumlv1wiLFxuICAgIFwi56W4XCIsXG4gICAgXCLkuJhcIixcbiAgICBcIueOhFwiLFxuICAgIFwi5rqcXCIsXG4gICAgXCLmm7BcIixcbiAgICBcIumAu1wiLFxuICAgIFwi5b2tXCIsXG4gICAgXCLlsJ1cIixcbiAgICBcIuWNv1wiLFxuICAgIFwi5aaoXCIsXG4gICAgXCLoiYdcIixcbiAgICBcIuWQnlwiLFxuICAgIFwi6Z+mXCIsXG4gICAgXCLmgKhcIixcbiAgICBcIuefrlwiLFxuICAgIFwi5q2HXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcIueahFwiLFxuICAgIFwi5LiAXCIsXG4gICAgXCLmmK9cIixcbiAgICBcIuWcqFwiLFxuICAgIFwi5LiNXCIsXG4gICAgXCLkuoZcIixcbiAgICBcIuaciVwiLFxuICAgIFwi5ZKMXCIsXG4gICAgXCLkurpcIixcbiAgICBcIumAmVwiLFxuICAgIFwi5LitXCIsXG4gICAgXCLlpKdcIixcbiAgICBcIueCulwiLFxuICAgIFwi5LiKXCIsXG4gICAgXCLlgItcIixcbiAgICBcIuWci1wiLFxuICAgIFwi5oiRXCIsXG4gICAgXCLku6VcIixcbiAgICBcIuimgVwiLFxuICAgIFwi5LuWXCIsXG4gICAgXCLmmYJcIixcbiAgICBcIuS+hlwiLFxuICAgIFwi55SoXCIsXG4gICAgXCLlgJFcIixcbiAgICBcIueUn1wiLFxuICAgIFwi5YiwXCIsXG4gICAgXCLkvZxcIixcbiAgICBcIuWcsFwiLFxuICAgIFwi5pa8XCIsXG4gICAgXCLlh7pcIixcbiAgICBcIuWwsVwiLFxuICAgIFwi5YiGXCIsXG4gICAgXCLlsI1cIixcbiAgICBcIuaIkFwiLFxuICAgIFwi5pyDXCIsXG4gICAgXCLlj69cIixcbiAgICBcIuS4u1wiLFxuICAgIFwi55m8XCIsXG4gICAgXCLlubRcIixcbiAgICBcIuWLlVwiLFxuICAgIFwi5ZCMXCIsXG4gICAgXCLlt6VcIixcbiAgICBcIuS5n1wiLFxuICAgIFwi6IO9XCIsXG4gICAgXCLkuItcIixcbiAgICBcIumBjlwiLFxuICAgIFwi5a2QXCIsXG4gICAgXCLoqqpcIixcbiAgICBcIueUolwiLFxuICAgIFwi56iuXCIsXG4gICAgXCLpnaJcIixcbiAgICBcIuiAjFwiLFxuICAgIFwi5pa5XCIsXG4gICAgXCLlvoxcIixcbiAgICBcIuWkmlwiLFxuICAgIFwi5a6aXCIsXG4gICAgXCLooYxcIixcbiAgICBcIuWtuFwiLFxuICAgIFwi5rOVXCIsXG4gICAgXCLmiYBcIixcbiAgICBcIuawkVwiLFxuICAgIFwi5b6XXCIsXG4gICAgXCLntpNcIixcbiAgICBcIuWNgVwiLFxuICAgIFwi5LiJXCIsXG4gICAgXCLkuYtcIixcbiAgICBcIumAslwiLFxuICAgIFwi6JGXXCIsXG4gICAgXCLnrYlcIixcbiAgICBcIumDqFwiLFxuICAgIFwi5bqmXCIsXG4gICAgXCLlrrZcIixcbiAgICBcIumbu1wiLFxuICAgIFwi5YqbXCIsXG4gICAgXCLoo6FcIixcbiAgICBcIuWmglwiLFxuICAgIFwi5rC0XCIsXG4gICAgXCLljJZcIixcbiAgICBcIumrmFwiLFxuICAgIFwi6IeqXCIsXG4gICAgXCLkuoxcIixcbiAgICBcIueQhlwiLFxuICAgIFwi6LW3XCIsXG4gICAgXCLlsI9cIixcbiAgICBcIueJqVwiLFxuICAgIFwi54++XCIsXG4gICAgXCLlr6ZcIixcbiAgICBcIuWKoFwiLFxuICAgIFwi6YePXCIsXG4gICAgXCLpg71cIixcbiAgICBcIuWFqVwiLFxuICAgIFwi6auUXCIsXG4gICAgXCLliLZcIixcbiAgICBcIuapn1wiLFxuICAgIFwi55W2XCIsXG4gICAgXCLkvb9cIixcbiAgICBcIum7nlwiLFxuICAgIFwi5b6eXCIsXG4gICAgXCLmpa1cIixcbiAgICBcIuacrFwiLFxuICAgIFwi5Y67XCIsXG4gICAgXCLmiopcIixcbiAgICBcIuaAp1wiLFxuICAgIFwi5aW9XCIsXG4gICAgXCLmh4lcIixcbiAgICBcIumWi1wiLFxuICAgIFwi5a6DXCIsXG4gICAgXCLlkIhcIixcbiAgICBcIumChFwiLFxuICAgIFwi5ZugXCIsXG4gICAgXCLnlLFcIixcbiAgICBcIuWFtlwiLFxuICAgIFwi5LqbXCIsXG4gICAgXCLnhLZcIixcbiAgICBcIuWJjVwiLFxuICAgIFwi5aSWXCIsXG4gICAgXCLlpKlcIixcbiAgICBcIuaUv1wiLFxuICAgIFwi5ZubXCIsXG4gICAgXCLml6VcIixcbiAgICBcIumCo1wiLFxuICAgIFwi56S+XCIsXG4gICAgXCLnvqlcIixcbiAgICBcIuS6i1wiLFxuICAgIFwi5bmzXCIsXG4gICAgXCLlvaJcIixcbiAgICBcIuebuFwiLFxuICAgIFwi5YWoXCIsXG4gICAgXCLooahcIixcbiAgICBcIumWk1wiLFxuICAgIFwi5qijXCIsXG4gICAgXCLoiIdcIixcbiAgICBcIumXnFwiLFxuICAgIFwi5ZCEXCIsXG4gICAgXCLph41cIixcbiAgICBcIuaWsFwiLFxuICAgIFwi57eaXCIsXG4gICAgXCLlhadcIixcbiAgICBcIuaVuFwiLFxuICAgIFwi5q2jXCIsXG4gICAgXCLlv4NcIixcbiAgICBcIuWPjVwiLFxuICAgIFwi5L2gXCIsXG4gICAgXCLmmI5cIixcbiAgICBcIueci1wiLFxuICAgIFwi5Y6fXCIsXG4gICAgXCLlj4hcIixcbiAgICBcIum6vFwiLFxuICAgIFwi5YipXCIsXG4gICAgXCLmr5RcIixcbiAgICBcIuaIllwiLFxuICAgIFwi5L2GXCIsXG4gICAgXCLos6pcIixcbiAgICBcIuawo1wiLFxuICAgIFwi56ysXCIsXG4gICAgXCLlkJFcIixcbiAgICBcIumBk1wiLFxuICAgIFwi5ZG9XCIsXG4gICAgXCLmraRcIixcbiAgICBcIuiuilwiLFxuICAgIFwi5qKdXCIsXG4gICAgXCLlj6pcIixcbiAgICBcIuayklwiLFxuICAgIFwi57WQXCIsXG4gICAgXCLop6NcIixcbiAgICBcIuWVj1wiLFxuICAgIFwi5oSPXCIsXG4gICAgXCLlu7pcIixcbiAgICBcIuaciFwiLFxuICAgIFwi5YWsXCIsXG4gICAgXCLnhKFcIixcbiAgICBcIuezu1wiLFxuICAgIFwi6LuNXCIsXG4gICAgXCLlvohcIixcbiAgICBcIuaDhVwiLFxuICAgIFwi6ICFXCIsXG4gICAgXCLmnIBcIixcbiAgICBcIueri1wiLFxuICAgIFwi5LujXCIsXG4gICAgXCLmg7NcIixcbiAgICBcIuW3slwiLFxuICAgIFwi6YCaXCIsXG4gICAgXCLkuKZcIixcbiAgICBcIuaPkFwiLFxuICAgIFwi55u0XCIsXG4gICAgXCLpoYxcIixcbiAgICBcIum7qFwiLFxuICAgIFwi56iLXCIsXG4gICAgXCLlsZVcIixcbiAgICBcIuS6lFwiLFxuICAgIFwi5p6cXCIsXG4gICAgXCLmlplcIixcbiAgICBcIuixoVwiLFxuICAgIFwi5ZOhXCIsXG4gICAgXCLpnalcIixcbiAgICBcIuS9jVwiLFxuICAgIFwi5YWlXCIsXG4gICAgXCLluLhcIixcbiAgICBcIuaWh1wiLFxuICAgIFwi57i9XCIsXG4gICAgXCLmrKFcIixcbiAgICBcIuWTgVwiLFxuICAgIFwi5byPXCIsXG4gICAgXCLmtLtcIixcbiAgICBcIuiorVwiLFxuICAgIFwi5Y+KXCIsXG4gICAgXCLnrqFcIixcbiAgICBcIueJuVwiLFxuICAgIFwi5Lu2XCIsXG4gICAgXCLplbdcIixcbiAgICBcIuaxglwiLFxuICAgIFwi6ICBXCIsXG4gICAgXCLpoK1cIixcbiAgICBcIuWfulwiLFxuICAgIFwi6LOHXCIsXG4gICAgXCLpgopcIixcbiAgICBcIua1gVwiLFxuICAgIFwi6LevXCIsXG4gICAgXCLntJpcIixcbiAgICBcIuWwkVwiLFxuICAgIFwi5ZyWXCIsXG4gICAgXCLlsbFcIixcbiAgICBcIue1sVwiLFxuICAgIFwi5o6lXCIsXG4gICAgXCLnn6VcIixcbiAgICBcIui8g1wiLFxuICAgIFwi5bCHXCIsXG4gICAgXCLntYRcIixcbiAgICBcIuimi1wiLFxuICAgIFwi6KiIXCIsXG4gICAgXCLliKVcIixcbiAgICBcIuWluVwiLFxuICAgIFwi5omLXCIsXG4gICAgXCLop5JcIixcbiAgICBcIuacn1wiLFxuICAgIFwi5qC5XCIsXG4gICAgXCLoq5ZcIixcbiAgICBcIumBi1wiLFxuICAgIFwi6L6yXCIsXG4gICAgXCLmjIdcIixcbiAgICBcIuW5vlwiLFxuICAgIFwi5LmdXCIsXG4gICAgXCLljYBcIixcbiAgICBcIuW8t1wiLFxuICAgIFwi5pS+XCIsXG4gICAgXCLmsbpcIixcbiAgICBcIuilv1wiLFxuICAgIFwi6KKrXCIsXG4gICAgXCLlublcIixcbiAgICBcIuWBmlwiLFxuICAgIFwi5b+FXCIsXG4gICAgXCLmiLBcIixcbiAgICBcIuWFiFwiLFxuICAgIFwi5ZueXCIsXG4gICAgXCLliYdcIixcbiAgICBcIuS7u1wiLFxuICAgIFwi5Y+WXCIsXG4gICAgXCLmk5pcIixcbiAgICBcIuiZlVwiLFxuICAgIFwi6ZqKXCIsXG4gICAgXCLljZdcIixcbiAgICBcIue1plwiLFxuICAgIFwi6ImyXCIsXG4gICAgXCLlhYlcIixcbiAgICBcIumWgFwiLFxuICAgIFwi5Y2zXCIsXG4gICAgXCLkv51cIixcbiAgICBcIuayu1wiLFxuICAgIFwi5YyXXCIsXG4gICAgXCLpgKBcIixcbiAgICBcIueZvlwiLFxuICAgIFwi6KaPXCIsXG4gICAgXCLnhrFcIixcbiAgICBcIumgmFwiLFxuICAgIFwi5LiDXCIsXG4gICAgXCLmtbdcIixcbiAgICBcIuWPo1wiLFxuICAgIFwi5p2xXCIsXG4gICAgXCLlsI5cIixcbiAgICBcIuWZqFwiLFxuICAgIFwi5aOTXCIsXG4gICAgXCLlv5dcIixcbiAgICBcIuS4llwiLFxuICAgIFwi6YeRXCIsXG4gICAgXCLlop5cIixcbiAgICBcIueIrVwiLFxuICAgIFwi5r+fXCIsXG4gICAgXCLpmo5cIixcbiAgICBcIuayuVwiLFxuICAgIFwi5oCdXCIsXG4gICAgXCLooZNcIixcbiAgICBcIualtVwiLFxuICAgIFwi5LqkXCIsXG4gICAgXCLlj5dcIixcbiAgICBcIuiBr1wiLFxuICAgIFwi5LuAXCIsXG4gICAgXCLoqo1cIixcbiAgICBcIuWFrVwiLFxuICAgIFwi5YWxXCIsXG4gICAgXCLmrIpcIixcbiAgICBcIuaUtlwiLFxuICAgIFwi6K2JXCIsXG4gICAgXCLmlLlcIixcbiAgICBcIua4hVwiLFxuICAgIFwi576OXCIsXG4gICAgXCLlho1cIixcbiAgICBcIuaOoVwiLFxuICAgIFwi6L2JXCIsXG4gICAgXCLmm7RcIixcbiAgICBcIuWWrlwiLFxuICAgIFwi6aKoXCIsXG4gICAgXCLliIdcIixcbiAgICBcIuaJk1wiLFxuICAgIFwi55m9XCIsXG4gICAgXCLmlZlcIixcbiAgICBcIumAn1wiLFxuICAgIFwi6IqxXCIsXG4gICAgXCLluLZcIixcbiAgICBcIuWuiVwiLFxuICAgIFwi5aC0XCIsXG4gICAgXCLouqtcIixcbiAgICBcIui7ilwiLFxuICAgIFwi5L6LXCIsXG4gICAgXCLnnJ9cIixcbiAgICBcIuWLmVwiLFxuICAgIFwi5YW3XCIsXG4gICAgXCLokKxcIixcbiAgICBcIuavj1wiLFxuICAgIFwi55uuXCIsXG4gICAgXCLoh7NcIixcbiAgICBcIumBlFwiLFxuICAgIFwi6LWwXCIsXG4gICAgXCLnqY1cIixcbiAgICBcIuekulwiLFxuICAgIFwi6K2wXCIsXG4gICAgXCLogbJcIixcbiAgICBcIuWgsVwiLFxuICAgIFwi6aylXCIsXG4gICAgXCLlroxcIixcbiAgICBcIumhnlwiLFxuICAgIFwi5YWrXCIsXG4gICAgXCLpm6JcIixcbiAgICBcIuiPr1wiLFxuICAgIFwi5ZCNXCIsXG4gICAgXCLnorpcIixcbiAgICBcIuaJjVwiLFxuICAgIFwi56eRXCIsXG4gICAgXCLlvLVcIixcbiAgICBcIuS/oVwiLFxuICAgIFwi6aasXCIsXG4gICAgXCLnr4BcIixcbiAgICBcIuipsVwiLFxuICAgIFwi57GzXCIsXG4gICAgXCLmlbRcIixcbiAgICBcIuepulwiLFxuICAgIFwi5YWDXCIsXG4gICAgXCLms4FcIixcbiAgICBcIuS7ilwiLFxuICAgIFwi6ZuGXCIsXG4gICAgXCLmuqtcIixcbiAgICBcIuWCs1wiLFxuICAgIFwi5ZyfXCIsXG4gICAgXCLoqLFcIixcbiAgICBcIuatpVwiLFxuICAgIFwi576kXCIsXG4gICAgXCLlu6NcIixcbiAgICBcIuefs1wiLFxuICAgIFwi6KiYXCIsXG4gICAgXCLpnIBcIixcbiAgICBcIuautVwiLFxuICAgIFwi56CUXCIsXG4gICAgXCLnlYxcIixcbiAgICBcIuaLiVwiLFxuICAgIFwi5p6XXCIsXG4gICAgXCLlvotcIixcbiAgICBcIuWPq1wiLFxuICAgIFwi5LiUXCIsXG4gICAgXCLnqbZcIixcbiAgICBcIuingFwiLFxuICAgIFwi6LaKXCIsXG4gICAgXCLnuZRcIixcbiAgICBcIuijnVwiLFxuICAgIFwi5b2xXCIsXG4gICAgXCLnrpdcIixcbiAgICBcIuS9jlwiLFxuICAgIFwi5oyBXCIsXG4gICAgXCLpn7NcIixcbiAgICBcIuecvlwiLFxuICAgIFwi5pu4XCIsXG4gICAgXCLluINcIixcbiAgICBcIuWkjVwiLFxuICAgIFwi5a65XCIsXG4gICAgXCLlhZJcIixcbiAgICBcIumgiFwiLFxuICAgIFwi6ZqbXCIsXG4gICAgXCLllYZcIixcbiAgICBcIumdnlwiLFxuICAgIFwi6amXXCIsXG4gICAgXCLpgKNcIixcbiAgICBcIuaWt1wiLFxuICAgIFwi5rexXCIsXG4gICAgXCLpm6NcIixcbiAgICBcIui/kVwiLFxuICAgIFwi56SmXCIsXG4gICAgXCLljYNcIixcbiAgICBcIumAsVwiLFxuICAgIFwi5aeUXCIsXG4gICAgXCLntKBcIixcbiAgICBcIuaKgFwiLFxuICAgIFwi5YKZXCIsXG4gICAgXCLljYpcIixcbiAgICBcIui+plwiLFxuICAgIFwi6Z2SXCIsXG4gICAgXCLnnIFcIixcbiAgICBcIuWIl1wiLFxuICAgIFwi57+SXCIsXG4gICAgXCLpn79cIixcbiAgICBcIue0hFwiLFxuICAgIFwi5pSvXCIsXG4gICAgXCLoiKxcIixcbiAgICBcIuWPslwiLFxuICAgIFwi5oSfXCIsXG4gICAgXCLli55cIixcbiAgICBcIuS+v1wiLFxuICAgIFwi5ZyYXCIsXG4gICAgXCLlvoBcIixcbiAgICBcIumFuFwiLFxuICAgIFwi5q23XCIsXG4gICAgXCLluIJcIixcbiAgICBcIuWFi1wiLFxuICAgIFwi5L2VXCIsXG4gICAgXCLpmaRcIixcbiAgICBcIua2iFwiLFxuICAgIFwi5qeLXCIsXG4gICAgXCLlupxcIixcbiAgICBcIueosVwiLFxuICAgIFwi5aSqXCIsXG4gICAgXCLmupZcIixcbiAgICBcIueyvlwiLFxuICAgIFwi5YC8XCIsXG4gICAgXCLomZ9cIixcbiAgICBcIueOh1wiLFxuICAgIFwi5pePXCIsXG4gICAgXCLntq1cIixcbiAgICBcIuWKg1wiLFxuICAgIFwi6YG4XCIsXG4gICAgXCLmqJlcIixcbiAgICBcIuWvq1wiLFxuICAgIFwi5a2YXCIsXG4gICAgXCLlgJlcIixcbiAgICBcIuavm1wiLFxuICAgIFwi6KaqXCIsXG4gICAgXCLlv6tcIixcbiAgICBcIuaViFwiLFxuICAgIFwi5pavXCIsXG4gICAgXCLpmaJcIixcbiAgICBcIuafpVwiLFxuICAgIFwi5rGfXCIsXG4gICAgXCLlnotcIixcbiAgICBcIuecvFwiLFxuICAgIFwi546LXCIsXG4gICAgXCLmjIlcIixcbiAgICBcIuagvFwiLFxuICAgIFwi6aSKXCIsXG4gICAgXCLmmJNcIixcbiAgICBcIue9rlwiLFxuICAgIFwi5rS+XCIsXG4gICAgXCLlsaRcIixcbiAgICBcIueJh1wiLFxuICAgIFwi5aeLXCIsXG4gICAgXCLljbtcIixcbiAgICBcIuWwiFwiLFxuICAgIFwi54uAXCIsXG4gICAgXCLogrJcIixcbiAgICBcIuW7oFwiLFxuICAgIFwi5LqsXCIsXG4gICAgXCLorZhcIixcbiAgICBcIumBqVwiLFxuICAgIFwi5bGsXCIsXG4gICAgXCLlnJNcIixcbiAgICBcIuWMhVwiLFxuICAgIFwi54GrXCIsXG4gICAgXCLkvY9cIixcbiAgICBcIuiqv1wiLFxuICAgIFwi5ru/XCIsXG4gICAgXCLnuKNcIixcbiAgICBcIuWxgFwiLFxuICAgIFwi54WnXCIsXG4gICAgXCLlj4NcIixcbiAgICBcIue0hVwiLFxuICAgIFwi57SwXCIsXG4gICAgXCLlvJVcIixcbiAgICBcIuiBvVwiLFxuICAgIFwi6KmyXCIsXG4gICAgXCLpkLVcIixcbiAgICBcIuWDuVwiLFxuICAgIFwi5Zq0XCIsXG4gICAgXCLpppZcIixcbiAgICBcIuW6lVwiLFxuICAgIFwi5rayXCIsXG4gICAgXCLlrphcIixcbiAgICBcIuW+t1wiLFxuICAgIFwi6ZqoXCIsXG4gICAgXCLnl4VcIixcbiAgICBcIuiYh1wiLFxuICAgIFwi5aSxXCIsXG4gICAgXCLniL5cIixcbiAgICBcIuatu1wiLFxuICAgIFwi6KybXCIsXG4gICAgXCLphY1cIixcbiAgICBcIuWls1wiLFxuICAgIFwi6buDXCIsXG4gICAgXCLmjqhcIixcbiAgICBcIumhr1wiLFxuICAgIFwi6KuHXCIsXG4gICAgXCLnvapcIixcbiAgICBcIuelnlwiLFxuICAgIFwi6JedXCIsXG4gICAgXCLlkaJcIixcbiAgICBcIuW4rVwiLFxuICAgIFwi5ZCrXCIsXG4gICAgXCLkvIFcIixcbiAgICBcIuacm1wiLFxuICAgIFwi5a+GXCIsXG4gICAgXCLmiblcIixcbiAgICBcIueHn1wiLFxuICAgIFwi6aCFXCIsXG4gICAgXCLpmLJcIixcbiAgICBcIuiIiVwiLFxuICAgIFwi55CDXCIsXG4gICAgXCLoi7FcIixcbiAgICBcIuawp1wiLFxuICAgIFwi5YuiXCIsXG4gICAgXCLlkYpcIixcbiAgICBcIuadjlwiLFxuICAgIFwi5Y+wXCIsXG4gICAgXCLokL1cIixcbiAgICBcIuacqFwiLFxuICAgIFwi5bmrXCIsXG4gICAgXCLovKpcIixcbiAgICBcIuegtFwiLFxuICAgIFwi5LqeXCIsXG4gICAgXCLluKtcIixcbiAgICBcIuWcjVwiLFxuICAgIFwi5rOoXCIsXG4gICAgXCLpgaBcIixcbiAgICBcIuWtl1wiLFxuICAgIFwi5p2QXCIsXG4gICAgXCLmjpJcIixcbiAgICBcIuS+m1wiLFxuICAgIFwi5rKzXCIsXG4gICAgXCLmhYtcIixcbiAgICBcIuWwgVwiLFxuICAgIFwi5Y+mXCIsXG4gICAgXCLmlr1cIixcbiAgICBcIua4m1wiLFxuICAgIFwi5qi5XCIsXG4gICAgXCLmurZcIixcbiAgICBcIuaAjlwiLFxuICAgIFwi5q2iXCIsXG4gICAgXCLmoYhcIixcbiAgICBcIuiogFwiLFxuICAgIFwi5aOrXCIsXG4gICAgXCLlnYdcIixcbiAgICBcIuatplwiLFxuICAgIFwi5Zu6XCIsXG4gICAgXCLokYlcIixcbiAgICBcIumtmlwiLFxuICAgIFwi5rOiXCIsXG4gICAgXCLoppZcIixcbiAgICBcIuWDhVwiLFxuICAgIFwi6LK7XCIsXG4gICAgXCLnt4pcIixcbiAgICBcIuaEm1wiLFxuICAgIFwi5bemXCIsXG4gICAgXCLnq6BcIixcbiAgICBcIuaXqVwiLFxuICAgIFwi5pydXCIsXG4gICAgXCLlrrNcIixcbiAgICBcIue6jFwiLFxuICAgIFwi6LyVXCIsXG4gICAgXCLmnI1cIixcbiAgICBcIuipplwiLFxuICAgIFwi6aOfXCIsXG4gICAgXCLlhYVcIixcbiAgICBcIuWFtVwiLFxuICAgIFwi5rqQXCIsXG4gICAgXCLliKRcIixcbiAgICBcIuitt1wiLFxuICAgIFwi5Y+4XCIsXG4gICAgXCLotrNcIixcbiAgICBcIuafkFwiLFxuICAgIFwi57e0XCIsXG4gICAgXCLlt65cIixcbiAgICBcIuiHtFwiLFxuICAgIFwi5p2/XCIsXG4gICAgXCLnlLBcIixcbiAgICBcIumZjVwiLFxuICAgIFwi6buRXCIsXG4gICAgXCLniq9cIixcbiAgICBcIuiyoFwiLFxuICAgIFwi5pOKXCIsXG4gICAgXCLojINcIixcbiAgICBcIue5vFwiLFxuICAgIFwi6IiIXCIsXG4gICAgXCLkvLxcIixcbiAgICBcIumkmFwiLFxuICAgIFwi5aCFXCIsXG4gICAgXCLmm7JcIixcbiAgICBcIui8uFwiLFxuICAgIFwi5L+uXCIsXG4gICAgXCLmlYVcIixcbiAgICBcIuWfjlwiLFxuICAgIFwi5aSrXCIsXG4gICAgXCLlpKBcIixcbiAgICBcIumAgVwiLFxuICAgIFwi562GXCIsXG4gICAgXCLoiLlcIixcbiAgICBcIuS9lFwiLFxuICAgIFwi5Y+zXCIsXG4gICAgXCLosqFcIixcbiAgICBcIuWQg1wiLFxuICAgIFwi5a+MXCIsXG4gICAgXCLmmKVcIixcbiAgICBcIuiBt1wiLFxuICAgIFwi6Ka6XCIsXG4gICAgXCLmvKJcIixcbiAgICBcIueVq1wiLFxuICAgIFwi5YqfXCIsXG4gICAgXCLlt7RcIixcbiAgICBcIui3n1wiLFxuICAgIFwi6ZuWXCIsXG4gICAgXCLpm5xcIixcbiAgICBcIumjm1wiLFxuICAgIFwi5qqiXCIsXG4gICAgXCLlkLhcIixcbiAgICBcIuWKqVwiLFxuICAgIFwi5piHXCIsXG4gICAgXCLpmb1cIixcbiAgICBcIuS6klwiLFxuICAgIFwi5YidXCIsXG4gICAgXCLlibVcIixcbiAgICBcIuaKl1wiLFxuICAgIFwi6ICDXCIsXG4gICAgXCLmipVcIixcbiAgICBcIuWjnlwiLFxuICAgIFwi562WXCIsXG4gICAgXCLlj6RcIixcbiAgICBcIuW+kVwiLFxuICAgIFwi5o+bXCIsXG4gICAgXCLmnKpcIixcbiAgICBcIui3kVwiLFxuICAgIFwi55WZXCIsXG4gICAgXCLpi7xcIixcbiAgICBcIuabvlwiLFxuICAgIFwi56uvXCIsXG4gICAgXCLosqxcIixcbiAgICBcIuermVwiLFxuICAgIFwi57ChXCIsXG4gICAgXCLov7BcIixcbiAgICBcIumMolwiLFxuICAgIFwi5YmvXCIsXG4gICAgXCLnm6FcIixcbiAgICBcIuW4nVwiLFxuICAgIFwi5bCEXCIsXG4gICAgXCLojYlcIixcbiAgICBcIuihnVwiLFxuICAgIFwi5om/XCIsXG4gICAgXCLnjahcIixcbiAgICBcIuS7pFwiLFxuICAgIFwi6ZmQXCIsXG4gICAgXCLpmL9cIixcbiAgICBcIuWuo1wiLFxuICAgIFwi55KwXCIsXG4gICAgXCLpm5lcIixcbiAgICBcIuiri1wiLFxuICAgIFwi6LaFXCIsXG4gICAgXCLlvq5cIixcbiAgICBcIuiuk1wiLFxuICAgIFwi5o6nXCIsXG4gICAgXCLlt55cIixcbiAgICBcIuiJr1wiLFxuICAgIFwi6Lu4XCIsXG4gICAgXCLmib5cIixcbiAgICBcIuWQplwiLFxuICAgIFwi57SAXCIsXG4gICAgXCLnm4pcIixcbiAgICBcIuS+nVwiLFxuICAgIFwi5YSqXCIsXG4gICAgXCLpoIJcIixcbiAgICBcIuekjlwiLFxuICAgIFwi6LyJXCIsXG4gICAgXCLlgJJcIixcbiAgICBcIuaIv1wiLFxuICAgIFwi56qBXCIsXG4gICAgXCLlnZBcIixcbiAgICBcIueyiVwiLFxuICAgIFwi5pW1XCIsXG4gICAgXCLnlaVcIixcbiAgICBcIuWuolwiLFxuICAgIFwi6KKBXCIsXG4gICAgXCLlhrdcIixcbiAgICBcIuWLnVwiLFxuICAgIFwi57WVXCIsXG4gICAgXCLmnpBcIixcbiAgICBcIuWhilwiLFxuICAgIFwi5YqRXCIsXG4gICAgXCLmuKxcIixcbiAgICBcIue1slwiLFxuICAgIFwi5Y2UXCIsXG4gICAgXCLoqLRcIixcbiAgICBcIuW/tVwiLFxuICAgIFwi6ZmzXCIsXG4gICAgXCLku41cIixcbiAgICBcIue+hVwiLFxuICAgIFwi6bm9XCIsXG4gICAgXCLlj4tcIixcbiAgICBcIua0i1wiLFxuICAgIFwi6YyvXCIsXG4gICAgXCLoi6ZcIixcbiAgICBcIuWknFwiLFxuICAgIFwi5YiRXCIsXG4gICAgXCLnp7tcIixcbiAgICBcIumgu1wiLFxuICAgIFwi6YCQXCIsXG4gICAgXCLpnaBcIixcbiAgICBcIua3t1wiLFxuICAgIFwi5q+NXCIsXG4gICAgXCLnn61cIixcbiAgICBcIuearlwiLFxuICAgIFwi57WCXCIsXG4gICAgXCLogZpcIixcbiAgICBcIuaxvVwiLFxuICAgIFwi5p2RXCIsXG4gICAgXCLpm7JcIixcbiAgICBcIuWTqlwiLFxuICAgIFwi5peiXCIsXG4gICAgXCLot51cIixcbiAgICBcIuihm1wiLFxuICAgIFwi5YGcXCIsXG4gICAgXCLng4hcIixcbiAgICBcIuWkrlwiLFxuICAgIFwi5a+fXCIsXG4gICAgXCLnh5JcIixcbiAgICBcIui/hVwiLFxuICAgIFwi5aKDXCIsXG4gICAgXCLoi6VcIixcbiAgICBcIuWNsFwiLFxuICAgIFwi5rSyXCIsXG4gICAgXCLliLtcIixcbiAgICBcIuaLrFwiLFxuICAgIFwi5r+AXCIsXG4gICAgXCLlrZRcIixcbiAgICBcIuaQnlwiLFxuICAgIFwi55SaXCIsXG4gICAgXCLlrqRcIixcbiAgICBcIuW+hVwiLFxuICAgIFwi5qC4XCIsXG4gICAgXCLmoKFcIixcbiAgICBcIuaVo1wiLFxuICAgIFwi5L61XCIsXG4gICAgXCLlkKdcIixcbiAgICBcIueUslwiLFxuICAgIFwi6YGKXCIsXG4gICAgXCLkuYVcIixcbiAgICBcIuiPnFwiLFxuICAgIFwi5ZGzXCIsXG4gICAgXCLoiIpcIixcbiAgICBcIuaooVwiLFxuICAgIFwi5rmWXCIsXG4gICAgXCLosqhcIixcbiAgICBcIuaQjVwiLFxuICAgIFwi6aCQXCIsXG4gICAgXCLpmLtcIixcbiAgICBcIuavq1wiLFxuICAgIFwi5pmuXCIsXG4gICAgXCLnqalcIixcbiAgICBcIuS5mVwiLFxuICAgIFwi5aq9XCIsXG4gICAgXCLmpI1cIixcbiAgICBcIuaBr1wiLFxuICAgIFwi5pO0XCIsXG4gICAgXCLpioBcIixcbiAgICBcIuiqnlwiLFxuICAgIFwi5o+uXCIsXG4gICAgXCLphZJcIixcbiAgICBcIuWuiFwiLFxuICAgIFwi5ou/XCIsXG4gICAgXCLluo9cIixcbiAgICBcIue0mVwiLFxuICAgIFwi6YarXCIsXG4gICAgXCLnvLpcIixcbiAgICBcIumbqFwiLFxuICAgIFwi5ZeOXCIsXG4gICAgXCLph51cIixcbiAgICBcIuWKiVwiLFxuICAgIFwi5ZWKXCIsXG4gICAgXCLmgKVcIixcbiAgICBcIuWUsVwiLFxuICAgIFwi6KqkXCIsXG4gICAgXCLoqJNcIixcbiAgICBcIumhmFwiLFxuICAgIFwi5a+pXCIsXG4gICAgXCLpmYRcIixcbiAgICBcIueNslwiLFxuICAgIFwi6Iy2XCIsXG4gICAgXCLprq5cIixcbiAgICBcIuezp1wiLFxuICAgIFwi5pakXCIsXG4gICAgXCLlralcIixcbiAgICBcIuiEq1wiLFxuICAgIFwi56GrXCIsXG4gICAgXCLogqVcIixcbiAgICBcIuWWhFwiLFxuICAgIFwi6b6NXCIsXG4gICAgXCLmvJRcIixcbiAgICBcIueItlwiLFxuICAgIFwi5ry4XCIsXG4gICAgXCLooYBcIixcbiAgICBcIuatoVwiLFxuICAgIFwi5qKwXCIsXG4gICAgXCLmjoxcIixcbiAgICBcIuatjFwiLFxuICAgIFwi5rKZXCIsXG4gICAgXCLliZtcIixcbiAgICBcIuaUu1wiLFxuICAgIFwi6KyCXCIsXG4gICAgXCLnm75cIixcbiAgICBcIuiojlwiLFxuICAgIFwi5pmaXCIsXG4gICAgXCLnspJcIixcbiAgICBcIuS6glwiLFxuICAgIFwi54eDXCIsXG4gICAgXCLnn5tcIixcbiAgICBcIuS5jlwiLFxuICAgIFwi5q66XCIsXG4gICAgXCLol6VcIixcbiAgICBcIuWvp1wiLFxuICAgIFwi6a2vXCIsXG4gICAgXCLosrRcIixcbiAgICBcIumQmFwiLFxuICAgIFwi54WkXCIsXG4gICAgXCLoroBcIixcbiAgICBcIuePrVwiLFxuICAgIFwi5LyvXCIsXG4gICAgXCLppplcIixcbiAgICBcIuS7i1wiLFxuICAgIFwi6L+rXCIsXG4gICAgXCLlj6VcIixcbiAgICBcIuixkFwiLFxuICAgIFwi5Z+5XCIsXG4gICAgXCLmj6FcIixcbiAgICBcIuiYrVwiLFxuICAgIFwi5pOUXCIsXG4gICAgXCLlvKZcIixcbiAgICBcIuibi1wiLFxuICAgIFwi5rKJXCIsXG4gICAgXCLlgYdcIixcbiAgICBcIuepv1wiLFxuICAgIFwi5Z+3XCIsXG4gICAgXCLnrZRcIixcbiAgICBcIuaoglwiLFxuICAgIFwi6KqwXCIsXG4gICAgXCLpoIZcIixcbiAgICBcIueFmVwiLFxuICAgIFwi57iuXCIsXG4gICAgXCLlvrVcIixcbiAgICBcIuiHiVwiLFxuICAgIFwi5ZacXCIsXG4gICAgXCLmnb5cIixcbiAgICBcIuiFs1wiLFxuICAgIFwi5ZuwXCIsXG4gICAgXCLnlbBcIixcbiAgICBcIuWFjVwiLFxuICAgIFwi6IOMXCIsXG4gICAgXCLmmJ9cIixcbiAgICBcIuemj1wiLFxuICAgIFwi6LK3XCIsXG4gICAgXCLmn5NcIixcbiAgICBcIuS6lVwiLFxuICAgIFwi5qaCXCIsXG4gICAgXCLmhaJcIixcbiAgICBcIuaAlVwiLFxuICAgIFwi56OBXCIsXG4gICAgXCLlgI1cIixcbiAgICBcIuelllwiLFxuICAgIFwi55qHXCIsXG4gICAgXCLkv4NcIixcbiAgICBcIumdnFwiLFxuICAgIFwi6KOcXCIsXG4gICAgXCLoqZVcIixcbiAgICBcIue/u1wiLFxuICAgIFwi6IKJXCIsXG4gICAgXCLouJBcIixcbiAgICBcIuWwvFwiLFxuICAgIFwi6KGjXCIsXG4gICAgXCLlr6xcIixcbiAgICBcIuaPmlwiLFxuICAgIFwi5qOJXCIsXG4gICAgXCLluIxcIixcbiAgICBcIuWCt1wiLFxuICAgIFwi5pONXCIsXG4gICAgXCLlnoJcIixcbiAgICBcIueni1wiLFxuICAgIFwi5a6cXCIsXG4gICAgXCLmsKtcIixcbiAgICBcIuWll1wiLFxuICAgIFwi552jXCIsXG4gICAgXCLmjK9cIixcbiAgICBcIuaetlwiLFxuICAgIFwi5LquXCIsXG4gICAgXCLmnKtcIixcbiAgICBcIuaGslwiLFxuICAgIFwi5oW2XCIsXG4gICAgXCLnt6hcIixcbiAgICBcIueJm1wiLFxuICAgIFwi6Ke4XCIsXG4gICAgXCLmmKBcIixcbiAgICBcIumbt1wiLFxuICAgIFwi6Yq3XCIsXG4gICAgXCLoqalcIixcbiAgICBcIuW6p1wiLFxuICAgIFwi5bGFXCIsXG4gICAgXCLmipNcIixcbiAgICBcIuijglwiLFxuICAgIFwi6IOeXCIsXG4gICAgXCLlkbxcIixcbiAgICBcIuWomFwiLFxuICAgIFwi5pmvXCIsXG4gICAgXCLlqIFcIixcbiAgICBcIue2oFwiLFxuICAgIFwi5pm2XCIsXG4gICAgXCLljppcIixcbiAgICBcIuebn1wiLFxuICAgIFwi6KGhXCIsXG4gICAgXCLpm55cIixcbiAgICBcIuWtq1wiLFxuICAgIFwi5bu2XCIsXG4gICAgXCLljbFcIixcbiAgICBcIuiGoFwiLFxuICAgIFwi5bGLXCIsXG4gICAgXCLphIlcIixcbiAgICBcIuiHqFwiLFxuICAgIFwi6Zm4XCIsXG4gICAgXCLpoadcIixcbiAgICBcIuaOiVwiLFxuICAgIFwi5ZGAXCIsXG4gICAgXCLnh4hcIixcbiAgICBcIuatslwiLFxuICAgIFwi5o6qXCIsXG4gICAgXCLmnZ9cIixcbiAgICBcIuiAkFwiLFxuICAgIFwi5YqHXCIsXG4gICAgXCLnjolcIixcbiAgICBcIui2mVwiLFxuICAgIFwi6LezXCIsXG4gICAgXCLlk6VcIixcbiAgICBcIuWto1wiLFxuICAgIFwi6KqyXCIsXG4gICAgXCLlh7FcIixcbiAgICBcIuiDoVwiLFxuICAgIFwi6aGNXCIsXG4gICAgXCLmrL5cIixcbiAgICBcIue0uVwiLFxuICAgIFwi5Y23XCIsXG4gICAgXCLpvYpcIixcbiAgICBcIuWBiVwiLFxuICAgIFwi6JK4XCIsXG4gICAgXCLmrpZcIixcbiAgICBcIuawuFwiLFxuICAgIFwi5a6XXCIsXG4gICAgXCLoi5dcIixcbiAgICBcIuW3nVwiLFxuICAgIFwi54iQXCIsXG4gICAgXCLlsqlcIixcbiAgICBcIuW8sVwiLFxuICAgIFwi6Zu2XCIsXG4gICAgXCLmpYpcIixcbiAgICBcIuWlj1wiLFxuICAgIFwi5rK/XCIsXG4gICAgXCLpnLJcIixcbiAgICBcIuahv1wiLFxuICAgIFwi5o6iXCIsXG4gICAgXCLmu5FcIixcbiAgICBcIumOrlwiLFxuICAgIFwi6aOvXCIsXG4gICAgXCLmv4NcIixcbiAgICBcIuiIqlwiLFxuICAgIFwi5oe3XCIsXG4gICAgXCLotpVcIixcbiAgICBcIuW6q1wiLFxuICAgIFwi5aWqXCIsXG4gICAgXCLkvIpcIixcbiAgICBcIumdiFwiLFxuICAgIFwi56iFXCIsXG4gICAgXCLpgJRcIixcbiAgICBcIua7hVwiLFxuICAgIFwi6LO9XCIsXG4gICAgXCLmrbhcIixcbiAgICBcIuWPrFwiLFxuICAgIFwi6byTXCIsXG4gICAgXCLmkq1cIixcbiAgICBcIuebpFwiLFxuICAgIFwi6KOBXCIsXG4gICAgXCLpmqpcIixcbiAgICBcIuW6t1wiLFxuICAgIFwi5ZSvXCIsXG4gICAgXCLpjIRcIixcbiAgICBcIuiPjFwiLFxuICAgIFwi57SUXCIsXG4gICAgXCLlgJ9cIixcbiAgICBcIuezllwiLFxuICAgIFwi6JOLXCIsXG4gICAgXCLmqatcIixcbiAgICBcIuesplwiLFxuICAgIFwi56eBXCIsXG4gICAgXCLliqpcIixcbiAgICBcIuWgglwiLFxuICAgIFwi5Z+fXCIsXG4gICAgXCLmp41cIixcbiAgICBcIua9pFwiLFxuICAgIFwi5bmFXCIsXG4gICAgXCLlk4hcIixcbiAgICBcIuern1wiLFxuICAgIFwi54afXCIsXG4gICAgXCLon7JcIixcbiAgICBcIua+pFwiLFxuICAgIFwi6IWmXCIsXG4gICAgXCLlo6RcIixcbiAgICBcIueis1wiLFxuICAgIFwi5q2QXCIsXG4gICAgXCLpgY1cIixcbiAgICBcIuWBtFwiLFxuICAgIFwi5a+oXCIsXG4gICAgXCLmlaJcIixcbiAgICBcIuW+uVwiLFxuICAgIFwi5oWuXCIsXG4gICAgXCLmlpxcIixcbiAgICBcIuiWhFwiLFxuICAgIFwi5bqtXCIsXG4gICAgXCLntI1cIixcbiAgICBcIuW9iFwiLFxuICAgIFwi6aO8XCIsXG4gICAgXCLkvLhcIixcbiAgICBcIuaKmFwiLFxuICAgIFwi6bqlXCIsXG4gICAgXCLmv5VcIixcbiAgICBcIuaal1wiLFxuICAgIFwi6I23XCIsXG4gICAgXCLnk6ZcIixcbiAgICBcIuWhnlwiLFxuICAgIFwi5bqKXCIsXG4gICAgXCLnr4lcIixcbiAgICBcIuaDoVwiLFxuICAgIFwi5oi2XCIsXG4gICAgXCLoqKpcIixcbiAgICBcIuWhlFwiLFxuICAgIFwi5aWHXCIsXG4gICAgXCLpgI9cIixcbiAgICBcIuaigVwiLFxuICAgIFwi5YiAXCIsXG4gICAgXCLml4tcIixcbiAgICBcIui3oVwiLFxuICAgIFwi5Y2hXCIsXG4gICAgXCLmsK9cIixcbiAgICBcIumBh1wiLFxuICAgIFwi5Lu9XCIsXG4gICAgXCLmr5JcIixcbiAgICBcIuazpVwiLFxuICAgIFwi6YCAXCIsXG4gICAgXCLmtJdcIixcbiAgICBcIuaTulwiLFxuICAgIFwi54GwXCIsXG4gICAgXCLlvalcIixcbiAgICBcIuizo1wiLFxuICAgIFwi6ICXXCIsXG4gICAgXCLlpI9cIixcbiAgICBcIuaTh1wiLFxuICAgIFwi5b+ZXCIsXG4gICAgXCLpioVcIixcbiAgICBcIueNu1wiLFxuICAgIFwi56GsXCIsXG4gICAgXCLkuohcIixcbiAgICBcIue5gVwiLFxuICAgIFwi5ZyIXCIsXG4gICAgXCLpm6pcIixcbiAgICBcIuWHvVwiLFxuICAgIFwi5LqmXCIsXG4gICAgXCLmir1cIixcbiAgICBcIuevh1wiLFxuICAgIFwi6ZmjXCIsXG4gICAgXCLpmbBcIixcbiAgICBcIuS4gVwiLFxuICAgIFwi5bC6XCIsXG4gICAgXCLov71cIixcbiAgICBcIuWghlwiLFxuICAgIFwi6ZuEXCIsXG4gICAgXCLov45cIixcbiAgICBcIuazm1wiLFxuICAgIFwi54i4XCIsXG4gICAgXCLmqJNcIixcbiAgICBcIumBv1wiLFxuICAgIFwi6KyAXCIsXG4gICAgXCLlmbhcIixcbiAgICBcIumHjlwiLFxuICAgIFwi6LGsXCIsXG4gICAgXCLml5dcIixcbiAgICBcIue0r1wiLFxuICAgIFwi5YGPXCIsXG4gICAgXCLlhbhcIixcbiAgICBcIumkqFwiLFxuICAgIFwi57SiXCIsXG4gICAgXCLnp6ZcIixcbiAgICBcIuiEglwiLFxuICAgIFwi5r2uXCIsXG4gICAgXCLniLpcIixcbiAgICBcIuixhlwiLFxuICAgIFwi5b+9XCIsXG4gICAgXCLmiZhcIixcbiAgICBcIumpmlwiLFxuICAgIFwi5aGRXCIsXG4gICAgXCLpgbpcIixcbiAgICBcIuaEiFwiLFxuICAgIFwi5pyxXCIsXG4gICAgXCLmm79cIixcbiAgICBcIue6llwiLFxuICAgIFwi57KXXCIsXG4gICAgXCLlgr5cIixcbiAgICBcIuWwmlwiLFxuICAgIFwi55ebXCIsXG4gICAgXCLmpZpcIixcbiAgICBcIuisnVwiLFxuICAgIFwi5aWuXCIsXG4gICAgXCLos7xcIixcbiAgICBcIuejqFwiLFxuICAgIFwi5ZCbXCIsXG4gICAgXCLmsaBcIixcbiAgICBcIuaXgVwiLFxuICAgIFwi56KOXCIsXG4gICAgXCLpqqhcIixcbiAgICBcIuebo1wiLFxuICAgIFwi5o2VXCIsXG4gICAgXCLlvJ9cIixcbiAgICBcIuaatFwiLFxuICAgIFwi5YmyXCIsXG4gICAgXCLosqtcIixcbiAgICBcIuauilwiLFxuICAgIFwi6YeLXCIsXG4gICAgXCLoqZ5cIixcbiAgICBcIuS6oVwiLFxuICAgIFwi5aOBXCIsXG4gICAgXCLpoJNcIixcbiAgICBcIuWvtlwiLFxuICAgIFwi5Y2IXCIsXG4gICAgXCLlobVcIixcbiAgICBcIuiBnlwiLFxuICAgIFwi5o+tXCIsXG4gICAgXCLngq5cIixcbiAgICBcIuaumFwiLFxuICAgIFwi5YasXCIsXG4gICAgXCLmqYtcIixcbiAgICBcIuWpplwiLFxuICAgIFwi6K2mXCIsXG4gICAgXCLntpxcIixcbiAgICBcIuaLm1wiLFxuICAgIFwi5ZCzXCIsXG4gICAgXCLku5hcIixcbiAgICBcIua1rlwiLFxuICAgIFwi6YGtXCIsXG4gICAgXCLlvpBcIixcbiAgICBcIuaCqFwiLFxuICAgIFwi5pCWXCIsXG4gICAgXCLosLdcIixcbiAgICBcIui0ilwiLFxuICAgIFwi566xXCIsXG4gICAgXCLpmpRcIixcbiAgICBcIuioglwiLFxuICAgIFwi55S3XCIsXG4gICAgXCLlkLlcIixcbiAgICBcIuWcklwiLFxuICAgIFwi57SbXCIsXG4gICAgXCLllJBcIixcbiAgICBcIuaVl1wiLFxuICAgIFwi5a6LXCIsXG4gICAgXCLnjrtcIixcbiAgICBcIuW3qFwiLFxuICAgIFwi6ICVXCIsXG4gICAgXCLlnaZcIixcbiAgICBcIuamrlwiLFxuICAgIFwi6ZaJXCIsXG4gICAgXCLngaNcIixcbiAgICBcIumNtVwiLFxuICAgIFwi5YehXCIsXG4gICAgXCLpp5BcIixcbiAgICBcIumNi1wiLFxuICAgIFwi5pWRXCIsXG4gICAgXCLmgalcIixcbiAgICBcIuWJnVwiLFxuICAgIFwi5YedXCIsXG4gICAgXCLpubxcIixcbiAgICBcIum9klwiLFxuICAgIFwi5oiqXCIsXG4gICAgXCLnhYlcIixcbiAgICBcIum6u1wiLFxuICAgIFwi57ShXCIsXG4gICAgXCLnpoFcIixcbiAgICBcIuW7olwiLFxuICAgIFwi55ubXCIsXG4gICAgXCLniYhcIixcbiAgICBcIue3qVwiLFxuICAgIFwi5reoXCIsXG4gICAgXCLnnZtcIixcbiAgICBcIuaYjFwiLFxuICAgIFwi5amaXCIsXG4gICAgXCLmtolcIixcbiAgICBcIuetklwiLFxuICAgIFwi5Zi0XCIsXG4gICAgXCLmj5JcIixcbiAgICBcIuWyuFwiLFxuICAgIFwi5pyXXCIsXG4gICAgXCLojopcIixcbiAgICBcIuihl1wiLFxuICAgIFwi6JePXCIsXG4gICAgXCLlp5FcIixcbiAgICBcIuiyv1wiLFxuICAgIFwi6IWQXCIsXG4gICAgXCLlpbRcIixcbiAgICBcIuWVplwiLFxuICAgIFwi5oWjXCIsXG4gICAgXCLkuZhcIixcbiAgICBcIuWkpVwiLFxuICAgIFwi5oGiXCIsXG4gICAgXCLli7tcIixcbiAgICBcIue0l1wiLFxuICAgIFwi5omOXCIsXG4gICAgXCLovq9cIixcbiAgICBcIuiAs1wiLFxuICAgIFwi5b2qXCIsXG4gICAgXCLoh6NcIixcbiAgICBcIuWEhFwiLFxuICAgIFwi55KDXCIsXG4gICAgXCLmirVcIixcbiAgICBcIuiEiFwiLFxuICAgIFwi56eAXCIsXG4gICAgXCLolqlcIixcbiAgICBcIuS/hFwiLFxuICAgIFwi57ayXCIsXG4gICAgXCLoiJ5cIixcbiAgICBcIuW6l1wiLFxuICAgIFwi5Zm0XCIsXG4gICAgXCLnuLFcIixcbiAgICBcIuWvuFwiLFxuICAgIFwi5rGXXCIsXG4gICAgXCLmjptcIixcbiAgICBcIua0qlwiLFxuICAgIFwi6LOAXCIsXG4gICAgXCLploNcIixcbiAgICBcIuafrFwiLFxuICAgIFwi54iGXCIsXG4gICAgXCLng69cIixcbiAgICBcIua0pVwiLFxuICAgIFwi56i7XCIsXG4gICAgXCLniYZcIixcbiAgICBcIui7n1wiLFxuICAgIFwi5YuHXCIsXG4gICAgXCLlg49cIixcbiAgICBcIua7vlwiLFxuICAgIFwi5Y6YXCIsXG4gICAgXCLokplcIixcbiAgICBcIuiKs1wiLFxuICAgIFwi6IKvXCIsXG4gICAgXCLlnaFcIixcbiAgICBcIuafsVwiLFxuICAgIFwi55uqXCIsXG4gICAgXCLohb9cIixcbiAgICBcIuWEgFwiLFxuICAgIFwi5peFXCIsXG4gICAgXCLlsL5cIixcbiAgICBcIui7i1wiLFxuICAgIFwi5YawXCIsXG4gICAgXCLosqJcIixcbiAgICBcIueZu1wiLFxuICAgIFwi6buOXCIsXG4gICAgXCLliYpcIixcbiAgICBcIumRvVwiLFxuICAgIFwi5YuSXCIsXG4gICAgXCLpgINcIixcbiAgICBcIumanFwiLFxuICAgIFwi5rCoXCIsXG4gICAgXCLpg61cIixcbiAgICBcIuWzsFwiLFxuICAgIFwi5bmjXCIsXG4gICAgXCLmuK9cIixcbiAgICBcIuS8j1wiLFxuICAgIFwi6LuMXCIsXG4gICAgXCLnlZ1cIixcbiAgICBcIueVolwiLFxuICAgIFwi5pOmXCIsXG4gICAgXCLojqtcIixcbiAgICBcIuWIulwiLFxuICAgIFwi5rWqXCIsXG4gICAgXCLnp5hcIixcbiAgICBcIuaPtFwiLFxuICAgIFwi5qCqXCIsXG4gICAgXCLlgaVcIixcbiAgICBcIuWUrlwiLFxuICAgIFwi6IKhXCIsXG4gICAgXCLls7ZcIixcbiAgICBcIueUmFwiLFxuICAgIFwi5rOhXCIsXG4gICAgXCLnnaFcIixcbiAgICBcIuerpVwiLFxuICAgIFwi6ZGEXCIsXG4gICAgXCLmua9cIixcbiAgICBcIumWpVwiLFxuICAgIFwi5LyRXCIsXG4gICAgXCLljK9cIixcbiAgICBcIuiIjVwiLFxuICAgIFwi54mnXCIsXG4gICAgXCLnuZ5cIixcbiAgICBcIueCuFwiLFxuICAgIFwi5ZOyXCIsXG4gICAgXCLno7dcIixcbiAgICBcIue4vlwiLFxuICAgIFwi5pyLXCIsXG4gICAgXCLmt6FcIixcbiAgICBcIuWwllwiLFxuICAgIFwi5ZWfXCIsXG4gICAgXCLpmbdcIixcbiAgICBcIuaftFwiLFxuICAgIFwi5ZGIXCIsXG4gICAgXCLlvpJcIixcbiAgICBcIumhj1wiLFxuICAgIFwi5reaXCIsXG4gICAgXCLnqI1cIixcbiAgICBcIuW/mFwiLFxuICAgIFwi5rO1XCIsXG4gICAgXCLol41cIixcbiAgICBcIuaLllwiLFxuICAgIFwi5rSeXCIsXG4gICAgXCLmjohcIixcbiAgICBcIumPoVwiLFxuICAgIFwi6L6bXCIsXG4gICAgXCLlo69cIixcbiAgICBcIumLklwiLFxuICAgIFwi6LKnXCIsXG4gICAgXCLomZtcIixcbiAgICBcIuW9jlwiLFxuICAgIFwi5pGpXCIsXG4gICAgXCLms7BcIixcbiAgICBcIuW5vFwiLFxuICAgIFwi5bu3XCIsXG4gICAgXCLlsIpcIixcbiAgICBcIueql1wiLFxuICAgIFwi57axXCIsXG4gICAgXCLlvIRcIixcbiAgICBcIumauFwiLFxuICAgIFwi55aRXCIsXG4gICAgXCLmsI9cIixcbiAgICBcIuWurlwiLFxuICAgIFwi5aeQXCIsXG4gICAgXCLpnIdcIixcbiAgICBcIueRnlwiLFxuICAgIFwi5oCqXCIsXG4gICAgXCLlsKRcIixcbiAgICBcIueQtFwiLFxuICAgIFwi5b6qXCIsXG4gICAgXCLmj49cIixcbiAgICBcIuiGnFwiLFxuICAgIFwi6YGVXCIsXG4gICAgXCLlpL5cIixcbiAgICBcIuiFsFwiLFxuICAgIFwi57ejXCIsXG4gICAgXCLnj6BcIixcbiAgICBcIueqrlwiLFxuICAgIFwi5qOuXCIsXG4gICAgXCLmnp1cIixcbiAgICBcIueruVwiLFxuICAgIFwi5rqdXCIsXG4gICAgXCLlgqxcIixcbiAgICBcIue5qVwiLFxuICAgIFwi5oa2XCIsXG4gICAgXCLpgqZcIixcbiAgICBcIuWJqVwiLFxuICAgIFwi5bm4XCIsXG4gICAgXCLmvL9cIixcbiAgICBcIuashFwiLFxuICAgIFwi5pOBXCIsXG4gICAgXCLniZlcIixcbiAgICBcIuiyr1wiLFxuICAgIFwi56auXCIsXG4gICAgXCLmv75cIixcbiAgICBcIumIiVwiLFxuICAgIFwi57SLXCIsXG4gICAgXCLnvbdcIixcbiAgICBcIuaLjVwiLFxuICAgIFwi5ZKxXCIsXG4gICAgXCLllopcIixcbiAgICBcIuiillwiLFxuICAgIFwi5Z+DXCIsXG4gICAgXCLli6RcIixcbiAgICBcIue9sFwiLFxuICAgIFwi54SmXCIsXG4gICAgXCLmvZtcIixcbiAgICBcIuS8jVwiLFxuICAgIFwi5aKoXCIsXG4gICAgXCLmrLJcIixcbiAgICBcIue4q1wiLFxuICAgIFwi5aeTXCIsXG4gICAgXCLliIpcIixcbiAgICBcIumjvVwiLFxuICAgIFwi5Lu/XCIsXG4gICAgXCLnjY5cIixcbiAgICBcIumLgVwiLFxuICAgIFwi6ay8XCIsXG4gICAgXCLpupdcIixcbiAgICBcIui3qFwiLFxuICAgIFwi6buYXCIsXG4gICAgXCLmjJZcIixcbiAgICBcIumPiFwiLFxuICAgIFwi5o6DXCIsXG4gICAgXCLllp1cIixcbiAgICBcIuiii1wiLFxuICAgIFwi54KtXCIsXG4gICAgXCLmsaFcIixcbiAgICBcIuW5lVwiLFxuICAgIFwi6Ku4XCIsXG4gICAgXCLlvKdcIixcbiAgICBcIuWLtVwiLFxuICAgIFwi5qKFXCIsXG4gICAgXCLlpbZcIixcbiAgICBcIua9lFwiLFxuICAgIFwi54G9XCIsXG4gICAgXCLoiJ9cIixcbiAgICBcIumRkVwiLFxuICAgIFwi6IuvXCIsXG4gICAgXCLoqJ9cIixcbiAgICBcIuaKsVwiLFxuICAgIFwi5q+AXCIsXG4gICAgXCLmh4JcIixcbiAgICBcIuWvklwiLFxuICAgIFwi5pm6XCIsXG4gICAgXCLln5RcIixcbiAgICBcIuWvhFwiLFxuICAgIFwi5bGGXCIsXG4gICAgXCLouo1cIixcbiAgICBcIua4oVwiLFxuICAgIFwi5oyRXCIsXG4gICAgXCLkuLlcIixcbiAgICBcIuiJsVwiLFxuICAgIFwi6LKdXCIsXG4gICAgXCLnorBcIixcbiAgICBcIuaLlFwiLFxuICAgIFwi54i5XCIsXG4gICAgXCLmiLRcIixcbiAgICBcIueivFwiLFxuICAgIFwi5aSiXCIsXG4gICAgXCLoir1cIixcbiAgICBcIueGlFwiLFxuICAgIFwi6LWkXCIsXG4gICAgXCLmvIFcIixcbiAgICBcIuWTrVwiLFxuICAgIFwi5pWsXCIsXG4gICAgXCLpoYZcIixcbiAgICBcIuWllFwiLFxuICAgIFwi6YmbXCIsXG4gICAgXCLku7JcIixcbiAgICBcIuiZjlwiLFxuICAgIFwi56iAXCIsXG4gICAgXCLlprlcIixcbiAgICBcIuS5j1wiLFxuICAgIFwi54+NXCIsXG4gICAgXCLnlLNcIixcbiAgICBcIuahjFwiLFxuICAgIFwi6YG1XCIsXG4gICAgXCLlhYFcIixcbiAgICBcIumahlwiLFxuICAgIFwi6J66XCIsXG4gICAgXCLlgIlcIixcbiAgICBcIumtj1wiLFxuICAgIFwi6YqzXCIsXG4gICAgXCLmm4lcIixcbiAgICBcIuawrlwiLFxuICAgIFwi5YW8XCIsXG4gICAgXCLpmrFcIixcbiAgICBcIuekmVwiLFxuICAgIFwi6LWrXCIsXG4gICAgXCLmkqVcIixcbiAgICBcIuW/oFwiLFxuICAgIFwi6IKFXCIsXG4gICAgXCLnvLhcIixcbiAgICBcIueJvVwiLFxuICAgIFwi5pC2XCIsXG4gICAgXCLljZpcIixcbiAgICBcIuW3p1wiLFxuICAgIFwi5q68XCIsXG4gICAgXCLlhYRcIixcbiAgICBcIuadnFwiLFxuICAgIFwi6KiKXCIsXG4gICAgXCLoqqBcIixcbiAgICBcIueip1wiLFxuICAgIFwi56WlXCIsXG4gICAgXCLmn69cIixcbiAgICBcIumggVwiLFxuICAgIFwi5behXCIsXG4gICAgXCLnn6lcIixcbiAgICBcIuaCslwiLFxuICAgIFwi54GMXCIsXG4gICAgXCLpvaFcIixcbiAgICBcIuWAq1wiLFxuICAgIFwi56WoXCIsXG4gICAgXCLlsItcIixcbiAgICBcIuahglwiLFxuICAgIFwi6YuqXCIsXG4gICAgXCLogZZcIixcbiAgICBcIuaBkFwiLFxuICAgIFwi5oGwXCIsXG4gICAgXCLphK1cIixcbiAgICBcIui2o1wiLFxuICAgIFwi5oqsXCIsXG4gICAgXCLojZJcIixcbiAgICBcIumosFwiLFxuICAgIFwi6LK8XCIsXG4gICAgXCLmn5RcIixcbiAgICBcIua7tFwiLFxuICAgIFwi54ybXCIsXG4gICAgXCLpl4pcIixcbiAgICBcIui8m1wiLFxuICAgIFwi5aa7XCIsXG4gICAgXCLloatcIixcbiAgICBcIuaSpFwiLFxuICAgIFwi5YSyXCIsXG4gICAgXCLnsL1cIixcbiAgICBcIumsp1wiLFxuICAgIFwi5pO+XCIsXG4gICAgXCLntKtcIixcbiAgICBcIuegglwiLFxuICAgIFwi6YGeXCIsXG4gICAgXCLmiLJcIixcbiAgICBcIuWQilwiLFxuICAgIFwi6Zm2XCIsXG4gICAgXCLkvJBcIixcbiAgICBcIumktVwiLFxuICAgIFwi55mCXCIsXG4gICAgXCLnk7ZcIixcbiAgICBcIuWphlwiLFxuICAgIFwi5pKrXCIsXG4gICAgXCLoh4JcIixcbiAgICBcIuaRuFwiLFxuICAgIFwi5b+NXCIsXG4gICAgXCLonaZcIixcbiAgICBcIuign1wiLFxuICAgIFwi6YSwXCIsXG4gICAgXCLog7hcIixcbiAgICBcIumej1wiLFxuICAgIFwi5pOgXCIsXG4gICAgXCLlgbZcIixcbiAgICBcIuajhFwiLFxuICAgIFwi5qe9XCIsXG4gICAgXCLli4FcIixcbiAgICBcIuS5s1wiLFxuICAgIFwi6YSnXCIsXG4gICAgXCLlkIlcIixcbiAgICBcIuS7gVwiLFxuICAgIFwi54ibXCIsXG4gICAgXCLno5pcIixcbiAgICBcIuenn1wiLFxuICAgIFwi54OPXCIsXG4gICAgXCLoiaZcIixcbiAgICBcIuS8tFwiLFxuICAgIFwi55OcXCIsXG4gICAgXCLmt7pcIixcbiAgICBcIuS4mVwiLFxuICAgIFwi5pqrXCIsXG4gICAgXCLnh6VcIixcbiAgICBcIuapoVwiLFxuICAgIFwi5p+zXCIsXG4gICAgXCLov7dcIixcbiAgICBcIuaallwiLFxuICAgIFwi54mMXCIsXG4gICAgXCLnp6dcIixcbiAgICBcIuiGvVwiLFxuICAgIFwi6KmzXCIsXG4gICAgXCLnsKdcIixcbiAgICBcIui4j1wiLFxuICAgIFwi55O3XCIsXG4gICAgXCLorZxcIixcbiAgICBcIuWRhlwiLFxuICAgIFwi6LOTXCIsXG4gICAgXCLns4pcIixcbiAgICBcIua0m1wiLFxuICAgIFwi6LydXCIsXG4gICAgXCLmhqRcIixcbiAgICBcIuertlwiLFxuICAgIFwi6ZqZXCIsXG4gICAgXCLmgJJcIixcbiAgICBcIueymFwiLFxuICAgIFwi5LmDXCIsXG4gICAgXCLnt5JcIixcbiAgICBcIuiCqVwiLFxuICAgIFwi57GNXCIsXG4gICAgXCLmlY9cIixcbiAgICBcIuWhl1wiLFxuICAgIFwi54aZXCIsXG4gICAgXCLnmoZcIixcbiAgICBcIuWBtVwiLFxuICAgIFwi5oe4XCIsXG4gICAgXCLmjphcIixcbiAgICBcIuS6q1wiLFxuICAgIFwi57O+XCIsXG4gICAgXCLphpJcIixcbiAgICBcIueLglwiLFxuICAgIFwi6Y6WXCIsXG4gICAgXCLmt4BcIixcbiAgICBcIuaBqFwiLFxuICAgIFwi54myXCIsXG4gICAgXCLpnLhcIixcbiAgICBcIueIrFwiLFxuICAgIFwi6LOeXCIsXG4gICAgXCLpgIZcIixcbiAgICBcIueOqVwiLFxuICAgIFwi6Zm1XCIsXG4gICAgXCLnpZ1cIixcbiAgICBcIuenklwiLFxuICAgIFwi5rWZXCIsXG4gICAgXCLosoxcIixcbiAgICBcIuW9uVwiLFxuICAgIFwi5b28XCIsXG4gICAgXCLmgolcIixcbiAgICBcIum0qFwiLFxuICAgIFwi6LaoXCIsXG4gICAgXCLps7NcIixcbiAgICBcIuaZqFwiLFxuICAgIFwi55WcXCIsXG4gICAgXCLovKlcIixcbiAgICBcIuenqVwiLFxuICAgIFwi5Y21XCIsXG4gICAgXCLnvbJcIixcbiAgICBcIuair1wiLFxuICAgIFwi54KOXCIsXG4gICAgXCLngZhcIixcbiAgICBcIuaji1wiLFxuICAgIFwi6amFXCIsXG4gICAgXCLnr6lcIixcbiAgICBcIuWzvVwiLFxuICAgIFwi5YaSXCIsXG4gICAgXCLllaVcIixcbiAgICBcIuWjvVwiLFxuICAgIFwi6K2vXCIsXG4gICAgXCLmtbhcIixcbiAgICBcIuaziVwiLFxuICAgIFwi5bi9XCIsXG4gICAgXCLpgbJcIixcbiAgICBcIuefvVwiLFxuICAgIFwi55aGXCIsXG4gICAgXCLosrhcIixcbiAgICBcIua8j1wiLFxuICAgIFwi56i/XCIsXG4gICAgXCLlhqBcIixcbiAgICBcIuWrqVwiLFxuICAgIFwi6ISFXCIsXG4gICAgXCLoiq9cIixcbiAgICBcIueJolwiLFxuICAgIFwi5Y+bXCIsXG4gICAgXCLonZVcIixcbiAgICBcIuWlp1wiLFxuICAgIFwi6bO0XCIsXG4gICAgXCLltrpcIixcbiAgICBcIue+ilwiLFxuICAgIFwi5oaRXCIsXG4gICAgXCLkuLJcIixcbiAgICBcIuWhmFwiLFxuICAgIFwi57mqXCIsXG4gICAgXCLphbVcIixcbiAgICBcIuiejVwiLFxuICAgIFwi55uGXCIsXG4gICAgXCLpjKtcIixcbiAgICBcIuW7n1wiLFxuICAgIFwi57GMXCIsXG4gICAgXCLlh41cIixcbiAgICBcIui8lFwiLFxuICAgIFwi5pSdXCIsXG4gICAgXCLopbJcIixcbiAgICBcIueti1wiLFxuICAgIFwi5ouSXCIsXG4gICAgXCLlg5pcIixcbiAgICBcIuaXsVwiLFxuICAgIFwi6YmAXCIsXG4gICAgXCLps6VcIixcbiAgICBcIua8hlwiLFxuICAgIFwi5rKIXCIsXG4gICAgXCLnnIlcIixcbiAgICBcIueWj1wiLFxuICAgIFwi5re7XCIsXG4gICAgXCLmo5JcIixcbiAgICBcIuepl1wiLFxuICAgIFwi56GdXCIsXG4gICAgXCLpn5NcIixcbiAgICBcIumAvFwiLFxuICAgIFwi5omtXCIsXG4gICAgXCLlg5FcIixcbiAgICBcIua2vFwiLFxuICAgIFwi5oy6XCIsXG4gICAgXCLnopdcIixcbiAgICBcIuagvVwiLFxuICAgIFwi54KSXCIsXG4gICAgXCLmna9cIixcbiAgICBcIuaCo1wiLFxuICAgIFwi6aS+XCIsXG4gICAgXCLli7hcIixcbiAgICBcIuixqlwiLFxuICAgIFwi6YG8XCIsXG4gICAgXCLli4NcIixcbiAgICBcIum0u1wiLFxuICAgIFwi5pemXCIsXG4gICAgXCLlkI9cIixcbiAgICBcIuaLnFwiLFxuICAgIFwi54uXXCIsXG4gICAgXCLln4tcIixcbiAgICBcIui8pVwiLFxuICAgIFwi5o6pXCIsXG4gICAgXCLpo7JcIixcbiAgICBcIuaQrFwiLFxuICAgIFwi5721XCIsXG4gICAgXCLovq1cIixcbiAgICBcIuWLvlwiLFxuICAgIFwi5omjXCIsXG4gICAgXCLkvLBcIixcbiAgICBcIuiUo1wiLFxuICAgIFwi57WoXCIsXG4gICAgXCLpnKdcIixcbiAgICBcIuS4iFwiLFxuICAgIFwi5py1XCIsXG4gICAgXCLlp4ZcIixcbiAgICBcIuaTrFwiLFxuICAgIFwi5a6HXCIsXG4gICAgXCLovK9cIixcbiAgICBcIumZnVwiLFxuICAgIFwi6ZuVXCIsXG4gICAgXCLlhJ9cIixcbiAgICBcIuiThFwiLFxuICAgIFwi5bSHXCIsXG4gICAgXCLliapcIixcbiAgICBcIuWAoVwiLFxuICAgIFwi5buzXCIsXG4gICAgXCLlkqxcIixcbiAgICBcIumnm1wiLFxuICAgIFwi6JavXCIsXG4gICAgXCLliLdcIixcbiAgICBcIuaWpVwiLFxuICAgIFwi55WqXCIsXG4gICAgXCLos6ZcIixcbiAgICBcIuWliVwiLFxuICAgIFwi5L2bXCIsXG4gICAgXCLmvoZcIixcbiAgICBcIua8q1wiLFxuICAgIFwi5pu8XCIsXG4gICAgXCLmiYdcIixcbiAgICBcIumIo1wiLFxuICAgIFwi5qGDXCIsXG4gICAgXCLmibZcIixcbiAgICBcIuS7lFwiLFxuICAgIFwi6L+UXCIsXG4gICAgXCLkv5dcIixcbiAgICBcIuiZp1wiLFxuICAgIFwi6IWUXCIsXG4gICAgXCLpnotcIixcbiAgICBcIuajsVwiLFxuICAgIFwi6KaGXCIsXG4gICAgXCLmoYZcIixcbiAgICBcIuaChFwiLFxuICAgIFwi5Y+UXCIsXG4gICAgXCLmkp5cIixcbiAgICBcIumomVwiLFxuICAgIFwi5YuYXCIsXG4gICAgXCLml7pcIixcbiAgICBcIuayuFwiLFxuICAgIFwi5a2kXCIsXG4gICAgXCLlkJBcIixcbiAgICBcIuWtn1wiLFxuICAgIFwi5rigXCIsXG4gICAgXCLlsYhcIixcbiAgICBcIueWvlwiLFxuICAgIFwi5aaZXCIsXG4gICAgXCLmg5xcIixcbiAgICBcIuS7sFwiLFxuICAgIFwi54ugXCIsXG4gICAgXCLohLlcIixcbiAgICBcIuirp1wiLFxuICAgIFwi5ouLXCIsXG4gICAgXCLpu7RcIixcbiAgICBcIuahkVwiLFxuICAgIFwi5bSXXCIsXG4gICAgXCLlmJtcIixcbiAgICBcIuihsFwiLFxuICAgIFwi55ucXCIsXG4gICAgXCLmu7JcIixcbiAgICBcIuiHn1wiLFxuICAgIFwi6LO0XCIsXG4gICAgXCLmuadcIixcbiAgICBcIueUnFwiLFxuICAgIFwi5pu5XCIsXG4gICAgXCLplrFcIixcbiAgICBcIuiCjFwiLFxuICAgIFwi5ZOpXCIsXG4gICAgXCLljrJcIixcbiAgICBcIueDtFwiLFxuICAgIFwi57evXCIsXG4gICAgXCLmr4VcIixcbiAgICBcIuaYqFwiLFxuICAgIFwi5YG9XCIsXG4gICAgXCLnl4dcIixcbiAgICBcIueFrlwiLFxuICAgIFwi5ZiGXCIsXG4gICAgXCLph5hcIixcbiAgICBcIuaQrVwiLFxuICAgIFwi6I6WXCIsXG4gICAgXCLnsaBcIixcbiAgICBcIumFt1wiLFxuICAgIFwi5YG3XCIsXG4gICAgXCLlvJNcIixcbiAgICBcIumMkFwiLFxuICAgIFwi5oGGXCIsXG4gICAgXCLlgpFcIixcbiAgICBcIuWdkVwiLFxuICAgIFwi6by7XCIsXG4gICAgXCLnv7xcIixcbiAgICBcIue2uFwiLFxuICAgIFwi5pWYXCIsXG4gICAgXCLnjYRcIixcbiAgICBcIumArlwiLFxuICAgIFwi572QXCIsXG4gICAgXCLntaFcIixcbiAgICBcIuajmlwiLFxuICAgIFwi5oqRXCIsXG4gICAgXCLohqhcIixcbiAgICBcIuiUrFwiLFxuICAgIFwi5a+6XCIsXG4gICAgXCLpqZ9cIixcbiAgICBcIuephlwiLFxuICAgIFwi5Ya2XCIsXG4gICAgXCLmnq9cIixcbiAgICBcIuWGilwiLFxuICAgIFwi5bGNXCIsXG4gICAgXCLlh7hcIixcbiAgICBcIue0s1wiLFxuICAgIFwi5Z2vXCIsXG4gICAgXCLniqdcIixcbiAgICBcIueEsFwiLFxuICAgIFwi6L2fXCIsXG4gICAgXCLmrKNcIixcbiAgICBcIuaZiVwiLFxuICAgIFwi55imXCIsXG4gICAgXCLnpqZcIixcbiAgICBcIumMoFwiLFxuICAgIFwi6YymXCIsXG4gICAgXCLllqpcIixcbiAgICBcIuaXrFwiLFxuICAgIFwi6Y2bXCIsXG4gICAgXCLlo59cIixcbiAgICBcIuaQnFwiLFxuICAgIFwi5pKyXCIsXG4gICAgXCLpgoBcIixcbiAgICBcIuS6rVwiLFxuICAgIFwi6YWvXCIsXG4gICAgXCLpgoFcIixcbiAgICBcIuiIklwiLFxuICAgIFwi6ISGXCIsXG4gICAgXCLphbZcIixcbiAgICBcIumWklwiLFxuICAgIFwi5oaCXCIsXG4gICAgXCLphZpcIixcbiAgICBcIumgkVwiLFxuICAgIFwi5769XCIsXG4gICAgXCLmvLJcIixcbiAgICBcIuWNuFwiLFxuICAgIFwi5LuXXCIsXG4gICAgXCLpmapcIixcbiAgICBcIumXolwiLFxuICAgIFwi5oeyXCIsXG4gICAgXCLmna1cIixcbiAgICBcIuWnmlwiLFxuICAgIFwi6IKaXCIsXG4gICAgXCLmjYlcIixcbiAgICBcIumjhFwiLFxuICAgIFwi5ryCXCIsXG4gICAgXCLmmIZcIixcbiAgICBcIuasulwiLFxuICAgIFwi5ZC+XCIsXG4gICAgXCLpg45cIixcbiAgICBcIueDt1wiLFxuICAgIFwi5rGBXCIsXG4gICAgXCLlkbVcIixcbiAgICBcIumjvlwiLFxuICAgIFwi6JWtXCIsXG4gICAgXCLpm4VcIixcbiAgICBcIumDtVwiLFxuICAgIFwi6YG3XCIsXG4gICAgXCLnh5VcIixcbiAgICBcIuaSklwiLFxuICAgIFwi5ae7XCIsXG4gICAgXCLotbRcIixcbiAgICBcIuWutFwiLFxuICAgIFwi54WpXCIsXG4gICAgXCLlgrVcIixcbiAgICBcIuW4s1wiLFxuICAgIFwi5paRXCIsXG4gICAgXCLpiLRcIixcbiAgICBcIuaXqFwiLFxuICAgIFwi6YaHXCIsXG4gICAgXCLokaNcIixcbiAgICBcIumkhVwiLFxuICAgIFwi6ZubXCIsXG4gICAgXCLlp79cIixcbiAgICBcIuaLjFwiLFxuICAgIFwi5YKFXCIsXG4gICAgXCLohblcIixcbiAgICBcIuWmpVwiLFxuICAgIFwi5o+JXCIsXG4gICAgXCLos6JcIixcbiAgICBcIuaLhlwiLFxuICAgIFwi5q2qXCIsXG4gICAgXCLokaFcIixcbiAgICBcIuiDulwiLFxuICAgIFwi5LifXCIsXG4gICAgXCLmtalcIixcbiAgICBcIuW+vVwiLFxuICAgIFwi5piCXCIsXG4gICAgXCLloopcIixcbiAgICBcIuaTi1wiLFxuICAgIFwi6Ka9XCIsXG4gICAgXCLosqpcIixcbiAgICBcIuaFsFwiLFxuICAgIFwi57mzXCIsXG4gICAgXCLmsapcIixcbiAgICBcIuaFjFwiLFxuICAgIFwi6aauXCIsXG4gICAgXCLoq75cIixcbiAgICBcIuWnnFwiLFxuICAgIFwi6Kq8XCIsXG4gICAgXCLlhYdcIixcbiAgICBcIuWKo1wiLFxuICAgIFwi6KqjXCIsXG4gICAgXCLogIBcIixcbiAgICBcIuaYj1wiLFxuICAgIFwi6Lq6XCIsXG4gICAgXCLnm4hcIixcbiAgICBcIumojlwiLFxuICAgIFwi5ZasXCIsXG4gICAgXCLmuqpcIixcbiAgICBcIuWPolwiLFxuICAgIFwi55unXCIsXG4gICAgXCLmirlcIixcbiAgICBcIuaCtlwiLFxuICAgIFwi6KuuXCIsXG4gICAgXCLliK5cIixcbiAgICBcIumnlVwiLFxuICAgIFwi57qcXCIsXG4gICAgXCLmgp9cIixcbiAgICBcIuaRmFwiLFxuICAgIFwi6Ym6XCIsXG4gICAgXCLmk7JcIixcbiAgICBcIumgl1wiLFxuICAgIFwi5bm7XCIsXG4gICAgXCLmn4RcIixcbiAgICBcIuaDoFwiLFxuICAgIFwi5oWYXCIsXG4gICAgXCLkvbNcIixcbiAgICBcIuS7h1wiLFxuICAgIFwi6IeYXCIsXG4gICAgXCLnqqlcIixcbiAgICBcIua7jFwiLFxuICAgIFwi5YqNXCIsXG4gICAgXCLnnqdcIixcbiAgICBcIuWgoVwiLFxuICAgIFwi5r2RXCIsXG4gICAgXCLolKVcIixcbiAgICBcIue9qVwiLFxuICAgIFwi6ZyNXCIsXG4gICAgXCLmkohcIixcbiAgICBcIuiDjlwiLFxuICAgIFwi6JK8XCIsXG4gICAgXCLmv7FcIixcbiAgICBcIuWAhlwiLFxuICAgIFwi5o2FXCIsXG4gICAgXCLmuZhcIixcbiAgICBcIuegjVwiLFxuICAgIFwi6ZyeXCIsXG4gICAgXCLpgrVcIixcbiAgICBcIuiQhFwiLFxuICAgIFwi55iLXCIsXG4gICAgXCLmt65cIixcbiAgICBcIumBglwiLFxuICAgIFwi54aKXCIsXG4gICAgXCLns55cIixcbiAgICBcIueDmFwiLFxuICAgIFwi5a6/XCIsXG4gICAgXCLmqpRcIixcbiAgICBcIuaIiFwiLFxuICAgIFwi6aeBXCIsXG4gICAgXCLlq4JcIixcbiAgICBcIuijlVwiLFxuICAgIFwi5b6ZXCIsXG4gICAgXCLnrq1cIixcbiAgICBcIuaNkFwiLFxuICAgIFwi6IW4XCIsXG4gICAgXCLmkpBcIixcbiAgICBcIuabrFwiLFxuICAgIFwi6L6oXCIsXG4gICAgXCLmrr9cIixcbiAgICBcIuiTrlwiLFxuICAgIFwi5pSkXCIsXG4gICAgXCLmlKpcIixcbiAgICBcIumGrFwiLFxuICAgIFwi5bGPXCIsXG4gICAgXCLnlqtcIixcbiAgICBcIuWTgFwiLFxuICAgIFwi6JShXCIsXG4gICAgXCLloLVcIixcbiAgICBcIuayq1wiLFxuICAgIFwi55q6XCIsXG4gICAgXCLmmqJcIixcbiAgICBcIueWilwiLFxuICAgIFwi6ZajXCIsXG4gICAgXCLokIpcIixcbiAgICBcIuaVslwiLFxuICAgIFwi6L2EXCIsXG4gICAgXCLpiaRcIixcbiAgICBcIueXlVwiLFxuICAgIFwi5aOpXCIsXG4gICAgXCLlt7dcIixcbiAgICBcIumkk1wiLFxuICAgIFwi56aNXCIsXG4gICAgXCLkuJhcIixcbiAgICBcIueOhFwiLFxuICAgIFwi5rqcXCIsXG4gICAgXCLmm7BcIixcbiAgICBcIumCj1wiLFxuICAgIFwi5b2tXCIsXG4gICAgXCLlmJdcIixcbiAgICBcIuWNv1wiLFxuICAgIFwi5aaoXCIsXG4gICAgXCLoiYdcIixcbiAgICBcIuWQnlwiLFxuICAgIFwi6Z+LXCIsXG4gICAgXCLmgKhcIixcbiAgICBcIuefrlwiLFxuICAgIFwi5q2HXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcImFiYW5kb25cIixcbiAgICBcImFiaWxpdHlcIixcbiAgICBcImFibGVcIixcbiAgICBcImFib3V0XCIsXG4gICAgXCJhYm92ZVwiLFxuICAgIFwiYWJzZW50XCIsXG4gICAgXCJhYnNvcmJcIixcbiAgICBcImFic3RyYWN0XCIsXG4gICAgXCJhYnN1cmRcIixcbiAgICBcImFidXNlXCIsXG4gICAgXCJhY2Nlc3NcIixcbiAgICBcImFjY2lkZW50XCIsXG4gICAgXCJhY2NvdW50XCIsXG4gICAgXCJhY2N1c2VcIixcbiAgICBcImFjaGlldmVcIixcbiAgICBcImFjaWRcIixcbiAgICBcImFjb3VzdGljXCIsXG4gICAgXCJhY3F1aXJlXCIsXG4gICAgXCJhY3Jvc3NcIixcbiAgICBcImFjdFwiLFxuICAgIFwiYWN0aW9uXCIsXG4gICAgXCJhY3RvclwiLFxuICAgIFwiYWN0cmVzc1wiLFxuICAgIFwiYWN0dWFsXCIsXG4gICAgXCJhZGFwdFwiLFxuICAgIFwiYWRkXCIsXG4gICAgXCJhZGRpY3RcIixcbiAgICBcImFkZHJlc3NcIixcbiAgICBcImFkanVzdFwiLFxuICAgIFwiYWRtaXRcIixcbiAgICBcImFkdWx0XCIsXG4gICAgXCJhZHZhbmNlXCIsXG4gICAgXCJhZHZpY2VcIixcbiAgICBcImFlcm9iaWNcIixcbiAgICBcImFmZmFpclwiLFxuICAgIFwiYWZmb3JkXCIsXG4gICAgXCJhZnJhaWRcIixcbiAgICBcImFnYWluXCIsXG4gICAgXCJhZ2VcIixcbiAgICBcImFnZW50XCIsXG4gICAgXCJhZ3JlZVwiLFxuICAgIFwiYWhlYWRcIixcbiAgICBcImFpbVwiLFxuICAgIFwiYWlyXCIsXG4gICAgXCJhaXJwb3J0XCIsXG4gICAgXCJhaXNsZVwiLFxuICAgIFwiYWxhcm1cIixcbiAgICBcImFsYnVtXCIsXG4gICAgXCJhbGNvaG9sXCIsXG4gICAgXCJhbGVydFwiLFxuICAgIFwiYWxpZW5cIixcbiAgICBcImFsbFwiLFxuICAgIFwiYWxsZXlcIixcbiAgICBcImFsbG93XCIsXG4gICAgXCJhbG1vc3RcIixcbiAgICBcImFsb25lXCIsXG4gICAgXCJhbHBoYVwiLFxuICAgIFwiYWxyZWFkeVwiLFxuICAgIFwiYWxzb1wiLFxuICAgIFwiYWx0ZXJcIixcbiAgICBcImFsd2F5c1wiLFxuICAgIFwiYW1hdGV1clwiLFxuICAgIFwiYW1hemluZ1wiLFxuICAgIFwiYW1vbmdcIixcbiAgICBcImFtb3VudFwiLFxuICAgIFwiYW11c2VkXCIsXG4gICAgXCJhbmFseXN0XCIsXG4gICAgXCJhbmNob3JcIixcbiAgICBcImFuY2llbnRcIixcbiAgICBcImFuZ2VyXCIsXG4gICAgXCJhbmdsZVwiLFxuICAgIFwiYW5ncnlcIixcbiAgICBcImFuaW1hbFwiLFxuICAgIFwiYW5rbGVcIixcbiAgICBcImFubm91bmNlXCIsXG4gICAgXCJhbm51YWxcIixcbiAgICBcImFub3RoZXJcIixcbiAgICBcImFuc3dlclwiLFxuICAgIFwiYW50ZW5uYVwiLFxuICAgIFwiYW50aXF1ZVwiLFxuICAgIFwiYW54aWV0eVwiLFxuICAgIFwiYW55XCIsXG4gICAgXCJhcGFydFwiLFxuICAgIFwiYXBvbG9neVwiLFxuICAgIFwiYXBwZWFyXCIsXG4gICAgXCJhcHBsZVwiLFxuICAgIFwiYXBwcm92ZVwiLFxuICAgIFwiYXByaWxcIixcbiAgICBcImFyY2hcIixcbiAgICBcImFyY3RpY1wiLFxuICAgIFwiYXJlYVwiLFxuICAgIFwiYXJlbmFcIixcbiAgICBcImFyZ3VlXCIsXG4gICAgXCJhcm1cIixcbiAgICBcImFybWVkXCIsXG4gICAgXCJhcm1vclwiLFxuICAgIFwiYXJteVwiLFxuICAgIFwiYXJvdW5kXCIsXG4gICAgXCJhcnJhbmdlXCIsXG4gICAgXCJhcnJlc3RcIixcbiAgICBcImFycml2ZVwiLFxuICAgIFwiYXJyb3dcIixcbiAgICBcImFydFwiLFxuICAgIFwiYXJ0ZWZhY3RcIixcbiAgICBcImFydGlzdFwiLFxuICAgIFwiYXJ0d29ya1wiLFxuICAgIFwiYXNrXCIsXG4gICAgXCJhc3BlY3RcIixcbiAgICBcImFzc2F1bHRcIixcbiAgICBcImFzc2V0XCIsXG4gICAgXCJhc3Npc3RcIixcbiAgICBcImFzc3VtZVwiLFxuICAgIFwiYXN0aG1hXCIsXG4gICAgXCJhdGhsZXRlXCIsXG4gICAgXCJhdG9tXCIsXG4gICAgXCJhdHRhY2tcIixcbiAgICBcImF0dGVuZFwiLFxuICAgIFwiYXR0aXR1ZGVcIixcbiAgICBcImF0dHJhY3RcIixcbiAgICBcImF1Y3Rpb25cIixcbiAgICBcImF1ZGl0XCIsXG4gICAgXCJhdWd1c3RcIixcbiAgICBcImF1bnRcIixcbiAgICBcImF1dGhvclwiLFxuICAgIFwiYXV0b1wiLFxuICAgIFwiYXV0dW1uXCIsXG4gICAgXCJhdmVyYWdlXCIsXG4gICAgXCJhdm9jYWRvXCIsXG4gICAgXCJhdm9pZFwiLFxuICAgIFwiYXdha2VcIixcbiAgICBcImF3YXJlXCIsXG4gICAgXCJhd2F5XCIsXG4gICAgXCJhd2Vzb21lXCIsXG4gICAgXCJhd2Z1bFwiLFxuICAgIFwiYXdrd2FyZFwiLFxuICAgIFwiYXhpc1wiLFxuICAgIFwiYmFieVwiLFxuICAgIFwiYmFjaGVsb3JcIixcbiAgICBcImJhY29uXCIsXG4gICAgXCJiYWRnZVwiLFxuICAgIFwiYmFnXCIsXG4gICAgXCJiYWxhbmNlXCIsXG4gICAgXCJiYWxjb255XCIsXG4gICAgXCJiYWxsXCIsXG4gICAgXCJiYW1ib29cIixcbiAgICBcImJhbmFuYVwiLFxuICAgIFwiYmFubmVyXCIsXG4gICAgXCJiYXJcIixcbiAgICBcImJhcmVseVwiLFxuICAgIFwiYmFyZ2FpblwiLFxuICAgIFwiYmFycmVsXCIsXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNpY1wiLFxuICAgIFwiYmFza2V0XCIsXG4gICAgXCJiYXR0bGVcIixcbiAgICBcImJlYWNoXCIsXG4gICAgXCJiZWFuXCIsXG4gICAgXCJiZWF1dHlcIixcbiAgICBcImJlY2F1c2VcIixcbiAgICBcImJlY29tZVwiLFxuICAgIFwiYmVlZlwiLFxuICAgIFwiYmVmb3JlXCIsXG4gICAgXCJiZWdpblwiLFxuICAgIFwiYmVoYXZlXCIsXG4gICAgXCJiZWhpbmRcIixcbiAgICBcImJlbGlldmVcIixcbiAgICBcImJlbG93XCIsXG4gICAgXCJiZWx0XCIsXG4gICAgXCJiZW5jaFwiLFxuICAgIFwiYmVuZWZpdFwiLFxuICAgIFwiYmVzdFwiLFxuICAgIFwiYmV0cmF5XCIsXG4gICAgXCJiZXR0ZXJcIixcbiAgICBcImJldHdlZW5cIixcbiAgICBcImJleW9uZFwiLFxuICAgIFwiYmljeWNsZVwiLFxuICAgIFwiYmlkXCIsXG4gICAgXCJiaWtlXCIsXG4gICAgXCJiaW5kXCIsXG4gICAgXCJiaW9sb2d5XCIsXG4gICAgXCJiaXJkXCIsXG4gICAgXCJiaXJ0aFwiLFxuICAgIFwiYml0dGVyXCIsXG4gICAgXCJibGFja1wiLFxuICAgIFwiYmxhZGVcIixcbiAgICBcImJsYW1lXCIsXG4gICAgXCJibGFua2V0XCIsXG4gICAgXCJibGFzdFwiLFxuICAgIFwiYmxlYWtcIixcbiAgICBcImJsZXNzXCIsXG4gICAgXCJibGluZFwiLFxuICAgIFwiYmxvb2RcIixcbiAgICBcImJsb3Nzb21cIixcbiAgICBcImJsb3VzZVwiLFxuICAgIFwiYmx1ZVwiLFxuICAgIFwiYmx1clwiLFxuICAgIFwiYmx1c2hcIixcbiAgICBcImJvYXJkXCIsXG4gICAgXCJib2F0XCIsXG4gICAgXCJib2R5XCIsXG4gICAgXCJib2lsXCIsXG4gICAgXCJib21iXCIsXG4gICAgXCJib25lXCIsXG4gICAgXCJib251c1wiLFxuICAgIFwiYm9va1wiLFxuICAgIFwiYm9vc3RcIixcbiAgICBcImJvcmRlclwiLFxuICAgIFwiYm9yaW5nXCIsXG4gICAgXCJib3Jyb3dcIixcbiAgICBcImJvc3NcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwiYm91bmNlXCIsXG4gICAgXCJib3hcIixcbiAgICBcImJveVwiLFxuICAgIFwiYnJhY2tldFwiLFxuICAgIFwiYnJhaW5cIixcbiAgICBcImJyYW5kXCIsXG4gICAgXCJicmFzc1wiLFxuICAgIFwiYnJhdmVcIixcbiAgICBcImJyZWFkXCIsXG4gICAgXCJicmVlemVcIixcbiAgICBcImJyaWNrXCIsXG4gICAgXCJicmlkZ2VcIixcbiAgICBcImJyaWVmXCIsXG4gICAgXCJicmlnaHRcIixcbiAgICBcImJyaW5nXCIsXG4gICAgXCJicmlza1wiLFxuICAgIFwiYnJvY2NvbGlcIixcbiAgICBcImJyb2tlblwiLFxuICAgIFwiYnJvbnplXCIsXG4gICAgXCJicm9vbVwiLFxuICAgIFwiYnJvdGhlclwiLFxuICAgIFwiYnJvd25cIixcbiAgICBcImJydXNoXCIsXG4gICAgXCJidWJibGVcIixcbiAgICBcImJ1ZGR5XCIsXG4gICAgXCJidWRnZXRcIixcbiAgICBcImJ1ZmZhbG9cIixcbiAgICBcImJ1aWxkXCIsXG4gICAgXCJidWxiXCIsXG4gICAgXCJidWxrXCIsXG4gICAgXCJidWxsZXRcIixcbiAgICBcImJ1bmRsZVwiLFxuICAgIFwiYnVua2VyXCIsXG4gICAgXCJidXJkZW5cIixcbiAgICBcImJ1cmdlclwiLFxuICAgIFwiYnVyc3RcIixcbiAgICBcImJ1c1wiLFxuICAgIFwiYnVzaW5lc3NcIixcbiAgICBcImJ1c3lcIixcbiAgICBcImJ1dHRlclwiLFxuICAgIFwiYnV5ZXJcIixcbiAgICBcImJ1enpcIixcbiAgICBcImNhYmJhZ2VcIixcbiAgICBcImNhYmluXCIsXG4gICAgXCJjYWJsZVwiLFxuICAgIFwiY2FjdHVzXCIsXG4gICAgXCJjYWdlXCIsXG4gICAgXCJjYWtlXCIsXG4gICAgXCJjYWxsXCIsXG4gICAgXCJjYWxtXCIsXG4gICAgXCJjYW1lcmFcIixcbiAgICBcImNhbXBcIixcbiAgICBcImNhblwiLFxuICAgIFwiY2FuYWxcIixcbiAgICBcImNhbmNlbFwiLFxuICAgIFwiY2FuZHlcIixcbiAgICBcImNhbm5vblwiLFxuICAgIFwiY2Fub2VcIixcbiAgICBcImNhbnZhc1wiLFxuICAgIFwiY2FueW9uXCIsXG4gICAgXCJjYXBhYmxlXCIsXG4gICAgXCJjYXBpdGFsXCIsXG4gICAgXCJjYXB0YWluXCIsXG4gICAgXCJjYXJcIixcbiAgICBcImNhcmJvblwiLFxuICAgIFwiY2FyZFwiLFxuICAgIFwiY2FyZ29cIixcbiAgICBcImNhcnBldFwiLFxuICAgIFwiY2FycnlcIixcbiAgICBcImNhcnRcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNhc2hcIixcbiAgICBcImNhc2lub1wiLFxuICAgIFwiY2FzdGxlXCIsXG4gICAgXCJjYXN1YWxcIixcbiAgICBcImNhdFwiLFxuICAgIFwiY2F0YWxvZ1wiLFxuICAgIFwiY2F0Y2hcIixcbiAgICBcImNhdGVnb3J5XCIsXG4gICAgXCJjYXR0bGVcIixcbiAgICBcImNhdWdodFwiLFxuICAgIFwiY2F1c2VcIixcbiAgICBcImNhdXRpb25cIixcbiAgICBcImNhdmVcIixcbiAgICBcImNlaWxpbmdcIixcbiAgICBcImNlbGVyeVwiLFxuICAgIFwiY2VtZW50XCIsXG4gICAgXCJjZW5zdXNcIixcbiAgICBcImNlbnR1cnlcIixcbiAgICBcImNlcmVhbFwiLFxuICAgIFwiY2VydGFpblwiLFxuICAgIFwiY2hhaXJcIixcbiAgICBcImNoYWxrXCIsXG4gICAgXCJjaGFtcGlvblwiLFxuICAgIFwiY2hhbmdlXCIsXG4gICAgXCJjaGFvc1wiLFxuICAgIFwiY2hhcHRlclwiLFxuICAgIFwiY2hhcmdlXCIsXG4gICAgXCJjaGFzZVwiLFxuICAgIFwiY2hhdFwiLFxuICAgIFwiY2hlYXBcIixcbiAgICBcImNoZWNrXCIsXG4gICAgXCJjaGVlc2VcIixcbiAgICBcImNoZWZcIixcbiAgICBcImNoZXJyeVwiLFxuICAgIFwiY2hlc3RcIixcbiAgICBcImNoaWNrZW5cIixcbiAgICBcImNoaWVmXCIsXG4gICAgXCJjaGlsZFwiLFxuICAgIFwiY2hpbW5leVwiLFxuICAgIFwiY2hvaWNlXCIsXG4gICAgXCJjaG9vc2VcIixcbiAgICBcImNocm9uaWNcIixcbiAgICBcImNodWNrbGVcIixcbiAgICBcImNodW5rXCIsXG4gICAgXCJjaHVyblwiLFxuICAgIFwiY2lnYXJcIixcbiAgICBcImNpbm5hbW9uXCIsXG4gICAgXCJjaXJjbGVcIixcbiAgICBcImNpdGl6ZW5cIixcbiAgICBcImNpdHlcIixcbiAgICBcImNpdmlsXCIsXG4gICAgXCJjbGFpbVwiLFxuICAgIFwiY2xhcFwiLFxuICAgIFwiY2xhcmlmeVwiLFxuICAgIFwiY2xhd1wiLFxuICAgIFwiY2xheVwiLFxuICAgIFwiY2xlYW5cIixcbiAgICBcImNsZXJrXCIsXG4gICAgXCJjbGV2ZXJcIixcbiAgICBcImNsaWNrXCIsXG4gICAgXCJjbGllbnRcIixcbiAgICBcImNsaWZmXCIsXG4gICAgXCJjbGltYlwiLFxuICAgIFwiY2xpbmljXCIsXG4gICAgXCJjbGlwXCIsXG4gICAgXCJjbG9ja1wiLFxuICAgIFwiY2xvZ1wiLFxuICAgIFwiY2xvc2VcIixcbiAgICBcImNsb3RoXCIsXG4gICAgXCJjbG91ZFwiLFxuICAgIFwiY2xvd25cIixcbiAgICBcImNsdWJcIixcbiAgICBcImNsdW1wXCIsXG4gICAgXCJjbHVzdGVyXCIsXG4gICAgXCJjbHV0Y2hcIixcbiAgICBcImNvYWNoXCIsXG4gICAgXCJjb2FzdFwiLFxuICAgIFwiY29jb251dFwiLFxuICAgIFwiY29kZVwiLFxuICAgIFwiY29mZmVlXCIsXG4gICAgXCJjb2lsXCIsXG4gICAgXCJjb2luXCIsXG4gICAgXCJjb2xsZWN0XCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiY29sdW1uXCIsXG4gICAgXCJjb21iaW5lXCIsXG4gICAgXCJjb21lXCIsXG4gICAgXCJjb21mb3J0XCIsXG4gICAgXCJjb21pY1wiLFxuICAgIFwiY29tbW9uXCIsXG4gICAgXCJjb21wYW55XCIsXG4gICAgXCJjb25jZXJ0XCIsXG4gICAgXCJjb25kdWN0XCIsXG4gICAgXCJjb25maXJtXCIsXG4gICAgXCJjb25ncmVzc1wiLFxuICAgIFwiY29ubmVjdFwiLFxuICAgIFwiY29uc2lkZXJcIixcbiAgICBcImNvbnRyb2xcIixcbiAgICBcImNvbnZpbmNlXCIsXG4gICAgXCJjb29rXCIsXG4gICAgXCJjb29sXCIsXG4gICAgXCJjb3BwZXJcIixcbiAgICBcImNvcHlcIixcbiAgICBcImNvcmFsXCIsXG4gICAgXCJjb3JlXCIsXG4gICAgXCJjb3JuXCIsXG4gICAgXCJjb3JyZWN0XCIsXG4gICAgXCJjb3N0XCIsXG4gICAgXCJjb3R0b25cIixcbiAgICBcImNvdWNoXCIsXG4gICAgXCJjb3VudHJ5XCIsXG4gICAgXCJjb3VwbGVcIixcbiAgICBcImNvdXJzZVwiLFxuICAgIFwiY291c2luXCIsXG4gICAgXCJjb3ZlclwiLFxuICAgIFwiY295b3RlXCIsXG4gICAgXCJjcmFja1wiLFxuICAgIFwiY3JhZGxlXCIsXG4gICAgXCJjcmFmdFwiLFxuICAgIFwiY3JhbVwiLFxuICAgIFwiY3JhbmVcIixcbiAgICBcImNyYXNoXCIsXG4gICAgXCJjcmF0ZXJcIixcbiAgICBcImNyYXdsXCIsXG4gICAgXCJjcmF6eVwiLFxuICAgIFwiY3JlYW1cIixcbiAgICBcImNyZWRpdFwiLFxuICAgIFwiY3JlZWtcIixcbiAgICBcImNyZXdcIixcbiAgICBcImNyaWNrZXRcIixcbiAgICBcImNyaW1lXCIsXG4gICAgXCJjcmlzcFwiLFxuICAgIFwiY3JpdGljXCIsXG4gICAgXCJjcm9wXCIsXG4gICAgXCJjcm9zc1wiLFxuICAgIFwiY3JvdWNoXCIsXG4gICAgXCJjcm93ZFwiLFxuICAgIFwiY3J1Y2lhbFwiLFxuICAgIFwiY3J1ZWxcIixcbiAgICBcImNydWlzZVwiLFxuICAgIFwiY3J1bWJsZVwiLFxuICAgIFwiY3J1bmNoXCIsXG4gICAgXCJjcnVzaFwiLFxuICAgIFwiY3J5XCIsXG4gICAgXCJjcnlzdGFsXCIsXG4gICAgXCJjdWJlXCIsXG4gICAgXCJjdWx0dXJlXCIsXG4gICAgXCJjdXBcIixcbiAgICBcImN1cGJvYXJkXCIsXG4gICAgXCJjdXJpb3VzXCIsXG4gICAgXCJjdXJyZW50XCIsXG4gICAgXCJjdXJ0YWluXCIsXG4gICAgXCJjdXJ2ZVwiLFxuICAgIFwiY3VzaGlvblwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJjdXRlXCIsXG4gICAgXCJjeWNsZVwiLFxuICAgIFwiZGFkXCIsXG4gICAgXCJkYW1hZ2VcIixcbiAgICBcImRhbXBcIixcbiAgICBcImRhbmNlXCIsXG4gICAgXCJkYW5nZXJcIixcbiAgICBcImRhcmluZ1wiLFxuICAgIFwiZGFzaFwiLFxuICAgIFwiZGF1Z2h0ZXJcIixcbiAgICBcImRhd25cIixcbiAgICBcImRheVwiLFxuICAgIFwiZGVhbFwiLFxuICAgIFwiZGViYXRlXCIsXG4gICAgXCJkZWJyaXNcIixcbiAgICBcImRlY2FkZVwiLFxuICAgIFwiZGVjZW1iZXJcIixcbiAgICBcImRlY2lkZVwiLFxuICAgIFwiZGVjbGluZVwiLFxuICAgIFwiZGVjb3JhdGVcIixcbiAgICBcImRlY3JlYXNlXCIsXG4gICAgXCJkZWVyXCIsXG4gICAgXCJkZWZlbnNlXCIsXG4gICAgXCJkZWZpbmVcIixcbiAgICBcImRlZnlcIixcbiAgICBcImRlZ3JlZVwiLFxuICAgIFwiZGVsYXlcIixcbiAgICBcImRlbGl2ZXJcIixcbiAgICBcImRlbWFuZFwiLFxuICAgIFwiZGVtaXNlXCIsXG4gICAgXCJkZW5pYWxcIixcbiAgICBcImRlbnRpc3RcIixcbiAgICBcImRlbnlcIixcbiAgICBcImRlcGFydFwiLFxuICAgIFwiZGVwZW5kXCIsXG4gICAgXCJkZXBvc2l0XCIsXG4gICAgXCJkZXB0aFwiLFxuICAgIFwiZGVwdXR5XCIsXG4gICAgXCJkZXJpdmVcIixcbiAgICBcImRlc2NyaWJlXCIsXG4gICAgXCJkZXNlcnRcIixcbiAgICBcImRlc2lnblwiLFxuICAgIFwiZGVza1wiLFxuICAgIFwiZGVzcGFpclwiLFxuICAgIFwiZGVzdHJveVwiLFxuICAgIFwiZGV0YWlsXCIsXG4gICAgXCJkZXRlY3RcIixcbiAgICBcImRldmVsb3BcIixcbiAgICBcImRldmljZVwiLFxuICAgIFwiZGV2b3RlXCIsXG4gICAgXCJkaWFncmFtXCIsXG4gICAgXCJkaWFsXCIsXG4gICAgXCJkaWFtb25kXCIsXG4gICAgXCJkaWFyeVwiLFxuICAgIFwiZGljZVwiLFxuICAgIFwiZGllc2VsXCIsXG4gICAgXCJkaWV0XCIsXG4gICAgXCJkaWZmZXJcIixcbiAgICBcImRpZ2l0YWxcIixcbiAgICBcImRpZ25pdHlcIixcbiAgICBcImRpbGVtbWFcIixcbiAgICBcImRpbm5lclwiLFxuICAgIFwiZGlub3NhdXJcIixcbiAgICBcImRpcmVjdFwiLFxuICAgIFwiZGlydFwiLFxuICAgIFwiZGlzYWdyZWVcIixcbiAgICBcImRpc2NvdmVyXCIsXG4gICAgXCJkaXNlYXNlXCIsXG4gICAgXCJkaXNoXCIsXG4gICAgXCJkaXNtaXNzXCIsXG4gICAgXCJkaXNvcmRlclwiLFxuICAgIFwiZGlzcGxheVwiLFxuICAgIFwiZGlzdGFuY2VcIixcbiAgICBcImRpdmVydFwiLFxuICAgIFwiZGl2aWRlXCIsXG4gICAgXCJkaXZvcmNlXCIsXG4gICAgXCJkaXp6eVwiLFxuICAgIFwiZG9jdG9yXCIsXG4gICAgXCJkb2N1bWVudFwiLFxuICAgIFwiZG9nXCIsXG4gICAgXCJkb2xsXCIsXG4gICAgXCJkb2xwaGluXCIsXG4gICAgXCJkb21haW5cIixcbiAgICBcImRvbmF0ZVwiLFxuICAgIFwiZG9ua2V5XCIsXG4gICAgXCJkb25vclwiLFxuICAgIFwiZG9vclwiLFxuICAgIFwiZG9zZVwiLFxuICAgIFwiZG91YmxlXCIsXG4gICAgXCJkb3ZlXCIsXG4gICAgXCJkcmFmdFwiLFxuICAgIFwiZHJhZ29uXCIsXG4gICAgXCJkcmFtYVwiLFxuICAgIFwiZHJhc3RpY1wiLFxuICAgIFwiZHJhd1wiLFxuICAgIFwiZHJlYW1cIixcbiAgICBcImRyZXNzXCIsXG4gICAgXCJkcmlmdFwiLFxuICAgIFwiZHJpbGxcIixcbiAgICBcImRyaW5rXCIsXG4gICAgXCJkcmlwXCIsXG4gICAgXCJkcml2ZVwiLFxuICAgIFwiZHJvcFwiLFxuICAgIFwiZHJ1bVwiLFxuICAgIFwiZHJ5XCIsXG4gICAgXCJkdWNrXCIsXG4gICAgXCJkdW1iXCIsXG4gICAgXCJkdW5lXCIsXG4gICAgXCJkdXJpbmdcIixcbiAgICBcImR1c3RcIixcbiAgICBcImR1dGNoXCIsXG4gICAgXCJkdXR5XCIsXG4gICAgXCJkd2FyZlwiLFxuICAgIFwiZHluYW1pY1wiLFxuICAgIFwiZWFnZXJcIixcbiAgICBcImVhZ2xlXCIsXG4gICAgXCJlYXJseVwiLFxuICAgIFwiZWFyblwiLFxuICAgIFwiZWFydGhcIixcbiAgICBcImVhc2lseVwiLFxuICAgIFwiZWFzdFwiLFxuICAgIFwiZWFzeVwiLFxuICAgIFwiZWNob1wiLFxuICAgIFwiZWNvbG9neVwiLFxuICAgIFwiZWNvbm9teVwiLFxuICAgIFwiZWRnZVwiLFxuICAgIFwiZWRpdFwiLFxuICAgIFwiZWR1Y2F0ZVwiLFxuICAgIFwiZWZmb3J0XCIsXG4gICAgXCJlZ2dcIixcbiAgICBcImVpZ2h0XCIsXG4gICAgXCJlaXRoZXJcIixcbiAgICBcImVsYm93XCIsXG4gICAgXCJlbGRlclwiLFxuICAgIFwiZWxlY3RyaWNcIixcbiAgICBcImVsZWdhbnRcIixcbiAgICBcImVsZW1lbnRcIixcbiAgICBcImVsZXBoYW50XCIsXG4gICAgXCJlbGV2YXRvclwiLFxuICAgIFwiZWxpdGVcIixcbiAgICBcImVsc2VcIixcbiAgICBcImVtYmFya1wiLFxuICAgIFwiZW1ib2R5XCIsXG4gICAgXCJlbWJyYWNlXCIsXG4gICAgXCJlbWVyZ2VcIixcbiAgICBcImVtb3Rpb25cIixcbiAgICBcImVtcGxveVwiLFxuICAgIFwiZW1wb3dlclwiLFxuICAgIFwiZW1wdHlcIixcbiAgICBcImVuYWJsZVwiLFxuICAgIFwiZW5hY3RcIixcbiAgICBcImVuZFwiLFxuICAgIFwiZW5kbGVzc1wiLFxuICAgIFwiZW5kb3JzZVwiLFxuICAgIFwiZW5lbXlcIixcbiAgICBcImVuZXJneVwiLFxuICAgIFwiZW5mb3JjZVwiLFxuICAgIFwiZW5nYWdlXCIsXG4gICAgXCJlbmdpbmVcIixcbiAgICBcImVuaGFuY2VcIixcbiAgICBcImVuam95XCIsXG4gICAgXCJlbmxpc3RcIixcbiAgICBcImVub3VnaFwiLFxuICAgIFwiZW5yaWNoXCIsXG4gICAgXCJlbnJvbGxcIixcbiAgICBcImVuc3VyZVwiLFxuICAgIFwiZW50ZXJcIixcbiAgICBcImVudGlyZVwiLFxuICAgIFwiZW50cnlcIixcbiAgICBcImVudmVsb3BlXCIsXG4gICAgXCJlcGlzb2RlXCIsXG4gICAgXCJlcXVhbFwiLFxuICAgIFwiZXF1aXBcIixcbiAgICBcImVyYVwiLFxuICAgIFwiZXJhc2VcIixcbiAgICBcImVyb2RlXCIsXG4gICAgXCJlcm9zaW9uXCIsXG4gICAgXCJlcnJvclwiLFxuICAgIFwiZXJ1cHRcIixcbiAgICBcImVzY2FwZVwiLFxuICAgIFwiZXNzYXlcIixcbiAgICBcImVzc2VuY2VcIixcbiAgICBcImVzdGF0ZVwiLFxuICAgIFwiZXRlcm5hbFwiLFxuICAgIFwiZXRoaWNzXCIsXG4gICAgXCJldmlkZW5jZVwiLFxuICAgIFwiZXZpbFwiLFxuICAgIFwiZXZva2VcIixcbiAgICBcImV2b2x2ZVwiLFxuICAgIFwiZXhhY3RcIixcbiAgICBcImV4YW1wbGVcIixcbiAgICBcImV4Y2Vzc1wiLFxuICAgIFwiZXhjaGFuZ2VcIixcbiAgICBcImV4Y2l0ZVwiLFxuICAgIFwiZXhjbHVkZVwiLFxuICAgIFwiZXhjdXNlXCIsXG4gICAgXCJleGVjdXRlXCIsXG4gICAgXCJleGVyY2lzZVwiLFxuICAgIFwiZXhoYXVzdFwiLFxuICAgIFwiZXhoaWJpdFwiLFxuICAgIFwiZXhpbGVcIixcbiAgICBcImV4aXN0XCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJleG90aWNcIixcbiAgICBcImV4cGFuZFwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJleHBpcmVcIixcbiAgICBcImV4cGxhaW5cIixcbiAgICBcImV4cG9zZVwiLFxuICAgIFwiZXhwcmVzc1wiLFxuICAgIFwiZXh0ZW5kXCIsXG4gICAgXCJleHRyYVwiLFxuICAgIFwiZXllXCIsXG4gICAgXCJleWVicm93XCIsXG4gICAgXCJmYWJyaWNcIixcbiAgICBcImZhY2VcIixcbiAgICBcImZhY3VsdHlcIixcbiAgICBcImZhZGVcIixcbiAgICBcImZhaW50XCIsXG4gICAgXCJmYWl0aFwiLFxuICAgIFwiZmFsbFwiLFxuICAgIFwiZmFsc2VcIixcbiAgICBcImZhbWVcIixcbiAgICBcImZhbWlseVwiLFxuICAgIFwiZmFtb3VzXCIsXG4gICAgXCJmYW5cIixcbiAgICBcImZhbmN5XCIsXG4gICAgXCJmYW50YXN5XCIsXG4gICAgXCJmYXJtXCIsXG4gICAgXCJmYXNoaW9uXCIsXG4gICAgXCJmYXRcIixcbiAgICBcImZhdGFsXCIsXG4gICAgXCJmYXRoZXJcIixcbiAgICBcImZhdGlndWVcIixcbiAgICBcImZhdWx0XCIsXG4gICAgXCJmYXZvcml0ZVwiLFxuICAgIFwiZmVhdHVyZVwiLFxuICAgIFwiZmVicnVhcnlcIixcbiAgICBcImZlZGVyYWxcIixcbiAgICBcImZlZVwiLFxuICAgIFwiZmVlZFwiLFxuICAgIFwiZmVlbFwiLFxuICAgIFwiZmVtYWxlXCIsXG4gICAgXCJmZW5jZVwiLFxuICAgIFwiZmVzdGl2YWxcIixcbiAgICBcImZldGNoXCIsXG4gICAgXCJmZXZlclwiLFxuICAgIFwiZmV3XCIsXG4gICAgXCJmaWJlclwiLFxuICAgIFwiZmljdGlvblwiLFxuICAgIFwiZmllbGRcIixcbiAgICBcImZpZ3VyZVwiLFxuICAgIFwiZmlsZVwiLFxuICAgIFwiZmlsbVwiLFxuICAgIFwiZmlsdGVyXCIsXG4gICAgXCJmaW5hbFwiLFxuICAgIFwiZmluZFwiLFxuICAgIFwiZmluZVwiLFxuICAgIFwiZmluZ2VyXCIsXG4gICAgXCJmaW5pc2hcIixcbiAgICBcImZpcmVcIixcbiAgICBcImZpcm1cIixcbiAgICBcImZpcnN0XCIsXG4gICAgXCJmaXNjYWxcIixcbiAgICBcImZpc2hcIixcbiAgICBcImZpdFwiLFxuICAgIFwiZml0bmVzc1wiLFxuICAgIFwiZml4XCIsXG4gICAgXCJmbGFnXCIsXG4gICAgXCJmbGFtZVwiLFxuICAgIFwiZmxhc2hcIixcbiAgICBcImZsYXRcIixcbiAgICBcImZsYXZvclwiLFxuICAgIFwiZmxlZVwiLFxuICAgIFwiZmxpZ2h0XCIsXG4gICAgXCJmbGlwXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiZmxvY2tcIixcbiAgICBcImZsb29yXCIsXG4gICAgXCJmbG93ZXJcIixcbiAgICBcImZsdWlkXCIsXG4gICAgXCJmbHVzaFwiLFxuICAgIFwiZmx5XCIsXG4gICAgXCJmb2FtXCIsXG4gICAgXCJmb2N1c1wiLFxuICAgIFwiZm9nXCIsXG4gICAgXCJmb2lsXCIsXG4gICAgXCJmb2xkXCIsXG4gICAgXCJmb2xsb3dcIixcbiAgICBcImZvb2RcIixcbiAgICBcImZvb3RcIixcbiAgICBcImZvcmNlXCIsXG4gICAgXCJmb3Jlc3RcIixcbiAgICBcImZvcmdldFwiLFxuICAgIFwiZm9ya1wiLFxuICAgIFwiZm9ydHVuZVwiLFxuICAgIFwiZm9ydW1cIixcbiAgICBcImZvcndhcmRcIixcbiAgICBcImZvc3NpbFwiLFxuICAgIFwiZm9zdGVyXCIsXG4gICAgXCJmb3VuZFwiLFxuICAgIFwiZm94XCIsXG4gICAgXCJmcmFnaWxlXCIsXG4gICAgXCJmcmFtZVwiLFxuICAgIFwiZnJlcXVlbnRcIixcbiAgICBcImZyZXNoXCIsXG4gICAgXCJmcmllbmRcIixcbiAgICBcImZyaW5nZVwiLFxuICAgIFwiZnJvZ1wiLFxuICAgIFwiZnJvbnRcIixcbiAgICBcImZyb3N0XCIsXG4gICAgXCJmcm93blwiLFxuICAgIFwiZnJvemVuXCIsXG4gICAgXCJmcnVpdFwiLFxuICAgIFwiZnVlbFwiLFxuICAgIFwiZnVuXCIsXG4gICAgXCJmdW5ueVwiLFxuICAgIFwiZnVybmFjZVwiLFxuICAgIFwiZnVyeVwiLFxuICAgIFwiZnV0dXJlXCIsXG4gICAgXCJnYWRnZXRcIixcbiAgICBcImdhaW5cIixcbiAgICBcImdhbGF4eVwiLFxuICAgIFwiZ2FsbGVyeVwiLFxuICAgIFwiZ2FtZVwiLFxuICAgIFwiZ2FwXCIsXG4gICAgXCJnYXJhZ2VcIixcbiAgICBcImdhcmJhZ2VcIixcbiAgICBcImdhcmRlblwiLFxuICAgIFwiZ2FybGljXCIsXG4gICAgXCJnYXJtZW50XCIsXG4gICAgXCJnYXNcIixcbiAgICBcImdhc3BcIixcbiAgICBcImdhdGVcIixcbiAgICBcImdhdGhlclwiLFxuICAgIFwiZ2F1Z2VcIixcbiAgICBcImdhemVcIixcbiAgICBcImdlbmVyYWxcIixcbiAgICBcImdlbml1c1wiLFxuICAgIFwiZ2VucmVcIixcbiAgICBcImdlbnRsZVwiLFxuICAgIFwiZ2VudWluZVwiLFxuICAgIFwiZ2VzdHVyZVwiLFxuICAgIFwiZ2hvc3RcIixcbiAgICBcImdpYW50XCIsXG4gICAgXCJnaWZ0XCIsXG4gICAgXCJnaWdnbGVcIixcbiAgICBcImdpbmdlclwiLFxuICAgIFwiZ2lyYWZmZVwiLFxuICAgIFwiZ2lybFwiLFxuICAgIFwiZ2l2ZVwiLFxuICAgIFwiZ2xhZFwiLFxuICAgIFwiZ2xhbmNlXCIsXG4gICAgXCJnbGFyZVwiLFxuICAgIFwiZ2xhc3NcIixcbiAgICBcImdsaWRlXCIsXG4gICAgXCJnbGltcHNlXCIsXG4gICAgXCJnbG9iZVwiLFxuICAgIFwiZ2xvb21cIixcbiAgICBcImdsb3J5XCIsXG4gICAgXCJnbG92ZVwiLFxuICAgIFwiZ2xvd1wiLFxuICAgIFwiZ2x1ZVwiLFxuICAgIFwiZ29hdFwiLFxuICAgIFwiZ29kZGVzc1wiLFxuICAgIFwiZ29sZFwiLFxuICAgIFwiZ29vZFwiLFxuICAgIFwiZ29vc2VcIixcbiAgICBcImdvcmlsbGFcIixcbiAgICBcImdvc3BlbFwiLFxuICAgIFwiZ29zc2lwXCIsXG4gICAgXCJnb3Zlcm5cIixcbiAgICBcImdvd25cIixcbiAgICBcImdyYWJcIixcbiAgICBcImdyYWNlXCIsXG4gICAgXCJncmFpblwiLFxuICAgIFwiZ3JhbnRcIixcbiAgICBcImdyYXBlXCIsXG4gICAgXCJncmFzc1wiLFxuICAgIFwiZ3Jhdml0eVwiLFxuICAgIFwiZ3JlYXRcIixcbiAgICBcImdyZWVuXCIsXG4gICAgXCJncmlkXCIsXG4gICAgXCJncmllZlwiLFxuICAgIFwiZ3JpdFwiLFxuICAgIFwiZ3JvY2VyeVwiLFxuICAgIFwiZ3JvdXBcIixcbiAgICBcImdyb3dcIixcbiAgICBcImdydW50XCIsXG4gICAgXCJndWFyZFwiLFxuICAgIFwiZ3Vlc3NcIixcbiAgICBcImd1aWRlXCIsXG4gICAgXCJndWlsdFwiLFxuICAgIFwiZ3VpdGFyXCIsXG4gICAgXCJndW5cIixcbiAgICBcImd5bVwiLFxuICAgIFwiaGFiaXRcIixcbiAgICBcImhhaXJcIixcbiAgICBcImhhbGZcIixcbiAgICBcImhhbW1lclwiLFxuICAgIFwiaGFtc3RlclwiLFxuICAgIFwiaGFuZFwiLFxuICAgIFwiaGFwcHlcIixcbiAgICBcImhhcmJvclwiLFxuICAgIFwiaGFyZFwiLFxuICAgIFwiaGFyc2hcIixcbiAgICBcImhhcnZlc3RcIixcbiAgICBcImhhdFwiLFxuICAgIFwiaGF2ZVwiLFxuICAgIFwiaGF3a1wiLFxuICAgIFwiaGF6YXJkXCIsXG4gICAgXCJoZWFkXCIsXG4gICAgXCJoZWFsdGhcIixcbiAgICBcImhlYXJ0XCIsXG4gICAgXCJoZWF2eVwiLFxuICAgIFwiaGVkZ2Vob2dcIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwiaGVsbG9cIixcbiAgICBcImhlbG1ldFwiLFxuICAgIFwiaGVscFwiLFxuICAgIFwiaGVuXCIsXG4gICAgXCJoZXJvXCIsXG4gICAgXCJoaWRkZW5cIixcbiAgICBcImhpZ2hcIixcbiAgICBcImhpbGxcIixcbiAgICBcImhpbnRcIixcbiAgICBcImhpcFwiLFxuICAgIFwiaGlyZVwiLFxuICAgIFwiaGlzdG9yeVwiLFxuICAgIFwiaG9iYnlcIixcbiAgICBcImhvY2tleVwiLFxuICAgIFwiaG9sZFwiLFxuICAgIFwiaG9sZVwiLFxuICAgIFwiaG9saWRheVwiLFxuICAgIFwiaG9sbG93XCIsXG4gICAgXCJob21lXCIsXG4gICAgXCJob25leVwiLFxuICAgIFwiaG9vZFwiLFxuICAgIFwiaG9wZVwiLFxuICAgIFwiaG9yblwiLFxuICAgIFwiaG9ycm9yXCIsXG4gICAgXCJob3JzZVwiLFxuICAgIFwiaG9zcGl0YWxcIixcbiAgICBcImhvc3RcIixcbiAgICBcImhvdGVsXCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJob3ZlclwiLFxuICAgIFwiaHViXCIsXG4gICAgXCJodWdlXCIsXG4gICAgXCJodW1hblwiLFxuICAgIFwiaHVtYmxlXCIsXG4gICAgXCJodW1vclwiLFxuICAgIFwiaHVuZHJlZFwiLFxuICAgIFwiaHVuZ3J5XCIsXG4gICAgXCJodW50XCIsXG4gICAgXCJodXJkbGVcIixcbiAgICBcImh1cnJ5XCIsXG4gICAgXCJodXJ0XCIsXG4gICAgXCJodXNiYW5kXCIsXG4gICAgXCJoeWJyaWRcIixcbiAgICBcImljZVwiLFxuICAgIFwiaWNvblwiLFxuICAgIFwiaWRlYVwiLFxuICAgIFwiaWRlbnRpZnlcIixcbiAgICBcImlkbGVcIixcbiAgICBcImlnbm9yZVwiLFxuICAgIFwiaWxsXCIsXG4gICAgXCJpbGxlZ2FsXCIsXG4gICAgXCJpbGxuZXNzXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwiaW1pdGF0ZVwiLFxuICAgIFwiaW1tZW5zZVwiLFxuICAgIFwiaW1tdW5lXCIsXG4gICAgXCJpbXBhY3RcIixcbiAgICBcImltcG9zZVwiLFxuICAgIFwiaW1wcm92ZVwiLFxuICAgIFwiaW1wdWxzZVwiLFxuICAgIFwiaW5jaFwiLFxuICAgIFwiaW5jbHVkZVwiLFxuICAgIFwiaW5jb21lXCIsXG4gICAgXCJpbmNyZWFzZVwiLFxuICAgIFwiaW5kZXhcIixcbiAgICBcImluZGljYXRlXCIsXG4gICAgXCJpbmRvb3JcIixcbiAgICBcImluZHVzdHJ5XCIsXG4gICAgXCJpbmZhbnRcIixcbiAgICBcImluZmxpY3RcIixcbiAgICBcImluZm9ybVwiLFxuICAgIFwiaW5oYWxlXCIsXG4gICAgXCJpbmhlcml0XCIsXG4gICAgXCJpbml0aWFsXCIsXG4gICAgXCJpbmplY3RcIixcbiAgICBcImluanVyeVwiLFxuICAgIFwiaW5tYXRlXCIsXG4gICAgXCJpbm5lclwiLFxuICAgIFwiaW5ub2NlbnRcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpbnF1aXJ5XCIsXG4gICAgXCJpbnNhbmVcIixcbiAgICBcImluc2VjdFwiLFxuICAgIFwiaW5zaWRlXCIsXG4gICAgXCJpbnNwaXJlXCIsXG4gICAgXCJpbnN0YWxsXCIsXG4gICAgXCJpbnRhY3RcIixcbiAgICBcImludGVyZXN0XCIsXG4gICAgXCJpbnRvXCIsXG4gICAgXCJpbnZlc3RcIixcbiAgICBcImludml0ZVwiLFxuICAgIFwiaW52b2x2ZVwiLFxuICAgIFwiaXJvblwiLFxuICAgIFwiaXNsYW5kXCIsXG4gICAgXCJpc29sYXRlXCIsXG4gICAgXCJpc3N1ZVwiLFxuICAgIFwiaXRlbVwiLFxuICAgIFwiaXZvcnlcIixcbiAgICBcImphY2tldFwiLFxuICAgIFwiamFndWFyXCIsXG4gICAgXCJqYXJcIixcbiAgICBcImphenpcIixcbiAgICBcImplYWxvdXNcIixcbiAgICBcImplYW5zXCIsXG4gICAgXCJqZWxseVwiLFxuICAgIFwiamV3ZWxcIixcbiAgICBcImpvYlwiLFxuICAgIFwiam9pblwiLFxuICAgIFwiam9rZVwiLFxuICAgIFwiam91cm5leVwiLFxuICAgIFwiam95XCIsXG4gICAgXCJqdWRnZVwiLFxuICAgIFwianVpY2VcIixcbiAgICBcImp1bXBcIixcbiAgICBcImp1bmdsZVwiLFxuICAgIFwianVuaW9yXCIsXG4gICAgXCJqdW5rXCIsXG4gICAgXCJqdXN0XCIsXG4gICAgXCJrYW5nYXJvb1wiLFxuICAgIFwia2VlblwiLFxuICAgIFwia2VlcFwiLFxuICAgIFwia2V0Y2h1cFwiLFxuICAgIFwia2V5XCIsXG4gICAgXCJraWNrXCIsXG4gICAgXCJraWRcIixcbiAgICBcImtpZG5leVwiLFxuICAgIFwia2luZFwiLFxuICAgIFwia2luZ2RvbVwiLFxuICAgIFwia2lzc1wiLFxuICAgIFwia2l0XCIsXG4gICAgXCJraXRjaGVuXCIsXG4gICAgXCJraXRlXCIsXG4gICAgXCJraXR0ZW5cIixcbiAgICBcImtpd2lcIixcbiAgICBcImtuZWVcIixcbiAgICBcImtuaWZlXCIsXG4gICAgXCJrbm9ja1wiLFxuICAgIFwia25vd1wiLFxuICAgIFwibGFiXCIsXG4gICAgXCJsYWJlbFwiLFxuICAgIFwibGFib3JcIixcbiAgICBcImxhZGRlclwiLFxuICAgIFwibGFkeVwiLFxuICAgIFwibGFrZVwiLFxuICAgIFwibGFtcFwiLFxuICAgIFwibGFuZ3VhZ2VcIixcbiAgICBcImxhcHRvcFwiLFxuICAgIFwibGFyZ2VcIixcbiAgICBcImxhdGVyXCIsXG4gICAgXCJsYXRpblwiLFxuICAgIFwibGF1Z2hcIixcbiAgICBcImxhdW5kcnlcIixcbiAgICBcImxhdmFcIixcbiAgICBcImxhd1wiLFxuICAgIFwibGF3blwiLFxuICAgIFwibGF3c3VpdFwiLFxuICAgIFwibGF5ZXJcIixcbiAgICBcImxhenlcIixcbiAgICBcImxlYWRlclwiLFxuICAgIFwibGVhZlwiLFxuICAgIFwibGVhcm5cIixcbiAgICBcImxlYXZlXCIsXG4gICAgXCJsZWN0dXJlXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJsZWdcIixcbiAgICBcImxlZ2FsXCIsXG4gICAgXCJsZWdlbmRcIixcbiAgICBcImxlaXN1cmVcIixcbiAgICBcImxlbW9uXCIsXG4gICAgXCJsZW5kXCIsXG4gICAgXCJsZW5ndGhcIixcbiAgICBcImxlbnNcIixcbiAgICBcImxlb3BhcmRcIixcbiAgICBcImxlc3NvblwiLFxuICAgIFwibGV0dGVyXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwibGlhclwiLFxuICAgIFwibGliZXJ0eVwiLFxuICAgIFwibGlicmFyeVwiLFxuICAgIFwibGljZW5zZVwiLFxuICAgIFwibGlmZVwiLFxuICAgIFwibGlmdFwiLFxuICAgIFwibGlnaHRcIixcbiAgICBcImxpa2VcIixcbiAgICBcImxpbWJcIixcbiAgICBcImxpbWl0XCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJsaW9uXCIsXG4gICAgXCJsaXF1aWRcIixcbiAgICBcImxpc3RcIixcbiAgICBcImxpdHRsZVwiLFxuICAgIFwibGl2ZVwiLFxuICAgIFwibGl6YXJkXCIsXG4gICAgXCJsb2FkXCIsXG4gICAgXCJsb2FuXCIsXG4gICAgXCJsb2JzdGVyXCIsXG4gICAgXCJsb2NhbFwiLFxuICAgIFwibG9ja1wiLFxuICAgIFwibG9naWNcIixcbiAgICBcImxvbmVseVwiLFxuICAgIFwibG9uZ1wiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibG90dGVyeVwiLFxuICAgIFwibG91ZFwiLFxuICAgIFwibG91bmdlXCIsXG4gICAgXCJsb3ZlXCIsXG4gICAgXCJsb3lhbFwiLFxuICAgIFwibHVja3lcIixcbiAgICBcImx1Z2dhZ2VcIixcbiAgICBcImx1bWJlclwiLFxuICAgIFwibHVuYXJcIixcbiAgICBcImx1bmNoXCIsXG4gICAgXCJsdXh1cnlcIixcbiAgICBcImx5cmljc1wiLFxuICAgIFwibWFjaGluZVwiLFxuICAgIFwibWFkXCIsXG4gICAgXCJtYWdpY1wiLFxuICAgIFwibWFnbmV0XCIsXG4gICAgXCJtYWlkXCIsXG4gICAgXCJtYWlsXCIsXG4gICAgXCJtYWluXCIsXG4gICAgXCJtYWpvclwiLFxuICAgIFwibWFrZVwiLFxuICAgIFwibWFtbWFsXCIsXG4gICAgXCJtYW5cIixcbiAgICBcIm1hbmFnZVwiLFxuICAgIFwibWFuZGF0ZVwiLFxuICAgIFwibWFuZ29cIixcbiAgICBcIm1hbnNpb25cIixcbiAgICBcIm1hbnVhbFwiLFxuICAgIFwibWFwbGVcIixcbiAgICBcIm1hcmJsZVwiLFxuICAgIFwibWFyY2hcIixcbiAgICBcIm1hcmdpblwiLFxuICAgIFwibWFyaW5lXCIsXG4gICAgXCJtYXJrZXRcIixcbiAgICBcIm1hcnJpYWdlXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtYXNzXCIsXG4gICAgXCJtYXN0ZXJcIixcbiAgICBcIm1hdGNoXCIsXG4gICAgXCJtYXRlcmlhbFwiLFxuICAgIFwibWF0aFwiLFxuICAgIFwibWF0cml4XCIsXG4gICAgXCJtYXR0ZXJcIixcbiAgICBcIm1heGltdW1cIixcbiAgICBcIm1hemVcIixcbiAgICBcIm1lYWRvd1wiLFxuICAgIFwibWVhblwiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwibWVhdFwiLFxuICAgIFwibWVjaGFuaWNcIixcbiAgICBcIm1lZGFsXCIsXG4gICAgXCJtZWRpYVwiLFxuICAgIFwibWVsb2R5XCIsXG4gICAgXCJtZWx0XCIsXG4gICAgXCJtZW1iZXJcIixcbiAgICBcIm1lbW9yeVwiLFxuICAgIFwibWVudGlvblwiLFxuICAgIFwibWVudVwiLFxuICAgIFwibWVyY3lcIixcbiAgICBcIm1lcmdlXCIsXG4gICAgXCJtZXJpdFwiLFxuICAgIFwibWVycnlcIixcbiAgICBcIm1lc2hcIixcbiAgICBcIm1lc3NhZ2VcIixcbiAgICBcIm1ldGFsXCIsXG4gICAgXCJtZXRob2RcIixcbiAgICBcIm1pZGRsZVwiLFxuICAgIFwibWlkbmlnaHRcIixcbiAgICBcIm1pbGtcIixcbiAgICBcIm1pbGxpb25cIixcbiAgICBcIm1pbWljXCIsXG4gICAgXCJtaW5kXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJtaW5vclwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJtaXJhY2xlXCIsXG4gICAgXCJtaXJyb3JcIixcbiAgICBcIm1pc2VyeVwiLFxuICAgIFwibWlzc1wiLFxuICAgIFwibWlzdGFrZVwiLFxuICAgIFwibWl4XCIsXG4gICAgXCJtaXhlZFwiLFxuICAgIFwibWl4dHVyZVwiLFxuICAgIFwibW9iaWxlXCIsXG4gICAgXCJtb2RlbFwiLFxuICAgIFwibW9kaWZ5XCIsXG4gICAgXCJtb21cIixcbiAgICBcIm1vbWVudFwiLFxuICAgIFwibW9uaXRvclwiLFxuICAgIFwibW9ua2V5XCIsXG4gICAgXCJtb25zdGVyXCIsXG4gICAgXCJtb250aFwiLFxuICAgIFwibW9vblwiLFxuICAgIFwibW9yYWxcIixcbiAgICBcIm1vcmVcIixcbiAgICBcIm1vcm5pbmdcIixcbiAgICBcIm1vc3F1aXRvXCIsXG4gICAgXCJtb3RoZXJcIixcbiAgICBcIm1vdGlvblwiLFxuICAgIFwibW90b3JcIixcbiAgICBcIm1vdW50YWluXCIsXG4gICAgXCJtb3VzZVwiLFxuICAgIFwibW92ZVwiLFxuICAgIFwibW92aWVcIixcbiAgICBcIm11Y2hcIixcbiAgICBcIm11ZmZpblwiLFxuICAgIFwibXVsZVwiLFxuICAgIFwibXVsdGlwbHlcIixcbiAgICBcIm11c2NsZVwiLFxuICAgIFwibXVzZXVtXCIsXG4gICAgXCJtdXNocm9vbVwiLFxuICAgIFwibXVzaWNcIixcbiAgICBcIm11c3RcIixcbiAgICBcIm11dHVhbFwiLFxuICAgIFwibXlzZWxmXCIsXG4gICAgXCJteXN0ZXJ5XCIsXG4gICAgXCJteXRoXCIsXG4gICAgXCJuYWl2ZVwiLFxuICAgIFwibmFtZVwiLFxuICAgIFwibmFwa2luXCIsXG4gICAgXCJuYXJyb3dcIixcbiAgICBcIm5hc3R5XCIsXG4gICAgXCJuYXRpb25cIixcbiAgICBcIm5hdHVyZVwiLFxuICAgIFwibmVhclwiLFxuICAgIFwibmVja1wiLFxuICAgIFwibmVlZFwiLFxuICAgIFwibmVnYXRpdmVcIixcbiAgICBcIm5lZ2xlY3RcIixcbiAgICBcIm5laXRoZXJcIixcbiAgICBcIm5lcGhld1wiLFxuICAgIFwibmVydmVcIixcbiAgICBcIm5lc3RcIixcbiAgICBcIm5ldFwiLFxuICAgIFwibmV0d29ya1wiLFxuICAgIFwibmV1dHJhbFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm5ld3NcIixcbiAgICBcIm5leHRcIixcbiAgICBcIm5pY2VcIixcbiAgICBcIm5pZ2h0XCIsXG4gICAgXCJub2JsZVwiLFxuICAgIFwibm9pc2VcIixcbiAgICBcIm5vbWluZWVcIixcbiAgICBcIm5vb2RsZVwiLFxuICAgIFwibm9ybWFsXCIsXG4gICAgXCJub3J0aFwiLFxuICAgIFwibm9zZVwiLFxuICAgIFwibm90YWJsZVwiLFxuICAgIFwibm90ZVwiLFxuICAgIFwibm90aGluZ1wiLFxuICAgIFwibm90aWNlXCIsXG4gICAgXCJub3ZlbFwiLFxuICAgIFwibm93XCIsXG4gICAgXCJudWNsZWFyXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcIm51cnNlXCIsXG4gICAgXCJudXRcIixcbiAgICBcIm9ha1wiLFxuICAgIFwib2JleVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJvYmxpZ2VcIixcbiAgICBcIm9ic2N1cmVcIixcbiAgICBcIm9ic2VydmVcIixcbiAgICBcIm9idGFpblwiLFxuICAgIFwib2J2aW91c1wiLFxuICAgIFwib2NjdXJcIixcbiAgICBcIm9jZWFuXCIsXG4gICAgXCJvY3RvYmVyXCIsXG4gICAgXCJvZG9yXCIsXG4gICAgXCJvZmZcIixcbiAgICBcIm9mZmVyXCIsXG4gICAgXCJvZmZpY2VcIixcbiAgICBcIm9mdGVuXCIsXG4gICAgXCJvaWxcIixcbiAgICBcIm9rYXlcIixcbiAgICBcIm9sZFwiLFxuICAgIFwib2xpdmVcIixcbiAgICBcIm9seW1waWNcIixcbiAgICBcIm9taXRcIixcbiAgICBcIm9uY2VcIixcbiAgICBcIm9uZVwiLFxuICAgIFwib25pb25cIixcbiAgICBcIm9ubGluZVwiLFxuICAgIFwib25seVwiLFxuICAgIFwib3BlblwiLFxuICAgIFwib3BlcmFcIixcbiAgICBcIm9waW5pb25cIixcbiAgICBcIm9wcG9zZVwiLFxuICAgIFwib3B0aW9uXCIsXG4gICAgXCJvcmFuZ2VcIixcbiAgICBcIm9yYml0XCIsXG4gICAgXCJvcmNoYXJkXCIsXG4gICAgXCJvcmRlclwiLFxuICAgIFwib3JkaW5hcnlcIixcbiAgICBcIm9yZ2FuXCIsXG4gICAgXCJvcmllbnRcIixcbiAgICBcIm9yaWdpbmFsXCIsXG4gICAgXCJvcnBoYW5cIixcbiAgICBcIm9zdHJpY2hcIixcbiAgICBcIm90aGVyXCIsXG4gICAgXCJvdXRkb29yXCIsXG4gICAgXCJvdXRlclwiLFxuICAgIFwib3V0cHV0XCIsXG4gICAgXCJvdXRzaWRlXCIsXG4gICAgXCJvdmFsXCIsXG4gICAgXCJvdmVuXCIsXG4gICAgXCJvdmVyXCIsXG4gICAgXCJvd25cIixcbiAgICBcIm93bmVyXCIsXG4gICAgXCJveHlnZW5cIixcbiAgICBcIm95c3RlclwiLFxuICAgIFwib3pvbmVcIixcbiAgICBcInBhY3RcIixcbiAgICBcInBhZGRsZVwiLFxuICAgIFwicGFnZVwiLFxuICAgIFwicGFpclwiLFxuICAgIFwicGFsYWNlXCIsXG4gICAgXCJwYWxtXCIsXG4gICAgXCJwYW5kYVwiLFxuICAgIFwicGFuZWxcIixcbiAgICBcInBhbmljXCIsXG4gICAgXCJwYW50aGVyXCIsXG4gICAgXCJwYXBlclwiLFxuICAgIFwicGFyYWRlXCIsXG4gICAgXCJwYXJlbnRcIixcbiAgICBcInBhcmtcIixcbiAgICBcInBhcnJvdFwiLFxuICAgIFwicGFydHlcIixcbiAgICBcInBhc3NcIixcbiAgICBcInBhdGNoXCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJwYXRpZW50XCIsXG4gICAgXCJwYXRyb2xcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBhdXNlXCIsXG4gICAgXCJwYXZlXCIsXG4gICAgXCJwYXltZW50XCIsXG4gICAgXCJwZWFjZVwiLFxuICAgIFwicGVhbnV0XCIsXG4gICAgXCJwZWFyXCIsXG4gICAgXCJwZWFzYW50XCIsXG4gICAgXCJwZWxpY2FuXCIsXG4gICAgXCJwZW5cIixcbiAgICBcInBlbmFsdHlcIixcbiAgICBcInBlbmNpbFwiLFxuICAgIFwicGVvcGxlXCIsXG4gICAgXCJwZXBwZXJcIixcbiAgICBcInBlcmZlY3RcIixcbiAgICBcInBlcm1pdFwiLFxuICAgIFwicGVyc29uXCIsXG4gICAgXCJwZXRcIixcbiAgICBcInBob25lXCIsXG4gICAgXCJwaG90b1wiLFxuICAgIFwicGhyYXNlXCIsXG4gICAgXCJwaHlzaWNhbFwiLFxuICAgIFwicGlhbm9cIixcbiAgICBcInBpY25pY1wiLFxuICAgIFwicGljdHVyZVwiLFxuICAgIFwicGllY2VcIixcbiAgICBcInBpZ1wiLFxuICAgIFwicGlnZW9uXCIsXG4gICAgXCJwaWxsXCIsXG4gICAgXCJwaWxvdFwiLFxuICAgIFwicGlua1wiLFxuICAgIFwicGlvbmVlclwiLFxuICAgIFwicGlwZVwiLFxuICAgIFwicGlzdG9sXCIsXG4gICAgXCJwaXRjaFwiLFxuICAgIFwicGl6emFcIixcbiAgICBcInBsYWNlXCIsXG4gICAgXCJwbGFuZXRcIixcbiAgICBcInBsYXN0aWNcIixcbiAgICBcInBsYXRlXCIsXG4gICAgXCJwbGF5XCIsXG4gICAgXCJwbGVhc2VcIixcbiAgICBcInBsZWRnZVwiLFxuICAgIFwicGx1Y2tcIixcbiAgICBcInBsdWdcIixcbiAgICBcInBsdW5nZVwiLFxuICAgIFwicG9lbVwiLFxuICAgIFwicG9ldFwiLFxuICAgIFwicG9pbnRcIixcbiAgICBcInBvbGFyXCIsXG4gICAgXCJwb2xlXCIsXG4gICAgXCJwb2xpY2VcIixcbiAgICBcInBvbmRcIixcbiAgICBcInBvbnlcIixcbiAgICBcInBvb2xcIixcbiAgICBcInBvcHVsYXJcIixcbiAgICBcInBvcnRpb25cIixcbiAgICBcInBvc2l0aW9uXCIsXG4gICAgXCJwb3NzaWJsZVwiLFxuICAgIFwicG9zdFwiLFxuICAgIFwicG90YXRvXCIsXG4gICAgXCJwb3R0ZXJ5XCIsXG4gICAgXCJwb3ZlcnR5XCIsXG4gICAgXCJwb3dkZXJcIixcbiAgICBcInBvd2VyXCIsXG4gICAgXCJwcmFjdGljZVwiLFxuICAgIFwicHJhaXNlXCIsXG4gICAgXCJwcmVkaWN0XCIsXG4gICAgXCJwcmVmZXJcIixcbiAgICBcInByZXBhcmVcIixcbiAgICBcInByZXNlbnRcIixcbiAgICBcInByZXR0eVwiLFxuICAgIFwicHJldmVudFwiLFxuICAgIFwicHJpY2VcIixcbiAgICBcInByaWRlXCIsXG4gICAgXCJwcmltYXJ5XCIsXG4gICAgXCJwcmludFwiLFxuICAgIFwicHJpb3JpdHlcIixcbiAgICBcInByaXNvblwiLFxuICAgIFwicHJpdmF0ZVwiLFxuICAgIFwicHJpemVcIixcbiAgICBcInByb2JsZW1cIixcbiAgICBcInByb2Nlc3NcIixcbiAgICBcInByb2R1Y2VcIixcbiAgICBcInByb2ZpdFwiLFxuICAgIFwicHJvZ3JhbVwiLFxuICAgIFwicHJvamVjdFwiLFxuICAgIFwicHJvbW90ZVwiLFxuICAgIFwicHJvb2ZcIixcbiAgICBcInByb3BlcnR5XCIsXG4gICAgXCJwcm9zcGVyXCIsXG4gICAgXCJwcm90ZWN0XCIsXG4gICAgXCJwcm91ZFwiLFxuICAgIFwicHJvdmlkZVwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJwdWRkaW5nXCIsXG4gICAgXCJwdWxsXCIsXG4gICAgXCJwdWxwXCIsXG4gICAgXCJwdWxzZVwiLFxuICAgIFwicHVtcGtpblwiLFxuICAgIFwicHVuY2hcIixcbiAgICBcInB1cGlsXCIsXG4gICAgXCJwdXBweVwiLFxuICAgIFwicHVyY2hhc2VcIixcbiAgICBcInB1cml0eVwiLFxuICAgIFwicHVycG9zZVwiLFxuICAgIFwicHVyc2VcIixcbiAgICBcInB1c2hcIixcbiAgICBcInB1dFwiLFxuICAgIFwicHV6emxlXCIsXG4gICAgXCJweXJhbWlkXCIsXG4gICAgXCJxdWFsaXR5XCIsXG4gICAgXCJxdWFudHVtXCIsXG4gICAgXCJxdWFydGVyXCIsXG4gICAgXCJxdWVzdGlvblwiLFxuICAgIFwicXVpY2tcIixcbiAgICBcInF1aXRcIixcbiAgICBcInF1aXpcIixcbiAgICBcInF1b3RlXCIsXG4gICAgXCJyYWJiaXRcIixcbiAgICBcInJhY2Nvb25cIixcbiAgICBcInJhY2VcIixcbiAgICBcInJhY2tcIixcbiAgICBcInJhZGFyXCIsXG4gICAgXCJyYWRpb1wiLFxuICAgIFwicmFpbFwiLFxuICAgIFwicmFpblwiLFxuICAgIFwicmFpc2VcIixcbiAgICBcInJhbGx5XCIsXG4gICAgXCJyYW1wXCIsXG4gICAgXCJyYW5jaFwiLFxuICAgIFwicmFuZG9tXCIsXG4gICAgXCJyYW5nZVwiLFxuICAgIFwicmFwaWRcIixcbiAgICBcInJhcmVcIixcbiAgICBcInJhdGVcIixcbiAgICBcInJhdGhlclwiLFxuICAgIFwicmF2ZW5cIixcbiAgICBcInJhd1wiLFxuICAgIFwicmF6b3JcIixcbiAgICBcInJlYWR5XCIsXG4gICAgXCJyZWFsXCIsXG4gICAgXCJyZWFzb25cIixcbiAgICBcInJlYmVsXCIsXG4gICAgXCJyZWJ1aWxkXCIsXG4gICAgXCJyZWNhbGxcIixcbiAgICBcInJlY2VpdmVcIixcbiAgICBcInJlY2lwZVwiLFxuICAgIFwicmVjb3JkXCIsXG4gICAgXCJyZWN5Y2xlXCIsXG4gICAgXCJyZWR1Y2VcIixcbiAgICBcInJlZmxlY3RcIixcbiAgICBcInJlZm9ybVwiLFxuICAgIFwicmVmdXNlXCIsXG4gICAgXCJyZWdpb25cIixcbiAgICBcInJlZ3JldFwiLFxuICAgIFwicmVndWxhclwiLFxuICAgIFwicmVqZWN0XCIsXG4gICAgXCJyZWxheFwiLFxuICAgIFwicmVsZWFzZVwiLFxuICAgIFwicmVsaWVmXCIsXG4gICAgXCJyZWx5XCIsXG4gICAgXCJyZW1haW5cIixcbiAgICBcInJlbWVtYmVyXCIsXG4gICAgXCJyZW1pbmRcIixcbiAgICBcInJlbW92ZVwiLFxuICAgIFwicmVuZGVyXCIsXG4gICAgXCJyZW5ld1wiLFxuICAgIFwicmVudFwiLFxuICAgIFwicmVvcGVuXCIsXG4gICAgXCJyZXBhaXJcIixcbiAgICBcInJlcGVhdFwiLFxuICAgIFwicmVwbGFjZVwiLFxuICAgIFwicmVwb3J0XCIsXG4gICAgXCJyZXF1aXJlXCIsXG4gICAgXCJyZXNjdWVcIixcbiAgICBcInJlc2VtYmxlXCIsXG4gICAgXCJyZXNpc3RcIixcbiAgICBcInJlc291cmNlXCIsXG4gICAgXCJyZXNwb25zZVwiLFxuICAgIFwicmVzdWx0XCIsXG4gICAgXCJyZXRpcmVcIixcbiAgICBcInJldHJlYXRcIixcbiAgICBcInJldHVyblwiLFxuICAgIFwicmV1bmlvblwiLFxuICAgIFwicmV2ZWFsXCIsXG4gICAgXCJyZXZpZXdcIixcbiAgICBcInJld2FyZFwiLFxuICAgIFwicmh5dGhtXCIsXG4gICAgXCJyaWJcIixcbiAgICBcInJpYmJvblwiLFxuICAgIFwicmljZVwiLFxuICAgIFwicmljaFwiLFxuICAgIFwicmlkZVwiLFxuICAgIFwicmlkZ2VcIixcbiAgICBcInJpZmxlXCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwicmlnaWRcIixcbiAgICBcInJpbmdcIixcbiAgICBcInJpb3RcIixcbiAgICBcInJpcHBsZVwiLFxuICAgIFwicmlza1wiLFxuICAgIFwicml0dWFsXCIsXG4gICAgXCJyaXZhbFwiLFxuICAgIFwicml2ZXJcIixcbiAgICBcInJvYWRcIixcbiAgICBcInJvYXN0XCIsXG4gICAgXCJyb2JvdFwiLFxuICAgIFwicm9idXN0XCIsXG4gICAgXCJyb2NrZXRcIixcbiAgICBcInJvbWFuY2VcIixcbiAgICBcInJvb2ZcIixcbiAgICBcInJvb2tpZVwiLFxuICAgIFwicm9vbVwiLFxuICAgIFwicm9zZVwiLFxuICAgIFwicm90YXRlXCIsXG4gICAgXCJyb3VnaFwiLFxuICAgIFwicm91bmRcIixcbiAgICBcInJvdXRlXCIsXG4gICAgXCJyb3lhbFwiLFxuICAgIFwicnViYmVyXCIsXG4gICAgXCJydWRlXCIsXG4gICAgXCJydWdcIixcbiAgICBcInJ1bGVcIixcbiAgICBcInJ1blwiLFxuICAgIFwicnVud2F5XCIsXG4gICAgXCJydXJhbFwiLFxuICAgIFwic2FkXCIsXG4gICAgXCJzYWRkbGVcIixcbiAgICBcInNhZG5lc3NcIixcbiAgICBcInNhZmVcIixcbiAgICBcInNhaWxcIixcbiAgICBcInNhbGFkXCIsXG4gICAgXCJzYWxtb25cIixcbiAgICBcInNhbG9uXCIsXG4gICAgXCJzYWx0XCIsXG4gICAgXCJzYWx1dGVcIixcbiAgICBcInNhbWVcIixcbiAgICBcInNhbXBsZVwiLFxuICAgIFwic2FuZFwiLFxuICAgIFwic2F0aXNmeVwiLFxuICAgIFwic2F0b3NoaVwiLFxuICAgIFwic2F1Y2VcIixcbiAgICBcInNhdXNhZ2VcIixcbiAgICBcInNhdmVcIixcbiAgICBcInNheVwiLFxuICAgIFwic2NhbGVcIixcbiAgICBcInNjYW5cIixcbiAgICBcInNjYXJlXCIsXG4gICAgXCJzY2F0dGVyXCIsXG4gICAgXCJzY2VuZVwiLFxuICAgIFwic2NoZW1lXCIsXG4gICAgXCJzY2hvb2xcIixcbiAgICBcInNjaWVuY2VcIixcbiAgICBcInNjaXNzb3JzXCIsXG4gICAgXCJzY29ycGlvblwiLFxuICAgIFwic2NvdXRcIixcbiAgICBcInNjcmFwXCIsXG4gICAgXCJzY3JlZW5cIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwic2NydWJcIixcbiAgICBcInNlYVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzZWFzb25cIixcbiAgICBcInNlYXRcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwic2VjcmV0XCIsXG4gICAgXCJzZWN0aW9uXCIsXG4gICAgXCJzZWN1cml0eVwiLFxuICAgIFwic2VlZFwiLFxuICAgIFwic2Vla1wiLFxuICAgIFwic2VnbWVudFwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzZWxsXCIsXG4gICAgXCJzZW1pbmFyXCIsXG4gICAgXCJzZW5pb3JcIixcbiAgICBcInNlbnNlXCIsXG4gICAgXCJzZW50ZW5jZVwiLFxuICAgIFwic2VyaWVzXCIsXG4gICAgXCJzZXJ2aWNlXCIsXG4gICAgXCJzZXNzaW9uXCIsXG4gICAgXCJzZXR0bGVcIixcbiAgICBcInNldHVwXCIsXG4gICAgXCJzZXZlblwiLFxuICAgIFwic2hhZG93XCIsXG4gICAgXCJzaGFmdFwiLFxuICAgIFwic2hhbGxvd1wiLFxuICAgIFwic2hhcmVcIixcbiAgICBcInNoZWRcIixcbiAgICBcInNoZWxsXCIsXG4gICAgXCJzaGVyaWZmXCIsXG4gICAgXCJzaGllbGRcIixcbiAgICBcInNoaWZ0XCIsXG4gICAgXCJzaGluZVwiLFxuICAgIFwic2hpcFwiLFxuICAgIFwic2hpdmVyXCIsXG4gICAgXCJzaG9ja1wiLFxuICAgIFwic2hvZVwiLFxuICAgIFwic2hvb3RcIixcbiAgICBcInNob3BcIixcbiAgICBcInNob3J0XCIsXG4gICAgXCJzaG91bGRlclwiLFxuICAgIFwic2hvdmVcIixcbiAgICBcInNocmltcFwiLFxuICAgIFwic2hydWdcIixcbiAgICBcInNodWZmbGVcIixcbiAgICBcInNoeVwiLFxuICAgIFwic2libGluZ1wiLFxuICAgIFwic2lja1wiLFxuICAgIFwic2lkZVwiLFxuICAgIFwic2llZ2VcIixcbiAgICBcInNpZ2h0XCIsXG4gICAgXCJzaWduXCIsXG4gICAgXCJzaWxlbnRcIixcbiAgICBcInNpbGtcIixcbiAgICBcInNpbGx5XCIsXG4gICAgXCJzaWx2ZXJcIixcbiAgICBcInNpbWlsYXJcIixcbiAgICBcInNpbXBsZVwiLFxuICAgIFwic2luY2VcIixcbiAgICBcInNpbmdcIixcbiAgICBcInNpcmVuXCIsXG4gICAgXCJzaXN0ZXJcIixcbiAgICBcInNpdHVhdGVcIixcbiAgICBcInNpeFwiLFxuICAgIFwic2l6ZVwiLFxuICAgIFwic2thdGVcIixcbiAgICBcInNrZXRjaFwiLFxuICAgIFwic2tpXCIsXG4gICAgXCJza2lsbFwiLFxuICAgIFwic2tpblwiLFxuICAgIFwic2tpcnRcIixcbiAgICBcInNrdWxsXCIsXG4gICAgXCJzbGFiXCIsXG4gICAgXCJzbGFtXCIsXG4gICAgXCJzbGVlcFwiLFxuICAgIFwic2xlbmRlclwiLFxuICAgIFwic2xpY2VcIixcbiAgICBcInNsaWRlXCIsXG4gICAgXCJzbGlnaHRcIixcbiAgICBcInNsaW1cIixcbiAgICBcInNsb2dhblwiLFxuICAgIFwic2xvdFwiLFxuICAgIFwic2xvd1wiLFxuICAgIFwic2x1c2hcIixcbiAgICBcInNtYWxsXCIsXG4gICAgXCJzbWFydFwiLFxuICAgIFwic21pbGVcIixcbiAgICBcInNtb2tlXCIsXG4gICAgXCJzbW9vdGhcIixcbiAgICBcInNuYWNrXCIsXG4gICAgXCJzbmFrZVwiLFxuICAgIFwic25hcFwiLFxuICAgIFwic25pZmZcIixcbiAgICBcInNub3dcIixcbiAgICBcInNvYXBcIixcbiAgICBcInNvY2NlclwiLFxuICAgIFwic29jaWFsXCIsXG4gICAgXCJzb2NrXCIsXG4gICAgXCJzb2RhXCIsXG4gICAgXCJzb2Z0XCIsXG4gICAgXCJzb2xhclwiLFxuICAgIFwic29sZGllclwiLFxuICAgIFwic29saWRcIixcbiAgICBcInNvbHV0aW9uXCIsXG4gICAgXCJzb2x2ZVwiLFxuICAgIFwic29tZW9uZVwiLFxuICAgIFwic29uZ1wiLFxuICAgIFwic29vblwiLFxuICAgIFwic29ycnlcIixcbiAgICBcInNvcnRcIixcbiAgICBcInNvdWxcIixcbiAgICBcInNvdW5kXCIsXG4gICAgXCJzb3VwXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInNvdXRoXCIsXG4gICAgXCJzcGFjZVwiLFxuICAgIFwic3BhcmVcIixcbiAgICBcInNwYXRpYWxcIixcbiAgICBcInNwYXduXCIsXG4gICAgXCJzcGVha1wiLFxuICAgIFwic3BlY2lhbFwiLFxuICAgIFwic3BlZWRcIixcbiAgICBcInNwZWxsXCIsXG4gICAgXCJzcGVuZFwiLFxuICAgIFwic3BoZXJlXCIsXG4gICAgXCJzcGljZVwiLFxuICAgIFwic3BpZGVyXCIsXG4gICAgXCJzcGlrZVwiLFxuICAgIFwic3BpblwiLFxuICAgIFwic3Bpcml0XCIsXG4gICAgXCJzcGxpdFwiLFxuICAgIFwic3BvaWxcIixcbiAgICBcInNwb25zb3JcIixcbiAgICBcInNwb29uXCIsXG4gICAgXCJzcG9ydFwiLFxuICAgIFwic3BvdFwiLFxuICAgIFwic3ByYXlcIixcbiAgICBcInNwcmVhZFwiLFxuICAgIFwic3ByaW5nXCIsXG4gICAgXCJzcHlcIixcbiAgICBcInNxdWFyZVwiLFxuICAgIFwic3F1ZWV6ZVwiLFxuICAgIFwic3F1aXJyZWxcIixcbiAgICBcInN0YWJsZVwiLFxuICAgIFwic3RhZGl1bVwiLFxuICAgIFwic3RhZmZcIixcbiAgICBcInN0YWdlXCIsXG4gICAgXCJzdGFpcnNcIixcbiAgICBcInN0YW1wXCIsXG4gICAgXCJzdGFuZFwiLFxuICAgIFwic3RhcnRcIixcbiAgICBcInN0YXRlXCIsXG4gICAgXCJzdGF5XCIsXG4gICAgXCJzdGVha1wiLFxuICAgIFwic3RlZWxcIixcbiAgICBcInN0ZW1cIixcbiAgICBcInN0ZXBcIixcbiAgICBcInN0ZXJlb1wiLFxuICAgIFwic3RpY2tcIixcbiAgICBcInN0aWxsXCIsXG4gICAgXCJzdGluZ1wiLFxuICAgIFwic3RvY2tcIixcbiAgICBcInN0b21hY2hcIixcbiAgICBcInN0b25lXCIsXG4gICAgXCJzdG9vbFwiLFxuICAgIFwic3RvcnlcIixcbiAgICBcInN0b3ZlXCIsXG4gICAgXCJzdHJhdGVneVwiLFxuICAgIFwic3RyZWV0XCIsXG4gICAgXCJzdHJpa2VcIixcbiAgICBcInN0cm9uZ1wiLFxuICAgIFwic3RydWdnbGVcIixcbiAgICBcInN0dWRlbnRcIixcbiAgICBcInN0dWZmXCIsXG4gICAgXCJzdHVtYmxlXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwic3ViamVjdFwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJzdWJ3YXlcIixcbiAgICBcInN1Y2Nlc3NcIixcbiAgICBcInN1Y2hcIixcbiAgICBcInN1ZGRlblwiLFxuICAgIFwic3VmZmVyXCIsXG4gICAgXCJzdWdhclwiLFxuICAgIFwic3VnZ2VzdFwiLFxuICAgIFwic3VpdFwiLFxuICAgIFwic3VtbWVyXCIsXG4gICAgXCJzdW5cIixcbiAgICBcInN1bm55XCIsXG4gICAgXCJzdW5zZXRcIixcbiAgICBcInN1cGVyXCIsXG4gICAgXCJzdXBwbHlcIixcbiAgICBcInN1cHJlbWVcIixcbiAgICBcInN1cmVcIixcbiAgICBcInN1cmZhY2VcIixcbiAgICBcInN1cmdlXCIsXG4gICAgXCJzdXJwcmlzZVwiLFxuICAgIFwic3Vycm91bmRcIixcbiAgICBcInN1cnZleVwiLFxuICAgIFwic3VzcGVjdFwiLFxuICAgIFwic3VzdGFpblwiLFxuICAgIFwic3dhbGxvd1wiLFxuICAgIFwic3dhbXBcIixcbiAgICBcInN3YXBcIixcbiAgICBcInN3YXJtXCIsXG4gICAgXCJzd2VhclwiLFxuICAgIFwic3dlZXRcIixcbiAgICBcInN3aWZ0XCIsXG4gICAgXCJzd2ltXCIsXG4gICAgXCJzd2luZ1wiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzd29yZFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJzeW1wdG9tXCIsXG4gICAgXCJzeXJ1cFwiLFxuICAgIFwic3lzdGVtXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGFja2xlXCIsXG4gICAgXCJ0YWdcIixcbiAgICBcInRhaWxcIixcbiAgICBcInRhbGVudFwiLFxuICAgIFwidGFsa1wiLFxuICAgIFwidGFua1wiLFxuICAgIFwidGFwZVwiLFxuICAgIFwidGFyZ2V0XCIsXG4gICAgXCJ0YXNrXCIsXG4gICAgXCJ0YXN0ZVwiLFxuICAgIFwidGF0dG9vXCIsXG4gICAgXCJ0YXhpXCIsXG4gICAgXCJ0ZWFjaFwiLFxuICAgIFwidGVhbVwiLFxuICAgIFwidGVsbFwiLFxuICAgIFwidGVuXCIsXG4gICAgXCJ0ZW5hbnRcIixcbiAgICBcInRlbm5pc1wiLFxuICAgIFwidGVudFwiLFxuICAgIFwidGVybVwiLFxuICAgIFwidGVzdFwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwidGhhbmtcIixcbiAgICBcInRoYXRcIixcbiAgICBcInRoZW1lXCIsXG4gICAgXCJ0aGVuXCIsXG4gICAgXCJ0aGVvcnlcIixcbiAgICBcInRoZXJlXCIsXG4gICAgXCJ0aGV5XCIsXG4gICAgXCJ0aGluZ1wiLFxuICAgIFwidGhpc1wiLFxuICAgIFwidGhvdWdodFwiLFxuICAgIFwidGhyZWVcIixcbiAgICBcInRocml2ZVwiLFxuICAgIFwidGhyb3dcIixcbiAgICBcInRodW1iXCIsXG4gICAgXCJ0aHVuZGVyXCIsXG4gICAgXCJ0aWNrZXRcIixcbiAgICBcInRpZGVcIixcbiAgICBcInRpZ2VyXCIsXG4gICAgXCJ0aWx0XCIsXG4gICAgXCJ0aW1iZXJcIixcbiAgICBcInRpbWVcIixcbiAgICBcInRpbnlcIixcbiAgICBcInRpcFwiLFxuICAgIFwidGlyZWRcIixcbiAgICBcInRpc3N1ZVwiLFxuICAgIFwidGl0bGVcIixcbiAgICBcInRvYXN0XCIsXG4gICAgXCJ0b2JhY2NvXCIsXG4gICAgXCJ0b2RheVwiLFxuICAgIFwidG9kZGxlclwiLFxuICAgIFwidG9lXCIsXG4gICAgXCJ0b2dldGhlclwiLFxuICAgIFwidG9pbGV0XCIsXG4gICAgXCJ0b2tlblwiLFxuICAgIFwidG9tYXRvXCIsXG4gICAgXCJ0b21vcnJvd1wiLFxuICAgIFwidG9uZVwiLFxuICAgIFwidG9uZ3VlXCIsXG4gICAgXCJ0b25pZ2h0XCIsXG4gICAgXCJ0b29sXCIsXG4gICAgXCJ0b290aFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJ0b3BpY1wiLFxuICAgIFwidG9wcGxlXCIsXG4gICAgXCJ0b3JjaFwiLFxuICAgIFwidG9ybmFkb1wiLFxuICAgIFwidG9ydG9pc2VcIixcbiAgICBcInRvc3NcIixcbiAgICBcInRvdGFsXCIsXG4gICAgXCJ0b3VyaXN0XCIsXG4gICAgXCJ0b3dhcmRcIixcbiAgICBcInRvd2VyXCIsXG4gICAgXCJ0b3duXCIsXG4gICAgXCJ0b3lcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ0cmFkZVwiLFxuICAgIFwidHJhZmZpY1wiLFxuICAgIFwidHJhZ2ljXCIsXG4gICAgXCJ0cmFpblwiLFxuICAgIFwidHJhbnNmZXJcIixcbiAgICBcInRyYXBcIixcbiAgICBcInRyYXNoXCIsXG4gICAgXCJ0cmF2ZWxcIixcbiAgICBcInRyYXlcIixcbiAgICBcInRyZWF0XCIsXG4gICAgXCJ0cmVlXCIsXG4gICAgXCJ0cmVuZFwiLFxuICAgIFwidHJpYWxcIixcbiAgICBcInRyaWJlXCIsXG4gICAgXCJ0cmlja1wiLFxuICAgIFwidHJpZ2dlclwiLFxuICAgIFwidHJpbVwiLFxuICAgIFwidHJpcFwiLFxuICAgIFwidHJvcGh5XCIsXG4gICAgXCJ0cm91YmxlXCIsXG4gICAgXCJ0cnVja1wiLFxuICAgIFwidHJ1ZVwiLFxuICAgIFwidHJ1bHlcIixcbiAgICBcInRydW1wZXRcIixcbiAgICBcInRydXN0XCIsXG4gICAgXCJ0cnV0aFwiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0dWJlXCIsXG4gICAgXCJ0dWl0aW9uXCIsXG4gICAgXCJ0dW1ibGVcIixcbiAgICBcInR1bmFcIixcbiAgICBcInR1bm5lbFwiLFxuICAgIFwidHVya2V5XCIsXG4gICAgXCJ0dXJuXCIsXG4gICAgXCJ0dXJ0bGVcIixcbiAgICBcInR3ZWx2ZVwiLFxuICAgIFwidHdlbnR5XCIsXG4gICAgXCJ0d2ljZVwiLFxuICAgIFwidHdpblwiLFxuICAgIFwidHdpc3RcIixcbiAgICBcInR3b1wiLFxuICAgIFwidHlwZVwiLFxuICAgIFwidHlwaWNhbFwiLFxuICAgIFwidWdseVwiLFxuICAgIFwidW1icmVsbGFcIixcbiAgICBcInVuYWJsZVwiLFxuICAgIFwidW5hd2FyZVwiLFxuICAgIFwidW5jbGVcIixcbiAgICBcInVuY292ZXJcIixcbiAgICBcInVuZGVyXCIsXG4gICAgXCJ1bmRvXCIsXG4gICAgXCJ1bmZhaXJcIixcbiAgICBcInVuZm9sZFwiLFxuICAgIFwidW5oYXBweVwiLFxuICAgIFwidW5pZm9ybVwiLFxuICAgIFwidW5pcXVlXCIsXG4gICAgXCJ1bml0XCIsXG4gICAgXCJ1bml2ZXJzZVwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwidW5sb2NrXCIsXG4gICAgXCJ1bnRpbFwiLFxuICAgIFwidW51c3VhbFwiLFxuICAgIFwidW52ZWlsXCIsXG4gICAgXCJ1cGRhdGVcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVwaG9sZFwiLFxuICAgIFwidXBvblwiLFxuICAgIFwidXBwZXJcIixcbiAgICBcInVwc2V0XCIsXG4gICAgXCJ1cmJhblwiLFxuICAgIFwidXJnZVwiLFxuICAgIFwidXNhZ2VcIixcbiAgICBcInVzZVwiLFxuICAgIFwidXNlZFwiLFxuICAgIFwidXNlZnVsXCIsXG4gICAgXCJ1c2VsZXNzXCIsXG4gICAgXCJ1c3VhbFwiLFxuICAgIFwidXRpbGl0eVwiLFxuICAgIFwidmFjYW50XCIsXG4gICAgXCJ2YWN1dW1cIixcbiAgICBcInZhZ3VlXCIsXG4gICAgXCJ2YWxpZFwiLFxuICAgIFwidmFsbGV5XCIsXG4gICAgXCJ2YWx2ZVwiLFxuICAgIFwidmFuXCIsXG4gICAgXCJ2YW5pc2hcIixcbiAgICBcInZhcG9yXCIsXG4gICAgXCJ2YXJpb3VzXCIsXG4gICAgXCJ2YXN0XCIsXG4gICAgXCJ2YXVsdFwiLFxuICAgIFwidmVoaWNsZVwiLFxuICAgIFwidmVsdmV0XCIsXG4gICAgXCJ2ZW5kb3JcIixcbiAgICBcInZlbnR1cmVcIixcbiAgICBcInZlbnVlXCIsXG4gICAgXCJ2ZXJiXCIsXG4gICAgXCJ2ZXJpZnlcIixcbiAgICBcInZlcnNpb25cIixcbiAgICBcInZlcnlcIixcbiAgICBcInZlc3NlbFwiLFxuICAgIFwidmV0ZXJhblwiLFxuICAgIFwidmlhYmxlXCIsXG4gICAgXCJ2aWJyYW50XCIsXG4gICAgXCJ2aWNpb3VzXCIsXG4gICAgXCJ2aWN0b3J5XCIsXG4gICAgXCJ2aWRlb1wiLFxuICAgIFwidmlld1wiLFxuICAgIFwidmlsbGFnZVwiLFxuICAgIFwidmludGFnZVwiLFxuICAgIFwidmlvbGluXCIsXG4gICAgXCJ2aXJ0dWFsXCIsXG4gICAgXCJ2aXJ1c1wiLFxuICAgIFwidmlzYVwiLFxuICAgIFwidmlzaXRcIixcbiAgICBcInZpc3VhbFwiLFxuICAgIFwidml0YWxcIixcbiAgICBcInZpdmlkXCIsXG4gICAgXCJ2b2NhbFwiLFxuICAgIFwidm9pY2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcInZvbGNhbm9cIixcbiAgICBcInZvbHVtZVwiLFxuICAgIFwidm90ZVwiLFxuICAgIFwidm95YWdlXCIsXG4gICAgXCJ3YWdlXCIsXG4gICAgXCJ3YWdvblwiLFxuICAgIFwid2FpdFwiLFxuICAgIFwid2Fsa1wiLFxuICAgIFwid2FsbFwiLFxuICAgIFwid2FsbnV0XCIsXG4gICAgXCJ3YW50XCIsXG4gICAgXCJ3YXJmYXJlXCIsXG4gICAgXCJ3YXJtXCIsXG4gICAgXCJ3YXJyaW9yXCIsXG4gICAgXCJ3YXNoXCIsXG4gICAgXCJ3YXNwXCIsXG4gICAgXCJ3YXN0ZVwiLFxuICAgIFwid2F0ZXJcIixcbiAgICBcIndhdmVcIixcbiAgICBcIndheVwiLFxuICAgIFwid2VhbHRoXCIsXG4gICAgXCJ3ZWFwb25cIixcbiAgICBcIndlYXJcIixcbiAgICBcIndlYXNlbFwiLFxuICAgIFwid2VhdGhlclwiLFxuICAgIFwid2ViXCIsXG4gICAgXCJ3ZWRkaW5nXCIsXG4gICAgXCJ3ZWVrZW5kXCIsXG4gICAgXCJ3ZWlyZFwiLFxuICAgIFwid2VsY29tZVwiLFxuICAgIFwid2VzdFwiLFxuICAgIFwid2V0XCIsXG4gICAgXCJ3aGFsZVwiLFxuICAgIFwid2hhdFwiLFxuICAgIFwid2hlYXRcIixcbiAgICBcIndoZWVsXCIsXG4gICAgXCJ3aGVuXCIsXG4gICAgXCJ3aGVyZVwiLFxuICAgIFwid2hpcFwiLFxuICAgIFwid2hpc3BlclwiLFxuICAgIFwid2lkZVwiLFxuICAgIFwid2lkdGhcIixcbiAgICBcIndpZmVcIixcbiAgICBcIndpbGRcIixcbiAgICBcIndpbGxcIixcbiAgICBcIndpblwiLFxuICAgIFwid2luZG93XCIsXG4gICAgXCJ3aW5lXCIsXG4gICAgXCJ3aW5nXCIsXG4gICAgXCJ3aW5rXCIsXG4gICAgXCJ3aW5uZXJcIixcbiAgICBcIndpbnRlclwiLFxuICAgIFwid2lyZVwiLFxuICAgIFwid2lzZG9tXCIsXG4gICAgXCJ3aXNlXCIsXG4gICAgXCJ3aXNoXCIsXG4gICAgXCJ3aXRuZXNzXCIsXG4gICAgXCJ3b2xmXCIsXG4gICAgXCJ3b21hblwiLFxuICAgIFwid29uZGVyXCIsXG4gICAgXCJ3b29kXCIsXG4gICAgXCJ3b29sXCIsXG4gICAgXCJ3b3JkXCIsXG4gICAgXCJ3b3JrXCIsXG4gICAgXCJ3b3JsZFwiLFxuICAgIFwid29ycnlcIixcbiAgICBcIndvcnRoXCIsXG4gICAgXCJ3cmFwXCIsXG4gICAgXCJ3cmVja1wiLFxuICAgIFwid3Jlc3RsZVwiLFxuICAgIFwid3Jpc3RcIixcbiAgICBcIndyaXRlXCIsXG4gICAgXCJ3cm9uZ1wiLFxuICAgIFwieWFyZFwiLFxuICAgIFwieWVhclwiLFxuICAgIFwieWVsbG93XCIsXG4gICAgXCJ5b3VcIixcbiAgICBcInlvdW5nXCIsXG4gICAgXCJ5b3V0aFwiLFxuICAgIFwiemVicmFcIixcbiAgICBcInplcm9cIixcbiAgICBcInpvbmVcIixcbiAgICBcInpvb1wiXG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gICAgXCJhYmFpc3NlclwiLFxuICAgIFwiYWJhbmRvblwiLFxuICAgIFwiYWJkaXF1ZXJcIixcbiAgICBcImFiZWlsbGVcIixcbiAgICBcImFib2xpclwiLFxuICAgIFwiYWJvcmRlclwiLFxuICAgIFwiYWJvdXRpclwiLFxuICAgIFwiYWJveWVyXCIsXG4gICAgXCJhYnJhc2lmXCIsXG4gICAgXCJhYnJldXZlclwiLFxuICAgIFwiYWJyaXRlclwiLFxuICAgIFwiYWJyb2dlclwiLFxuICAgIFwiYWJydXB0XCIsXG4gICAgXCJhYnNlbmNlXCIsXG4gICAgXCJhYnNvbHVcIixcbiAgICBcImFic3VyZGVcIixcbiAgICBcImFidXNpZlwiLFxuICAgIFwiYWJ5c3NhbFwiLFxuICAgIFwiYWNhZGXMgW1pZVwiLFxuICAgIFwiYWNham91XCIsXG4gICAgXCJhY2FyaWVuXCIsXG4gICAgXCJhY2NhYmxlclwiLFxuICAgIFwiYWNjZXB0ZXJcIixcbiAgICBcImFjY2xhbWVyXCIsXG4gICAgXCJhY2NvbGFkZVwiLFxuICAgIFwiYWNjcm9jaGVcIixcbiAgICBcImFjY3VzZXJcIixcbiAgICBcImFjZXJiZVwiLFxuICAgIFwiYWNoYXRcIixcbiAgICBcImFjaGV0ZXJcIixcbiAgICBcImFjaWR1bGVyXCIsXG4gICAgXCJhY2llclwiLFxuICAgIFwiYWNvbXB0ZVwiLFxuICAgIFwiYWNxdWXMgXJpclwiLFxuICAgIFwiYWNyb255bWVcIixcbiAgICBcImFjdGV1clwiLFxuICAgIFwiYWN0aWZcIixcbiAgICBcImFjdHVlbFwiLFxuICAgIFwiYWRlcHRlXCIsXG4gICAgXCJhZGXMgXF1YXRcIixcbiAgICBcImFkaGXMgXNpZlwiLFxuICAgIFwiYWRqZWN0aWZcIixcbiAgICBcImFkanVnZXJcIixcbiAgICBcImFkbWV0dHJlXCIsXG4gICAgXCJhZG1pcmVyXCIsXG4gICAgXCJhZG9wdGVyXCIsXG4gICAgXCJhZG9yZXJcIixcbiAgICBcImFkb3VjaXJcIixcbiAgICBcImFkcmVzc2VcIixcbiAgICBcImFkcm9pdFwiLFxuICAgIFwiYWR1bHRlXCIsXG4gICAgXCJhZHZlcmJlXCIsXG4gICAgXCJhZcyBcmVyXCIsXG4gICAgXCJhZcyBcm9uZWZcIixcbiAgICBcImFmZmFpcmVcIixcbiAgICBcImFmZmVjdGVyXCIsXG4gICAgXCJhZmZpY2hlXCIsXG4gICAgXCJhZmZyZXV4XCIsXG4gICAgXCJhZmZ1YmxlclwiLFxuICAgIFwiYWdhY2VyXCIsXG4gICAgXCJhZ2VuY2VyXCIsXG4gICAgXCJhZ2lsZVwiLFxuICAgIFwiYWdpdGVyXCIsXG4gICAgXCJhZ3JhZmVyXCIsXG4gICAgXCJhZ3JlzIFhYmxlXCIsXG4gICAgXCJhZ3J1bWVcIixcbiAgICBcImFpZGVyXCIsXG4gICAgXCJhaWd1aWxsZVwiLFxuICAgIFwiYWlsaWVyXCIsXG4gICAgXCJhaW1hYmxlXCIsXG4gICAgXCJhaXNhbmNlXCIsXG4gICAgXCJham91dGVyXCIsXG4gICAgXCJhanVzdGVyXCIsXG4gICAgXCJhbGFybWVyXCIsXG4gICAgXCJhbGNoaW1pZVwiLFxuICAgIFwiYWxlcnRlXCIsXG4gICAgXCJhbGdlzIBicmVcIixcbiAgICBcImFsZ3VlXCIsXG4gICAgXCJhbGllzIFuZXJcIixcbiAgICBcImFsaW1lbnRcIixcbiAgICBcImFsbGXMgWdlclwiLFxuICAgIFwiYWxsaWFnZVwiLFxuICAgIFwiYWxsb3VlclwiLFxuICAgIFwiYWxsdW1lclwiLFxuICAgIFwiYWxvdXJkaXJcIixcbiAgICBcImFscGFnYVwiLFxuICAgIFwiYWx0ZXNzZVwiLFxuICAgIFwiYWx2ZcyBb2xlXCIsXG4gICAgXCJhbWF0ZXVyXCIsXG4gICAgXCJhbWJpZ3VcIixcbiAgICBcImFtYnJlXCIsXG4gICAgXCJhbWXMgW5hZ2VyXCIsXG4gICAgXCJhbWVydHVtZVwiLFxuICAgIFwiYW1pZG9uXCIsXG4gICAgXCJhbWlyYWxcIixcbiAgICBcImFtb3JjZXJcIixcbiAgICBcImFtb3VyXCIsXG4gICAgXCJhbW92aWJsZVwiLFxuICAgIFwiYW1waGliaWVcIixcbiAgICBcImFtcGxldXJcIixcbiAgICBcImFtdXNhbnRcIixcbiAgICBcImFuYWx5c2VcIixcbiAgICBcImFuYXBob3JlXCIsXG4gICAgXCJhbmFyY2hpZVwiLFxuICAgIFwiYW5hdG9taWVcIixcbiAgICBcImFuY2llblwiLFxuICAgIFwiYW5lzIFhbnRpclwiLFxuICAgIFwiYW5nbGVcIixcbiAgICBcImFuZ29pc3NlXCIsXG4gICAgXCJhbmd1bGV1eFwiLFxuICAgIFwiYW5pbWFsXCIsXG4gICAgXCJhbm5leGVyXCIsXG4gICAgXCJhbm5vbmNlXCIsXG4gICAgXCJhbm51ZWxcIixcbiAgICBcImFub2RpblwiLFxuICAgIFwiYW5vbWFsaWVcIixcbiAgICBcImFub255bWVcIixcbiAgICBcImFub3JtYWxcIixcbiAgICBcImFudGVubmVcIixcbiAgICBcImFudGlkb3RlXCIsXG4gICAgXCJhbnhpZXV4XCIsXG4gICAgXCJhcGFpc2VyXCIsXG4gICAgXCJhcGXMgXJpdGlmXCIsXG4gICAgXCJhcGxhbmlyXCIsXG4gICAgXCJhcG9sb2dpZVwiLFxuICAgIFwiYXBwYXJlaWxcIixcbiAgICBcImFwcGVsZXJcIixcbiAgICBcImFwcG9ydGVyXCIsXG4gICAgXCJhcHB1eWVyXCIsXG4gICAgXCJhcXVhcml1bVwiLFxuICAgIFwiYXF1ZWR1Y1wiLFxuICAgIFwiYXJiaXRyZVwiLFxuICAgIFwiYXJidXN0ZVwiLFxuICAgIFwiYXJkZXVyXCIsXG4gICAgXCJhcmRvaXNlXCIsXG4gICAgXCJhcmdlbnRcIixcbiAgICBcImFybGVxdWluXCIsXG4gICAgXCJhcm1hdHVyZVwiLFxuICAgIFwiYXJtZW1lbnRcIixcbiAgICBcImFybW9pcmVcIixcbiAgICBcImFybXVyZVwiLFxuICAgIFwiYXJwZW50ZXJcIixcbiAgICBcImFycmFjaGVyXCIsXG4gICAgXCJhcnJpdmVyXCIsXG4gICAgXCJhcnJvc2VyXCIsXG4gICAgXCJhcnNlbmljXCIsXG4gICAgXCJhcnRlzIFyaWVsXCIsXG4gICAgXCJhcnRpY2xlXCIsXG4gICAgXCJhc3BlY3RcIixcbiAgICBcImFzcGhhbHRlXCIsXG4gICAgXCJhc3BpcmVyXCIsXG4gICAgXCJhc3NhdXRcIixcbiAgICBcImFzc2VydmlyXCIsXG4gICAgXCJhc3NpZXR0ZVwiLFxuICAgIFwiYXNzb2NpZXJcIixcbiAgICBcImFzc3VyZXJcIixcbiAgICBcImFzdGljb3RcIixcbiAgICBcImFzdHJlXCIsXG4gICAgXCJhc3R1Y2VcIixcbiAgICBcImF0ZWxpZXJcIixcbiAgICBcImF0b21lXCIsXG4gICAgXCJhdHJpdW1cIixcbiAgICBcImF0cm9jZVwiLFxuICAgIFwiYXR0YXF1ZVwiLFxuICAgIFwiYXR0ZW50aWZcIixcbiAgICBcImF0dGlyZXJcIixcbiAgICBcImF0dHJhcGVyXCIsXG4gICAgXCJhdWJhaW5lXCIsXG4gICAgXCJhdWJlcmdlXCIsXG4gICAgXCJhdWRhY2VcIixcbiAgICBcImF1ZGlibGVcIixcbiAgICBcImF1Z3VyZXJcIixcbiAgICBcImF1cm9yZVwiLFxuICAgIFwiYXV0b21uZVwiLFxuICAgIFwiYXV0cnVjaGVcIixcbiAgICBcImF2YWxlclwiLFxuICAgIFwiYXZhbmNlclwiLFxuICAgIFwiYXZhcmljZVwiLFxuICAgIFwiYXZlbmlyXCIsXG4gICAgXCJhdmVyc2VcIixcbiAgICBcImF2ZXVnbGVcIixcbiAgICBcImF2aWF0ZXVyXCIsXG4gICAgXCJhdmlkZVwiLFxuICAgIFwiYXZpb25cIixcbiAgICBcImF2aXNlclwiLFxuICAgIFwiYXZvaW5lXCIsXG4gICAgXCJhdm91ZXJcIixcbiAgICBcImF2cmlsXCIsXG4gICAgXCJheGlhbFwiLFxuICAgIFwiYXhpb21lXCIsXG4gICAgXCJiYWRnZVwiLFxuICAgIFwiYmFmb3VlclwiLFxuICAgIFwiYmFnYWdlXCIsXG4gICAgXCJiYWd1ZXR0ZVwiLFxuICAgIFwiYmFpZ25hZGVcIixcbiAgICBcImJhbGFuY2VyXCIsXG4gICAgXCJiYWxjb25cIixcbiAgICBcImJhbGVpbmVcIixcbiAgICBcImJhbGlzYWdlXCIsXG4gICAgXCJiYW1iaW5cIixcbiAgICBcImJhbmNhaXJlXCIsXG4gICAgXCJiYW5kYWdlXCIsXG4gICAgXCJiYW5saWV1ZVwiLFxuICAgIFwiYmFubmllzIByZVwiLFxuICAgIFwiYmFucXVpZXJcIixcbiAgICBcImJhcmJpZXJcIixcbiAgICBcImJhcmlsXCIsXG4gICAgXCJiYXJvblwiLFxuICAgIFwiYmFycXVlXCIsXG4gICAgXCJiYXJyYWdlXCIsXG4gICAgXCJiYXNzaW5cIixcbiAgICBcImJhc3Rpb25cIixcbiAgICBcImJhdGFpbGxlXCIsXG4gICAgXCJiYXRlYXVcIixcbiAgICBcImJhdHRlcmllXCIsXG4gICAgXCJiYXVkcmllclwiLFxuICAgIFwiYmF2YXJkZXJcIixcbiAgICBcImJlbGV0dGVcIixcbiAgICBcImJlzIFsaWVyXCIsXG4gICAgXCJiZWxvdGVcIixcbiAgICBcImJlzIFuZcyBZmljZVwiLFxuICAgIFwiYmVyY2VhdVwiLFxuICAgIFwiYmVyZ2VyXCIsXG4gICAgXCJiZXJsaW5lXCIsXG4gICAgXCJiZXJtdWRhXCIsXG4gICAgXCJiZXNhY2VcIixcbiAgICBcImJlc29nbmVcIixcbiAgICBcImJlzIF0YWlsXCIsXG4gICAgXCJiZXVycmVcIixcbiAgICBcImJpYmVyb25cIixcbiAgICBcImJpY3ljbGVcIixcbiAgICBcImJpZHVsZVwiLFxuICAgIFwiYmlqb3VcIixcbiAgICBcImJpbGFuXCIsXG4gICAgXCJiaWxpbmd1ZVwiLFxuICAgIFwiYmlsbGFyZFwiLFxuICAgIFwiYmluYWlyZVwiLFxuICAgIFwiYmlvbG9naWVcIixcbiAgICBcImJpb3BzaWVcIixcbiAgICBcImJpb3R5cGVcIixcbiAgICBcImJpc2N1aXRcIixcbiAgICBcImJpc29uXCIsXG4gICAgXCJiaXN0b3VyaVwiLFxuICAgIFwiYml0dW1lXCIsXG4gICAgXCJiaXphcnJlXCIsXG4gICAgXCJibGFmYXJkXCIsXG4gICAgXCJibGFndWVcIixcbiAgICBcImJsYW5jaGlyXCIsXG4gICAgXCJibGVzc2FudFwiLFxuICAgIFwiYmxpbmRlclwiLFxuICAgIFwiYmxvbmRcIixcbiAgICBcImJsb3F1ZXJcIixcbiAgICBcImJsb3Vzb25cIixcbiAgICBcImJvYmFyZFwiLFxuICAgIFwiYm9iaW5lXCIsXG4gICAgXCJib2lyZVwiLFxuICAgIFwiYm9pc2VyXCIsXG4gICAgXCJib2xpZGVcIixcbiAgICBcImJvbmJvblwiLFxuICAgIFwiYm9uZGlyXCIsXG4gICAgXCJib25oZXVyXCIsXG4gICAgXCJib25pZmllclwiLFxuICAgIFwiYm9udXNcIixcbiAgICBcImJvcmR1cmVcIixcbiAgICBcImJvcm5lXCIsXG4gICAgXCJib3R0ZVwiLFxuICAgIFwiYm91Y2xlXCIsXG4gICAgXCJib3VldXhcIixcbiAgICBcImJvdWdpZVwiLFxuICAgIFwiYm91bG9uXCIsXG4gICAgXCJib3VxdWluXCIsXG4gICAgXCJib3Vyc2VcIixcbiAgICBcImJvdXNzb2xlXCIsXG4gICAgXCJib3V0aXF1ZVwiLFxuICAgIFwiYm94ZXVyXCIsXG4gICAgXCJicmFuY2hlXCIsXG4gICAgXCJicmFzaWVyXCIsXG4gICAgXCJicmF2ZVwiLFxuICAgIFwiYnJlYmlzXCIsXG4gICAgXCJicmXMgGNoZVwiLFxuICAgIFwiYnJldXZhZ2VcIixcbiAgICBcImJyaWNvbGVyXCIsXG4gICAgXCJicmlnYWRlXCIsXG4gICAgXCJicmlsbGFudFwiLFxuICAgIFwiYnJpb2NoZVwiLFxuICAgIFwiYnJpcXVlXCIsXG4gICAgXCJicm9jaHVyZVwiLFxuICAgIFwiYnJvZGVyXCIsXG4gICAgXCJicm9uemVyXCIsXG4gICAgXCJicm91c3NlXCIsXG4gICAgXCJicm95ZXVyXCIsXG4gICAgXCJicnVtZVwiLFxuICAgIFwiYnJ1c3F1ZVwiLFxuICAgIFwiYnJ1dGFsXCIsXG4gICAgXCJicnV5YW50XCIsXG4gICAgXCJidWZmbGVcIixcbiAgICBcImJ1aXNzb25cIixcbiAgICBcImJ1bGxldGluXCIsXG4gICAgXCJidXJlYXVcIixcbiAgICBcImJ1cmluXCIsXG4gICAgXCJidXN0aWVyXCIsXG4gICAgXCJidXRpbmVyXCIsXG4gICAgXCJidXRvaXJcIixcbiAgICBcImJ1dmFibGVcIixcbiAgICBcImJ1dmV0dGVcIixcbiAgICBcImNhYmFub25cIixcbiAgICBcImNhYmluZVwiLFxuICAgIFwiY2FjaGV0dGVcIixcbiAgICBcImNhZGVhdVwiLFxuICAgIFwiY2FkcmVcIixcbiAgICBcImNhZmXMgWluZVwiLFxuICAgIFwiY2FpbGxvdVwiLFxuICAgIFwiY2Fpc3NvblwiLFxuICAgIFwiY2FsY3VsZXJcIixcbiAgICBcImNhbGVwaW5cIixcbiAgICBcImNhbGlicmVcIixcbiAgICBcImNhbG1lclwiLFxuICAgIFwiY2Fsb21uaWVcIixcbiAgICBcImNhbHZhaXJlXCIsXG4gICAgXCJjYW1hcmFkZVwiLFxuICAgIFwiY2FtZcyBcmFcIixcbiAgICBcImNhbWlvblwiLFxuICAgIFwiY2FtcGFnbmVcIixcbiAgICBcImNhbmFsXCIsXG4gICAgXCJjYW5ldG9uXCIsXG4gICAgXCJjYW5vblwiLFxuICAgIFwiY2FudGluZVwiLFxuICAgIFwiY2FudWxhclwiLFxuICAgIFwiY2FwYWJsZVwiLFxuICAgIFwiY2Fwb3JhbFwiLFxuICAgIFwiY2FwcmljZVwiLFxuICAgIFwiY2Fwc3VsZVwiLFxuICAgIFwiY2FwdGVyXCIsXG4gICAgXCJjYXB1Y2hlXCIsXG4gICAgXCJjYXJhYmluZVwiLFxuICAgIFwiY2FyYm9uZVwiLFxuICAgIFwiY2FyZXNzZXJcIixcbiAgICBcImNhcmlib3VcIixcbiAgICBcImNhcm5hZ2VcIixcbiAgICBcImNhcm90dGVcIixcbiAgICBcImNhcnJlYXVcIixcbiAgICBcImNhcnRvblwiLFxuICAgIFwiY2FzY2FkZVwiLFxuICAgIFwiY2FzaWVyXCIsXG4gICAgXCJjYXNxdWVcIixcbiAgICBcImNhc3N1cmVcIixcbiAgICBcImNhdXNlclwiLFxuICAgIFwiY2F1dGlvblwiLFxuICAgIFwiY2F2YWxpZXJcIixcbiAgICBcImNhdmVybmVcIixcbiAgICBcImNhdmlhclwiLFxuICAgIFwiY2XMgWRpbGxlXCIsXG4gICAgXCJjZWludHVyZVwiLFxuICAgIFwiY2XMgWxlc3RlXCIsXG4gICAgXCJjZWxsdWxlXCIsXG4gICAgXCJjZW5kcmllclwiLFxuICAgIFwiY2Vuc3VyZXJcIixcbiAgICBcImNlbnRyYWxcIixcbiAgICBcImNlcmNsZVwiLFxuICAgIFwiY2XMgXJlzIFicmFsXCIsXG4gICAgXCJjZXJpc2VcIixcbiAgICBcImNlcm5lclwiLFxuICAgIFwiY2VydmVhdVwiLFxuICAgIFwiY2Vzc2VyXCIsXG4gICAgXCJjaGFncmluXCIsXG4gICAgXCJjaGFpc2VcIixcbiAgICBcImNoYWxldXJcIixcbiAgICBcImNoYW1icmVcIixcbiAgICBcImNoYW5jZVwiLFxuICAgIFwiY2hhcGl0cmVcIixcbiAgICBcImNoYXJib25cIixcbiAgICBcImNoYXNzZXVyXCIsXG4gICAgXCJjaGF0b25cIixcbiAgICBcImNoYXVzc29uXCIsXG4gICAgXCJjaGF2aXJlclwiLFxuICAgIFwiY2hlbWlzZVwiLFxuICAgIFwiY2hlbmlsbGVcIixcbiAgICBcImNoZcyBcXVpZXJcIixcbiAgICBcImNoZXJjaGVyXCIsXG4gICAgXCJjaGV2YWxcIixcbiAgICBcImNoaWVuXCIsXG4gICAgXCJjaGlmZnJlXCIsXG4gICAgXCJjaGlnbm9uXCIsXG4gICAgXCJjaGltZcyAcmVcIixcbiAgICBcImNoaW90XCIsXG4gICAgXCJjaGxvcnVyZVwiLFxuICAgIFwiY2hvY29sYXRcIixcbiAgICBcImNob2lzaXJcIixcbiAgICBcImNob3NlXCIsXG4gICAgXCJjaG91ZXR0ZVwiLFxuICAgIFwiY2hyb21lXCIsXG4gICAgXCJjaHV0ZVwiLFxuICAgIFwiY2lnYXJlXCIsXG4gICAgXCJjaWdvZ25lXCIsXG4gICAgXCJjaW1lbnRlclwiLFxuICAgIFwiY2luZcyBbWFcIixcbiAgICBcImNpbnRyZXJcIixcbiAgICBcImNpcmN1bGVyXCIsXG4gICAgXCJjaXJlclwiLFxuICAgIFwiY2lycXVlXCIsXG4gICAgXCJjaXRlcm5lXCIsXG4gICAgXCJjaXRveWVuXCIsXG4gICAgXCJjaXRyb25cIixcbiAgICBcImNpdmlsXCIsXG4gICAgXCJjbGFpcm9uXCIsXG4gICAgXCJjbGFtZXVyXCIsXG4gICAgXCJjbGFxdWVyXCIsXG4gICAgXCJjbGFzc2VcIixcbiAgICBcImNsYXZpZXJcIixcbiAgICBcImNsaWVudFwiLFxuICAgIFwiY2xpZ25lclwiLFxuICAgIFwiY2xpbWF0XCIsXG4gICAgXCJjbGl2YWdlXCIsXG4gICAgXCJjbG9jaGVcIixcbiAgICBcImNsb25hZ2VcIixcbiAgICBcImNsb3BvcnRlXCIsXG4gICAgXCJjb2JhbHRcIixcbiAgICBcImNvYnJhXCIsXG4gICAgXCJjb2Nhc3NlXCIsXG4gICAgXCJjb2NvdGllclwiLFxuICAgIFwiY29kZXJcIixcbiAgICBcImNvZGlmaWVyXCIsXG4gICAgXCJjb2ZmcmVcIixcbiAgICBcImNvZ25lclwiLFxuICAgIFwiY29oZcyBc2lvblwiLFxuICAgIFwiY29pZmZlclwiLFxuICAgIFwiY29pbmNlclwiLFxuICAgIFwiY29sZcyAcmVcIixcbiAgICBcImNvbGlicmlcIixcbiAgICBcImNvbGxpbmVcIixcbiAgICBcImNvbG1hdGVyXCIsXG4gICAgXCJjb2xvbmVsXCIsXG4gICAgXCJjb21iYXRcIixcbiAgICBcImNvbWXMgWRpZVwiLFxuICAgIFwiY29tbWFuZGVcIixcbiAgICBcImNvbXBhY3RcIixcbiAgICBcImNvbmNlcnRcIixcbiAgICBcImNvbmR1aXJlXCIsXG4gICAgXCJjb25maWVyXCIsXG4gICAgXCJjb25nZWxlclwiLFxuICAgIFwiY29ubm90ZXJcIixcbiAgICBcImNvbnNvbm5lXCIsXG4gICAgXCJjb250YWN0XCIsXG4gICAgXCJjb252ZXhlXCIsXG4gICAgXCJjb3BhaW5cIixcbiAgICBcImNvcGllXCIsXG4gICAgXCJjb3JhaWxcIixcbiAgICBcImNvcmJlYXVcIixcbiAgICBcImNvcmRhZ2VcIixcbiAgICBcImNvcm5pY2hlXCIsXG4gICAgXCJjb3JwdXNcIixcbiAgICBcImNvcnJlY3RcIixcbiAgICBcImNvcnRlzIBnZVwiLFxuICAgIFwiY29zbWlxdWVcIixcbiAgICBcImNvc3R1bWVcIixcbiAgICBcImNvdG9uXCIsXG4gICAgXCJjb3VkZVwiLFxuICAgIFwiY291cHVyZVwiLFxuICAgIFwiY291cmFnZVwiLFxuICAgIFwiY291dGVhdVwiLFxuICAgIFwiY291dnJpclwiLFxuICAgIFwiY295b3RlXCIsXG4gICAgXCJjcmFiZVwiLFxuICAgIFwiY3JhaW50ZVwiLFxuICAgIFwiY3JhdmF0ZVwiLFxuICAgIFwiY3JheW9uXCIsXG4gICAgXCJjcmXMgWF0dXJlXCIsXG4gICAgXCJjcmXMgWRpdGVyXCIsXG4gICAgXCJjcmXMgW1ldXhcIixcbiAgICBcImNyZXVzZXJcIixcbiAgICBcImNyZXZldHRlXCIsXG4gICAgXCJjcmlibGVyXCIsXG4gICAgXCJjcmllclwiLFxuICAgIFwiY3Jpc3RhbFwiLFxuICAgIFwiY3JpdGXMgHJlXCIsXG4gICAgXCJjcm9pcmVcIixcbiAgICBcImNyb3F1ZXJcIixcbiAgICBcImNyb3RhbGVcIixcbiAgICBcImNydWNpYWxcIixcbiAgICBcImNydWVsXCIsXG4gICAgXCJjcnlwdGVyXCIsXG4gICAgXCJjdWJpcXVlXCIsXG4gICAgXCJjdWVpbGxpclwiLFxuICAgIFwiY3VpbGxlzIByZVwiLFxuICAgIFwiY3Vpc2luZVwiLFxuICAgIFwiY3VpdnJlXCIsXG4gICAgXCJjdWxtaW5lclwiLFxuICAgIFwiY3VsdGl2ZXJcIixcbiAgICBcImN1bXVsZXJcIixcbiAgICBcImN1cGlkZVwiLFxuICAgIFwiY3VyYXRpZlwiLFxuICAgIFwiY3Vyc2V1clwiLFxuICAgIFwiY3lhbnVyZVwiLFxuICAgIFwiY3ljbGVcIixcbiAgICBcImN5bGluZHJlXCIsXG4gICAgXCJjeW5pcXVlXCIsXG4gICAgXCJkYWlnbmVyXCIsXG4gICAgXCJkYW1pZXJcIixcbiAgICBcImRhbmdlclwiLFxuICAgIFwiZGFuc2V1clwiLFxuICAgIFwiZGF1cGhpblwiLFxuICAgIFwiZGXMgWJhdHRyZVwiLFxuICAgIFwiZGXMgWJpdGVyXCIsXG4gICAgXCJkZcyBYm9yZGVyXCIsXG4gICAgXCJkZcyBYnJpZGVyXCIsXG4gICAgXCJkZcyBYnV0YW50XCIsXG4gICAgXCJkZcyBY2FsZXJcIixcbiAgICBcImRlzIFjZW1icmVcIixcbiAgICBcImRlzIFjaGlyZXJcIixcbiAgICBcImRlzIFjaWRlclwiLFxuICAgIFwiZGXMgWNsYXJlclwiLFxuICAgIFwiZGXMgWNvcmVyXCIsXG4gICAgXCJkZcyBY3JpcmVcIixcbiAgICBcImRlzIFjdXBsZXJcIixcbiAgICBcImRlzIFkYWxlXCIsXG4gICAgXCJkZcyBZHVjdGlmXCIsXG4gICAgXCJkZcyBZXNzZVwiLFxuICAgIFwiZGXMgWZlbnNpZlwiLFxuICAgIFwiZGXMgWZpbGVyXCIsXG4gICAgXCJkZcyBZnJheWVyXCIsXG4gICAgXCJkZcyBZ2FnZXJcIixcbiAgICBcImRlzIFnaXZyZXJcIixcbiAgICBcImRlzIFnbHV0aXJcIixcbiAgICBcImRlzIFncmFmZXJcIixcbiAgICBcImRlzIFqZXVuZXJcIixcbiAgICBcImRlzIFsaWNlXCIsXG4gICAgXCJkZcyBbG9nZXJcIixcbiAgICBcImRlbWFuZGVyXCIsXG4gICAgXCJkZW1ldXJlclwiLFxuICAgIFwiZGXMgW1vbGlyXCIsXG4gICAgXCJkZcyBbmljaGVyXCIsXG4gICAgXCJkZcyBbm91ZXJcIixcbiAgICBcImRlbnRlbGxlXCIsXG4gICAgXCJkZcyBbnVkZXJcIixcbiAgICBcImRlzIFwYXJ0XCIsXG4gICAgXCJkZcyBcGVuc2VyXCIsXG4gICAgXCJkZcyBcGhhc2VyXCIsXG4gICAgXCJkZcyBcGxhY2VyXCIsXG4gICAgXCJkZcyBcG9zZXJcIixcbiAgICBcImRlzIFyYW5nZXJcIixcbiAgICBcImRlzIFyb2JlclwiLFxuICAgIFwiZGXMgXNhc3RyZVwiLFxuICAgIFwiZGVzY2VudGVcIixcbiAgICBcImRlzIFzZXJ0XCIsXG4gICAgXCJkZcyBc2lnbmVyXCIsXG4gICAgXCJkZcyBc29iZcyBaXJcIixcbiAgICBcImRlc3NpbmVyXCIsXG4gICAgXCJkZXN0cmllclwiLFxuICAgIFwiZGXMgXRhY2hlclwiLFxuICAgIFwiZGXMgXRlc3RlclwiLFxuICAgIFwiZGXMgXRvdXJlclwiLFxuICAgIFwiZGXMgXRyZXNzZVwiLFxuICAgIFwiZGV2YW5jZXJcIixcbiAgICBcImRldmVuaXJcIixcbiAgICBcImRldmluZXJcIixcbiAgICBcImRldm9pclwiLFxuICAgIFwiZGlhYmxlXCIsXG4gICAgXCJkaWFsb2d1ZVwiLFxuICAgIFwiZGlhbWFudFwiLFxuICAgIFwiZGljdGVyXCIsXG4gICAgXCJkaWZmZcyBcmVyXCIsXG4gICAgXCJkaWdlzIFyZXJcIixcbiAgICBcImRpZ2l0YWxcIixcbiAgICBcImRpZ25lXCIsXG4gICAgXCJkaWx1ZXJcIixcbiAgICBcImRpbWFuY2hlXCIsXG4gICAgXCJkaW1pbnVlclwiLFxuICAgIFwiZGlveHlkZVwiLFxuICAgIFwiZGlyZWN0aWZcIixcbiAgICBcImRpcmlnZXJcIixcbiAgICBcImRpc2N1dGVyXCIsXG4gICAgXCJkaXNwb3NlclwiLFxuICAgIFwiZGlzc2lwZXJcIixcbiAgICBcImRpc3RhbmNlXCIsXG4gICAgXCJkaXZlcnRpclwiLFxuICAgIFwiZGl2aXNlclwiLFxuICAgIFwiZG9jaWxlXCIsXG4gICAgXCJkb2N0ZXVyXCIsXG4gICAgXCJkb2dtZVwiLFxuICAgIFwiZG9pZ3RcIixcbiAgICBcImRvbWFpbmVcIixcbiAgICBcImRvbWljaWxlXCIsXG4gICAgXCJkb21wdGVyXCIsXG4gICAgXCJkb25hdGV1clwiLFxuICAgIFwiZG9uam9uXCIsXG4gICAgXCJkb25uZXJcIixcbiAgICBcImRvcGFtaW5lXCIsXG4gICAgXCJkb3J0b2lyXCIsXG4gICAgXCJkb3J1cmVcIixcbiAgICBcImRvc2FnZVwiLFxuICAgIFwiZG9zZXVyXCIsXG4gICAgXCJkb3NzaWVyXCIsXG4gICAgXCJkb3RhdGlvblwiLFxuICAgIFwiZG91YW5pZXJcIixcbiAgICBcImRvdWJsZVwiLFxuICAgIFwiZG91Y2V1clwiLFxuICAgIFwiZG91dGVyXCIsXG4gICAgXCJkb3llblwiLFxuICAgIFwiZHJhZ29uXCIsXG4gICAgXCJkcmFwZXJcIixcbiAgICBcImRyZXNzZXJcIixcbiAgICBcImRyaWJibGVyXCIsXG4gICAgXCJkcm9pdHVyZVwiLFxuICAgIFwiZHVwZXJpZVwiLFxuICAgIFwiZHVwbGV4ZVwiLFxuICAgIFwiZHVyYWJsZVwiLFxuICAgIFwiZHVyY2lyXCIsXG4gICAgXCJkeW5hc3RpZVwiLFxuICAgIFwiZcyBYmxvdWlyXCIsXG4gICAgXCJlzIFjYXJ0ZXJcIixcbiAgICBcImXMgWNoYXJwZVwiLFxuICAgIFwiZcyBY2hlbGxlXCIsXG4gICAgXCJlzIFjbGFpcmVyXCIsXG4gICAgXCJlzIFjbGlwc2VcIixcbiAgICBcImXMgWNsb3JlXCIsXG4gICAgXCJlzIFjbHVzZVwiLFxuICAgIFwiZcyBY29sZVwiLFxuICAgIFwiZcyBY29ub21pZVwiLFxuICAgIFwiZcyBY29yY2VcIixcbiAgICBcImXMgWNvdXRlclwiLFxuICAgIFwiZcyBY3Jhc2VyXCIsXG4gICAgXCJlzIFjcmXMgW1lclwiLFxuICAgIFwiZcyBY3JpdmFpblwiLFxuICAgIFwiZcyBY3JvdVwiLFxuICAgIFwiZcyBY3VtZVwiLFxuICAgIFwiZcyBY3VyZXVpbFwiLFxuICAgIFwiZcyBZGlmaWVyXCIsXG4gICAgXCJlzIFkdXF1ZXJcIixcbiAgICBcImVmZmFjZXJcIixcbiAgICBcImVmZmVjdGlmXCIsXG4gICAgXCJlZmZpZ2llXCIsXG4gICAgXCJlZmZvcnRcIixcbiAgICBcImVmZnJheWVyXCIsXG4gICAgXCJlZmZ1c2lvblwiLFxuICAgIFwiZcyBZ2FsaXNlclwiLFxuICAgIFwiZcyBZ2FyZXJcIixcbiAgICBcImXMgWplY3RlclwiLFxuICAgIFwiZcyBbGFib3JlclwiLFxuICAgIFwiZcyBbGFyZ2lyXCIsXG4gICAgXCJlzIFsZWN0cm9uXCIsXG4gICAgXCJlzIFsZcyBZ2FudFwiLFxuICAgIFwiZcyBbGXMgXBoYW50XCIsXG4gICAgXCJlzIFsZcyAdmVcIixcbiAgICBcImXMgWxpZ2libGVcIixcbiAgICBcImXMgWxpdGlzbWVcIixcbiAgICBcImXMgWxvZ2VcIixcbiAgICBcImXMgWx1Y2lkZXJcIixcbiAgICBcImXMgWx1ZGVyXCIsXG4gICAgXCJlbWJhbGxlclwiLFxuICAgIFwiZW1iZWxsaXJcIixcbiAgICBcImVtYnJ5b25cIixcbiAgICBcImXMgW1lcmF1ZGVcIixcbiAgICBcImXMgW1pc3Npb25cIixcbiAgICBcImVtbWVuZXJcIixcbiAgICBcImXMgW1vdGlvblwiLFxuICAgIFwiZcyBbW91dm9pclwiLFxuICAgIFwiZW1wZXJldXJcIixcbiAgICBcImVtcGxveWVyXCIsXG4gICAgXCJlbXBvcnRlclwiLFxuICAgIFwiZW1wcmlzZVwiLFxuICAgIFwiZcyBbXVsc2lvblwiLFxuICAgIFwiZW5jYWRyZXJcIixcbiAgICBcImVuY2hlzIByZVwiLFxuICAgIFwiZW5jbGF2ZVwiLFxuICAgIFwiZW5jb2NoZVwiLFxuICAgIFwiZW5kaWd1ZXJcIixcbiAgICBcImVuZG9zc2VyXCIsXG4gICAgXCJlbmRyb2l0XCIsXG4gICAgXCJlbmR1aXJlXCIsXG4gICAgXCJlzIFuZXJnaWVcIixcbiAgICBcImVuZmFuY2VcIixcbiAgICBcImVuZmVybWVyXCIsXG4gICAgXCJlbmZvdWlyXCIsXG4gICAgXCJlbmdhZ2VyXCIsXG4gICAgXCJlbmdpblwiLFxuICAgIFwiZW5nbG9iZXJcIixcbiAgICBcImXMgW5pZ21lXCIsXG4gICAgXCJlbmphbWJlclwiLFxuICAgIFwiZW5qZXVcIixcbiAgICBcImVubGV2ZXJcIixcbiAgICBcImVubmVtaVwiLFxuICAgIFwiZW5udXlldXhcIixcbiAgICBcImVucmljaGlyXCIsXG4gICAgXCJlbnJvYmFnZVwiLFxuICAgIFwiZW5zZWlnbmVcIixcbiAgICBcImVudGFzc2VyXCIsXG4gICAgXCJlbnRlbmRyZVwiLFxuICAgIFwiZW50aWVyXCIsXG4gICAgXCJlbnRvdXJlclwiLFxuICAgIFwiZW50cmF2ZXJcIixcbiAgICBcImXMgW51bWXMgXJlclwiLFxuICAgIFwiZW52YWhpclwiLFxuICAgIFwiZW52aWFibGVcIixcbiAgICBcImVudm95ZXJcIixcbiAgICBcImVuenltZVwiLFxuICAgIFwiZcyBb2xpZW5cIixcbiAgICBcImXMgXBhaXNzaXJcIixcbiAgICBcImXMgXBhcmduZVwiLFxuICAgIFwiZcyBcGF0YW50XCIsXG4gICAgXCJlzIFwYXVsZVwiLFxuICAgIFwiZcyBcGljZXJpZVwiLFxuICAgIFwiZcyBcGlkZcyBbWllXCIsXG4gICAgXCJlzIFwaWVyXCIsXG4gICAgXCJlzIFwaWxvZ3VlXCIsXG4gICAgXCJlzIFwaW5lXCIsXG4gICAgXCJlzIFwaXNvZGVcIixcbiAgICBcImXMgXBpdGFwaGVcIixcbiAgICBcImXMgXBvcXVlXCIsXG4gICAgXCJlzIFwcmV1dmVcIixcbiAgICBcImXMgXByb3V2ZXJcIixcbiAgICBcImXMgXB1aXNhbnRcIixcbiAgICBcImXMgXF1ZXJyZVwiLFxuICAgIFwiZcyBcXVpcGVcIixcbiAgICBcImXMgXJpZ2VyXCIsXG4gICAgXCJlzIFyb3Npb25cIixcbiAgICBcImVycmV1clwiLFxuICAgIFwiZcyBcnVwdGlvblwiLFxuICAgIFwiZXNjYWxpZXJcIixcbiAgICBcImVzcGFkb25cIixcbiAgICBcImVzcGXMgGNlXCIsXG4gICAgXCJlc3BpZcyAZ2xlXCIsXG4gICAgXCJlc3BvaXJcIixcbiAgICBcImVzcHJpdFwiLFxuICAgIFwiZXNxdWl2ZXJcIixcbiAgICBcImVzc2F5ZXJcIixcbiAgICBcImVzc2VuY2VcIixcbiAgICBcImVzc2lldVwiLFxuICAgIFwiZXNzb3JlclwiLFxuICAgIFwiZXN0aW1lXCIsXG4gICAgXCJlc3RvbWFjXCIsXG4gICAgXCJlc3RyYWRlXCIsXG4gICAgXCJlzIF0YWdlzIByZVwiLFxuICAgIFwiZcyBdGFsZXJcIixcbiAgICBcImXMgXRhbmNoZVwiLFxuICAgIFwiZcyBdGF0aXF1ZVwiLFxuICAgIFwiZcyBdGVpbmRyZVwiLFxuICAgIFwiZcyBdGVuZG9pclwiLFxuICAgIFwiZcyBdGVybmVsXCIsXG4gICAgXCJlzIF0aGFub2xcIixcbiAgICBcImXMgXRoaXF1ZVwiLFxuICAgIFwiZXRobmllXCIsXG4gICAgXCJlzIF0aXJlclwiLFxuICAgIFwiZcyBdG9mZmVyXCIsXG4gICAgXCJlzIF0b2lsZVwiLFxuICAgIFwiZcyBdG9ubmFudFwiLFxuICAgIFwiZcyBdG91cmRpclwiLFxuICAgIFwiZcyBdHJhbmdlXCIsXG4gICAgXCJlzIF0cm9pdFwiLFxuICAgIFwiZcyBdHVkZVwiLFxuICAgIFwiZXVwaG9yaWVcIixcbiAgICBcImXMgXZhbHVlclwiLFxuICAgIFwiZcyBdmFzaW9uXCIsXG4gICAgXCJlzIF2ZW50YWlsXCIsXG4gICAgXCJlzIF2aWRlbmNlXCIsXG4gICAgXCJlzIF2aXRlclwiLFxuICAgIFwiZcyBdm9sdXRpZlwiLFxuICAgIFwiZcyBdm9xdWVyXCIsXG4gICAgXCJleGFjdFwiLFxuICAgIFwiZXhhZ2XMgXJlclwiLFxuICAgIFwiZXhhdWNlclwiLFxuICAgIFwiZXhjZWxsZXJcIixcbiAgICBcImV4Y2l0YW50XCIsXG4gICAgXCJleGNsdXNpZlwiLFxuICAgIFwiZXhjdXNlXCIsXG4gICAgXCJleGXMgWN1dGVyXCIsXG4gICAgXCJleGVtcGxlXCIsXG4gICAgXCJleGVyY2VyXCIsXG4gICAgXCJleGhhbGVyXCIsXG4gICAgXCJleGhvcnRlclwiLFxuICAgIFwiZXhpZ2VuY2VcIixcbiAgICBcImV4aWxlclwiLFxuICAgIFwiZXhpc3RlclwiLFxuICAgIFwiZXhvdGlxdWVcIixcbiAgICBcImV4cGXMgWRpZXJcIixcbiAgICBcImV4cGxvcmVyXCIsXG4gICAgXCJleHBvc2VyXCIsXG4gICAgXCJleHByaW1lclwiLFxuICAgIFwiZXhxdWlzXCIsXG4gICAgXCJleHRlbnNpZlwiLFxuICAgIFwiZXh0cmFpcmVcIixcbiAgICBcImV4dWx0ZXJcIixcbiAgICBcImZhYmxlXCIsXG4gICAgXCJmYWJ1bGV1eFwiLFxuICAgIFwiZmFjZXR0ZVwiLFxuICAgIFwiZmFjaWxlXCIsXG4gICAgXCJmYWN0dXJlXCIsXG4gICAgXCJmYWlibGlyXCIsXG4gICAgXCJmYWxhaXNlXCIsXG4gICAgXCJmYW1ldXhcIixcbiAgICBcImZhbWlsbGVcIixcbiAgICBcImZhcmNldXJcIixcbiAgICBcImZhcmZlbHVcIixcbiAgICBcImZhcmluZVwiLFxuICAgIFwiZmFyb3VjaGVcIixcbiAgICBcImZhc2NpbmVyXCIsXG4gICAgXCJmYXRhbFwiLFxuICAgIFwiZmF0aWd1ZVwiLFxuICAgIFwiZmF1Y29uXCIsXG4gICAgXCJmYXV0aWZcIixcbiAgICBcImZhdmV1clwiLFxuICAgIFwiZmF2b3JpXCIsXG4gICAgXCJmZcyBYnJpbGVcIixcbiAgICBcImZlzIFjb25kZXJcIixcbiAgICBcImZlzIFkZcyBcmVyXCIsXG4gICAgXCJmZcyBbGluXCIsXG4gICAgXCJmZW1tZVwiLFxuICAgIFwiZmXMgW11clwiLFxuICAgIFwiZmVuZG9pclwiLFxuICAgIFwiZmXMgW9kYWxcIixcbiAgICBcImZlcm1lclwiLFxuICAgIFwiZmXMgXJvY2VcIixcbiAgICBcImZlcnZldXJcIixcbiAgICBcImZlc3RpdmFsXCIsXG4gICAgXCJmZXVpbGxlXCIsXG4gICAgXCJmZXV0cmVcIixcbiAgICBcImZlzIF2cmllclwiLFxuICAgIFwiZmlhc2NvXCIsXG4gICAgXCJmaWNlbGVyXCIsXG4gICAgXCJmaWN0aWZcIixcbiAgICBcImZpZGXMgGxlXCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZpbGF0dXJlXCIsXG4gICAgXCJmaWxldGFnZVwiLFxuICAgIFwiZmlsaWXMgHJlXCIsXG4gICAgXCJmaWxsZXVsXCIsXG4gICAgXCJmaWxtZXJcIixcbiAgICBcImZpbG91XCIsXG4gICAgXCJmaWx0cmVyXCIsXG4gICAgXCJmaW5hbmNlclwiLFxuICAgIFwiZmluaXJcIixcbiAgICBcImZpb2xlXCIsXG4gICAgXCJmaXJtZVwiLFxuICAgIFwiZmlzc3VyZVwiLFxuICAgIFwiZml4ZXJcIixcbiAgICBcImZsYWlyZXJcIixcbiAgICBcImZsYW1tZVwiLFxuICAgIFwiZmxhc3F1ZVwiLFxuICAgIFwiZmxhdHRldXJcIixcbiAgICBcImZsZcyBYXVcIixcbiAgICBcImZsZcyAY2hlXCIsXG4gICAgXCJmbGV1clwiLFxuICAgIFwiZmxleGlvblwiLFxuICAgIFwiZmxvY29uXCIsXG4gICAgXCJmbG9yZVwiLFxuICAgIFwiZmx1Y3R1ZXJcIixcbiAgICBcImZsdWlkZVwiLFxuICAgIFwiZmx1dmlhbFwiLFxuICAgIFwiZm9saWVcIixcbiAgICBcImZvbmRlcmllXCIsXG4gICAgXCJmb25naWJsZVwiLFxuICAgIFwiZm9udGFpbmVcIixcbiAgICBcImZvcmNlclwiLFxuICAgIFwiZm9yZ2Vyb25cIixcbiAgICBcImZvcm11bGVyXCIsXG4gICAgXCJmb3J0dW5lXCIsXG4gICAgXCJmb3NzaWxlXCIsXG4gICAgXCJmb3VkcmVcIixcbiAgICBcImZvdWdlzIByZVwiLFxuICAgIFwiZm91aWxsZXJcIixcbiAgICBcImZvdWx1cmVcIixcbiAgICBcImZvdXJtaVwiLFxuICAgIFwiZnJhZ2lsZVwiLFxuICAgIFwiZnJhaXNlXCIsXG4gICAgXCJmcmFuY2hpclwiLFxuICAgIFwiZnJhcHBlclwiLFxuICAgIFwiZnJheWV1clwiLFxuICAgIFwiZnJlzIFnYXRlXCIsXG4gICAgXCJmcmVpbmVyXCIsXG4gICAgXCJmcmVsb25cIixcbiAgICBcImZyZcyBbWlyXCIsXG4gICAgXCJmcmXMgW5lzIFzaWVcIixcbiAgICBcImZyZcyAcmVcIixcbiAgICBcImZyaWFibGVcIixcbiAgICBcImZyaWN0aW9uXCIsXG4gICAgXCJmcmlzc29uXCIsXG4gICAgXCJmcml2b2xlXCIsXG4gICAgXCJmcm9pZFwiLFxuICAgIFwiZnJvbWFnZVwiLFxuICAgIFwiZnJvbnRhbFwiLFxuICAgIFwiZnJvdHRlclwiLFxuICAgIFwiZnJ1aXRcIixcbiAgICBcImZ1Z2l0aWZcIixcbiAgICBcImZ1aXRlXCIsXG4gICAgXCJmdXJldXJcIixcbiAgICBcImZ1cmlldXhcIixcbiAgICBcImZ1cnRpZlwiLFxuICAgIFwiZnVzaW9uXCIsXG4gICAgXCJmdXR1clwiLFxuICAgIFwiZ2FnbmVyXCIsXG4gICAgXCJnYWxheGllXCIsXG4gICAgXCJnYWxlcmllXCIsXG4gICAgXCJnYW1iYWRlclwiLFxuICAgIFwiZ2FyYW50aXJcIixcbiAgICBcImdhcmRpZW5cIixcbiAgICBcImdhcm5pclwiLFxuICAgIFwiZ2FycmlndWVcIixcbiAgICBcImdhemVsbGVcIixcbiAgICBcImdhem9uXCIsXG4gICAgXCJnZcyBYW50XCIsXG4gICAgXCJnZcyBbGF0aW5lXCIsXG4gICAgXCJnZcyBbHVsZVwiLFxuICAgIFwiZ2VuZGFybWVcIixcbiAgICBcImdlzIFuZcyBcmFsXCIsXG4gICAgXCJnZcyBbmllXCIsXG4gICAgXCJnZW5vdVwiLFxuICAgIFwiZ2VudGlsXCIsXG4gICAgXCJnZcyBb2xvZ2llXCIsXG4gICAgXCJnZcyBb21lzIB0cmVcIixcbiAgICBcImdlzIFyYW5pdW1cIixcbiAgICBcImdlcm1lXCIsXG4gICAgXCJnZXN0dWVsXCIsXG4gICAgXCJnZXlzZXJcIixcbiAgICBcImdpYmllclwiLFxuICAgIFwiZ2ljbGVyXCIsXG4gICAgXCJnaXJhZmVcIixcbiAgICBcImdpdnJlXCIsXG4gICAgXCJnbGFjZVwiLFxuICAgIFwiZ2xhaXZlXCIsXG4gICAgXCJnbGlzc2VyXCIsXG4gICAgXCJnbG9iZVwiLFxuICAgIFwiZ2xvaXJlXCIsXG4gICAgXCJnbG9yaWV1eFwiLFxuICAgIFwiZ29sZmV1clwiLFxuICAgIFwiZ29tbWVcIixcbiAgICBcImdvbmZsZXJcIixcbiAgICBcImdvcmdlXCIsXG4gICAgXCJnb3JpbGxlXCIsXG4gICAgXCJnb3Vkcm9uXCIsXG4gICAgXCJnb3VmZnJlXCIsXG4gICAgXCJnb3Vsb3RcIixcbiAgICBcImdvdXBpbGxlXCIsXG4gICAgXCJnb3VybWFuZFwiLFxuICAgIFwiZ291dHRlXCIsXG4gICAgXCJncmFkdWVsXCIsXG4gICAgXCJncmFmZml0aVwiLFxuICAgIFwiZ3JhaW5lXCIsXG4gICAgXCJncmFuZFwiLFxuICAgIFwiZ3JhcHBpblwiLFxuICAgIFwiZ3JhdHVpdFwiLFxuICAgIFwiZ3JhdmlyXCIsXG4gICAgXCJncmVuYXRcIixcbiAgICBcImdyaWZmdXJlXCIsXG4gICAgXCJncmlsbGVyXCIsXG4gICAgXCJncmltcGVyXCIsXG4gICAgXCJncm9nbmVyXCIsXG4gICAgXCJncm9uZGVyXCIsXG4gICAgXCJncm90dGVcIixcbiAgICBcImdyb3VwZVwiLFxuICAgIFwiZ3J1Z2VyXCIsXG4gICAgXCJncnV0aWVyXCIsXG4gICAgXCJncnV5ZcyAcmVcIixcbiAgICBcImd1ZcyBcGFyZFwiLFxuICAgIFwiZ3VlcnJpZXJcIixcbiAgICBcImd1aWRlXCIsXG4gICAgXCJndWltYXV2ZVwiLFxuICAgIFwiZ3VpdGFyZVwiLFxuICAgIFwiZ3VzdGF0aWZcIixcbiAgICBcImd5bW5hc3RlXCIsXG4gICAgXCJneXJvc3RhdFwiLFxuICAgIFwiaGFiaXR1ZGVcIixcbiAgICBcImhhY2hvaXJcIixcbiAgICBcImhhbHRlXCIsXG4gICAgXCJoYW1lYXVcIixcbiAgICBcImhhbmdhclwiLFxuICAgIFwiaGFubmV0b25cIixcbiAgICBcImhhcmljb3RcIixcbiAgICBcImhhcm1vbmllXCIsXG4gICAgXCJoYXJwb25cIixcbiAgICBcImhhc2FyZFwiLFxuICAgIFwiaGXMgWxpdW1cIixcbiAgICBcImhlzIFtYXRvbWVcIixcbiAgICBcImhlcmJlXCIsXG4gICAgXCJoZcyBcmlzc29uXCIsXG4gICAgXCJoZXJtaW5lXCIsXG4gICAgXCJoZcyBcm9uXCIsXG4gICAgXCJoZcyBc2l0ZXJcIixcbiAgICBcImhldXJldXhcIixcbiAgICBcImhpYmVybmVyXCIsXG4gICAgXCJoaWJvdVwiLFxuICAgIFwiaGlsYXJhbnRcIixcbiAgICBcImhpc3RvaXJlXCIsXG4gICAgXCJoaXZlclwiLFxuICAgIFwiaG9tYXJkXCIsXG4gICAgXCJob21tYWdlXCIsXG4gICAgXCJob21vZ2XMgG5lXCIsXG4gICAgXCJob25uZXVyXCIsXG4gICAgXCJob25vcmVyXCIsXG4gICAgXCJob250ZXV4XCIsXG4gICAgXCJob3JkZVwiLFxuICAgIFwiaG9yaXpvblwiLFxuICAgIFwiaG9ybG9nZVwiLFxuICAgIFwiaG9ybW9uZVwiLFxuICAgIFwiaG9ycmlibGVcIixcbiAgICBcImhvdWxldXhcIixcbiAgICBcImhvdXNzZVwiLFxuICAgIFwiaHVibG90XCIsXG4gICAgXCJodWlsZXV4XCIsXG4gICAgXCJodW1haW5cIixcbiAgICBcImh1bWJsZVwiLFxuICAgIFwiaHVtaWRlXCIsXG4gICAgXCJodW1vdXJcIixcbiAgICBcImh1cmxlclwiLFxuICAgIFwiaHlkcm9tZWxcIixcbiAgICBcImh5Z2llzIBuZVwiLFxuICAgIFwiaHltbmVcIixcbiAgICBcImh5cG5vc2VcIixcbiAgICBcImlkeWxsZVwiLFxuICAgIFwiaWdub3JlclwiLFxuICAgIFwiaWd1YW5lXCIsXG4gICAgXCJpbGxpY2l0ZVwiLFxuICAgIFwiaWxsdXNpb25cIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJpbWJpYmVyXCIsXG4gICAgXCJpbWl0ZXJcIixcbiAgICBcImltbWVuc2VcIixcbiAgICBcImltbW9iaWxlXCIsXG4gICAgXCJpbW11YWJsZVwiLFxuICAgIFwiaW1wYWN0XCIsXG4gICAgXCJpbXBlzIFyaWFsXCIsXG4gICAgXCJpbXBsb3JlclwiLFxuICAgIFwiaW1wb3NlclwiLFxuICAgIFwiaW1wcmltZXJcIixcbiAgICBcImltcHV0ZXJcIixcbiAgICBcImluY2FybmVyXCIsXG4gICAgXCJpbmNlbmRpZVwiLFxuICAgIFwiaW5jaWRlbnRcIixcbiAgICBcImluY2xpbmVyXCIsXG4gICAgXCJpbmNvbG9yZVwiLFxuICAgIFwiaW5kZXhlclwiLFxuICAgIFwiaW5kaWNlXCIsXG4gICAgXCJpbmR1Y3RpZlwiLFxuICAgIFwiaW5lzIFkaXRcIixcbiAgICBcImluZXB0aWVcIixcbiAgICBcImluZXhhY3RcIixcbiAgICBcImluZmluaVwiLFxuICAgIFwiaW5mbGlnZXJcIixcbiAgICBcImluZm9ybWVyXCIsXG4gICAgXCJpbmZ1c2lvblwiLFxuICAgIFwiaW5nZcyBcmVyXCIsXG4gICAgXCJpbmhhbGVyXCIsXG4gICAgXCJpbmhpYmVyXCIsXG4gICAgXCJpbmplY3RlclwiLFxuICAgIFwiaW5qdXJlXCIsXG4gICAgXCJpbm5vY2VudFwiLFxuICAgIFwiaW5vY3VsZXJcIixcbiAgICBcImlub25kZXJcIixcbiAgICBcImluc2NyaXJlXCIsXG4gICAgXCJpbnNlY3RlXCIsXG4gICAgXCJpbnNpZ25lXCIsXG4gICAgXCJpbnNvbGl0ZVwiLFxuICAgIFwiaW5zcGlyZXJcIixcbiAgICBcImluc3RpbmN0XCIsXG4gICAgXCJpbnN1bHRlclwiLFxuICAgIFwiaW50YWN0XCIsXG4gICAgXCJpbnRlbnNlXCIsXG4gICAgXCJpbnRpbWVcIixcbiAgICBcImludHJpZ3VlXCIsXG4gICAgXCJpbnR1aXRpZlwiLFxuICAgIFwiaW51dGlsZVwiLFxuICAgIFwiaW52YXNpb25cIixcbiAgICBcImludmVudGVyXCIsXG4gICAgXCJpbnZpdGVyXCIsXG4gICAgXCJpbnZvcXVlclwiLFxuICAgIFwiaXJvbmlxdWVcIixcbiAgICBcImlycmFkaWVyXCIsXG4gICAgXCJpcnJlzIFlbFwiLFxuICAgIFwiaXJyaXRlclwiLFxuICAgIFwiaXNvbGVyXCIsXG4gICAgXCJpdm9pcmVcIixcbiAgICBcIml2cmVzc2VcIixcbiAgICBcImphZ3VhclwiLFxuICAgIFwiamFpbGxpclwiLFxuICAgIFwiamFtYmVcIixcbiAgICBcImphbnZpZXJcIixcbiAgICBcImphcmRpblwiLFxuICAgIFwiamF1Z2VyXCIsXG4gICAgXCJqYXVuZVwiLFxuICAgIFwiamF2ZWxvdFwiLFxuICAgIFwiamV0YWJsZVwiLFxuICAgIFwiamV0b25cIixcbiAgICBcImpldWRpXCIsXG4gICAgXCJqZXVuZXNzZVwiLFxuICAgIFwiam9pbmRyZVwiLFxuICAgIFwiam9uY2hlclwiLFxuICAgIFwiam9uZ2xlclwiLFxuICAgIFwiam91ZXVyXCIsXG4gICAgXCJqb3Vpc3NpZlwiLFxuICAgIFwiam91cm5hbFwiLFxuICAgIFwiam92aWFsXCIsXG4gICAgXCJqb3lhdVwiLFxuICAgIFwiam95ZXV4XCIsXG4gICAgXCJqdWJpbGVyXCIsXG4gICAgXCJqdWdlbWVudFwiLFxuICAgIFwianVuaW9yXCIsXG4gICAgXCJqdXBvblwiLFxuICAgIFwianVyaXN0ZVwiLFxuICAgIFwianVzdGljZVwiLFxuICAgIFwianV0ZXV4XCIsXG4gICAgXCJqdXZlzIFuaWxlXCIsXG4gICAgXCJrYXlha1wiLFxuICAgIFwia2ltb25vXCIsXG4gICAgXCJraW9zcXVlXCIsXG4gICAgXCJsYWJlbFwiLFxuICAgIFwibGFiaWFsXCIsXG4gICAgXCJsYWJvdXJlclwiLFxuICAgIFwibGFjZcyBcmVyXCIsXG4gICAgXCJsYWN0b3NlXCIsXG4gICAgXCJsYWd1bmVcIixcbiAgICBcImxhaW5lXCIsXG4gICAgXCJsYWlzc2VyXCIsXG4gICAgXCJsYWl0aWVyXCIsXG4gICAgXCJsYW1iZWF1XCIsXG4gICAgXCJsYW1lbGxlXCIsXG4gICAgXCJsYW1wZVwiLFxuICAgIFwibGFuY2V1clwiLFxuICAgIFwibGFuZ2FnZVwiLFxuICAgIFwibGFudGVybmVcIixcbiAgICBcImxhcGluXCIsXG4gICAgXCJsYXJnZXVyXCIsXG4gICAgXCJsYXJtZVwiLFxuICAgIFwibGF1cmllclwiLFxuICAgIFwibGF2YWJvXCIsXG4gICAgXCJsYXZvaXJcIixcbiAgICBcImxlY3R1cmVcIixcbiAgICBcImxlzIFnYWxcIixcbiAgICBcImxlzIFnZXJcIixcbiAgICBcImxlzIFndW1lXCIsXG4gICAgXCJsZXNzaXZlXCIsXG4gICAgXCJsZXR0cmVcIixcbiAgICBcImxldmllclwiLFxuICAgIFwibGV4aXF1ZVwiLFxuICAgIFwibGXMgXphcmRcIixcbiAgICBcImxpYXNzZVwiLFxuICAgIFwibGliZcyBcmVyXCIsXG4gICAgXCJsaWJyZVwiLFxuICAgIFwibGljZW5jZVwiLFxuICAgIFwibGljb3JuZVwiLFxuICAgIFwibGllzIBnZVwiLFxuICAgIFwibGllzIB2cmVcIixcbiAgICBcImxpZ2F0dXJlXCIsXG4gICAgXCJsaWdvdGVyXCIsXG4gICAgXCJsaWd1ZVwiLFxuICAgIFwibGltZXJcIixcbiAgICBcImxpbWl0ZVwiLFxuICAgIFwibGltb25hZGVcIixcbiAgICBcImxpbXBpZGVcIixcbiAgICBcImxpbmXMgWFpcmVcIixcbiAgICBcImxpbmdvdFwiLFxuICAgIFwibGlvbmNlYXVcIixcbiAgICBcImxpcXVpZGVcIixcbiAgICBcImxpc2llzIByZVwiLFxuICAgIFwibGlzdGVyXCIsXG4gICAgXCJsaXRoaXVtXCIsXG4gICAgXCJsaXRpZ2VcIixcbiAgICBcImxpdHRvcmFsXCIsXG4gICAgXCJsaXZyZXVyXCIsXG4gICAgXCJsb2dpcXVlXCIsXG4gICAgXCJsb2ludGFpblwiLFxuICAgIFwibG9pc2lyXCIsXG4gICAgXCJsb21icmljXCIsXG4gICAgXCJsb3RlcmllXCIsXG4gICAgXCJsb3VlclwiLFxuICAgIFwibG91cmRcIixcbiAgICBcImxvdXRyZVwiLFxuICAgIFwibG91dmVcIixcbiAgICBcImxveWFsXCIsXG4gICAgXCJsdWJpZVwiLFxuICAgIFwibHVjaWRlXCIsXG4gICAgXCJsdWNyYXRpZlwiLFxuICAgIFwibHVldXJcIixcbiAgICBcImx1Z3VicmVcIixcbiAgICBcImx1aXNhbnRcIixcbiAgICBcImx1bWllzIByZVwiLFxuICAgIFwibHVuYWlyZVwiLFxuICAgIFwibHVuZGlcIixcbiAgICBcImx1cm9uXCIsXG4gICAgXCJsdXR0ZXJcIixcbiAgICBcImx1eHVldXhcIixcbiAgICBcIm1hY2hpbmVcIixcbiAgICBcIm1hZ2FzaW5cIixcbiAgICBcIm1hZ2VudGFcIixcbiAgICBcIm1hZ2lxdWVcIixcbiAgICBcIm1haWdyZVwiLFxuICAgIFwibWFpbGxvblwiLFxuICAgIFwibWFpbnRpZW5cIixcbiAgICBcIm1haXJpZVwiLFxuICAgIFwibWFpc29uXCIsXG4gICAgXCJtYWpvcmVyXCIsXG4gICAgXCJtYWxheGVyXCIsXG4gICAgXCJtYWxlzIFmaWNlXCIsXG4gICAgXCJtYWxoZXVyXCIsXG4gICAgXCJtYWxpY2VcIixcbiAgICBcIm1hbGxldHRlXCIsXG4gICAgXCJtYW1tb3V0aFwiLFxuICAgIFwibWFuZGF0ZXJcIixcbiAgICBcIm1hbmlhYmxlXCIsXG4gICAgXCJtYW5xdWFudFwiLFxuICAgIFwibWFudGVhdVwiLFxuICAgIFwibWFudWVsXCIsXG4gICAgXCJtYXJhdGhvblwiLFxuICAgIFwibWFyYnJlXCIsXG4gICAgXCJtYXJjaGFuZFwiLFxuICAgIFwibWFyZGlcIixcbiAgICBcIm1hcml0aW1lXCIsXG4gICAgXCJtYXJxdWV1clwiLFxuICAgIFwibWFycm9uXCIsXG4gICAgXCJtYXJ0ZWxlclwiLFxuICAgIFwibWFzY290dGVcIixcbiAgICBcIm1hc3NpZlwiLFxuICAgIFwibWF0ZcyBcmllbFwiLFxuICAgIFwibWF0aWXMgHJlXCIsXG4gICAgXCJtYXRyYXF1ZVwiLFxuICAgIFwibWF1ZGlyZVwiLFxuICAgIFwibWF1c3NhZGVcIixcbiAgICBcIm1hdXZlXCIsXG4gICAgXCJtYXhpbWFsXCIsXG4gICAgXCJtZcyBY2hhbnRcIixcbiAgICBcIm1lzIFjb25udVwiLFxuICAgIFwibWXMgWRhaWxsZVwiLFxuICAgIFwibWXMgWRlY2luXCIsXG4gICAgXCJtZcyBZGl0ZXJcIixcbiAgICBcIm1lzIFkdXNlXCIsXG4gICAgXCJtZWlsbGV1clwiLFxuICAgIFwibWXMgWxhbmdlXCIsXG4gICAgXCJtZcyBbG9kaWVcIixcbiAgICBcIm1lbWJyZVwiLFxuICAgIFwibWXMgW1vaXJlXCIsXG4gICAgXCJtZW5hY2VyXCIsXG4gICAgXCJtZW5lclwiLFxuICAgIFwibWVuaGlyXCIsXG4gICAgXCJtZW5zb25nZVwiLFxuICAgIFwibWVudG9yXCIsXG4gICAgXCJtZXJjcmVkaVwiLFxuICAgIFwibWXMgXJpdGVcIixcbiAgICBcIm1lcmxlXCIsXG4gICAgXCJtZXNzYWdlclwiLFxuICAgIFwibWVzdXJlXCIsXG4gICAgXCJtZcyBdGFsXCIsXG4gICAgXCJtZcyBdGXMgW9yZVwiLFxuICAgIFwibWXMgXRob2RlXCIsXG4gICAgXCJtZcyBdGllclwiLFxuICAgIFwibWV1YmxlXCIsXG4gICAgXCJtaWF1bGVyXCIsXG4gICAgXCJtaWNyb2JlXCIsXG4gICAgXCJtaWV0dGVcIixcbiAgICBcIm1pZ25vblwiLFxuICAgIFwibWlncmVyXCIsXG4gICAgXCJtaWxpZXVcIixcbiAgICBcIm1pbGxpb25cIixcbiAgICBcIm1pbWlxdWVcIixcbiAgICBcIm1pbmNlXCIsXG4gICAgXCJtaW5lzIFyYWxcIixcbiAgICBcIm1pbmltYWxcIixcbiAgICBcIm1pbm9yZXJcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwibWlyYWNsZVwiLFxuICAgIFwibWlyb2l0ZXJcIixcbiAgICBcIm1pc3NpbGVcIixcbiAgICBcIm1peHRlXCIsXG4gICAgXCJtb2JpbGVcIixcbiAgICBcIm1vZGVybmVcIixcbiAgICBcIm1vZWxsZXV4XCIsXG4gICAgXCJtb25kaWFsXCIsXG4gICAgXCJtb25pdGV1clwiLFxuICAgIFwibW9ubmFpZVwiLFxuICAgIFwibW9ub3RvbmVcIixcbiAgICBcIm1vbnN0cmVcIixcbiAgICBcIm1vbnRhZ25lXCIsXG4gICAgXCJtb251bWVudFwiLFxuICAgIFwibW9xdWV1clwiLFxuICAgIFwibW9yY2VhdVwiLFxuICAgIFwibW9yc3VyZVwiLFxuICAgIFwibW9ydGllclwiLFxuICAgIFwibW90ZXVyXCIsXG4gICAgXCJtb3RpZlwiLFxuICAgIFwibW91Y2hlXCIsXG4gICAgXCJtb3VmbGVcIixcbiAgICBcIm1vdWxpblwiLFxuICAgIFwibW91c3NvblwiLFxuICAgIFwibW91dG9uXCIsXG4gICAgXCJtb3V2YW50XCIsXG4gICAgXCJtdWx0aXBsZVwiLFxuICAgIFwibXVuaXRpb25cIixcbiAgICBcIm11cmFpbGxlXCIsXG4gICAgXCJtdXJlzIBuZVwiLFxuICAgIFwibXVybXVyZVwiLFxuICAgIFwibXVzY2xlXCIsXG4gICAgXCJtdXNlzIF1bVwiLFxuICAgIFwibXVzaWNpZW5cIixcbiAgICBcIm11dGF0aW9uXCIsXG4gICAgXCJtdXRlclwiLFxuICAgIFwibXV0dWVsXCIsXG4gICAgXCJteXJpYWRlXCIsXG4gICAgXCJteXJ0aWxsZVwiLFxuICAgIFwibXlzdGXMgHJlXCIsXG4gICAgXCJteXRoaXF1ZVwiLFxuICAgIFwibmFnZXVyXCIsXG4gICAgXCJuYXBwZVwiLFxuICAgIFwibmFycXVvaXNcIixcbiAgICBcIm5hcnJlclwiLFxuICAgIFwibmF0YXRpb25cIixcbiAgICBcIm5hdGlvblwiLFxuICAgIFwibmF0dXJlXCIsXG4gICAgXCJuYXVmcmFnZVwiLFxuICAgIFwibmF1dGlxdWVcIixcbiAgICBcIm5hdmlyZVwiLFxuICAgIFwibmXMgWJ1bGV1eFwiLFxuICAgIFwibmVjdGFyXCIsXG4gICAgXCJuZcyBZmFzdGVcIixcbiAgICBcIm5lzIFnYXRpb25cIixcbiAgICBcIm5lzIFnbGlnZXJcIixcbiAgICBcIm5lzIFnb2NpZXJcIixcbiAgICBcIm5laWdlXCIsXG4gICAgXCJuZXJ2ZXV4XCIsXG4gICAgXCJuZXR0b3llclwiLFxuICAgIFwibmV1cm9uZVwiLFxuICAgIFwibmV1dHJvblwiLFxuICAgIFwibmV2ZXVcIixcbiAgICBcIm5pY2hlXCIsXG4gICAgXCJuaWNrZWxcIixcbiAgICBcIm5pdHJhdGVcIixcbiAgICBcIm5pdmVhdVwiLFxuICAgIFwibm9ibGVcIixcbiAgICBcIm5vY2lmXCIsXG4gICAgXCJub2N0dXJuZVwiLFxuICAgIFwibm9pcmNldXJcIixcbiAgICBcIm5vaXNldHRlXCIsXG4gICAgXCJub21hZGVcIixcbiAgICBcIm5vbWJyZXV4XCIsXG4gICAgXCJub21tZXJcIixcbiAgICBcIm5vcm1hdGlmXCIsXG4gICAgXCJub3RhYmxlXCIsXG4gICAgXCJub3RpZmllclwiLFxuICAgIFwibm90b2lyZVwiLFxuICAgIFwibm91cnJpclwiLFxuICAgIFwibm91dmVhdVwiLFxuICAgIFwibm92YXRldXJcIixcbiAgICBcIm5vdmVtYnJlXCIsXG4gICAgXCJub3ZpY2VcIixcbiAgICBcIm51YWdlXCIsXG4gICAgXCJudWFuY2VyXCIsXG4gICAgXCJudWlyZVwiLFxuICAgIFwibnVpc2libGVcIixcbiAgICBcIm51bWXMgXJvXCIsXG4gICAgXCJudXB0aWFsXCIsXG4gICAgXCJudXF1ZVwiLFxuICAgIFwibnV0cml0aWZcIixcbiAgICBcIm9iZcyBaXJcIixcbiAgICBcIm9iamVjdGlmXCIsXG4gICAgXCJvYmxpZ2VyXCIsXG4gICAgXCJvYnNjdXJcIixcbiAgICBcIm9ic2VydmVyXCIsXG4gICAgXCJvYnN0YWNsZVwiLFxuICAgIFwib2J0ZW5pclwiLFxuICAgIFwib2J0dXJlclwiLFxuICAgIFwib2NjYXNpb25cIixcbiAgICBcIm9jY3VwZXJcIixcbiAgICBcIm9jZcyBYW5cIixcbiAgICBcIm9jdG9icmVcIixcbiAgICBcIm9jdHJveWVyXCIsXG4gICAgXCJvY3R1cGxlclwiLFxuICAgIFwib2N1bGFpcmVcIixcbiAgICBcIm9kZXVyXCIsXG4gICAgXCJvZG9yYW50XCIsXG4gICAgXCJvZmZlbnNlclwiLFxuICAgIFwib2ZmaWNpZXJcIixcbiAgICBcIm9mZnJpclwiLFxuICAgIFwib2dpdmVcIixcbiAgICBcIm9pc2VhdVwiLFxuICAgIFwib2lzaWxsb25cIixcbiAgICBcIm9sZmFjdGlmXCIsXG4gICAgXCJvbGl2aWVyXCIsXG4gICAgXCJvbWJyYWdlXCIsXG4gICAgXCJvbWV0dHJlXCIsXG4gICAgXCJvbmN0dWV1eFwiLFxuICAgIFwib25kdWxlclwiLFxuICAgIFwib25lzIFyZXV4XCIsXG4gICAgXCJvbmlyaXF1ZVwiLFxuICAgIFwib3BhbGVcIixcbiAgICBcIm9wYXF1ZVwiLFxuICAgIFwib3BlzIFyZXJcIixcbiAgICBcIm9waW5pb25cIixcbiAgICBcIm9wcG9ydHVuXCIsXG4gICAgXCJvcHByaW1lclwiLFxuICAgIFwib3B0ZXJcIixcbiAgICBcIm9wdGlxdWVcIixcbiAgICBcIm9yYWdldXhcIixcbiAgICBcIm9yYW5nZVwiLFxuICAgIFwib3JiaXRlXCIsXG4gICAgXCJvcmRvbm5lclwiLFxuICAgIFwib3JlaWxsZVwiLFxuICAgIFwib3JnYW5lXCIsXG4gICAgXCJvcmd1ZWlsXCIsXG4gICAgXCJvcmlmaWNlXCIsXG4gICAgXCJvcm5lbWVudFwiLFxuICAgIFwib3JxdWVcIixcbiAgICBcIm9ydGllXCIsXG4gICAgXCJvc2NpbGxlclwiLFxuICAgIFwib3Ntb3NlXCIsXG4gICAgXCJvc3NhdHVyZVwiLFxuICAgIFwib3RhcmllXCIsXG4gICAgXCJvdXJhZ2FuXCIsXG4gICAgXCJvdXJzb25cIixcbiAgICBcIm91dGlsXCIsXG4gICAgXCJvdXRyYWdlclwiLFxuICAgIFwib3V2cmFnZVwiLFxuICAgIFwib3ZhdGlvblwiLFxuICAgIFwib3h5ZGVcIixcbiAgICBcIm94eWdlzIBuZVwiLFxuICAgIFwib3pvbmVcIixcbiAgICBcInBhaXNpYmxlXCIsXG4gICAgXCJwYWxhY2VcIixcbiAgICBcInBhbG1hcmXMgHNcIixcbiAgICBcInBhbG91cmRlXCIsXG4gICAgXCJwYWxwZXJcIixcbiAgICBcInBhbmFjaGVcIixcbiAgICBcInBhbmRhXCIsXG4gICAgXCJwYW5nb2xpblwiLFxuICAgIFwicGFuaXF1ZXJcIixcbiAgICBcInBhbm5lYXVcIixcbiAgICBcInBhbm9yYW1hXCIsXG4gICAgXCJwYW50YWxvblwiLFxuICAgIFwicGFwYXllXCIsXG4gICAgXCJwYXBpZXJcIixcbiAgICBcInBhcG90ZXJcIixcbiAgICBcInBhcHlydXNcIixcbiAgICBcInBhcmFkb3hlXCIsXG4gICAgXCJwYXJjZWxsZVwiLFxuICAgIFwicGFyZXNzZVwiLFxuICAgIFwicGFyZnVtZXJcIixcbiAgICBcInBhcmxlclwiLFxuICAgIFwicGFyb2xlXCIsXG4gICAgXCJwYXJyYWluXCIsXG4gICAgXCJwYXJzZW1lclwiLFxuICAgIFwicGFydGFnZXJcIixcbiAgICBcInBhcnVyZVwiLFxuICAgIFwicGFydmVuaXJcIixcbiAgICBcInBhc3Npb25cIixcbiAgICBcInBhc3RlzIBxdWVcIixcbiAgICBcInBhdGVybmVsXCIsXG4gICAgXCJwYXRpZW5jZVwiLFxuICAgIFwicGF0cm9uXCIsXG4gICAgXCJwYXZpbGxvblwiLFxuICAgIFwicGF2b2lzZXJcIixcbiAgICBcInBheWVyXCIsXG4gICAgXCJwYXlzYWdlXCIsXG4gICAgXCJwZWlnbmVcIixcbiAgICBcInBlaW50cmVcIixcbiAgICBcInBlbGFnZVwiLFxuICAgIFwicGXMgWxpY2FuXCIsXG4gICAgXCJwZWxsZVwiLFxuICAgIFwicGVsb3VzZVwiLFxuICAgIFwicGVsdWNoZVwiLFxuICAgIFwicGVuZHVsZVwiLFxuICAgIFwicGXMgW5lzIF0cmVyXCIsXG4gICAgXCJwZcyBbmlibGVcIixcbiAgICBcInBlbnNpZlwiLFxuICAgIFwicGXMgW51cmllXCIsXG4gICAgXCJwZcyBcGl0ZVwiLFxuICAgIFwicGXMgXBsdW1cIixcbiAgICBcInBlcmRyaXhcIixcbiAgICBcInBlcmZvcmVyXCIsXG4gICAgXCJwZcyBcmlvZGVcIixcbiAgICBcInBlcm11dGVyXCIsXG4gICAgXCJwZXJwbGV4ZVwiLFxuICAgIFwicGVyc2lsXCIsXG4gICAgXCJwZXJ0ZVwiLFxuICAgIFwicGVzZXJcIixcbiAgICBcInBlzIF0YWxlXCIsXG4gICAgXCJwZXRpdFwiLFxuICAgIFwicGXMgXRyaXJcIixcbiAgICBcInBldXBsZVwiLFxuICAgIFwicGhhcmFvblwiLFxuICAgIFwicGhvYmllXCIsXG4gICAgXCJwaG9xdWVcIixcbiAgICBcInBob3RvblwiLFxuICAgIFwicGhyYXNlXCIsXG4gICAgXCJwaHlzaXF1ZVwiLFxuICAgIFwicGlhbm9cIixcbiAgICBcInBpY3R1cmFsXCIsXG4gICAgXCJwaWXMgGNlXCIsXG4gICAgXCJwaWVycmVcIixcbiAgICBcInBpZXV2cmVcIixcbiAgICBcInBpbG90ZVwiLFxuICAgIFwicGluY2VhdVwiLFxuICAgIFwicGlwZXR0ZVwiLFxuICAgIFwicGlxdWVyXCIsXG4gICAgXCJwaXJvZ3VlXCIsXG4gICAgXCJwaXNjaW5lXCIsXG4gICAgXCJwaXN0b25cIixcbiAgICBcInBpdm90ZXJcIixcbiAgICBcInBpeGVsXCIsXG4gICAgXCJwaXp6YVwiLFxuICAgIFwicGxhY2FyZFwiLFxuICAgIFwicGxhZm9uZFwiLFxuICAgIFwicGxhaXNpclwiLFxuICAgIFwicGxhbmVyXCIsXG4gICAgXCJwbGFxdWVcIixcbiAgICBcInBsYXN0cm9uXCIsXG4gICAgXCJwbGF0ZWF1XCIsXG4gICAgXCJwbGV1cmVyXCIsXG4gICAgXCJwbGV4dXNcIixcbiAgICBcInBsaWFnZVwiLFxuICAgIFwicGxvbWJcIixcbiAgICBcInBsb25nZXJcIixcbiAgICBcInBsdWllXCIsXG4gICAgXCJwbHVtYWdlXCIsXG4gICAgXCJwb2NoZXR0ZVwiLFxuICAgIFwicG9lzIFzaWVcIixcbiAgICBcInBvZcyAdGVcIixcbiAgICBcInBvaW50ZVwiLFxuICAgIFwicG9pcmllclwiLFxuICAgIFwicG9pc3NvblwiLFxuICAgIFwicG9pdnJlXCIsXG4gICAgXCJwb2xhaXJlXCIsXG4gICAgXCJwb2xpY2llclwiLFxuICAgIFwicG9sbGVuXCIsXG4gICAgXCJwb2x5Z29uZVwiLFxuICAgIFwicG9tbWFkZVwiLFxuICAgIFwicG9tcGllclwiLFxuICAgIFwicG9uY3R1ZWxcIixcbiAgICBcInBvbmRlzIFyZXJcIixcbiAgICBcInBvbmV5XCIsXG4gICAgXCJwb3J0aXF1ZVwiLFxuICAgIFwicG9zaXRpb25cIixcbiAgICBcInBvc3NlzIFkZXJcIixcbiAgICBcInBvc3R1cmVcIixcbiAgICBcInBvdGFnZXJcIixcbiAgICBcInBvdGVhdVwiLFxuICAgIFwicG90aW9uXCIsXG4gICAgXCJwb3VjZVwiLFxuICAgIFwicG91bGFpblwiLFxuICAgIFwicG91bW9uXCIsXG4gICAgXCJwb3VycHJlXCIsXG4gICAgXCJwb3Vzc2luXCIsXG4gICAgXCJwb3V2b2lyXCIsXG4gICAgXCJwcmFpcmllXCIsXG4gICAgXCJwcmF0aXF1ZVwiLFxuICAgIFwicHJlzIFjaWV1eFwiLFxuICAgIFwicHJlzIFkaXJlXCIsXG4gICAgXCJwcmXMgWZpeGVcIixcbiAgICBcInByZcyBbHVkZVwiLFxuICAgIFwicHJlzIFub21cIixcbiAgICBcInByZcyBc2VuY2VcIixcbiAgICBcInByZcyBdGV4dGVcIixcbiAgICBcInByZcyBdm9pclwiLFxuICAgIFwicHJpbWl0aWZcIixcbiAgICBcInByaW5jZVwiLFxuICAgIFwicHJpc29uXCIsXG4gICAgXCJwcml2ZXJcIixcbiAgICBcInByb2JsZcyAbWVcIixcbiAgICBcInByb2NlzIFkZXJcIixcbiAgICBcInByb2RpZ2VcIixcbiAgICBcInByb2ZvbmRcIixcbiAgICBcInByb2dyZcyAc1wiLFxuICAgIFwicHJvaWVcIixcbiAgICBcInByb2pldGVyXCIsXG4gICAgXCJwcm9sb2d1ZVwiLFxuICAgIFwicHJvbWVuZXJcIixcbiAgICBcInByb3ByZVwiLFxuICAgIFwicHJvc3BlzIByZVwiLFxuICAgIFwicHJvdGXMgWdlclwiLFxuICAgIFwicHJvdWVzc2VcIixcbiAgICBcInByb3ZlcmJlXCIsXG4gICAgXCJwcnVkZW5jZVwiLFxuICAgIFwicHJ1bmVhdVwiLFxuICAgIFwicHN5Y2hvc2VcIixcbiAgICBcInB1YmxpY1wiLFxuICAgIFwicHVjZXJvblwiLFxuICAgIFwicHVpc2VyXCIsXG4gICAgXCJwdWxwZVwiLFxuICAgIFwicHVsc2FyXCIsXG4gICAgXCJwdW5haXNlXCIsXG4gICAgXCJwdW5pdGlmXCIsXG4gICAgXCJwdXBpdHJlXCIsXG4gICAgXCJwdXJpZmllclwiLFxuICAgIFwicHV6emxlXCIsXG4gICAgXCJweXJhbWlkZVwiLFxuICAgIFwicXVhc2FyXCIsXG4gICAgXCJxdWVyZWxsZVwiLFxuICAgIFwicXVlc3Rpb25cIixcbiAgICBcInF1aWXMgXR1ZGVcIixcbiAgICBcInF1aXR0ZXJcIixcbiAgICBcInF1b3RpZW50XCIsXG4gICAgXCJyYWNpbmVcIixcbiAgICBcInJhY29udGVyXCIsXG4gICAgXCJyYWRpZXV4XCIsXG4gICAgXCJyYWdvbmRpblwiLFxuICAgIFwicmFpZGV1clwiLFxuICAgIFwicmFpc2luXCIsXG4gICAgXCJyYWxlbnRpclwiLFxuICAgIFwicmFsbG9uZ2VcIixcbiAgICBcInJhbWFzc2VyXCIsXG4gICAgXCJyYXBpZGVcIixcbiAgICBcInJhc2FnZVwiLFxuICAgIFwicmF0aXNzZXJcIixcbiAgICBcInJhdmFnZXJcIixcbiAgICBcInJhdmluXCIsXG4gICAgXCJyYXlvbm5lclwiLFxuICAgIFwicmXMgWFjdGlmXCIsXG4gICAgXCJyZcyBYWdpclwiLFxuICAgIFwicmXMgWFsaXNlclwiLFxuICAgIFwicmXMgWFuaW1lclwiLFxuICAgIFwicmVjZXZvaXJcIixcbiAgICBcInJlzIFjaXRlclwiLFxuICAgIFwicmXMgWNsYW1lclwiLFxuICAgIFwicmXMgWNvbHRlclwiLFxuICAgIFwicmVjcnV0ZXJcIixcbiAgICBcInJlY3VsZXJcIixcbiAgICBcInJlY3ljbGVyXCIsXG4gICAgXCJyZcyBZGlnZXJcIixcbiAgICBcInJlZG91dGVyXCIsXG4gICAgXCJyZWZhaXJlXCIsXG4gICAgXCJyZcyBZmxleGVcIixcbiAgICBcInJlzIFmb3JtZXJcIixcbiAgICBcInJlZnJhaW5cIixcbiAgICBcInJlZnVnZVwiLFxuICAgIFwicmXMgWdhbGllblwiLFxuICAgIFwicmXMgWdpb25cIixcbiAgICBcInJlzIFnbGFnZVwiLFxuICAgIFwicmXMgWd1bGllclwiLFxuICAgIFwicmXMgWl0ZcyBcmVyXCIsXG4gICAgXCJyZWpldGVyXCIsXG4gICAgXCJyZWpvdWVyXCIsXG4gICAgXCJyZWxhdGlmXCIsXG4gICAgXCJyZWxldmVyXCIsXG4gICAgXCJyZWxpZWZcIixcbiAgICBcInJlbWFycXVlXCIsXG4gICAgXCJyZW1lzIBkZVwiLFxuICAgIFwicmVtaXNlXCIsXG4gICAgXCJyZW1vbnRlclwiLFxuICAgIFwicmVtcGxpclwiLFxuICAgIFwicmVtdWVyXCIsXG4gICAgXCJyZW5hcmRcIixcbiAgICBcInJlbmZvcnRcIixcbiAgICBcInJlbmlmbGVyXCIsXG4gICAgXCJyZW5vbmNlclwiLFxuICAgIFwicmVudHJlclwiLFxuICAgIFwicmVudm9pXCIsXG4gICAgXCJyZXBsaWVyXCIsXG4gICAgXCJyZXBvcnRlclwiLFxuICAgIFwicmVwcmlzZVwiLFxuICAgIFwicmVwdGlsZVwiLFxuICAgIFwicmVxdWluXCIsXG4gICAgXCJyZcyBc2VydmVcIixcbiAgICBcInJlzIFzaW5ldXhcIixcbiAgICBcInJlzIFzb3VkcmVcIixcbiAgICBcInJlc3BlY3RcIixcbiAgICBcInJlc3RlclwiLFxuICAgIFwicmXMgXN1bHRhdFwiLFxuICAgIFwicmXMgXRhYmxpclwiLFxuICAgIFwicmV0ZW5pclwiLFxuICAgIFwicmXMgXRpY3VsZVwiLFxuICAgIFwicmV0b21iZXJcIixcbiAgICBcInJldHJhY2VyXCIsXG4gICAgXCJyZcyBdW5pb25cIixcbiAgICBcInJlzIF1c3NpclwiLFxuICAgIFwicmV2YW5jaGVcIixcbiAgICBcInJldml2cmVcIixcbiAgICBcInJlzIF2b2x0ZVwiLFxuICAgIFwicmXMgXZ1bHNpZlwiLFxuICAgIFwicmljaGVzc2VcIixcbiAgICBcInJpZGVhdVwiLFxuICAgIFwicmlldXJcIixcbiAgICBcInJpZ2lkZVwiLFxuICAgIFwicmlnb2xlclwiLFxuICAgIFwicmluY2VyXCIsXG4gICAgXCJyaXBvc3RlclwiLFxuICAgIFwicmlzaWJsZVwiLFxuICAgIFwicmlzcXVlXCIsXG4gICAgXCJyaXR1ZWxcIixcbiAgICBcInJpdmFsXCIsXG4gICAgXCJyaXZpZcyAcmVcIixcbiAgICBcInJvY2hldXhcIixcbiAgICBcInJvbWFuY2VcIixcbiAgICBcInJvbXByZVwiLFxuICAgIFwicm9uY2VcIixcbiAgICBcInJvbmRpblwiLFxuICAgIFwicm9zZWF1XCIsXG4gICAgXCJyb3NpZXJcIixcbiAgICBcInJvdGF0aWZcIixcbiAgICBcInJvdG9yXCIsXG4gICAgXCJyb3R1bGVcIixcbiAgICBcInJvdWdlXCIsXG4gICAgXCJyb3VpbGxlXCIsXG4gICAgXCJyb3VsZWF1XCIsXG4gICAgXCJyb3V0aW5lXCIsXG4gICAgXCJyb3lhdW1lXCIsXG4gICAgXCJydWJhblwiLFxuICAgIFwicnViaXNcIixcbiAgICBcInJ1Y2hlXCIsXG4gICAgXCJydWVsbGVcIixcbiAgICBcInJ1Z3VldXhcIixcbiAgICBcInJ1aW5lclwiLFxuICAgIFwicnVpc3NlYXVcIixcbiAgICBcInJ1c2VyXCIsXG4gICAgXCJydXN0aXF1ZVwiLFxuICAgIFwicnl0aG1lXCIsXG4gICAgXCJzYWJsZXJcIixcbiAgICBcInNhYm90ZXJcIixcbiAgICBcInNhYnJlXCIsXG4gICAgXCJzYWNvY2hlXCIsXG4gICAgXCJzYWZhcmlcIixcbiAgICBcInNhZ2Vzc2VcIixcbiAgICBcInNhaXNpclwiLFxuICAgIFwic2FsYWRlXCIsXG4gICAgXCJzYWxpdmVcIixcbiAgICBcInNhbG9uXCIsXG4gICAgXCJzYWx1ZXJcIixcbiAgICBcInNhbWVkaVwiLFxuICAgIFwic2FuY3Rpb25cIixcbiAgICBcInNhbmdsaWVyXCIsXG4gICAgXCJzYXJjYXNtZVwiLFxuICAgIFwic2FyZGluZVwiLFxuICAgIFwic2F0dXJlclwiLFxuICAgIFwic2F1Z3JlbnVcIixcbiAgICBcInNhdW1vblwiLFxuICAgIFwic2F1dGVyXCIsXG4gICAgXCJzYXV2YWdlXCIsXG4gICAgXCJzYXZhbnRcIixcbiAgICBcInNhdm9ubmVyXCIsXG4gICAgXCJzY2FscGVsXCIsXG4gICAgXCJzY2FuZGFsZVwiLFxuICAgIFwic2NlzIFsZcyBcmF0XCIsXG4gICAgXCJzY2XMgW5hcmlvXCIsXG4gICAgXCJzY2VwdHJlXCIsXG4gICAgXCJzY2hlzIFtYVwiLFxuICAgIFwic2NpZW5jZVwiLFxuICAgIFwic2NpbmRlclwiLFxuICAgIFwic2NvcmVcIixcbiAgICBcInNjcnV0aW5cIixcbiAgICBcInNjdWxwdGVyXCIsXG4gICAgXCJzZcyBYW5jZVwiLFxuICAgIFwic2XMgWNhYmxlXCIsXG4gICAgXCJzZcyBY2hlclwiLFxuICAgIFwic2Vjb3VlclwiLFxuICAgIFwic2XMgWNyZcyBdGVyXCIsXG4gICAgXCJzZcyBZGF0aWZcIixcbiAgICBcInNlzIFkdWlyZVwiLFxuICAgIFwic2VpZ25ldXJcIixcbiAgICBcInNlzIFqb3VyXCIsXG4gICAgXCJzZcyBbGVjdGlmXCIsXG4gICAgXCJzZW1haW5lXCIsXG4gICAgXCJzZW1ibGVyXCIsXG4gICAgXCJzZW1lbmNlXCIsXG4gICAgXCJzZcyBbWluYWxcIixcbiAgICBcInNlzIFuYXRldXJcIixcbiAgICBcInNlbnNpYmxlXCIsXG4gICAgXCJzZW50ZW5jZVwiLFxuICAgIFwic2XMgXBhcmVyXCIsXG4gICAgXCJzZcyBcXVlbmNlXCIsXG4gICAgXCJzZXJlaW5cIixcbiAgICBcInNlcmdlbnRcIixcbiAgICBcInNlzIFyaWV1eFwiLFxuICAgIFwic2VycnVyZVwiLFxuICAgIFwic2XMgXJ1bVwiLFxuICAgIFwic2VydmljZVwiLFxuICAgIFwic2XMgXNhbWVcIixcbiAgICBcInNlzIF2aXJcIixcbiAgICBcInNldnJhZ2VcIixcbiAgICBcInNleHR1cGxlXCIsXG4gICAgXCJzaWRlzIFyYWxcIixcbiAgICBcInNpZcyAY2xlXCIsXG4gICAgXCJzaWXMgWdlclwiLFxuICAgIFwic2lmZmxlclwiLFxuICAgIFwic2lnbGVcIixcbiAgICBcInNpZ25hbFwiLFxuICAgIFwic2lsZW5jZVwiLFxuICAgIFwic2lsaWNpdW1cIixcbiAgICBcInNpbXBsZVwiLFxuICAgIFwic2luY2XMgHJlXCIsXG4gICAgXCJzaW5pc3RyZVwiLFxuICAgIFwic2lwaG9uXCIsXG4gICAgXCJzaXJvcFwiLFxuICAgIFwic2lzbWlxdWVcIixcbiAgICBcInNpdHVlclwiLFxuICAgIFwic2tpZXJcIixcbiAgICBcInNvY2lhbFwiLFxuICAgIFwic29jbGVcIixcbiAgICBcInNvZGl1bVwiLFxuICAgIFwic29pZ25ldXhcIixcbiAgICBcInNvbGRhdFwiLFxuICAgIFwic29sZWlsXCIsXG4gICAgXCJzb2xpdHVkZVwiLFxuICAgIFwic29sdWJsZVwiLFxuICAgIFwic29tYnJlXCIsXG4gICAgXCJzb21tZWlsXCIsXG4gICAgXCJzb21ub2xlclwiLFxuICAgIFwic29uZGVcIixcbiAgICBcInNvbmdldXJcIixcbiAgICBcInNvbm5ldHRlXCIsXG4gICAgXCJzb25vcmVcIixcbiAgICBcInNvcmNpZXJcIixcbiAgICBcInNvcnRpclwiLFxuICAgIFwic29zaWVcIixcbiAgICBcInNvdHRpc2VcIixcbiAgICBcInNvdWNpZXV4XCIsXG4gICAgXCJzb3VkdXJlXCIsXG4gICAgXCJzb3VmZmxlXCIsXG4gICAgXCJzb3VsZXZlclwiLFxuICAgIFwic291cGFwZVwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJzb3V0aXJlclwiLFxuICAgIFwic291dmVuaXJcIixcbiAgICBcInNwYWNpZXV4XCIsXG4gICAgXCJzcGF0aWFsXCIsXG4gICAgXCJzcGXMgWNpYWxcIixcbiAgICBcInNwaGXMgHJlXCIsXG4gICAgXCJzcGlyYWxcIixcbiAgICBcInN0YWJsZVwiLFxuICAgIFwic3RhdGlvblwiLFxuICAgIFwic3Rlcm51bVwiLFxuICAgIFwic3RpbXVsdXNcIixcbiAgICBcInN0aXB1bGVyXCIsXG4gICAgXCJzdHJpY3RcIixcbiAgICBcInN0dWRpZXV4XCIsXG4gICAgXCJzdHVwZXVyXCIsXG4gICAgXCJzdHlsaXN0ZVwiLFxuICAgIFwic3VibGltZVwiLFxuICAgIFwic3Vic3RyYXRcIixcbiAgICBcInN1YnRpbFwiLFxuICAgIFwic3VidmVuaXJcIixcbiAgICBcInN1Y2NlzIBzXCIsXG4gICAgXCJzdWNyZVwiLFxuICAgIFwic3VmZml4ZVwiLFxuICAgIFwic3VnZ2XMgXJlclwiLFxuICAgIFwic3VpdmV1clwiLFxuICAgIFwic3VsZmF0ZVwiLFxuICAgIFwic3VwZXJiZVwiLFxuICAgIFwic3VwcGxpZXJcIixcbiAgICBcInN1cmZhY2VcIixcbiAgICBcInN1cmljYXRlXCIsXG4gICAgXCJzdXJtZW5lclwiLFxuICAgIFwic3VycHJpc2VcIixcbiAgICBcInN1cnNhdXRcIixcbiAgICBcInN1cnZpZVwiLFxuICAgIFwic3VzcGVjdFwiLFxuICAgIFwic3lsbGFiZVwiLFxuICAgIFwic3ltYm9sZVwiLFxuICAgIFwic3ltZcyBdHJpZVwiLFxuICAgIFwic3luYXBzZVwiLFxuICAgIFwic3ludGF4ZVwiLFxuICAgIFwic3lzdGXMgG1lXCIsXG4gICAgXCJ0YWJhY1wiLFxuICAgIFwidGFibGllclwiLFxuICAgIFwidGFjdGlsZVwiLFxuICAgIFwidGFpbGxlclwiLFxuICAgIFwidGFsZW50XCIsXG4gICAgXCJ0YWxpc21hblwiLFxuICAgIFwidGFsb25uZXJcIixcbiAgICBcInRhbWJvdXJcIixcbiAgICBcInRhbWlzZXJcIixcbiAgICBcInRhbmdpYmxlXCIsXG4gICAgXCJ0YXBpc1wiLFxuICAgIFwidGFxdWluZXJcIixcbiAgICBcInRhcmRlclwiLFxuICAgIFwidGFyaWZcIixcbiAgICBcInRhcnRpbmVcIixcbiAgICBcInRhc3NlXCIsXG4gICAgXCJ0YXRhbWlcIixcbiAgICBcInRhdG91YWdlXCIsXG4gICAgXCJ0YXVwZVwiLFxuICAgIFwidGF1cmVhdVwiLFxuICAgIFwidGF4ZXJcIixcbiAgICBcInRlzIFtb2luXCIsXG4gICAgXCJ0ZW1wb3JlbFwiLFxuICAgIFwidGVuYWlsbGVcIixcbiAgICBcInRlbmRyZVwiLFxuICAgIFwidGVuZXVyXCIsXG4gICAgXCJ0ZW5pclwiLFxuICAgIFwidGVuc2lvblwiLFxuICAgIFwidGVybWluZXJcIixcbiAgICBcInRlcm5lXCIsXG4gICAgXCJ0ZXJyaWJsZVwiLFxuICAgIFwidGXMgXRpbmVcIixcbiAgICBcInRleHRlXCIsXG4gICAgXCJ0aGXMgG1lXCIsXG4gICAgXCJ0aGXMgW9yaWVcIixcbiAgICBcInRoZcyBcmFwaWVcIixcbiAgICBcInRob3JheFwiLFxuICAgIFwidGliaWFcIixcbiAgICBcInRpZcyAZGVcIixcbiAgICBcInRpbWlkZVwiLFxuICAgIFwidGlyZWxpcmVcIixcbiAgICBcInRpcm9pclwiLFxuICAgIFwidGlzc3VcIixcbiAgICBcInRpdGFuZVwiLFxuICAgIFwidGl0cmVcIixcbiAgICBcInRpdHViZXJcIixcbiAgICBcInRvYm9nZ2FuXCIsXG4gICAgXCJ0b2xlzIFyYW50XCIsXG4gICAgXCJ0b21hdGVcIixcbiAgICBcInRvbmlxdWVcIixcbiAgICBcInRvbm5lYXVcIixcbiAgICBcInRvcG9ueW1lXCIsXG4gICAgXCJ0b3JjaGVcIixcbiAgICBcInRvcmRyZVwiLFxuICAgIFwidG9ybmFkZVwiLFxuICAgIFwidG9ycGlsbGVcIixcbiAgICBcInRvcnJlbnRcIixcbiAgICBcInRvcnNlXCIsXG4gICAgXCJ0b3J0dWVcIixcbiAgICBcInRvdGVtXCIsXG4gICAgXCJ0b3VjaGVyXCIsXG4gICAgXCJ0b3VybmFnZVwiLFxuICAgIFwidG91c3NlclwiLFxuICAgIFwidG94aW5lXCIsXG4gICAgXCJ0cmFjdGlvblwiLFxuICAgIFwidHJhZmljXCIsXG4gICAgXCJ0cmFnaXF1ZVwiLFxuICAgIFwidHJhaGlyXCIsXG4gICAgXCJ0cmFpblwiLFxuICAgIFwidHJhbmNoZXJcIixcbiAgICBcInRyYXZhaWxcIixcbiAgICBcInRyZcyAZmxlXCIsXG4gICAgXCJ0cmVtcGVyXCIsXG4gICAgXCJ0cmXMgXNvclwiLFxuICAgIFwidHJldWlsXCIsXG4gICAgXCJ0cmlhZ2VcIixcbiAgICBcInRyaWJ1bmFsXCIsXG4gICAgXCJ0cmljb3RlclwiLFxuICAgIFwidHJpbG9naWVcIixcbiAgICBcInRyaW9tcGhlXCIsXG4gICAgXCJ0cmlwbGVyXCIsXG4gICAgXCJ0cml0dXJlclwiLFxuICAgIFwidHJpdmlhbFwiLFxuICAgIFwidHJvbWJvbmVcIixcbiAgICBcInRyb25jXCIsXG4gICAgXCJ0cm9waWNhbFwiLFxuICAgIFwidHJvdXBlYXVcIixcbiAgICBcInR1aWxlXCIsXG4gICAgXCJ0dWxpcGVcIixcbiAgICBcInR1bXVsdGVcIixcbiAgICBcInR1bm5lbFwiLFxuICAgIFwidHVyYmluZVwiLFxuICAgIFwidHV0ZXVyXCIsXG4gICAgXCJ0dXRveWVyXCIsXG4gICAgXCJ0dXlhdVwiLFxuICAgIFwidHltcGFuXCIsXG4gICAgXCJ0eXBob25cIixcbiAgICBcInR5cGlxdWVcIixcbiAgICBcInR5cmFuXCIsXG4gICAgXCJ1YnVlc3F1ZVwiLFxuICAgIFwidWx0aW1lXCIsXG4gICAgXCJ1bHRyYXNvblwiLFxuICAgIFwidW5hbmltZVwiLFxuICAgIFwidW5pZmllclwiLFxuICAgIFwidW5pb25cIixcbiAgICBcInVuaXF1ZVwiLFxuICAgIFwidW5pdGFpcmVcIixcbiAgICBcInVuaXZlcnNcIixcbiAgICBcInVyYW5pdW1cIixcbiAgICBcInVyYmFpblwiLFxuICAgIFwidXJ0aWNhbnRcIixcbiAgICBcInVzYWdlXCIsXG4gICAgXCJ1c2luZVwiLFxuICAgIFwidXN1ZWxcIixcbiAgICBcInVzdXJlXCIsXG4gICAgXCJ1dGlsZVwiLFxuICAgIFwidXRvcGllXCIsXG4gICAgXCJ2YWNhcm1lXCIsXG4gICAgXCJ2YWNjaW5cIixcbiAgICBcInZhZ2Fib25kXCIsXG4gICAgXCJ2YWd1ZVwiLFxuICAgIFwidmFpbGxhbnRcIixcbiAgICBcInZhaW5jcmVcIixcbiAgICBcInZhaXNzZWF1XCIsXG4gICAgXCJ2YWxhYmxlXCIsXG4gICAgXCJ2YWxpc2VcIixcbiAgICBcInZhbGxvblwiLFxuICAgIFwidmFsdmVcIixcbiAgICBcInZhbXBpcmVcIixcbiAgICBcInZhbmlsbGVcIixcbiAgICBcInZhcGV1clwiLFxuICAgIFwidmFyaWVyXCIsXG4gICAgXCJ2YXNldXhcIixcbiAgICBcInZhc3NhbFwiLFxuICAgIFwidmFzdGVcIixcbiAgICBcInZlY3RldXJcIixcbiAgICBcInZlZGV0dGVcIixcbiAgICBcInZlzIFnZcyBdGFsXCIsXG4gICAgXCJ2ZcyBaGljdWxlXCIsXG4gICAgXCJ2ZWluYXJkXCIsXG4gICAgXCJ2ZcyBbG9jZVwiLFxuICAgIFwidmVuZHJlZGlcIixcbiAgICBcInZlzIFuZcyBcmVyXCIsXG4gICAgXCJ2ZW5nZXJcIixcbiAgICBcInZlbmltZXV4XCIsXG4gICAgXCJ2ZW50b3VzZVwiLFxuICAgIFwidmVyZHVyZVwiLFxuICAgIFwidmXMgXJpblwiLFxuICAgIFwidmVybmlyXCIsXG4gICAgXCJ2ZXJyb3VcIixcbiAgICBcInZlcnNlclwiLFxuICAgIFwidmVydHVcIixcbiAgICBcInZlc3RvblwiLFxuICAgIFwidmXMgXRlzIFyYW5cIixcbiAgICBcInZlzIF0dXN0ZVwiLFxuICAgIFwidmV4YW50XCIsXG4gICAgXCJ2ZXhlclwiLFxuICAgIFwidmlhZHVjXCIsXG4gICAgXCJ2aWFuZGVcIixcbiAgICBcInZpY3RvaXJlXCIsXG4gICAgXCJ2aWRhbmdlXCIsXG4gICAgXCJ2aWRlzIFvXCIsXG4gICAgXCJ2aWduZXR0ZVwiLFxuICAgIFwidmlndWV1clwiLFxuICAgIFwidmlsYWluXCIsXG4gICAgXCJ2aWxsYWdlXCIsXG4gICAgXCJ2aW5haWdyZVwiLFxuICAgIFwidmlvbG9uXCIsXG4gICAgXCJ2aXBlzIByZVwiLFxuICAgIFwidmlyZW1lbnRcIixcbiAgICBcInZpcnR1b3NlXCIsXG4gICAgXCJ2aXJ1c1wiLFxuICAgIFwidmlzYWdlXCIsXG4gICAgXCJ2aXNldXJcIixcbiAgICBcInZpc2lvblwiLFxuICAgIFwidmlzcXVldXhcIixcbiAgICBcInZpc3VlbFwiLFxuICAgIFwidml0YWxcIixcbiAgICBcInZpdGVzc2VcIixcbiAgICBcInZpdGljb2xlXCIsXG4gICAgXCJ2aXRyaW5lXCIsXG4gICAgXCJ2aXZhY2VcIixcbiAgICBcInZpdmlwYXJlXCIsXG4gICAgXCJ2b2NhdGlvblwiLFxuICAgIFwidm9ndWVyXCIsXG4gICAgXCJ2b2lsZVwiLFxuICAgIFwidm9pc2luXCIsXG4gICAgXCJ2b2l0dXJlXCIsXG4gICAgXCJ2b2xhaWxsZVwiLFxuICAgIFwidm9sY2FuXCIsXG4gICAgXCJ2b2x0aWdlclwiLFxuICAgIFwidm9sdW1lXCIsXG4gICAgXCJ2b3JhY2VcIixcbiAgICBcInZvcnRleFwiLFxuICAgIFwidm90ZXJcIixcbiAgICBcInZvdWxvaXJcIixcbiAgICBcInZveWFnZVwiLFxuICAgIFwidm95ZWxsZVwiLFxuICAgIFwid2Fnb25cIixcbiAgICBcInhlzIFub25cIixcbiAgICBcInlhY2h0XCIsXG4gICAgXCJ6ZcyAYnJlXCIsXG4gICAgXCJ6ZcyBbml0aFwiLFxuICAgIFwiemVzdGVcIixcbiAgICBcInpvb2xvZ2llXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcImFiYWNvXCIsXG4gICAgXCJhYmJhZ2xpb1wiLFxuICAgIFwiYWJiaW5hdG9cIixcbiAgICBcImFiZXRlXCIsXG4gICAgXCJhYmlzc29cIixcbiAgICBcImFib2xpcmVcIixcbiAgICBcImFicmFzaXZvXCIsXG4gICAgXCJhYnJvZ2F0b1wiLFxuICAgIFwiYWNjYWRlcmVcIixcbiAgICBcImFjY2Vubm9cIixcbiAgICBcImFjY3VzYXRvXCIsXG4gICAgXCJhY2V0b25lXCIsXG4gICAgXCJhY2hpbGxlXCIsXG4gICAgXCJhY2lkb1wiLFxuICAgIFwiYWNxdWFcIixcbiAgICBcImFjcmVcIixcbiAgICBcImFjcmlsaWNvXCIsXG4gICAgXCJhY3JvYmF0YVwiLFxuICAgIFwiYWN1dG9cIixcbiAgICBcImFkYWdpb1wiLFxuICAgIFwiYWRkZWJpdG9cIixcbiAgICBcImFkZG9tZVwiLFxuICAgIFwiYWRlZ3VhdG9cIixcbiAgICBcImFkZXJpcmVcIixcbiAgICBcImFkaXBlXCIsXG4gICAgXCJhZG90dGFyZVwiLFxuICAgIFwiYWR1bGFyZVwiLFxuICAgIFwiYWZmYWJpbGVcIixcbiAgICBcImFmZmV0dG9cIixcbiAgICBcImFmZmlzc29cIixcbiAgICBcImFmZnJhbnRvXCIsXG4gICAgXCJhZm9yaXNtYVwiLFxuICAgIFwiYWZvc29cIixcbiAgICBcImFmcmljYW5vXCIsXG4gICAgXCJhZ2F2ZVwiLFxuICAgIFwiYWdlbnRlXCIsXG4gICAgXCJhZ2V2b2xlXCIsXG4gICAgXCJhZ2dhbmNpb1wiLFxuICAgIFwiYWdpcmVcIixcbiAgICBcImFnaXRhcmVcIixcbiAgICBcImFnb25pc21vXCIsXG4gICAgXCJhZ3JpY29sb1wiLFxuICAgIFwiYWdydW1ldG9cIixcbiAgICBcImFndXp6b1wiLFxuICAgIFwiYWxhYmFyZGFcIixcbiAgICBcImFsYXRvXCIsXG4gICAgXCJhbGJhdHJvXCIsXG4gICAgXCJhbGJlcmF0b1wiLFxuICAgIFwiYWxib1wiLFxuICAgIFwiYWxidW1lXCIsXG4gICAgXCJhbGNlXCIsXG4gICAgXCJhbGNvbGljb1wiLFxuICAgIFwiYWxldHRvbmVcIixcbiAgICBcImFsZmFcIixcbiAgICBcImFsZ2VicmFcIixcbiAgICBcImFsaWFudGVcIixcbiAgICBcImFsaWJpXCIsXG4gICAgXCJhbGltZW50b1wiLFxuICAgIFwiYWxsYWdhdG9cIixcbiAgICBcImFsbGVncm9cIixcbiAgICBcImFsbGlldm9cIixcbiAgICBcImFsbG9kb2xhXCIsXG4gICAgXCJhbGx1c2l2b1wiLFxuICAgIFwiYWxtZW5vXCIsXG4gICAgXCJhbG9nZW5vXCIsXG4gICAgXCJhbHBhY2FcIixcbiAgICBcImFscGVzdHJlXCIsXG4gICAgXCJhbHRhbGVuYVwiLFxuICAgIFwiYWx0ZXJub1wiLFxuICAgIFwiYWx0aWNjaW9cIixcbiAgICBcImFsdHJvdmVcIixcbiAgICBcImFsdW5ub1wiLFxuICAgIFwiYWx2ZW9sb1wiLFxuICAgIFwiYWx6YXJlXCIsXG4gICAgXCJhbWFsZ2FtYVwiLFxuICAgIFwiYW1hbml0YVwiLFxuICAgIFwiYW1hcmVuYVwiLFxuICAgIFwiYW1iaXRvXCIsXG4gICAgXCJhbWJyYXRvXCIsXG4gICAgXCJhbWViYVwiLFxuICAgIFwiYW1lcmljYVwiLFxuICAgIFwiYW1ldGlzdGFcIixcbiAgICBcImFtaWNvXCIsXG4gICAgXCJhbW1hc3NvXCIsXG4gICAgXCJhbW1lbmRhXCIsXG4gICAgXCJhbW1pcmFyZVwiLFxuICAgIFwiYW1tb25pdG9cIixcbiAgICBcImFtb3JlXCIsXG4gICAgXCJhbXBpb1wiLFxuICAgIFwiYW1wbGlhcmVcIixcbiAgICBcImFtdWxldG9cIixcbiAgICBcImFuYWNhcmRvXCIsXG4gICAgXCJhbmFncmFmZVwiLFxuICAgIFwiYW5hbGlzdGFcIixcbiAgICBcImFuYXJjaGlhXCIsXG4gICAgXCJhbmF0cmFcIixcbiAgICBcImFuY2FcIixcbiAgICBcImFuY2VsbGFcIixcbiAgICBcImFuY29yYVwiLFxuICAgIFwiYW5kYXJlXCIsXG4gICAgXCJhbmRyZWFcIixcbiAgICBcImFuZWxsb1wiLFxuICAgIFwiYW5nZWxvXCIsXG4gICAgXCJhbmdvbGFyZVwiLFxuICAgIFwiYW5ndXN0b1wiLFxuICAgIFwiYW5pbWFcIixcbiAgICBcImFubmVnYXJlXCIsXG4gICAgXCJhbm5pZGF0b1wiLFxuICAgIFwiYW5ub1wiLFxuICAgIFwiYW5udW5jaW9cIixcbiAgICBcImFub25pbW9cIixcbiAgICBcImFudGljaXBvXCIsXG4gICAgXCJhbnppXCIsXG4gICAgXCJhcGF0aWNvXCIsXG4gICAgXCJhcGVydHVyYVwiLFxuICAgIFwiYXBvZGVcIixcbiAgICBcImFwcGFyaXJlXCIsXG4gICAgXCJhcHBldGl0b1wiLFxuICAgIFwiYXBwb2dnaW9cIixcbiAgICBcImFwcHJvZG9cIixcbiAgICBcImFwcHVudG9cIixcbiAgICBcImFwcmlsZVwiLFxuICAgIFwiYXJhYmljYVwiLFxuICAgIFwiYXJhY2hpZGVcIixcbiAgICBcImFyYWdvc3RhXCIsXG4gICAgXCJhcmFsZGljYVwiLFxuICAgIFwiYXJhbmNpb1wiLFxuICAgIFwiYXJhdHVyYVwiLFxuICAgIFwiYXJhenpvXCIsXG4gICAgXCJhcmJpdHJvXCIsXG4gICAgXCJhcmNoaXZpb1wiLFxuICAgIFwiYXJkaXRvXCIsXG4gICAgXCJhcmVuaWxlXCIsXG4gICAgXCJhcmdlbnRvXCIsXG4gICAgXCJhcmdpbmVcIixcbiAgICBcImFyZ3V0b1wiLFxuICAgIFwiYXJpYVwiLFxuICAgIFwiYXJtb25pYVwiLFxuICAgIFwiYXJuZXNlXCIsXG4gICAgXCJhcnJlZGF0b1wiLFxuICAgIFwiYXJyaW5nYVwiLFxuICAgIFwiYXJyb3N0b1wiLFxuICAgIFwiYXJzZW5pY29cIixcbiAgICBcImFyc29cIixcbiAgICBcImFydGVmaWNlXCIsXG4gICAgXCJhcnppbGxvXCIsXG4gICAgXCJhc2NpdXR0b1wiLFxuICAgIFwiYXNjb2x0b1wiLFxuICAgIFwiYXNlcHNpXCIsXG4gICAgXCJhc2V0dGljb1wiLFxuICAgIFwiYXNmYWx0b1wiLFxuICAgIFwiYXNpbm9cIixcbiAgICBcImFzb2xhXCIsXG4gICAgXCJhc3BpcmF0b1wiLFxuICAgIFwiYXNwcm9cIixcbiAgICBcImFzc2FnZ2lvXCIsXG4gICAgXCJhc3NlXCIsXG4gICAgXCJhc3NvbHV0b1wiLFxuICAgIFwiYXNzdXJkb1wiLFxuICAgIFwiYXN0YVwiLFxuICAgIFwiYXN0ZW51dG9cIixcbiAgICBcImFzdGljZVwiLFxuICAgIFwiYXN0cmF0dG9cIixcbiAgICBcImF0YXZpY29cIixcbiAgICBcImF0ZWlzbW9cIixcbiAgICBcImF0b21pY29cIixcbiAgICBcImF0b25vXCIsXG4gICAgXCJhdHRlc2FcIixcbiAgICBcImF0dGl2YXJlXCIsXG4gICAgXCJhdHRvcm5vXCIsXG4gICAgXCJhdHRyaXRvXCIsXG4gICAgXCJhdHR1YWxlXCIsXG4gICAgXCJhdXNpbGlvXCIsXG4gICAgXCJhdXN0cmlhXCIsXG4gICAgXCJhdXRpc3RhXCIsXG4gICAgXCJhdXRvbm9tb1wiLFxuICAgIFwiYXV0dW5ub1wiLFxuICAgIFwiYXZhbnphdG9cIixcbiAgICBcImF2ZXJlXCIsXG4gICAgXCJhdnZlbmlyZVwiLFxuICAgIFwiYXZ2aXNvXCIsXG4gICAgXCJhdnZvbGdlcmVcIixcbiAgICBcImF6aW9uZVwiLFxuICAgIFwiYXpvdG9cIixcbiAgICBcImF6emltb1wiLFxuICAgIFwiYXp6dXJyb1wiLFxuICAgIFwiYmFiZWxlXCIsXG4gICAgXCJiYWNjYW5vXCIsXG4gICAgXCJiYWNpbm9cIixcbiAgICBcImJhY29cIixcbiAgICBcImJhZGVzc2FcIixcbiAgICBcImJhZGlsYXRhXCIsXG4gICAgXCJiYWduYXRvXCIsXG4gICAgXCJiYWl0YVwiLFxuICAgIFwiYmFsY29uZVwiLFxuICAgIFwiYmFsZG9cIixcbiAgICBcImJhbGVuYVwiLFxuICAgIFwiYmFsbGF0YVwiLFxuICAgIFwiYmFsemFub1wiLFxuICAgIFwiYmFtYmlub1wiLFxuICAgIFwiYmFuZGlyZVwiLFxuICAgIFwiYmFyYW9uZGFcIixcbiAgICBcImJhcmJhcm9cIixcbiAgICBcImJhcmNhXCIsXG4gICAgXCJiYXJpdG9ub1wiLFxuICAgIFwiYmFybHVtZVwiLFxuICAgIFwiYmFyb2Njb1wiLFxuICAgIFwiYmFzaWxpY29cIixcbiAgICBcImJhc3NvXCIsXG4gICAgXCJiYXRvc3RhXCIsXG4gICAgXCJiYXR0dXRvXCIsXG4gICAgXCJiYXVsZVwiLFxuICAgIFwiYmF2YVwiLFxuICAgIFwiYmF2b3NhXCIsXG4gICAgXCJiZWNjb1wiLFxuICAgIFwiYmVmZmFcIixcbiAgICBcImJlbGdpb1wiLFxuICAgIFwiYmVsdmFcIixcbiAgICBcImJlbmRhXCIsXG4gICAgXCJiZW5ldm9sZVwiLFxuICAgIFwiYmVuaWdub1wiLFxuICAgIFwiYmVuemluYVwiLFxuICAgIFwiYmVyZVwiLFxuICAgIFwiYmVybGluYVwiLFxuICAgIFwiYmV0YVwiLFxuICAgIFwiYmliaXRhXCIsXG4gICAgXCJiaWNpXCIsXG4gICAgXCJiaWRvbmVcIixcbiAgICBcImJpZmlkb1wiLFxuICAgIFwiYmlnYVwiLFxuICAgIFwiYmlsYW5jaWFcIixcbiAgICBcImJpbWJvXCIsXG4gICAgXCJiaW5vY29sb1wiLFxuICAgIFwiYmlvbG9nb1wiLFxuICAgIFwiYmlwZWRlXCIsXG4gICAgXCJiaXBvbGFyZVwiLFxuICAgIFwiYmlyYmFudGVcIixcbiAgICBcImJpcnJhXCIsXG4gICAgXCJiaXNjb3R0b1wiLFxuICAgIFwiYmlzZXN0b1wiLFxuICAgIFwiYmlzbm9ubm9cIixcbiAgICBcImJpc29udGVcIixcbiAgICBcImJpc3R1cmlcIixcbiAgICBcImJpenphcnJvXCIsXG4gICAgXCJibGFuZG9cIixcbiAgICBcImJsYXR0YVwiLFxuICAgIFwiYm9sbGl0b1wiLFxuICAgIFwiYm9uaWZpY29cIixcbiAgICBcImJvcmRvXCIsXG4gICAgXCJib3Njb1wiLFxuICAgIFwiYm90YW5pY29cIixcbiAgICBcImJvdHRpbm9cIixcbiAgICBcImJvenpvbG9cIixcbiAgICBcImJyYWNjaW9cIixcbiAgICBcImJyYWRpcG9cIixcbiAgICBcImJyYW1hXCIsXG4gICAgXCJicmFuY2FcIixcbiAgICBcImJyYXZ1cmFcIixcbiAgICBcImJyZXRlbGxhXCIsXG4gICAgXCJicmV2ZXR0b1wiLFxuICAgIFwiYnJlenphXCIsXG4gICAgXCJicmlnbGlhXCIsXG4gICAgXCJicmlsbGFudGVcIixcbiAgICBcImJyaW5kYXJlXCIsXG4gICAgXCJicm9jY29sb1wiLFxuICAgIFwiYnJvZG9cIixcbiAgICBcImJyb256aW5hXCIsXG4gICAgXCJicnVsbG9cIixcbiAgICBcImJydW5vXCIsXG4gICAgXCJidWJib25lXCIsXG4gICAgXCJidWNhXCIsXG4gICAgXCJidWRpbm9cIixcbiAgICBcImJ1ZmZvbmVcIixcbiAgICBcImJ1aW9cIixcbiAgICBcImJ1bGJvXCIsXG4gICAgXCJidW9ub1wiLFxuICAgIFwiYnVybG9uZVwiLFxuICAgIFwiYnVycmFzY2FcIixcbiAgICBcImJ1c3NvbGFcIixcbiAgICBcImJ1c3RhXCIsXG4gICAgXCJjYWRldHRvXCIsXG4gICAgXCJjYWR1Y29cIixcbiAgICBcImNhbGFtYXJvXCIsXG4gICAgXCJjYWxjb2xvXCIsXG4gICAgXCJjYWxlc3NlXCIsXG4gICAgXCJjYWxpYnJvXCIsXG4gICAgXCJjYWxtb1wiLFxuICAgIFwiY2Fsb3JpYVwiLFxuICAgIFwiY2FtYnVzYVwiLFxuICAgIFwiY2FtZXJhdGFcIixcbiAgICBcImNhbWljaWFcIixcbiAgICBcImNhbW1pbm9cIixcbiAgICBcImNhbW9sYVwiLFxuICAgIFwiY2FtcGFsZVwiLFxuICAgIFwiY2FuYXBhXCIsXG4gICAgXCJjYW5kZWxhXCIsXG4gICAgXCJjYW5lXCIsXG4gICAgXCJjYW5pbm9cIixcbiAgICBcImNhbm90dG9cIixcbiAgICBcImNhbnRpbmFcIixcbiAgICBcImNhcGFjZVwiLFxuICAgIFwiY2FwZWxsb1wiLFxuICAgIFwiY2FwaXRvbG9cIixcbiAgICBcImNhcG9naXJvXCIsXG4gICAgXCJjYXBwZXJvXCIsXG4gICAgXCJjYXByYVwiLFxuICAgIFwiY2Fwc3VsYVwiLFxuICAgIFwiY2FyYXBhY2VcIixcbiAgICBcImNhcmNhc3NhXCIsXG4gICAgXCJjYXJkb1wiLFxuICAgIFwiY2FyaXNtYVwiLFxuICAgIFwiY2Fyb3ZhbmFcIixcbiAgICBcImNhcnJldHRvXCIsXG4gICAgXCJjYXJ0b2xpbmFcIixcbiAgICBcImNhc2FjY2lvXCIsXG4gICAgXCJjYXNjYXRhXCIsXG4gICAgXCJjYXNlcm1hXCIsXG4gICAgXCJjYXNvXCIsXG4gICAgXCJjYXNzb25lXCIsXG4gICAgXCJjYXN0ZWxsb1wiLFxuICAgIFwiY2FzdWFsZVwiLFxuICAgIFwiY2F0YXN0YVwiLFxuICAgIFwiY2F0ZW5hXCIsXG4gICAgXCJjYXRyYW1lXCIsXG4gICAgXCJjYXV0b1wiLFxuICAgIFwiY2F2aWxsb1wiLFxuICAgIFwiY2VkaWJpbGVcIixcbiAgICBcImNlZHJhdGFcIixcbiAgICBcImNlZmFsb1wiLFxuICAgIFwiY2VsZWJyZVwiLFxuICAgIFwiY2VsbHVsYXJlXCIsXG4gICAgXCJjZW5hXCIsXG4gICAgXCJjZW5vbmVcIixcbiAgICBcImNlbnRlc2ltb1wiLFxuICAgIFwiY2VyYW1pY2FcIixcbiAgICBcImNlcmNhcmVcIixcbiAgICBcImNlcnRvXCIsXG4gICAgXCJjZXJ1bWVcIixcbiAgICBcImNlcnZlbGxvXCIsXG4gICAgXCJjZXNvaWFcIixcbiAgICBcImNlc3BvXCIsXG4gICAgXCJjZXRvXCIsXG4gICAgXCJjaGVsYVwiLFxuICAgIFwiY2hpYXJvXCIsXG4gICAgXCJjaGljY2FcIixcbiAgICBcImNoaWVkZXJlXCIsXG4gICAgXCJjaGltZXJhXCIsXG4gICAgXCJjaGluYVwiLFxuICAgIFwiY2hpcnVyZ29cIixcbiAgICBcImNoaXRhcnJhXCIsXG4gICAgXCJjaWFvXCIsXG4gICAgXCJjaWNsaXNtb1wiLFxuICAgIFwiY2lmcmFyZVwiLFxuICAgIFwiY2lnbm9cIixcbiAgICBcImNpbGluZHJvXCIsXG4gICAgXCJjaW90dG9sb1wiLFxuICAgIFwiY2lyY2FcIixcbiAgICBcImNpcnJvc2lcIixcbiAgICBcImNpdHJpY29cIixcbiAgICBcImNpdHRhZGlub1wiLFxuICAgIFwiY2l1ZmZvXCIsXG4gICAgXCJjaXZldHRhXCIsXG4gICAgXCJjaXZpbGVcIixcbiAgICBcImNsYXNzaWNvXCIsXG4gICAgXCJjbGluaWNhXCIsXG4gICAgXCJjbG9yb1wiLFxuICAgIFwiY29jY29cIixcbiAgICBcImNvZGFyZG9cIixcbiAgICBcImNvZGljZVwiLFxuICAgIFwiY29lcmVudGVcIixcbiAgICBcImNvZ25vbWVcIixcbiAgICBcImNvbGxhcmVcIixcbiAgICBcImNvbG1hdG9cIixcbiAgICBcImNvbG9yZVwiLFxuICAgIFwiY29scG9zb1wiLFxuICAgIFwiY29sdGl2YXRvXCIsXG4gICAgXCJjb2x6YVwiLFxuICAgIFwiY29tYVwiLFxuICAgIFwiY29tZXRhXCIsXG4gICAgXCJjb21tYW5kb1wiLFxuICAgIFwiY29tb2RvXCIsXG4gICAgXCJjb21wdXRlclwiLFxuICAgIFwiY29tdW5lXCIsXG4gICAgXCJjb25jaXNvXCIsXG4gICAgXCJjb25kdXJyZVwiLFxuICAgIFwiY29uZmVybWFcIixcbiAgICBcImNvbmdlbGFyZVwiLFxuICAgIFwiY29uaXVnZVwiLFxuICAgIFwiY29ubmVzc29cIixcbiAgICBcImNvbm9zY2VyZVwiLFxuICAgIFwiY29uc3Vtb1wiLFxuICAgIFwiY29udGludW9cIixcbiAgICBcImNvbnZlZ25vXCIsXG4gICAgXCJjb3BlcnRvXCIsXG4gICAgXCJjb3Bpb25lXCIsXG4gICAgXCJjb3BwaWFcIixcbiAgICBcImNvcHJpY2Fwb1wiLFxuICAgIFwiY29yYXp6YVwiLFxuICAgIFwiY29yZGF0YVwiLFxuICAgIFwiY29yaWNhdG9cIixcbiAgICBcImNvcm5pY2VcIixcbiAgICBcImNvcm9sbGFcIixcbiAgICBcImNvcnBvXCIsXG4gICAgXCJjb3JyZWRvXCIsXG4gICAgXCJjb3JzaWFcIixcbiAgICBcImNvcnRlc2VcIixcbiAgICBcImNvc21pY29cIixcbiAgICBcImNvc3RhbnRlXCIsXG4gICAgXCJjb3R0dXJhXCIsXG4gICAgXCJjb3ZhdG9cIixcbiAgICBcImNyYXRlcmVcIixcbiAgICBcImNyYXZhdHRhXCIsXG4gICAgXCJjcmVhdG9cIixcbiAgICBcImNyZWRlcmVcIixcbiAgICBcImNyZW1vc29cIixcbiAgICBcImNyZXNjaXRhXCIsXG4gICAgXCJjcmV0YVwiLFxuICAgIFwiY3JpY2V0b1wiLFxuICAgIFwiY3JpbmFsZVwiLFxuICAgIFwiY3Jpc2lcIixcbiAgICBcImNyaXRpY29cIixcbiAgICBcImNyb2NlXCIsXG4gICAgXCJjcm9uYWNhXCIsXG4gICAgXCJjcm9zdGF0YVwiLFxuICAgIFwiY3J1Y2lhbGVcIixcbiAgICBcImNydXNjYVwiLFxuICAgIFwiY3VjaXJlXCIsXG4gICAgXCJjdWN1bG9cIixcbiAgICBcImN1Z2lub1wiLFxuICAgIFwiY3VsbGF0b1wiLFxuICAgIFwiY3Vwb2xhXCIsXG4gICAgXCJjdXJhdG9yZVwiLFxuICAgIFwiY3Vyc29yZVwiLFxuICAgIFwiY3Vydm9cIixcbiAgICBcImN1c2Npbm9cIixcbiAgICBcImN1c3RvZGVcIixcbiAgICBcImRhZG9cIixcbiAgICBcImRhaW5vXCIsXG4gICAgXCJkYWxtYXRhXCIsXG4gICAgXCJkYW1lcmlub1wiLFxuICAgIFwiZGFuaWVsYVwiLFxuICAgIFwiZGFubm9zb1wiLFxuICAgIFwiZGFuemFyZVwiLFxuICAgIFwiZGF0YXRvXCIsXG4gICAgXCJkYXZhbnRpXCIsXG4gICAgXCJkYXZ2ZXJvXCIsXG4gICAgXCJkZWJ1dHRvXCIsXG4gICAgXCJkZWNlbm5pb1wiLFxuICAgIFwiZGVjaXNvXCIsXG4gICAgXCJkZWNsaW5vXCIsXG4gICAgXCJkZWNvbGxvXCIsXG4gICAgXCJkZWNyZXRvXCIsXG4gICAgXCJkZWRpY2F0b1wiLFxuICAgIFwiZGVmaW5pdG9cIixcbiAgICBcImRlZm9ybWVcIixcbiAgICBcImRlZ25vXCIsXG4gICAgXCJkZWxlZ2FyZVwiLFxuICAgIFwiZGVsZmlub1wiLFxuICAgIFwiZGVsaXJpb1wiLFxuICAgIFwiZGVsdGFcIixcbiAgICBcImRlbWVuemFcIixcbiAgICBcImRlbm90YXRvXCIsXG4gICAgXCJkZW50cm9cIixcbiAgICBcImRlcG9zaXRvXCIsXG4gICAgXCJkZXJhcGF0YVwiLFxuICAgIFwiZGVyaXZhcmVcIixcbiAgICBcImRlcm9nYVwiLFxuICAgIFwiZGVzY3JpdHRvXCIsXG4gICAgXCJkZXNlcnRvXCIsXG4gICAgXCJkZXNpZGVyaW9cIixcbiAgICBcImRlc3VtZXJlXCIsXG4gICAgXCJkZXRlcnNpdm9cIixcbiAgICBcImRldm90b1wiLFxuICAgIFwiZGlhbWV0cm9cIixcbiAgICBcImRpY2VtYnJlXCIsXG4gICAgXCJkaWVkcm9cIixcbiAgICBcImRpZmVzb1wiLFxuICAgIFwiZGlmZnVzb1wiLFxuICAgIFwiZGlnZXJpcmVcIixcbiAgICBcImRpZ2l0YWxlXCIsXG4gICAgXCJkaWx1dmlvXCIsXG4gICAgXCJkaW5hbWljb1wiLFxuICAgIFwiZGlubmFuemlcIixcbiAgICBcImRpcGludG9cIixcbiAgICBcImRpcGxvbWFcIixcbiAgICBcImRpcG9sb1wiLFxuICAgIFwiZGlyYWRhcmVcIixcbiAgICBcImRpcmVcIixcbiAgICBcImRpcm90dG9cIixcbiAgICBcImRpcnVwb1wiLFxuICAgIFwiZGlzYWdpb1wiLFxuICAgIFwiZGlzY3JldG9cIixcbiAgICBcImRpc2ZhcmVcIixcbiAgICBcImRpc2dlbG9cIixcbiAgICBcImRpc3Bvc3RvXCIsXG4gICAgXCJkaXN0YW56YVwiLFxuICAgIFwiZGlzdW1hbm9cIixcbiAgICBcImRpdG9cIixcbiAgICBcImRpdmFub1wiLFxuICAgIFwiZGl2ZWx0b1wiLFxuICAgIFwiZGl2aWRlcmVcIixcbiAgICBcImRpdm9yYXRvXCIsXG4gICAgXCJkb2Jsb25lXCIsXG4gICAgXCJkb2NlbnRlXCIsXG4gICAgXCJkb2dhbmFsZVwiLFxuICAgIFwiZG9nbWFcIixcbiAgICBcImRvbGNlXCIsXG4gICAgXCJkb21hdG9cIixcbiAgICBcImRvbWVuaWNhXCIsXG4gICAgXCJkb21pbmFyZVwiLFxuICAgIFwiZG9uZG9sb1wiLFxuICAgIFwiZG9ub1wiLFxuICAgIFwiZG9ybWlyZVwiLFxuICAgIFwiZG90ZVwiLFxuICAgIFwiZG90dG9yZVwiLFxuICAgIFwiZG92dXRvXCIsXG4gICAgXCJkb3p6aW5hXCIsXG4gICAgXCJkcmFnb1wiLFxuICAgIFwiZHJ1aWRvXCIsXG4gICAgXCJkdWJiaW9cIixcbiAgICBcImR1Yml0YXJlXCIsXG4gICAgXCJkdWNhbGVcIixcbiAgICBcImR1bmFcIixcbiAgICBcImR1b21vXCIsXG4gICAgXCJkdXBsaWNlXCIsXG4gICAgXCJkdXJhdHVyb1wiLFxuICAgIFwiZWJhbm9cIixcbiAgICBcImVjY2Vzc29cIixcbiAgICBcImVjY29cIixcbiAgICBcImVjbGlzc2lcIixcbiAgICBcImVjb25vbWlhXCIsXG4gICAgXCJlZGVyYVwiLFxuICAgIFwiZWRpY29sYVwiLFxuICAgIFwiZWRpbGVcIixcbiAgICBcImVkaXRvcmlhXCIsXG4gICAgXCJlZHVjYXJlXCIsXG4gICAgXCJlZ2Vtb25pYVwiLFxuICAgIFwiZWdsaVwiLFxuICAgIFwiZWdvaXNtb1wiLFxuICAgIFwiZWdyZWdpb1wiLFxuICAgIFwiZWxhYm9yYXRvXCIsXG4gICAgXCJlbGFyZ2lyZVwiLFxuICAgIFwiZWxlZ2FudGVcIixcbiAgICBcImVsZW5jYXRvXCIsXG4gICAgXCJlbGV0dG9cIixcbiAgICBcImVsZXZhcmVcIixcbiAgICBcImVsZmljb1wiLFxuICAgIFwiZWxpY2FcIixcbiAgICBcImVsbW9cIixcbiAgICBcImVsc2FcIixcbiAgICBcImVsdXNvXCIsXG4gICAgXCJlbWFuYXRvXCIsXG4gICAgXCJlbWJsZW1hXCIsXG4gICAgXCJlbWVzc29cIixcbiAgICBcImVtaXJvXCIsXG4gICAgXCJlbW90aXZvXCIsXG4gICAgXCJlbW96aW9uZVwiLFxuICAgIFwiZW1waXJpY29cIixcbiAgICBcImVtdWxvXCIsXG4gICAgXCJlbmRlbWljb1wiLFxuICAgIFwiZW5kdXJvXCIsXG4gICAgXCJlbmVyZ2lhXCIsXG4gICAgXCJlbmZhc2lcIixcbiAgICBcImVub3RlY2FcIixcbiAgICBcImVudHJhcmVcIixcbiAgICBcImVuemltYVwiLFxuICAgIFwiZXBhdGl0ZVwiLFxuICAgIFwiZXBpbG9nb1wiLFxuICAgIFwiZXBpc29kaW9cIixcbiAgICBcImVwb2NhbGVcIixcbiAgICBcImVwcHVyZVwiLFxuICAgIFwiZXF1YXRvcmVcIixcbiAgICBcImVyYXJpb1wiLFxuICAgIFwiZXJiYVwiLFxuICAgIFwiZXJib3NvXCIsXG4gICAgXCJlcmVkZVwiLFxuICAgIFwiZXJlbWl0YVwiLFxuICAgIFwiZXJpZ2VyZVwiLFxuICAgIFwiZXJtZXRpY29cIixcbiAgICBcImVyb2VcIixcbiAgICBcImVyb3Npdm9cIixcbiAgICBcImVycmFudGVcIixcbiAgICBcImVzYWdvbm9cIixcbiAgICBcImVzYW1lXCIsXG4gICAgXCJlc2FuaW1lXCIsXG4gICAgXCJlc2F1ZGlyZVwiLFxuICAgIFwiZXNjYVwiLFxuICAgIFwiZXNlbXBpb1wiLFxuICAgIFwiZXNlcmNpdG9cIixcbiAgICBcImVzaWJpdG9cIixcbiAgICBcImVzaWdlbnRlXCIsXG4gICAgXCJlc2lzdGVyZVwiLFxuICAgIFwiZXNpdG9cIixcbiAgICBcImVzb2ZhZ29cIixcbiAgICBcImVzb3J0YXRvXCIsXG4gICAgXCJlc29zb1wiLFxuICAgIFwiZXNwYW5zb1wiLFxuICAgIFwiZXNwcmVzc29cIixcbiAgICBcImVzc2VuemFcIixcbiAgICBcImVzc29cIixcbiAgICBcImVzdGVzb1wiLFxuICAgIFwiZXN0aW1hcmVcIixcbiAgICBcImVzdG9uaWFcIixcbiAgICBcImVzdHJvc29cIixcbiAgICBcImVzdWx0YXJlXCIsXG4gICAgXCJldGlsaWNvXCIsXG4gICAgXCJldG5pY29cIixcbiAgICBcImV0cnVzY29cIixcbiAgICBcImV0dG9cIixcbiAgICBcImV1Y2xpZGVvXCIsXG4gICAgXCJldXJvcGFcIixcbiAgICBcImV2YXNvXCIsXG4gICAgXCJldmlkZW56YVwiLFxuICAgIFwiZXZpdGF0b1wiLFxuICAgIFwiZXZvbHV0b1wiLFxuICAgIFwiZXZ2aXZhXCIsXG4gICAgXCJmYWJicmljYVwiLFxuICAgIFwiZmFjY2VuZGFcIixcbiAgICBcImZhY2hpcm9cIixcbiAgICBcImZhbGNvXCIsXG4gICAgXCJmYW1pZ2xpYVwiLFxuICAgIFwiZmFuYWxlXCIsXG4gICAgXCJmYW5mYXJhXCIsXG4gICAgXCJmYW5nb1wiLFxuICAgIFwiZmFudGFzbWFcIixcbiAgICBcImZhcmVcIixcbiAgICBcImZhcmZhbGxhXCIsXG4gICAgXCJmYXJpbm9zb1wiLFxuICAgIFwiZmFybWFjb1wiLFxuICAgIFwiZmFzY2lhXCIsXG4gICAgXCJmYXN0b3NvXCIsXG4gICAgXCJmYXN1bGxvXCIsXG4gICAgXCJmYXRpY2FyZVwiLFxuICAgIFwiZmF0b1wiLFxuICAgIFwiZmF2b2xvc29cIixcbiAgICBcImZlYmJyZVwiLFxuICAgIFwiZmVjb2xhXCIsXG4gICAgXCJmZWRlXCIsXG4gICAgXCJmZWdhdG9cIixcbiAgICBcImZlbHBhXCIsXG4gICAgXCJmZWx0cm9cIixcbiAgICBcImZlbW1pbmFcIixcbiAgICBcImZlbmRlcmVcIixcbiAgICBcImZlbm9tZW5vXCIsXG4gICAgXCJmZXJtZW50b1wiLFxuICAgIFwiZmVycm9cIixcbiAgICBcImZlcnRpbGVcIixcbiAgICBcImZlc3N1cmFcIixcbiAgICBcImZlc3Rpdm9cIixcbiAgICBcImZldHRhXCIsXG4gICAgXCJmZXVkb1wiLFxuICAgIFwiZmlhYmFcIixcbiAgICBcImZpZHVjaWFcIixcbiAgICBcImZpZmFcIixcbiAgICBcImZpZ3VyYXRvXCIsXG4gICAgXCJmaWxvXCIsXG4gICAgXCJmaW5hbnphXCIsXG4gICAgXCJmaW5lc3RyYVwiLFxuICAgIFwiZmluaXJlXCIsXG4gICAgXCJmaW9yZVwiLFxuICAgIFwiZmlzY2FsZVwiLFxuICAgIFwiZmlzaWNvXCIsXG4gICAgXCJmaXVtZVwiLFxuICAgIFwiZmxhY29uZVwiLFxuICAgIFwiZmxhbWVuY29cIixcbiAgICBcImZsZWJvXCIsXG4gICAgXCJmbGVtbWFcIixcbiAgICBcImZsb3JpZG9cIixcbiAgICBcImZsdWVudGVcIixcbiAgICBcImZsdW9yb1wiLFxuICAgIFwiZm9iaWNvXCIsXG4gICAgXCJmb2NhY2NpYVwiLFxuICAgIFwiZm9jb3NvXCIsXG4gICAgXCJmb2RlcmF0b1wiLFxuICAgIFwiZm9nbGlvXCIsXG4gICAgXCJmb2xhdGFcIixcbiAgICBcImZvbGNsb3JlXCIsXG4gICAgXCJmb2xnb3JlXCIsXG4gICAgXCJmb25kZW50ZVwiLFxuICAgIFwiZm9uZXRpY29cIixcbiAgICBcImZvbmlhXCIsXG4gICAgXCJmb250YW5hXCIsXG4gICAgXCJmb3JiaXRvXCIsXG4gICAgXCJmb3JjaGV0dGFcIixcbiAgICBcImZvcmVzdGFcIixcbiAgICBcImZvcm1pY2FcIixcbiAgICBcImZvcm5haW9cIixcbiAgICBcImZvcm9cIixcbiAgICBcImZvcnRlenphXCIsXG4gICAgXCJmb3J6YXJlXCIsXG4gICAgXCJmb3NmYXRvXCIsXG4gICAgXCJmb3Nzb1wiLFxuICAgIFwiZnJhY2Fzc29cIixcbiAgICBcImZyYW5hXCIsXG4gICAgXCJmcmFzc2lub1wiLFxuICAgIFwiZnJhdGVsbG9cIixcbiAgICBcImZyZWNjZXR0YVwiLFxuICAgIFwiZnJlbmF0YVwiLFxuICAgIFwiZnJlc2NvXCIsXG4gICAgXCJmcmlnb1wiLFxuICAgIFwiZnJvbGxpbm9cIixcbiAgICBcImZyb25kZVwiLFxuICAgIFwiZnJ1Z2FsZVwiLFxuICAgIFwiZnJ1dHRhXCIsXG4gICAgXCJmdWNpbGF0YVwiLFxuICAgIFwiZnVjc2lhXCIsXG4gICAgXCJmdWdnZW50ZVwiLFxuICAgIFwiZnVsbWluZVwiLFxuICAgIFwiZnVsdm9cIixcbiAgICBcImZ1bWFudGVcIixcbiAgICBcImZ1bWV0dG9cIixcbiAgICBcImZ1bW9zb1wiLFxuICAgIFwiZnVuZVwiLFxuICAgIFwiZnVuemlvbmVcIixcbiAgICBcImZ1b2NvXCIsXG4gICAgXCJmdXJib1wiLFxuICAgIFwiZnVyZ29uZVwiLFxuICAgIFwiZnVyb3JlXCIsXG4gICAgXCJmdXNvXCIsXG4gICAgXCJmdXRpbGVcIixcbiAgICBcImdhYmJpYW5vXCIsXG4gICAgXCJnYWZmZVwiLFxuICAgIFwiZ2FsYXRlb1wiLFxuICAgIFwiZ2FsbGluYVwiLFxuICAgIFwiZ2Fsb3Bwb1wiLFxuICAgIFwiZ2FtYmVyb1wiLFxuICAgIFwiZ2FtbWFcIixcbiAgICBcImdhcmFuemlhXCIsXG4gICAgXCJnYXJib1wiLFxuICAgIFwiZ2Fyb2Zhbm9cIixcbiAgICBcImdhcnpvbmVcIixcbiAgICBcImdhc2RvdHRvXCIsXG4gICAgXCJnYXNvbGlvXCIsXG4gICAgXCJnYXN0cmljb1wiLFxuICAgIFwiZ2F0dG9cIixcbiAgICBcImdhdWRpb1wiLFxuICAgIFwiZ2F6ZWJvXCIsXG4gICAgXCJnYXp6ZWxsYVwiLFxuICAgIFwiZ2Vjb1wiLFxuICAgIFwiZ2VsYXRpbmFcIixcbiAgICBcImdlbHNvXCIsXG4gICAgXCJnZW1lbGxvXCIsXG4gICAgXCJnZW1tYXRvXCIsXG4gICAgXCJnZW5lXCIsXG4gICAgXCJnZW5pdG9yZVwiLFxuICAgIFwiZ2VubmFpb1wiLFxuICAgIFwiZ2Vub3RpcG9cIixcbiAgICBcImdlcmdvXCIsXG4gICAgXCJnaGVwYXJkb1wiLFxuICAgIFwiZ2hpYWNjaW9cIixcbiAgICBcImdoaXNhXCIsXG4gICAgXCJnaWFsbG9cIixcbiAgICBcImdpbGRhXCIsXG4gICAgXCJnaW5lcHJvXCIsXG4gICAgXCJnaW9jYXJlXCIsXG4gICAgXCJnaW9pZWxsb1wiLFxuICAgIFwiZ2lvcm5vXCIsXG4gICAgXCJnaW92ZVwiLFxuICAgIFwiZ2lyYXRvXCIsXG4gICAgXCJnaXJvbmVcIixcbiAgICBcImdpdHRhdGFcIixcbiAgICBcImdpdWRpemlvXCIsXG4gICAgXCJnaXVyYXRvXCIsXG4gICAgXCJnaXVzdG9cIixcbiAgICBcImdsb2J1bG9cIixcbiAgICBcImdsdXRpbmVcIixcbiAgICBcImdub21vXCIsXG4gICAgXCJnb2JiYVwiLFxuICAgIFwiZ29sZlwiLFxuICAgIFwiZ29taXRvXCIsXG4gICAgXCJnb21tb25lXCIsXG4gICAgXCJnb25maW9cIixcbiAgICBcImdvbm5hXCIsXG4gICAgXCJnb3Zlcm5vXCIsXG4gICAgXCJncmFjaWxlXCIsXG4gICAgXCJncmFkb1wiLFxuICAgIFwiZ3JhZmljb1wiLFxuICAgIFwiZ3JhbW1vXCIsXG4gICAgXCJncmFuZGVcIixcbiAgICBcImdyYXR0YXJlXCIsXG4gICAgXCJncmF2b3NvXCIsXG4gICAgXCJncmF6aWFcIixcbiAgICBcImdyZWNhXCIsXG4gICAgXCJncmVnZ2VcIixcbiAgICBcImdyaWZvbmVcIixcbiAgICBcImdyaWdpb1wiLFxuICAgIFwiZ3JpbnphXCIsXG4gICAgXCJncm90dGFcIixcbiAgICBcImdydXBwb1wiLFxuICAgIFwiZ3VhZGFnbm9cIixcbiAgICBcImd1YWlvXCIsXG4gICAgXCJndWFudG9cIixcbiAgICBcImd1YXJkYXJlXCIsXG4gICAgXCJndWZvXCIsXG4gICAgXCJndWlkYXJlXCIsXG4gICAgXCJpYmVybmF0b1wiLFxuICAgIFwiaWNvbmFcIixcbiAgICBcImlkZW50aWNvXCIsXG4gICAgXCJpZGlsbGlvXCIsXG4gICAgXCJpZG9sb1wiLFxuICAgIFwiaWRyYVwiLFxuICAgIFwiaWRyaWNvXCIsXG4gICAgXCJpZHJvZ2Vub1wiLFxuICAgIFwiaWdpZW5lXCIsXG4gICAgXCJpZ25hcm9cIixcbiAgICBcImlnbm9yYXRvXCIsXG4gICAgXCJpbGFyZVwiLFxuICAgIFwiaWxsZXNvXCIsXG4gICAgXCJpbGxvZ2ljb1wiLFxuICAgIFwiaWxsdWRlcmVcIixcbiAgICBcImltYmFsbG9cIixcbiAgICBcImltYmV2dXRvXCIsXG4gICAgXCJpbWJvY2NvXCIsXG4gICAgXCJpbWJ1dG9cIixcbiAgICBcImltbWFuZVwiLFxuICAgIFwiaW1tZXJzb1wiLFxuICAgIFwiaW1tb2xhdG9cIixcbiAgICBcImltcGFjY29cIixcbiAgICBcImltcGV0b1wiLFxuICAgIFwiaW1waWVnb1wiLFxuICAgIFwiaW1wb3J0b1wiLFxuICAgIFwiaW1wcm9udGFcIixcbiAgICBcImluYWxhcmVcIixcbiAgICBcImluYXJjYXJlXCIsXG4gICAgXCJpbmF0dGl2b1wiLFxuICAgIFwiaW5jYW50b1wiLFxuICAgIFwiaW5jZW5kaW9cIixcbiAgICBcImluY2hpbm9cIixcbiAgICBcImluY2lzaXZvXCIsXG4gICAgXCJpbmNsdXNvXCIsXG4gICAgXCJpbmNvbnRyb1wiLFxuICAgIFwiaW5jcm9jaW9cIixcbiAgICBcImluY3Vib1wiLFxuICAgIFwiaW5kYWdpbmVcIixcbiAgICBcImluZGlhXCIsXG4gICAgXCJpbmRvbGVcIixcbiAgICBcImluZWRpdG9cIixcbiAgICBcImluZmF0dGlcIixcbiAgICBcImluZmlsYXJlXCIsXG4gICAgXCJpbmZsaXR0b1wiLFxuICAgIFwiaW5nYWdnaW9cIixcbiAgICBcImluZ2Vnbm9cIixcbiAgICBcImluZ2xlc2VcIixcbiAgICBcImluZ29yZG9cIixcbiAgICBcImluZ3Jvc3NvXCIsXG4gICAgXCJpbm5lc2NvXCIsXG4gICAgXCJpbm9kb3JlXCIsXG4gICAgXCJpbm9sdHJhcmVcIixcbiAgICBcImlub25kYXRvXCIsXG4gICAgXCJpbnNhbm9cIixcbiAgICBcImluc2V0dG9cIixcbiAgICBcImluc2llbWVcIixcbiAgICBcImluc29ubmlhXCIsXG4gICAgXCJpbnN1bGluYVwiLFxuICAgIFwiaW50YXNhdG9cIixcbiAgICBcImludGVyb1wiLFxuICAgIFwiaW50b25hY29cIixcbiAgICBcImludHVpdG9cIixcbiAgICBcImludW1pZGlyZVwiLFxuICAgIFwiaW52YWxpZG9cIixcbiAgICBcImludmVjZVwiLFxuICAgIFwiaW52aXRvXCIsXG4gICAgXCJpcGVyYm9sZVwiLFxuICAgIFwiaXBub3RpY29cIixcbiAgICBcImlwb3Rlc2lcIixcbiAgICBcImlwcGljYVwiLFxuICAgIFwiaXJpZGVcIixcbiAgICBcImlybGFuZGFcIixcbiAgICBcImlyb25pY29cIixcbiAgICBcImlycmlnYXRvXCIsXG4gICAgXCJpcnJvcmFyZVwiLFxuICAgIFwiaXNvbGF0b1wiLFxuICAgIFwiaXNvdG9wb1wiLFxuICAgIFwiaXN0ZXJpY29cIixcbiAgICBcImlzdGl0dXRvXCIsXG4gICAgXCJpc3RyaWNlXCIsXG4gICAgXCJpdGFsaWFcIixcbiAgICBcIml0ZXJhcmVcIixcbiAgICBcImxhYmJyb1wiLFxuICAgIFwibGFiaXJpbnRvXCIsXG4gICAgXCJsYWNjYVwiLFxuICAgIFwibGFjZXJhdG9cIixcbiAgICBcImxhY3JpbWFcIixcbiAgICBcImxhY3VuYVwiLFxuICAgIFwibGFkZG92ZVwiLFxuICAgIFwibGFnb1wiLFxuICAgIFwibGFtcG9cIixcbiAgICBcImxhbmNldHRhXCIsXG4gICAgXCJsYW50ZXJuYVwiLFxuICAgIFwibGFyZG9zb1wiLFxuICAgIFwibGFyZ2FcIixcbiAgICBcImxhcmluZ2VcIixcbiAgICBcImxhc3RyYVwiLFxuICAgIFwibGF0ZW56YVwiLFxuICAgIFwibGF0aW5vXCIsXG4gICAgXCJsYXR0dWdhXCIsXG4gICAgXCJsYXZhZ25hXCIsXG4gICAgXCJsYXZvcm9cIixcbiAgICBcImxlZ2FsZVwiLFxuICAgIFwibGVnZ2Vyb1wiLFxuICAgIFwibGVtYm9cIixcbiAgICBcImxlbnRlenphXCIsXG4gICAgXCJsZW56YVwiLFxuICAgIFwibGVvbmVcIixcbiAgICBcImxlcHJlXCIsXG4gICAgXCJsZXNpdm9cIixcbiAgICBcImxlc3NhdG9cIixcbiAgICBcImxlc3RvXCIsXG4gICAgXCJsZXR0ZXJhbGVcIixcbiAgICBcImxldmFcIixcbiAgICBcImxldmlnYXRvXCIsXG4gICAgXCJsaWJlcm9cIixcbiAgICBcImxpZG9cIixcbiAgICBcImxpZXZpdG9cIixcbiAgICBcImxpbGxhXCIsXG4gICAgXCJsaW1hdHVyYVwiLFxuICAgIFwibGltaXRhcmVcIixcbiAgICBcImxpbXBpZG9cIixcbiAgICBcImxpbmVhcmVcIixcbiAgICBcImxpbmd1YVwiLFxuICAgIFwibGlxdWlkb1wiLFxuICAgIFwibGlyYVwiLFxuICAgIFwibGlyaWNhXCIsXG4gICAgXCJsaXNjYVwiLFxuICAgIFwibGl0ZVwiLFxuICAgIFwibGl0aWdpb1wiLFxuICAgIFwibGl2cmVhXCIsXG4gICAgXCJsb2NhbmRhXCIsXG4gICAgXCJsb2RlXCIsXG4gICAgXCJsb2dpY2FcIixcbiAgICBcImxvbWJhcmVcIixcbiAgICBcImxvbmRyYVwiLFxuICAgIFwibG9uZ2V2b1wiLFxuICAgIFwibG9xdWFjZVwiLFxuICAgIFwibG9yZW56b1wiLFxuICAgIFwibG90b1wiLFxuICAgIFwibG90dGVyaWFcIixcbiAgICBcImx1Y2VcIixcbiAgICBcImx1Y2lkYXRvXCIsXG4gICAgXCJsdW1hY2FcIixcbiAgICBcImx1bWlub3NvXCIsXG4gICAgXCJsdW5nb1wiLFxuICAgIFwibHVwb1wiLFxuICAgIFwibHVwcG9sb1wiLFxuICAgIFwibHVzaW5nYVwiLFxuICAgIFwibHVzc29cIixcbiAgICBcImx1dHRvXCIsXG4gICAgXCJtYWNhYnJvXCIsXG4gICAgXCJtYWNjaGluYVwiLFxuICAgIFwibWFjZXJvXCIsXG4gICAgXCJtYWNpbmF0b1wiLFxuICAgIFwibWFkYW1hXCIsXG4gICAgXCJtYWdpY29cIixcbiAgICBcIm1hZ2xpYVwiLFxuICAgIFwibWFnbmV0ZVwiLFxuICAgIFwibWFncm9cIixcbiAgICBcIm1haW9saWNhXCIsXG4gICAgXCJtYWxhZmVkZVwiLFxuICAgIFwibWFsZ3JhZG9cIixcbiAgICBcIm1hbGludGVzb1wiLFxuICAgIFwibWFsc2Fub1wiLFxuICAgIFwibWFsdG9cIixcbiAgICBcIm1hbHVtb3JlXCIsXG4gICAgXCJtYW5hXCIsXG4gICAgXCJtYW5jaWFcIixcbiAgICBcIm1hbmRvcmxhXCIsXG4gICAgXCJtYW5naWFyZVwiLFxuICAgIFwibWFuaWZlc3RvXCIsXG4gICAgXCJtYW5uYXJvXCIsXG4gICAgXCJtYW5vdnJhXCIsXG4gICAgXCJtYW5zYXJkYVwiLFxuICAgIFwibWFudGlkZVwiLFxuICAgIFwibWFudWJyaW9cIixcbiAgICBcIm1hcHBhXCIsXG4gICAgXCJtYXJhdG9uYVwiLFxuICAgIFwibWFyY2lyZVwiLFxuICAgIFwibWFyZXR0YVwiLFxuICAgIFwibWFybW9cIixcbiAgICBcIm1hcnN1cGlvXCIsXG4gICAgXCJtYXNjaGVyYVwiLFxuICAgIFwibWFzc2FpYVwiLFxuICAgIFwibWFzdGlub1wiLFxuICAgIFwibWF0ZXJhc3NvXCIsXG4gICAgXCJtYXRyaWNvbGFcIixcbiAgICBcIm1hdHRvbmVcIixcbiAgICBcIm1hdHVyb1wiLFxuICAgIFwibWF6dXJjYVwiLFxuICAgIFwibWVhbmRyb1wiLFxuICAgIFwibWVjY2FuaWNvXCIsXG4gICAgXCJtZWNlbmF0ZVwiLFxuICAgIFwibWVkZXNpbW9cIixcbiAgICBcIm1lZGl0YXJlXCIsXG4gICAgXCJtZWdhXCIsXG4gICAgXCJtZWxhc3NhXCIsXG4gICAgXCJtZWxpc1wiLFxuICAgIFwibWVsb2RpYVwiLFxuICAgIFwibWVuaW5nZVwiLFxuICAgIFwibWVub1wiLFxuICAgIFwibWVuc29sYVwiLFxuICAgIFwibWVyY3VyaW9cIixcbiAgICBcIm1lcmVuZGFcIixcbiAgICBcIm1lcmxvXCIsXG4gICAgXCJtZXNjaGlub1wiLFxuICAgIFwibWVzZVwiLFxuICAgIFwibWVzc2VyZVwiLFxuICAgIFwibWVzdG9sb1wiLFxuICAgIFwibWV0YWxsb1wiLFxuICAgIFwibWV0b2RvXCIsXG4gICAgXCJtZXR0ZXJlXCIsXG4gICAgXCJtaWFnb2xhcmVcIixcbiAgICBcIm1pY2FcIixcbiAgICBcIm1pY2VsaW9cIixcbiAgICBcIm1pY2hlbGVcIixcbiAgICBcIm1pY3JvYm9cIixcbiAgICBcIm1pZG9sbG9cIixcbiAgICBcIm1pZWxlXCIsXG4gICAgXCJtaWdsaW9yZVwiLFxuICAgIFwibWlsYW5vXCIsXG4gICAgXCJtaWxpdGVcIixcbiAgICBcIm1pbW9zYVwiLFxuICAgIFwibWluZXJhbGVcIixcbiAgICBcIm1pbmlcIixcbiAgICBcIm1pbm9yZVwiLFxuICAgIFwibWlyaW5vXCIsXG4gICAgXCJtaXJ0aWxsb1wiLFxuICAgIFwibWlzY2VsYVwiLFxuICAgIFwibWlzc2l2YVwiLFxuICAgIFwibWlzdG9cIixcbiAgICBcIm1pc3VyYXJlXCIsXG4gICAgXCJtaXRlenphXCIsXG4gICAgXCJtaXRpZ2FyZVwiLFxuICAgIFwibWl0cmFcIixcbiAgICBcIm1pdHRlbnRlXCIsXG4gICAgXCJtbmVtb25pY29cIixcbiAgICBcIm1vZGVsbG9cIixcbiAgICBcIm1vZGlmaWNhXCIsXG4gICAgXCJtb2R1bG9cIixcbiAgICBcIm1vZ2Fub1wiLFxuICAgIFwibW9naW9cIixcbiAgICBcIm1vbGVcIixcbiAgICBcIm1vbG9zc29cIixcbiAgICBcIm1vbmFzdGVyb1wiLFxuICAgIFwibW9uY29cIixcbiAgICBcIm1vbmRpbmFcIixcbiAgICBcIm1vbmV0YXJpb1wiLFxuICAgIFwibW9uaWxlXCIsXG4gICAgXCJtb25vdG9ub1wiLFxuICAgIFwibW9uc29uZVwiLFxuICAgIFwibW9udGF0b1wiLFxuICAgIFwibW9udmlzb1wiLFxuICAgIFwibW9yYVwiLFxuICAgIFwibW9yZGVyZVwiLFxuICAgIFwibW9yc2ljYXRvXCIsXG4gICAgXCJtb3N0cm9cIixcbiAgICBcIm1vdGl2YXRvXCIsXG4gICAgXCJtb3Rvc2VnYVwiLFxuICAgIFwibW90dG9cIixcbiAgICBcIm1vdmVuemFcIixcbiAgICBcIm1vdmltZW50b1wiLFxuICAgIFwibW96em9cIixcbiAgICBcIm11Y2NhXCIsXG4gICAgXCJtdWNvc2FcIixcbiAgICBcIm11ZmZhXCIsXG4gICAgXCJtdWdoZXR0b1wiLFxuICAgIFwibXVnbmFpb1wiLFxuICAgIFwibXVsYXR0b1wiLFxuICAgIFwibXVsaW5lbGxvXCIsXG4gICAgXCJtdWx0aXBsb1wiLFxuICAgIFwibXVtbWlhXCIsXG4gICAgXCJtdW50b1wiLFxuICAgIFwibXVvdmVyZVwiLFxuICAgIFwibXVyYWxlXCIsXG4gICAgXCJtdXNhXCIsXG4gICAgXCJtdXNjb2xvXCIsXG4gICAgXCJtdXNpY2FcIixcbiAgICBcIm11dGV2b2xlXCIsXG4gICAgXCJtdXRvXCIsXG4gICAgXCJuYWJhYmJvXCIsXG4gICAgXCJuYWZ0YVwiLFxuICAgIFwibmFub21ldHJvXCIsXG4gICAgXCJuYXJjaXNvXCIsXG4gICAgXCJuYXJpY2VcIixcbiAgICBcIm5hcnJhdG9cIixcbiAgICBcIm5hc2NlcmVcIixcbiAgICBcIm5hc3RyYXJlXCIsXG4gICAgXCJuYXR1cmFsZVwiLFxuICAgIFwibmF1dGljYVwiLFxuICAgIFwibmF2aWdsaW9cIixcbiAgICBcIm5lYnVsb3NhXCIsXG4gICAgXCJuZWNyb3NpXCIsXG4gICAgXCJuZWdhdGl2b1wiLFxuICAgIFwibmVnb3ppb1wiLFxuICAgIFwibmVtbWVub1wiLFxuICAgIFwibmVvZml0YVwiLFxuICAgIFwibmVyZXR0b1wiLFxuICAgIFwibmVydm9cIixcbiAgICBcIm5lc3N1bm9cIixcbiAgICBcIm5ldHR1bm9cIixcbiAgICBcIm5ldXRyYWxlXCIsXG4gICAgXCJuZXZlXCIsXG4gICAgXCJuZXZyb3RpY29cIixcbiAgICBcIm5pY2NoaWFcIixcbiAgICBcIm5pbmZhXCIsXG4gICAgXCJuaXRpZG9cIixcbiAgICBcIm5vYmlsZVwiLFxuICAgIFwibm9jaXZvXCIsXG4gICAgXCJub2RvXCIsXG4gICAgXCJub21lXCIsXG4gICAgXCJub21pbmFcIixcbiAgICBcIm5vcmRpY29cIixcbiAgICBcIm5vcm1hbGVcIixcbiAgICBcIm5vcnZlZ2VzZVwiLFxuICAgIFwibm9zdHJhbm9cIixcbiAgICBcIm5vdGFyZVwiLFxuICAgIFwibm90aXppYVwiLFxuICAgIFwibm90dHVybm9cIixcbiAgICBcIm5vdmVsbGFcIixcbiAgICBcIm51Y2xlb1wiLFxuICAgIFwibnVsbGFcIixcbiAgICBcIm51bWVyb1wiLFxuICAgIFwibnVvdm9cIixcbiAgICBcIm51dHJpcmVcIixcbiAgICBcIm51dm9sYVwiLFxuICAgIFwibnV6aWFsZVwiLFxuICAgIFwib2FzaVwiLFxuICAgIFwib2JiZWRpcmVcIixcbiAgICBcIm9iYmxpZ29cIixcbiAgICBcIm9iZWxpc2NvXCIsXG4gICAgXCJvYmxpb1wiLFxuICAgIFwib2JvbG9cIixcbiAgICBcIm9ic29sZXRvXCIsXG4gICAgXCJvY2Nhc2lvbmVcIixcbiAgICBcIm9jY2hpb1wiLFxuICAgIFwib2NjaWRlbnRlXCIsXG4gICAgXCJvY2NvcnJlcmVcIixcbiAgICBcIm9jY3VsdGFyZVwiLFxuICAgIFwib2NyYVwiLFxuICAgIFwib2N1bGF0b1wiLFxuICAgIFwib2RpZXJub1wiLFxuICAgIFwib2RvcmFyZVwiLFxuICAgIFwib2ZmZXJ0YVwiLFxuICAgIFwib2ZmcmlyZVwiLFxuICAgIFwib2ZmdXNjYXRvXCIsXG4gICAgXCJvZ2dldHRvXCIsXG4gICAgXCJvZ2dpXCIsXG4gICAgXCJvZ251bm9cIixcbiAgICBcIm9sYW5kZXNlXCIsXG4gICAgXCJvbGZhdHRvXCIsXG4gICAgXCJvbGlhdG9cIixcbiAgICBcIm9saXZhXCIsXG4gICAgXCJvbG9ncmFtbWFcIixcbiAgICBcIm9sdHJlXCIsXG4gICAgXCJvbWFnZ2lvXCIsXG4gICAgXCJvbWJlbGljb1wiLFxuICAgIFwib21icmFcIixcbiAgICBcIm9tZWdhXCIsXG4gICAgXCJvbWlzc2lvbmVcIixcbiAgICBcIm9uZG9zb1wiLFxuICAgIFwib25lcmVcIixcbiAgICBcIm9uaWNlXCIsXG4gICAgXCJvbm5pdm9yb1wiLFxuICAgIFwib25vcmV2b2xlXCIsXG4gICAgXCJvbnRhXCIsXG4gICAgXCJvcGVyYXRvXCIsXG4gICAgXCJvcGluaW9uZVwiLFxuICAgIFwib3Bwb3N0b1wiLFxuICAgIFwib3JhY29sb1wiLFxuICAgIFwib3JhZm9cIixcbiAgICBcIm9yZGluZVwiLFxuICAgIFwib3JlY2NoaW5vXCIsXG4gICAgXCJvcmVmaWNlXCIsXG4gICAgXCJvcmZhbm9cIixcbiAgICBcIm9yZ2FuaWNvXCIsXG4gICAgXCJvcmlnaW5lXCIsXG4gICAgXCJvcml6em9udGVcIixcbiAgICBcIm9ybWFcIixcbiAgICBcIm9ybWVnZ2lvXCIsXG4gICAgXCJvcm5hdGl2b1wiLFxuICAgIFwib3JvbG9naW9cIixcbiAgICBcIm9ycmVuZG9cIixcbiAgICBcIm9ycmliaWxlXCIsXG4gICAgXCJvcnRlbnNpYVwiLFxuICAgIFwib3J0aWNhXCIsXG4gICAgXCJvcnphdGFcIixcbiAgICBcIm9yem9cIixcbiAgICBcIm9zYXJlXCIsXG4gICAgXCJvc2N1cmFyZVwiLFxuICAgIFwib3Ntb3NpXCIsXG4gICAgXCJvc3BlZGFsZVwiLFxuICAgIFwib3NwaXRlXCIsXG4gICAgXCJvc3NhXCIsXG4gICAgXCJvc3NpZGFyZVwiLFxuICAgIFwib3N0YWNvbG9cIixcbiAgICBcIm9zdGVcIixcbiAgICBcIm90aXRlXCIsXG4gICAgXCJvdHJlXCIsXG4gICAgXCJvdHRhZ29ub1wiLFxuICAgIFwib3R0aW1vXCIsXG4gICAgXCJvdHRvYnJlXCIsXG4gICAgXCJvdmFsZVwiLFxuICAgIFwib3Zlc3RcIixcbiAgICBcIm92aW5vXCIsXG4gICAgXCJvdmlwYXJvXCIsXG4gICAgXCJvdm9jaXRvXCIsXG4gICAgXCJvdnVucXVlXCIsXG4gICAgXCJvdnZpYXJlXCIsXG4gICAgXCJvemlvXCIsXG4gICAgXCJwYWNjaGV0dG9cIixcbiAgICBcInBhY2VcIixcbiAgICBcInBhY2lmaWNvXCIsXG4gICAgXCJwYWRlbGxhXCIsXG4gICAgXCJwYWRyb25lXCIsXG4gICAgXCJwYWVzZVwiLFxuICAgIFwicGFnYVwiLFxuICAgIFwicGFnaW5hXCIsXG4gICAgXCJwYWxhenppbmFcIixcbiAgICBcInBhbGVzYXJlXCIsXG4gICAgXCJwYWxsaWRvXCIsXG4gICAgXCJwYWxvXCIsXG4gICAgXCJwYWx1ZGVcIixcbiAgICBcInBhbmRvcm9cIixcbiAgICBcInBhbm5lbGxvXCIsXG4gICAgXCJwYW9sb1wiLFxuICAgIFwicGFvbmF6em9cIixcbiAgICBcInBhcHJpY2FcIixcbiAgICBcInBhcmFib2xhXCIsXG4gICAgXCJwYXJjZWxsYVwiLFxuICAgIFwicGFyZXJlXCIsXG4gICAgXCJwYXJnb2xvXCIsXG4gICAgXCJwYXJpXCIsXG4gICAgXCJwYXJsYXRvXCIsXG4gICAgXCJwYXJvbGFcIixcbiAgICBcInBhcnRpcmVcIixcbiAgICBcInBhcnZlbnphXCIsXG4gICAgXCJwYXJ6aWFsZVwiLFxuICAgIFwicGFzc2l2b1wiLFxuICAgIFwicGFzdGljY2FcIixcbiAgICBcInBhdGFjY2FcIixcbiAgICBcInBhdG9sb2dpYVwiLFxuICAgIFwicGF0dHVtZVwiLFxuICAgIFwicGF2b25lXCIsXG4gICAgXCJwZWNjYXRvXCIsXG4gICAgXCJwZWRhbGFyZVwiLFxuICAgIFwicGVkb25hbGVcIixcbiAgICBcInBlZ2dpb1wiLFxuICAgIFwicGVsb3NvXCIsXG4gICAgXCJwZW5hcmVcIixcbiAgICBcInBlbmRpY2VcIixcbiAgICBcInBlbmlzb2xhXCIsXG4gICAgXCJwZW5udXRvXCIsXG4gICAgXCJwZW5vbWJyYVwiLFxuICAgIFwicGVuc2FyZVwiLFxuICAgIFwicGVudG9sYVwiLFxuICAgIFwicGVwZVwiLFxuICAgIFwicGVwaXRhXCIsXG4gICAgXCJwZXJiZW5lXCIsXG4gICAgXCJwZXJjb3Jzb1wiLFxuICAgIFwicGVyZG9uYXRvXCIsXG4gICAgXCJwZXJmb3JhcmVcIixcbiAgICBcInBlcmdhbWVuYVwiLFxuICAgIFwicGVyaW9kb1wiLFxuICAgIFwicGVybWVzc29cIixcbiAgICBcInBlcm5vXCIsXG4gICAgXCJwZXJwbGVzc29cIixcbiAgICBcInBlcnN1YXNvXCIsXG4gICAgXCJwZXJ0dWdpb1wiLFxuICAgIFwicGVydmFzb1wiLFxuICAgIFwicGVzYXRvcmVcIixcbiAgICBcInBlc2lzdGFcIixcbiAgICBcInBlc29cIixcbiAgICBcInBlc3RpZmVyb1wiLFxuICAgIFwicGV0YWxvXCIsXG4gICAgXCJwZXR0aW5lXCIsXG4gICAgXCJwZXR1bGFudGVcIixcbiAgICBcInBlenpvXCIsXG4gICAgXCJwaWFjZXJlXCIsXG4gICAgXCJwaWFudGFcIixcbiAgICBcInBpYXR0aW5vXCIsXG4gICAgXCJwaWNjaW5vXCIsXG4gICAgXCJwaWNvenphXCIsXG4gICAgXCJwaWVnYVwiLFxuICAgIFwicGlldHJhXCIsXG4gICAgXCJwaWZmZXJvXCIsXG4gICAgXCJwaWdpYW1hXCIsXG4gICAgXCJwaWdvbGlvXCIsXG4gICAgXCJwaWdyb1wiLFxuICAgIFwicGlsYVwiLFxuICAgIFwicGlsaWZlcm9cIixcbiAgICBcInBpbGxvbGFcIixcbiAgICBcInBpbG90YVwiLFxuICAgIFwicGltcGFudGVcIixcbiAgICBcInBpbmV0YVwiLFxuICAgIFwicGlubmFcIixcbiAgICBcInBpbm9sb1wiLFxuICAgIFwicGlvZ2dpYVwiLFxuICAgIFwicGlvbWJvXCIsXG4gICAgXCJwaXJhbWlkZVwiLFxuICAgIFwicGlyZXRpY29cIixcbiAgICBcInBpcml0ZVwiLFxuICAgIFwicGlyb2xpc2lcIixcbiAgICBcInBpdG9uZVwiLFxuICAgIFwicGl6emljb1wiLFxuICAgIFwicGxhY2Vib1wiLFxuICAgIFwicGxhbmFyZVwiLFxuICAgIFwicGxhc21hXCIsXG4gICAgXCJwbGF0YW5vXCIsXG4gICAgXCJwbGVuYXJpb1wiLFxuICAgIFwicG9jaGV6emFcIixcbiAgICBcInBvZGVyb3NvXCIsXG4gICAgXCJwb2Rpc21vXCIsXG4gICAgXCJwb2VzaWFcIixcbiAgICBcInBvZ2dpYXJlXCIsXG4gICAgXCJwb2xlbnRhXCIsXG4gICAgXCJwb2xpZ29ub1wiLFxuICAgIFwicG9sbGljZVwiLFxuICAgIFwicG9sbW9uaXRlXCIsXG4gICAgXCJwb2xwZXR0YVwiLFxuICAgIFwicG9sc29cIixcbiAgICBcInBvbHRyb25hXCIsXG4gICAgXCJwb2x2ZXJlXCIsXG4gICAgXCJwb21pY2VcIixcbiAgICBcInBvbW9kb3JvXCIsXG4gICAgXCJwb250ZVwiLFxuICAgIFwicG9wb2xvc29cIixcbiAgICBcInBvcmZpZG9cIixcbiAgICBcInBvcm9zb1wiLFxuICAgIFwicG9ycG9yYVwiLFxuICAgIFwicG9ycmVcIixcbiAgICBcInBvcnRhdGFcIixcbiAgICBcInBvc2FcIixcbiAgICBcInBvc2l0aXZvXCIsXG4gICAgXCJwb3NzZXNzb1wiLFxuICAgIFwicG9zdHVsYXRvXCIsXG4gICAgXCJwb3Rhc3Npb1wiLFxuICAgIFwicG90ZXJlXCIsXG4gICAgXCJwcmFuem9cIixcbiAgICBcInByYXNzaVwiLFxuICAgIFwicHJhdGljYVwiLFxuICAgIFwicHJlY2x1c29cIixcbiAgICBcInByZWRpY2FcIixcbiAgICBcInByZWZpc3NvXCIsXG4gICAgXCJwcmVnaWF0b1wiLFxuICAgIFwicHJlbGlldm9cIixcbiAgICBcInByZW1lcmVcIixcbiAgICBcInByZW5vdGFyZVwiLFxuICAgIFwicHJlcGFyYXRvXCIsXG4gICAgXCJwcmVzZW56YVwiLFxuICAgIFwicHJldGVzdG9cIixcbiAgICBcInByZXZhbHNvXCIsXG4gICAgXCJwcmltYVwiLFxuICAgIFwicHJpbmNpcGVcIixcbiAgICBcInByaXZhdG9cIixcbiAgICBcInByb2JsZW1hXCIsXG4gICAgXCJwcm9jdXJhXCIsXG4gICAgXCJwcm9kdXJyZVwiLFxuICAgIFwicHJvZnVtb1wiLFxuICAgIFwicHJvZ2V0dG9cIixcbiAgICBcInByb2x1bmdhXCIsXG4gICAgXCJwcm9tZXNzYVwiLFxuICAgIFwicHJvbm9tZVwiLFxuICAgIFwicHJvcG9zdGFcIixcbiAgICBcInByb3JvZ2FcIixcbiAgICBcInByb3Rlc29cIixcbiAgICBcInByb3ZhXCIsXG4gICAgXCJwcnVkZW50ZVwiLFxuICAgIFwicHJ1Z25hXCIsXG4gICAgXCJwcnVyaXRvXCIsXG4gICAgXCJwc2ljaGVcIixcbiAgICBcInB1YmJsaWNvXCIsXG4gICAgXCJwdWRpY2FcIixcbiAgICBcInB1Z2lsYXRvXCIsXG4gICAgXCJwdWdub1wiLFxuICAgIFwicHVsY2VcIixcbiAgICBcInB1bGl0b1wiLFxuICAgIFwicHVsc2FudGVcIixcbiAgICBcInB1bnRhcmVcIixcbiAgICBcInB1cGF6em9cIixcbiAgICBcInB1cGlsbGFcIixcbiAgICBcInB1cm9cIixcbiAgICBcInF1YWRyb1wiLFxuICAgIFwicXVhbGNvc2FcIixcbiAgICBcInF1YXNpXCIsXG4gICAgXCJxdWVyZWxhXCIsXG4gICAgXCJxdW90YVwiLFxuICAgIFwicmFjY29sdG9cIixcbiAgICBcInJhZGRvcHBpb1wiLFxuICAgIFwicmFkaWNhbGVcIixcbiAgICBcInJhZHVuYXRvXCIsXG4gICAgXCJyYWZmaWNhXCIsXG4gICAgXCJyYWdhenpvXCIsXG4gICAgXCJyYWdpb25lXCIsXG4gICAgXCJyYWdub1wiLFxuICAgIFwicmFtYXJyb1wiLFxuICAgIFwicmFtaW5nb1wiLFxuICAgIFwicmFtb1wiLFxuICAgIFwicmFuZGFnaW9cIixcbiAgICBcInJhbnRvbGFyZVwiLFxuICAgIFwicmFwYXRvXCIsXG4gICAgXCJyYXBpbmFcIixcbiAgICBcInJhcHByZXNvXCIsXG4gICAgXCJyYXNhdHVyYVwiLFxuICAgIFwicmFzY2hpYXRvXCIsXG4gICAgXCJyYXNlbnRlXCIsXG4gICAgXCJyYXNzZWduYVwiLFxuICAgIFwicmFzdHJlbGxvXCIsXG4gICAgXCJyYXRhXCIsXG4gICAgXCJyYXZ2ZWR1dG9cIixcbiAgICBcInJlYWxlXCIsXG4gICAgXCJyZWNlcGlyZVwiLFxuICAgIFwicmVjaW50b1wiLFxuICAgIFwicmVjbHV0YVwiLFxuICAgIFwicmVjb25kaXRvXCIsXG4gICAgXCJyZWN1cGVyb1wiLFxuICAgIFwicmVkZGl0b1wiLFxuICAgIFwicmVkaW1lcmVcIixcbiAgICBcInJlZ2FsYXRvXCIsXG4gICAgXCJyZWdpc3Ryb1wiLFxuICAgIFwicmVnb2xhXCIsXG4gICAgXCJyZWdyZXNzb1wiLFxuICAgIFwicmVsYXppb25lXCIsXG4gICAgXCJyZW1hcmVcIixcbiAgICBcInJlbW90b1wiLFxuICAgIFwicmVubmFcIixcbiAgICBcInJlcGxpY2FcIixcbiAgICBcInJlcHJpbWVyZVwiLFxuICAgIFwicmVwdXRhcmVcIixcbiAgICBcInJlc2FcIixcbiAgICBcInJlc2lkZW50ZVwiLFxuICAgIFwicmVzcG9uc29cIixcbiAgICBcInJlc3RhdXJvXCIsXG4gICAgXCJyZXRlXCIsXG4gICAgXCJyZXRpbmFcIixcbiAgICBcInJldG9yaWNhXCIsXG4gICAgXCJyZXR0aWZpY2FcIixcbiAgICBcInJldm9jYXRvXCIsXG4gICAgXCJyaWFzc3VudG9cIixcbiAgICBcInJpYmFkaXJlXCIsXG4gICAgXCJyaWJlbGxlXCIsXG4gICAgXCJyaWJyZXp6b1wiLFxuICAgIFwicmljYXJpY2FcIixcbiAgICBcInJpY2NvXCIsXG4gICAgXCJyaWNldmVyZVwiLFxuICAgIFwicmljaWNsYXRvXCIsXG4gICAgXCJyaWNvcmRvXCIsXG4gICAgXCJyaWNyZWR1dG9cIixcbiAgICBcInJpZGljb2xvXCIsXG4gICAgXCJyaWR1cnJlXCIsXG4gICAgXCJyaWZhc2FyZVwiLFxuICAgIFwicmlmbGVzc29cIixcbiAgICBcInJpZm9ybWFcIixcbiAgICBcInJpZnVnaW9cIixcbiAgICBcInJpZ2FyZVwiLFxuICAgIFwicmlnZXR0YXRvXCIsXG4gICAgXCJyaWdoZWxsb1wiLFxuICAgIFwicmlsYXNzYXRvXCIsXG4gICAgXCJyaWxldmF0b1wiLFxuICAgIFwicmltYW5lcmVcIixcbiAgICBcInJpbWJhbHpvXCIsXG4gICAgXCJyaW1lZGlvXCIsXG4gICAgXCJyaW1vcmNoaW9cIixcbiAgICBcInJpbmFzY2l0YVwiLFxuICAgIFwicmluY2Fyb1wiLFxuICAgIFwicmluZm9yem9cIixcbiAgICBcInJpbm5vdm9cIixcbiAgICBcInJpbm9tYXRvXCIsXG4gICAgXCJyaW5zYXZpdG9cIixcbiAgICBcInJpbnRvY2NvXCIsXG4gICAgXCJyaW51bmNpYVwiLFxuICAgIFwicmludmVuaXJlXCIsXG4gICAgXCJyaXBhcmF0b1wiLFxuICAgIFwicmlwZXR1dG9cIixcbiAgICBcInJpcGllbm9cIixcbiAgICBcInJpcG9ydGFyZVwiLFxuICAgIFwicmlwcmVzYVwiLFxuICAgIFwicmlwdWxpcmVcIixcbiAgICBcInJpc2F0YVwiLFxuICAgIFwicmlzY2hpb1wiLFxuICAgIFwicmlzZXJ2YVwiLFxuICAgIFwicmlzaWJpbGVcIixcbiAgICBcInJpc29cIixcbiAgICBcInJpc3BldHRvXCIsXG4gICAgXCJyaXN0b3JvXCIsXG4gICAgXCJyaXN1bHRhdG9cIixcbiAgICBcInJpc3ZvbHRvXCIsXG4gICAgXCJyaXRhcmRvXCIsXG4gICAgXCJyaXRlZ25vXCIsXG4gICAgXCJyaXRtaWNvXCIsXG4gICAgXCJyaXRyb3ZvXCIsXG4gICAgXCJyaXVuaW9uZVwiLFxuICAgIFwicml2YVwiLFxuICAgIFwicml2ZXJzb1wiLFxuICAgIFwicml2aW5jaXRhXCIsXG4gICAgXCJyaXZvbHRvXCIsXG4gICAgXCJyaXpvbWFcIixcbiAgICBcInJvYmFcIixcbiAgICBcInJvYm90aWNvXCIsXG4gICAgXCJyb2J1c3RvXCIsXG4gICAgXCJyb2NjaWFcIixcbiAgICBcInJvY29cIixcbiAgICBcInJvZGFnZ2lvXCIsXG4gICAgXCJyb2RlcmVcIixcbiAgICBcInJvZGl0b3JlXCIsXG4gICAgXCJyb2dpdG9cIixcbiAgICBcInJvbGxpb1wiLFxuICAgIFwicm9tYW50aWNvXCIsXG4gICAgXCJyb21wZXJlXCIsXG4gICAgXCJyb256aW9cIixcbiAgICBcInJvc29sYXJlXCIsXG4gICAgXCJyb3Nwb1wiLFxuICAgIFwicm90YW50ZVwiLFxuICAgIFwicm90b25kb1wiLFxuICAgIFwicm90dWxhXCIsXG4gICAgXCJyb3Zlc2Npb1wiLFxuICAgIFwicnViaXp6b1wiLFxuICAgIFwicnVicmljYVwiLFxuICAgIFwicnVnYVwiLFxuICAgIFwicnVsbGlub1wiLFxuICAgIFwicnVtaW5lXCIsXG4gICAgXCJydW1vcm9zb1wiLFxuICAgIFwicnVvbG9cIixcbiAgICBcInJ1cGVcIixcbiAgICBcInJ1c3NhcmVcIixcbiAgICBcInJ1c3RpY29cIixcbiAgICBcInNhYmF0b1wiLFxuICAgIFwic2FiYmlhcmVcIixcbiAgICBcInNhYm90YXRvXCIsXG4gICAgXCJzYWdvbWFcIixcbiAgICBcInNhbGFzc29cIixcbiAgICBcInNhbGRhdHVyYVwiLFxuICAgIFwic2FsZ2VtbWFcIixcbiAgICBcInNhbGl2YXJlXCIsXG4gICAgXCJzYWxtb25lXCIsXG4gICAgXCJzYWxvbmVcIixcbiAgICBcInNhbHRhcmVcIixcbiAgICBcInNhbHV0b1wiLFxuICAgIFwic2Fsdm9cIixcbiAgICBcInNhcGVyZVwiLFxuICAgIFwic2FwaWRvXCIsXG4gICAgXCJzYXBvcml0b1wiLFxuICAgIFwic2FyYWNlbm9cIixcbiAgICBcInNhcmNhc21vXCIsXG4gICAgXCJzYXJ0b1wiLFxuICAgIFwic2Fzc29zb1wiLFxuICAgIFwic2F0ZWxsaXRlXCIsXG4gICAgXCJzYXRpcmFcIixcbiAgICBcInNhdG9sbG9cIixcbiAgICBcInNhdHVybm9cIixcbiAgICBcInNhdmFuYVwiLFxuICAgIFwic2F2aW9cIixcbiAgICBcInNhemlhdG9cIixcbiAgICBcInNiYWRpZ2xpb1wiLFxuICAgIFwic2JhbHpvXCIsXG4gICAgXCJzYmFuY2F0b1wiLFxuICAgIFwic2JhcnJhXCIsXG4gICAgXCJzYmF0dGVyZVwiLFxuICAgIFwic2JhdmFyZVwiLFxuICAgIFwic2JlbmRhcmVcIixcbiAgICBcInNiaXJjaWFyZVwiLFxuICAgIFwic2Jsb2NjYXRvXCIsXG4gICAgXCJzYm9jY2lhdG9cIixcbiAgICBcInNicmluYXJlXCIsXG4gICAgXCJzYnJ1ZmZvbmVcIixcbiAgICBcInNidWZmYXJlXCIsXG4gICAgXCJzY2Ficm9zb1wiLFxuICAgIFwic2NhZGVuemFcIixcbiAgICBcInNjYWxhXCIsXG4gICAgXCJzY2FtYmlhcmVcIixcbiAgICBcInNjYW5kYWxvXCIsXG4gICAgXCJzY2Fwb2xhXCIsXG4gICAgXCJzY2Fyc29cIixcbiAgICBcInNjYXRlbmFyZVwiLFxuICAgIFwic2NhdmF0b1wiLFxuICAgIFwic2NlbHRvXCIsXG4gICAgXCJzY2VuaWNvXCIsXG4gICAgXCJzY2V0dHJvXCIsXG4gICAgXCJzY2hlZGFcIixcbiAgICBcInNjaGllbmFcIixcbiAgICBcInNjaWFycGFcIixcbiAgICBcInNjaWVuemFcIixcbiAgICBcInNjaW5kZXJlXCIsXG4gICAgXCJzY2lwcG9cIixcbiAgICBcInNjaXJvcHBvXCIsXG4gICAgXCJzY2l2b2xvXCIsXG4gICAgXCJzY2xlcmFyZVwiLFxuICAgIFwic2NvZGVsbGFcIixcbiAgICBcInNjb2xwaXRvXCIsXG4gICAgXCJzY29tcGFydG9cIixcbiAgICBcInNjb25mb3J0b1wiLFxuICAgIFwic2NvcHJpcmVcIixcbiAgICBcInNjb3J0YVwiLFxuICAgIFwic2Nvc3NvbmVcIixcbiAgICBcInNjb3p6ZXNlXCIsXG4gICAgXCJzY3JpYmFcIixcbiAgICBcInNjcm9sbGFyZVwiLFxuICAgIFwic2NydXRpbmlvXCIsXG4gICAgXCJzY3VkZXJpYVwiLFxuICAgIFwic2N1bHRvcmVcIixcbiAgICBcInNjdW9sYVwiLFxuICAgIFwic2N1cm9cIixcbiAgICBcInNjdXNhcmVcIixcbiAgICBcInNkZWJpdGFyZVwiLFxuICAgIFwic2RvZ2FuYXJlXCIsXG4gICAgXCJzZWNjYXR1cmFcIixcbiAgICBcInNlY29uZG9cIixcbiAgICBcInNlZGFub1wiLFxuICAgIFwic2VnZ2lvbGFcIixcbiAgICBcInNlZ25hbGF0b1wiLFxuICAgIFwic2VncmVnYXRvXCIsXG4gICAgXCJzZWd1aXRvXCIsXG4gICAgXCJzZWxjaWF0b1wiLFxuICAgIFwic2VsZXR0aXZvXCIsXG4gICAgXCJzZWxsYVwiLFxuICAgIFwic2VsdmFnZ2lvXCIsXG4gICAgXCJzZW1hZm9yb1wiLFxuICAgIFwic2VtYnJhcmVcIixcbiAgICBcInNlbWVcIixcbiAgICBcInNlbWluYXRvXCIsXG4gICAgXCJzZW1wcmVcIixcbiAgICBcInNlbnNvXCIsXG4gICAgXCJzZW50aXJlXCIsXG4gICAgXCJzZXBvbHRvXCIsXG4gICAgXCJzZXF1ZW56YVwiLFxuICAgIFwic2VyYXRhXCIsXG4gICAgXCJzZXJiYXRvXCIsXG4gICAgXCJzZXJlbm9cIixcbiAgICBcInNlcmlvXCIsXG4gICAgXCJzZXJwZW50ZVwiLFxuICAgIFwic2VycmFnbGlvXCIsXG4gICAgXCJzZXJ2aXJlXCIsXG4gICAgXCJzZXN0aW5hXCIsXG4gICAgXCJzZXRvbGFcIixcbiAgICBcInNldHRpbWFuYVwiLFxuICAgIFwic2ZhY2Vsb1wiLFxuICAgIFwic2ZhbGRhcmVcIixcbiAgICBcInNmYW1hdG9cIixcbiAgICBcInNmYXJ6b3NvXCIsXG4gICAgXCJzZmF0aWNhdG9cIixcbiAgICBcInNmZXJhXCIsXG4gICAgXCJzZmlkYVwiLFxuICAgIFwic2ZpbGF0b1wiLFxuICAgIFwic2ZpbmdlXCIsXG4gICAgXCJzZm9jYXRvXCIsXG4gICAgXCJzZm9kZXJhcmVcIixcbiAgICBcInNmb2dvXCIsXG4gICAgXCJzZm9sdGlyZVwiLFxuICAgIFwic2ZvcnphdG9cIixcbiAgICBcInNmcmF0dG9cIixcbiAgICBcInNmcnV0dGF0b1wiLFxuICAgIFwic2Z1Z2dpdG9cIixcbiAgICBcInNmdW1hcmVcIixcbiAgICBcInNmdXNvXCIsXG4gICAgXCJzZ2FiZWxsb1wiLFxuICAgIFwic2dhcmJhdG9cIixcbiAgICBcInNnb25maWFyZVwiLFxuICAgIFwic2dvcmJpb1wiLFxuICAgIFwic2dyYXNzYXRvXCIsXG4gICAgXCJzZ3VhcmRvXCIsXG4gICAgXCJzaWJpbG9cIixcbiAgICBcInNpY2NvbWVcIixcbiAgICBcInNpZXJyYVwiLFxuICAgIFwic2lnbGFcIixcbiAgICBcInNpZ25vcmVcIixcbiAgICBcInNpbGVuemlvXCIsXG4gICAgXCJzaWxsYWJhXCIsXG4gICAgXCJzaW1ib2xvXCIsXG4gICAgXCJzaW1wYXRpY29cIixcbiAgICBcInNpbXVsYXRvXCIsXG4gICAgXCJzaW5mb25pYVwiLFxuICAgIFwic2luZ29sb1wiLFxuICAgIFwic2luaXN0cm9cIixcbiAgICBcInNpbm9cIixcbiAgICBcInNpbnRlc2lcIixcbiAgICBcInNpbnVzb2lkZVwiLFxuICAgIFwic2lwYXJpb1wiLFxuICAgIFwic2lzbWFcIixcbiAgICBcInNpc3RvbGVcIixcbiAgICBcInNpdHVhdG9cIixcbiAgICBcInNsaXR0YVwiLFxuICAgIFwic2xvZ2F0dXJhXCIsXG4gICAgXCJzbG92ZW5vXCIsXG4gICAgXCJzbWFycml0b1wiLFxuICAgIFwic21lbW9yYXRvXCIsXG4gICAgXCJzbWVudGl0b1wiLFxuICAgIFwic21lcmFsZG9cIixcbiAgICBcInNtaWx6b1wiLFxuICAgIFwic21vbnRhcmVcIixcbiAgICBcInNtb3R0YXRvXCIsXG4gICAgXCJzbXVzc2F0b1wiLFxuICAgIFwic25lbGxpcmVcIixcbiAgICBcInNuZXJ2YXRvXCIsXG4gICAgXCJzbm9kb1wiLFxuICAgIFwic29iYmFsem9cIixcbiAgICBcInNvYnJpb1wiLFxuICAgIFwic29jY29yc29cIixcbiAgICBcInNvY2lhbGVcIixcbiAgICBcInNvZGFsZVwiLFxuICAgIFwic29mZml0dG9cIixcbiAgICBcInNvZ25vXCIsXG4gICAgXCJzb2xkYXRvXCIsXG4gICAgXCJzb2xlbm5lXCIsXG4gICAgXCJzb2xpZG9cIixcbiAgICBcInNvbGxhenpvXCIsXG4gICAgXCJzb2xvXCIsXG4gICAgXCJzb2x1YmlsZVwiLFxuICAgIFwic29sdmVudGVcIixcbiAgICBcInNvbWF0aWNvXCIsXG4gICAgXCJzb21tYVwiLFxuICAgIFwic29uZGFcIixcbiAgICBcInNvbmV0dG9cIixcbiAgICBcInNvbm5pZmVyb1wiLFxuICAgIFwic29waXJlXCIsXG4gICAgXCJzb3BwZXNvXCIsXG4gICAgXCJzb3ByYVwiLFxuICAgIFwic29yZ2VyZVwiLFxuICAgIFwic29ycGFzc29cIixcbiAgICBcInNvcnJpc29cIixcbiAgICBcInNvcnNvXCIsXG4gICAgXCJzb3J0ZWdnaW9cIixcbiAgICBcInNvcnZvbGF0b1wiLFxuICAgIFwic29zcGlyb1wiLFxuICAgIFwic29zdGFcIixcbiAgICBcInNvdHRpbGVcIixcbiAgICBcInNwYWRhXCIsXG4gICAgXCJzcGFsbGFcIixcbiAgICBcInNwYXJnZXJlXCIsXG4gICAgXCJzcGF0b2xhXCIsXG4gICAgXCJzcGF2ZW50b1wiLFxuICAgIFwic3BhenpvbGFcIixcbiAgICBcInNwZWNpZVwiLFxuICAgIFwic3BlZGlyZVwiLFxuICAgIFwic3BlZ25lcmVcIixcbiAgICBcInNwZWxhdHVyYVwiLFxuICAgIFwic3BlcmFuemFcIixcbiAgICBcInNwZXNzb3JlXCIsXG4gICAgXCJzcGV0dHJhbGVcIixcbiAgICBcInNwZXp6YXRvXCIsXG4gICAgXCJzcGlhXCIsXG4gICAgXCJzcGlnb2xvc29cIixcbiAgICBcInNwaWxsYXRvXCIsXG4gICAgXCJzcGlub3NvXCIsXG4gICAgXCJzcGlyYWxlXCIsXG4gICAgXCJzcGxlbmRpZG9cIixcbiAgICBcInNwb3J0aXZvXCIsXG4gICAgXCJzcG9zb1wiLFxuICAgIFwic3ByYW5nYVwiLFxuICAgIFwic3ByZWNhcmVcIixcbiAgICBcInNwcm9uYXRvXCIsXG4gICAgXCJzcHJ1enpvXCIsXG4gICAgXCJzcHVudGlub1wiLFxuICAgIFwic3F1aWxsb1wiLFxuICAgIFwic3JhZGljYXJlXCIsXG4gICAgXCJzcm90b2xhdG9cIixcbiAgICBcInN0YWJpbGVcIixcbiAgICBcInN0YWNjb1wiLFxuICAgIFwic3RhZmZhXCIsXG4gICAgXCJzdGFnbmFyZVwiLFxuICAgIFwic3RhbXBhdG9cIixcbiAgICBcInN0YW50aW9cIixcbiAgICBcInN0YXJudXRvXCIsXG4gICAgXCJzdGFzZXJhXCIsXG4gICAgXCJzdGF0dXRvXCIsXG4gICAgXCJzdGVsb1wiLFxuICAgIFwic3RlcHBhXCIsXG4gICAgXCJzdGVyem9cIixcbiAgICBcInN0aWxldHRvXCIsXG4gICAgXCJzdGltYVwiLFxuICAgIFwic3RpcnBlXCIsXG4gICAgXCJzdGl2YWxlXCIsXG4gICAgXCJzdGl6em9zb1wiLFxuICAgIFwic3RvbmF0b1wiLFxuICAgIFwic3Rvcmljb1wiLFxuICAgIFwic3RyYXBwb1wiLFxuICAgIFwic3RyZWdhdG9cIixcbiAgICBcInN0cmlkdWxvXCIsXG4gICAgXCJzdHJvenphcmVcIixcbiAgICBcInN0cnV0dG9cIixcbiAgICBcInN0dWNjYXJlXCIsXG4gICAgXCJzdHVmb1wiLFxuICAgIFwic3R1cGVuZG9cIixcbiAgICBcInN1YmVudHJvXCIsXG4gICAgXCJzdWNjb3NvXCIsXG4gICAgXCJzdWRvcmVcIixcbiAgICBcInN1Z2dlcml0b1wiLFxuICAgIFwic3Vnb1wiLFxuICAgIFwic3VsdGFub1wiLFxuICAgIFwic3VvbmFyZVwiLFxuICAgIFwic3VwZXJib1wiLFxuICAgIFwic3VwcG9ydG9cIixcbiAgICBcInN1cmdlbGF0b1wiLFxuICAgIFwic3Vycm9nYXRvXCIsXG4gICAgXCJzdXNzdXJyb1wiLFxuICAgIFwic3V0dXJhXCIsXG4gICAgXCJzdmFnYXJlXCIsXG4gICAgXCJzdmVkZXNlXCIsXG4gICAgXCJzdmVnbGlvXCIsXG4gICAgXCJzdmVsYXJlXCIsXG4gICAgXCJzdmVudXRvXCIsXG4gICAgXCJzdmV6aWFcIixcbiAgICBcInN2aWx1cHBvXCIsXG4gICAgXCJzdmlzdGFcIixcbiAgICBcInN2aXp6ZXJhXCIsXG4gICAgXCJzdm9sdGFcIixcbiAgICBcInN2dW90YXJlXCIsXG4gICAgXCJ0YWJhY2NvXCIsXG4gICAgXCJ0YWJ1bGF0b1wiLFxuICAgIFwidGFjY2lhcmVcIixcbiAgICBcInRhY2l0dXJub1wiLFxuICAgIFwidGFsZVwiLFxuICAgIFwidGFsaXNtYW5vXCIsXG4gICAgXCJ0YW1wb25lXCIsXG4gICAgXCJ0YW5uaW5vXCIsXG4gICAgXCJ0YXJhXCIsXG4gICAgXCJ0YXJkaXZvXCIsXG4gICAgXCJ0YXJnYXRvXCIsXG4gICAgXCJ0YXJpZmZhXCIsXG4gICAgXCJ0YXJwYXJlXCIsXG4gICAgXCJ0YXJ0YXJ1Z2FcIixcbiAgICBcInRhc3RvXCIsXG4gICAgXCJ0YXR0aWNvXCIsXG4gICAgXCJ0YXZlcm5hXCIsXG4gICAgXCJ0YXZvbGF0YVwiLFxuICAgIFwidGF6emFcIixcbiAgICBcInRlY2FcIixcbiAgICBcInRlY25pY29cIixcbiAgICBcInRlbGVmb25vXCIsXG4gICAgXCJ0ZW1lcmFyaW9cIixcbiAgICBcInRlbXBvXCIsXG4gICAgXCJ0ZW11dG9cIixcbiAgICBcInRlbmRvbmVcIixcbiAgICBcInRlbmVyb1wiLFxuICAgIFwidGVuc2lvbmVcIixcbiAgICBcInRlbnRhY29sb1wiLFxuICAgIFwidGVvcmVtYVwiLFxuICAgIFwidGVybWVcIixcbiAgICBcInRlcnJhenpvXCIsXG4gICAgXCJ0ZXJ6ZXR0b1wiLFxuICAgIFwidGVzaVwiLFxuICAgIFwidGVzc2VyYXRvXCIsXG4gICAgXCJ0ZXN0YXRvXCIsXG4gICAgXCJ0ZXRyb1wiLFxuICAgIFwidGV0dG9pYVwiLFxuICAgIFwidGlmYXJlXCIsXG4gICAgXCJ0aWdlbGxhXCIsXG4gICAgXCJ0aW1icm9cIixcbiAgICBcInRpbnRvXCIsXG4gICAgXCJ0aXBpY29cIixcbiAgICBcInRpcG9ncmFmb1wiLFxuICAgIFwidGlyYWdnaW9cIixcbiAgICBcInRpcm9cIixcbiAgICBcInRpdGFuaW9cIixcbiAgICBcInRpdG9sb1wiLFxuICAgIFwidGl0dWJhbnRlXCIsXG4gICAgXCJ0aXppb1wiLFxuICAgIFwidGl6em9uZVwiLFxuICAgIFwidG9jY2FyZVwiLFxuICAgIFwidG9sbGVyYXJlXCIsXG4gICAgXCJ0b2x0b1wiLFxuICAgIFwidG9tYm9sYVwiLFxuICAgIFwidG9tb1wiLFxuICAgIFwidG9uZm9cIixcbiAgICBcInRvbnNpbGxhXCIsXG4gICAgXCJ0b3BhemlvXCIsXG4gICAgXCJ0b3BvbG9naWFcIixcbiAgICBcInRvcHBhXCIsXG4gICAgXCJ0b3JiYVwiLFxuICAgIFwidG9ybmFyZVwiLFxuICAgIFwidG9ycm9uZVwiLFxuICAgIFwidG9ydG9yYVwiLFxuICAgIFwidG9zY2Fub1wiLFxuICAgIFwidG9zc2lyZVwiLFxuICAgIFwidG9zdGF0dXJhXCIsXG4gICAgXCJ0b3Rhbm9cIixcbiAgICBcInRyYWJvY2NvXCIsXG4gICAgXCJ0cmFjaGVhXCIsXG4gICAgXCJ0cmFmaWxhXCIsXG4gICAgXCJ0cmFnZWRpYVwiLFxuICAgIFwidHJhbGNpb1wiLFxuICAgIFwidHJhbW9udG9cIixcbiAgICBcInRyYW5zaXRvXCIsXG4gICAgXCJ0cmFwYW5vXCIsXG4gICAgXCJ0cmFycmVcIixcbiAgICBcInRyYXNsb2NvXCIsXG4gICAgXCJ0cmF0dGF0b1wiLFxuICAgIFwidHJhdmVcIixcbiAgICBcInRyZWNjaWFcIixcbiAgICBcInRyZW1vbGlvXCIsXG4gICAgXCJ0cmVzcG9sb1wiLFxuICAgIFwidHJpYnV0b1wiLFxuICAgIFwidHJpY2hlY29cIixcbiAgICBcInRyaWZvZ2xpb1wiLFxuICAgIFwidHJpbGxvXCIsXG4gICAgXCJ0cmluY2VhXCIsXG4gICAgXCJ0cmlvXCIsXG4gICAgXCJ0cmlzdGV6emFcIixcbiAgICBcInRyaXR1cmF0b1wiLFxuICAgIFwidHJpdmVsbGFcIixcbiAgICBcInRyb21iYVwiLFxuICAgIFwidHJvbm9cIixcbiAgICBcInRyb3Bwb1wiLFxuICAgIFwidHJvdHRvbGFcIixcbiAgICBcInRyb3ZhcmVcIixcbiAgICBcInRydWNjYXRvXCIsXG4gICAgXCJ0dWJhdHVyYVwiLFxuICAgIFwidHVmZmF0b1wiLFxuICAgIFwidHVsaXBhbm9cIixcbiAgICBcInR1bXVsdG9cIixcbiAgICBcInR1bmlzaWFcIixcbiAgICBcInR1cmJhcmVcIixcbiAgICBcInR1cmNoaW5vXCIsXG4gICAgXCJ0dXRhXCIsXG4gICAgXCJ0dXRlbGFcIixcbiAgICBcInViaWNhdG9cIixcbiAgICBcInVjY2VsbG9cIixcbiAgICBcInVjY2lzb3JlXCIsXG4gICAgXCJ1ZGlyZVwiLFxuICAgIFwidWRpdGl2b1wiLFxuICAgIFwidWZmYVwiLFxuICAgIFwidWZmaWNpb1wiLFxuICAgIFwidWd1YWxlXCIsXG4gICAgXCJ1bGlzc2VcIixcbiAgICBcInVsdGltYXRvXCIsXG4gICAgXCJ1bWFub1wiLFxuICAgIFwidW1pbGVcIixcbiAgICBcInVtb3Jpc21vXCIsXG4gICAgXCJ1bmNpbmV0dG9cIixcbiAgICBcInVuZ2VyZVwiLFxuICAgIFwidW5naGVyZXNlXCIsXG4gICAgXCJ1bmljb3Jub1wiLFxuICAgIFwidW5pZmljYXRvXCIsXG4gICAgXCJ1bmlzb25vXCIsXG4gICAgXCJ1bml0YXJpb1wiLFxuICAgIFwidW50ZVwiLFxuICAgIFwidW92b1wiLFxuICAgIFwidXB1cGFcIixcbiAgICBcInVyYWdhbm9cIixcbiAgICBcInVyZ2VuemFcIixcbiAgICBcInVybG9cIixcbiAgICBcInVzYW56YVwiLFxuICAgIFwidXNhdG9cIixcbiAgICBcInVzY2l0b1wiLFxuICAgIFwidXNpZ25vbG9cIixcbiAgICBcInVzdXJhaW9cIixcbiAgICBcInV0ZW5zaWxlXCIsXG4gICAgXCJ1dGlsaXp6b1wiLFxuICAgIFwidXRvcGlhXCIsXG4gICAgXCJ2YWNhbnRlXCIsXG4gICAgXCJ2YWNjaW5hdG9cIixcbiAgICBcInZhZ2Fib25kb1wiLFxuICAgIFwidmFnbGlhdG9cIixcbiAgICBcInZhbGFuZ2FcIixcbiAgICBcInZhbGdvXCIsXG4gICAgXCJ2YWxpY29cIixcbiAgICBcInZhbGxldHRhXCIsXG4gICAgXCJ2YWxvcm9zb1wiLFxuICAgIFwidmFsdXRhcmVcIixcbiAgICBcInZhbHZvbGFcIixcbiAgICBcInZhbXBhdGFcIixcbiAgICBcInZhbmdhcmVcIixcbiAgICBcInZhbml0b3NvXCIsXG4gICAgXCJ2YW5vXCIsXG4gICAgXCJ2YW50YWdnaW9cIixcbiAgICBcInZhbnZlcmFcIixcbiAgICBcInZhcG9yZVwiLFxuICAgIFwidmFyYW5vXCIsXG4gICAgXCJ2YXJjYXRvXCIsXG4gICAgXCJ2YXJpYW50ZVwiLFxuICAgIFwidmFzY2FcIixcbiAgICBcInZlZGV0dGFcIixcbiAgICBcInZlZG92YVwiLFxuICAgIFwidmVkdXRvXCIsXG4gICAgXCJ2ZWdldGFsZVwiLFxuICAgIFwidmVpY29sb1wiLFxuICAgIFwidmVsY3JvXCIsXG4gICAgXCJ2ZWxpbmFcIixcbiAgICBcInZlbGx1dG9cIixcbiAgICBcInZlbG9jZVwiLFxuICAgIFwidmVuYXRvXCIsXG4gICAgXCJ2ZW5kZW1taWFcIixcbiAgICBcInZlbnRvXCIsXG4gICAgXCJ2ZXJhY2VcIixcbiAgICBcInZlcmJhbGVcIixcbiAgICBcInZlcmdvZ25hXCIsXG4gICAgXCJ2ZXJpZmljYVwiLFxuICAgIFwidmVyb1wiLFxuICAgIFwidmVycnVjYVwiLFxuICAgIFwidmVydGljYWxlXCIsXG4gICAgXCJ2ZXNjaWNhXCIsXG4gICAgXCJ2ZXNzaWxsb1wiLFxuICAgIFwidmVzdGFsZVwiLFxuICAgIFwidmV0ZXJhbm9cIixcbiAgICBcInZldHJpbmFcIixcbiAgICBcInZldHVzdG9cIixcbiAgICBcInZpYW5kYW50ZVwiLFxuICAgIFwidmlicmFudGVcIixcbiAgICBcInZpY2VuZGFcIixcbiAgICBcInZpY2hpbmdvXCIsXG4gICAgXCJ2aWNpbmFuemFcIixcbiAgICBcInZpZGltYXJlXCIsXG4gICAgXCJ2aWdpbGlhXCIsXG4gICAgXCJ2aWduZXRvXCIsXG4gICAgXCJ2aWdvcmVcIixcbiAgICBcInZpbGVcIixcbiAgICBcInZpbGxhbm9cIixcbiAgICBcInZpbWluaVwiLFxuICAgIFwidmluY2l0b3JlXCIsXG4gICAgXCJ2aW9sYVwiLFxuICAgIFwidmlwZXJhXCIsXG4gICAgXCJ2aXJnb2xhXCIsXG4gICAgXCJ2aXJvbG9nb1wiLFxuICAgIFwidmlydWxlbnRvXCIsXG4gICAgXCJ2aXNjb3NvXCIsXG4gICAgXCJ2aXNpb25lXCIsXG4gICAgXCJ2aXNwb1wiLFxuICAgIFwidmlzc3V0b1wiLFxuICAgIFwidmlzdXJhXCIsXG4gICAgXCJ2aXRhXCIsXG4gICAgXCJ2aXRlbGxvXCIsXG4gICAgXCJ2aXR0aW1hXCIsXG4gICAgXCJ2aXZhbmRhXCIsXG4gICAgXCJ2aXZpZG9cIixcbiAgICBcInZpemlhcmVcIixcbiAgICBcInZvY2VcIixcbiAgICBcInZvZ2FcIixcbiAgICBcInZvbGF0aWxlXCIsXG4gICAgXCJ2b2xlcmVcIixcbiAgICBcInZvbHBlXCIsXG4gICAgXCJ2b3JhZ2luZVwiLFxuICAgIFwidnVsY2Fub1wiLFxuICAgIFwiemFtcG9nbmFcIixcbiAgICBcInphbm5hXCIsXG4gICAgXCJ6YXBwYXRvXCIsXG4gICAgXCJ6YXR0ZXJhXCIsXG4gICAgXCJ6YXZvcnJhXCIsXG4gICAgXCJ6ZWZpcm9cIixcbiAgICBcInplbGFudGVcIixcbiAgICBcInplbG9cIixcbiAgICBcInplbnplcm9cIixcbiAgICBcInplcmJpbm9cIixcbiAgICBcInppYmV0dG9cIixcbiAgICBcInppbmNvXCIsXG4gICAgXCJ6aXJjb25lXCIsXG4gICAgXCJ6aXR0b1wiLFxuICAgIFwiem9sbGFcIixcbiAgICBcInpvdGljb1wiLFxuICAgIFwienVjY2hlcm9cIixcbiAgICBcInp1Zm9sb1wiLFxuICAgIFwienVsdVwiLFxuICAgIFwienVwcGFcIlxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwi44GC44GE44GT44GP44GX44KTXCIsXG4gICAgXCLjgYLjgYTjgZXjgaRcIixcbiAgICBcIuOBguOBhOOBn+OCmVwiLFxuICAgIFwi44GC44GK44Gd44KZ44KJXCIsXG4gICAgXCLjgYLjgYvjgaHjgoPjgpNcIixcbiAgICBcIuOBguOBjeOCi1wiLFxuICAgIFwi44GC44GR44GL44KZ44GfXCIsXG4gICAgXCLjgYLjgZHjgotcIixcbiAgICBcIuOBguOBk+OBi+OCmeOCjOOCi1wiLFxuICAgIFwi44GC44GV44GEXCIsXG4gICAgXCLjgYLjgZXjgbJcIixcbiAgICBcIuOBguOBl+OBguOBqFwiLFxuICAgIFwi44GC44GX44KZ44KP44GGXCIsXG4gICAgXCLjgYLjgZnjgpnjgYvjgotcIixcbiAgICBcIuOBguOBmeOCmeOBjVwiLFxuICAgIFwi44GC44Gd44G144KZXCIsXG4gICAgXCLjgYLjgZ/jgYjjgotcIixcbiAgICBcIuOBguOBn+OBn+OCgeOCi1wiLFxuICAgIFwi44GC44Gf44KK44G+44GIXCIsXG4gICAgXCLjgYLjgZ/jgotcIixcbiAgICBcIuOBguOBpOOBhFwiLFxuICAgIFwi44GC44Gk44GL44GGXCIsXG4gICAgXCLjgYLjgaPjgZfjgoXjgY9cIixcbiAgICBcIuOBguOBpOOBvuOCilwiLFxuICAgIFwi44GC44Gk44KB44KLXCIsXG4gICAgXCLjgYLjgabjgapcIixcbiAgICBcIuOBguOBpuOBr+OBvuOCi1wiLFxuICAgIFwi44GC44Gy44KLXCIsXG4gICAgXCLjgYLjgbXjgpnjgolcIixcbiAgICBcIuOBguOBteOCmeOCi1wiLFxuICAgIFwi44GC44G144KM44KLXCIsXG4gICAgXCLjgYLjgb7jgYRcIixcbiAgICBcIuOBguOBvuOBqOOCmVwiLFxuICAgIFwi44GC44G+44KE44GL44GZXCIsXG4gICAgXCLjgYLjgb7jgopcIixcbiAgICBcIuOBguOBv+OCguOBrlwiLFxuICAgIFwi44GC44KB44KK44GLXCIsXG4gICAgXCLjgYLjgoTjgb7jgotcIixcbiAgICBcIuOBguOChuOCgFwiLFxuICAgIFwi44GC44KJ44GE44GP44KZ44G+XCIsXG4gICAgXCLjgYLjgonjgZdcIixcbiAgICBcIuOBguOCieOBmeOBl+OCmVwiLFxuICAgIFwi44GC44KJ44Gf44KB44KLXCIsXG4gICAgXCLjgYLjgonjgobjgotcIixcbiAgICBcIuOBguOCieOCj+OBmVwiLFxuICAgIFwi44GC44KK44GL44KZ44Go44GGXCIsXG4gICAgXCLjgYLjgo/jgZvjgotcIixcbiAgICBcIuOBguOCj+OBpuOCi1wiLFxuICAgIFwi44GC44KT44GEXCIsXG4gICAgXCLjgYLjgpPjgYvjgpnjgYRcIixcbiAgICBcIuOBguOCk+OBk1wiLFxuICAgIFwi44GC44KT44Gb44KZ44KTXCIsXG4gICAgXCLjgYLjgpPjgabjgYRcIixcbiAgICBcIuOBguOCk+OBquOBhFwiLFxuICAgIFwi44GC44KT44G+44KKXCIsXG4gICAgXCLjgYTjgYTjgZ/jgpnjgZlcIixcbiAgICBcIuOBhOOBiuOCk1wiLFxuICAgIFwi44GE44GL44KZ44GEXCIsXG4gICAgXCLjgYTjgYvjgpnjgY9cIixcbiAgICBcIuOBhOOBjeOBiuOBhFwiLFxuICAgIFwi44GE44GN44Gq44KKXCIsXG4gICAgXCLjgYTjgY3jgoLjga5cIixcbiAgICBcIuOBhOOBjeOCi1wiLFxuICAgIFwi44GE44GP44GX44KZXCIsXG4gICAgXCLjgYTjgY/jgbXjgpnjgpNcIixcbiAgICBcIuOBhOOBkeOBr+OCmeOBqlwiLFxuICAgIFwi44GE44GR44KTXCIsXG4gICAgXCLjgYTjgZPjgYZcIixcbiAgICBcIuOBhOOBk+OBj1wiLFxuICAgIFwi44GE44GT44GkXCIsXG4gICAgXCLjgYTjgZXjgb7jgZfjgYRcIixcbiAgICBcIuOBhOOBleOCk1wiLFxuICAgIFwi44GE44GX44GNXCIsXG4gICAgXCLjgYTjgZfjgpnjgoXjgYZcIixcbiAgICBcIuOBhOOBl+OCmeOCh+OBhlwiLFxuICAgIFwi44GE44GX44KZ44KP44KLXCIsXG4gICAgXCLjgYTjgZnjgpnjgb9cIixcbiAgICBcIuOBhOOBmeOCmeOCjFwiLFxuICAgIFwi44GE44Gb44GEXCIsXG4gICAgXCLjgYTjgZvjgYjjgbLjgplcIixcbiAgICBcIuOBhOOBm+OBi+OBhFwiLFxuICAgIFwi44GE44Gb44GNXCIsXG4gICAgXCLjgYTjgZvjgpnjgpNcIixcbiAgICBcIuOBhOOBneOBhuOCjeOBhlwiLFxuICAgIFwi44GE44Gd44GL44KZ44GX44GEXCIsXG4gICAgXCLjgYTjgZ/jgpnjgYRcIixcbiAgICBcIuOBhOOBn+OCmeOBj1wiLFxuICAgIFwi44GE44Gf44GZ44KZ44KJXCIsXG4gICAgXCLjgYTjgZ/jgb9cIixcbiAgICBcIuOBhOOBn+OCiuOBglwiLFxuICAgIFwi44GE44Gh44GK44GGXCIsXG4gICAgXCLjgYTjgaHjgZfjgplcIixcbiAgICBcIuOBhOOBoeOBqOOCmVwiLFxuICAgIFwi44GE44Gh44Gv44KZXCIsXG4gICAgXCLjgYTjgaHjgbXjgplcIixcbiAgICBcIuOBhOOBoeOCiuOCheOBhlwiLFxuICAgIFwi44GE44Gk44GLXCIsXG4gICAgXCLjgYTjgaPjgZfjgoXjgpNcIixcbiAgICBcIuOBhOOBo+OBm+OBhFwiLFxuICAgIFwi44GE44Gj44Gd44GGXCIsXG4gICAgXCLjgYTjgaPjgZ/jgpNcIixcbiAgICBcIuOBhOOBo+OBoVwiLFxuICAgIFwi44GE44Gj44Gm44GEXCIsXG4gICAgXCLjgYTjgaPjgbvjgprjgYZcIixcbiAgICBcIuOBhOOBpuOBleOCmVwiLFxuICAgIFwi44GE44Gm44KTXCIsXG4gICAgXCLjgYTjgajjgpnjgYZcIixcbiAgICBcIuOBhOOBqOOBk1wiLFxuICAgIFwi44GE44Gq44GEXCIsXG4gICAgXCLjgYTjgarjgYtcIixcbiAgICBcIuOBhOOBreOCgOOCilwiLFxuICAgIFwi44GE44Gu44GhXCIsXG4gICAgXCLjgYTjga7jgotcIixcbiAgICBcIuOBhOOBr+OBpFwiLFxuICAgIFwi44GE44Gv44KZ44KLXCIsXG4gICAgXCLjgYTjga/jgpNcIixcbiAgICBcIuOBhOOBsuOCmeOBjVwiLFxuICAgIFwi44GE44Gy44KTXCIsXG4gICAgXCLjgYTjgbXjgY9cIixcbiAgICBcIuOBhOOBuOOCk1wiLFxuICAgIFwi44GE44G744GGXCIsXG4gICAgXCLjgYTjgb/jgpNcIixcbiAgICBcIuOBhOOCguOBhuOBqFwiLFxuICAgIFwi44GE44KC44Gf44KMXCIsXG4gICAgXCLjgYTjgoLjgopcIixcbiAgICBcIuOBhOOChOOBi+OCmeOCi1wiLFxuICAgIFwi44GE44KE44GZXCIsXG4gICAgXCLjgYTjgojjgYvjgpNcIixcbiAgICBcIuOBhOOCiOOBj1wiLFxuICAgIFwi44GE44KJ44GEXCIsXG4gICAgXCLjgYTjgonjgZnjgahcIixcbiAgICBcIuOBhOOCiuOBj+OCmeOBoVwiLFxuICAgIFwi44GE44KK44KH44GGXCIsXG4gICAgXCLjgYTjgozjgYRcIixcbiAgICBcIuOBhOOCjOOCguOBrlwiLFxuICAgIFwi44GE44KM44KLXCIsXG4gICAgXCLjgYTjgo3jgYjjgpPjgbLjgprjgaRcIixcbiAgICBcIuOBhOOCj+OBhFwiLFxuICAgIFwi44GE44KP44GGXCIsXG4gICAgXCLjgYTjgo/jgYvjgpNcIixcbiAgICBcIuOBhOOCj+OBr+OCmVwiLFxuICAgIFwi44GE44KP44KG44KLXCIsXG4gICAgXCLjgYTjgpPjgZHjgpnjgpPjgb7jgoFcIixcbiAgICBcIuOBhOOCk+OBleOBpFwiLFxuICAgIFwi44GE44KT44GX44KH44GGXCIsXG4gICAgXCLjgYTjgpPjgojjgYZcIixcbiAgICBcIuOBhuOBiOOBjVwiLFxuICAgIFwi44GG44GI44KLXCIsXG4gICAgXCLjgYbjgYrjgZXjgplcIixcbiAgICBcIuOBhuOBi+OCmeOBhFwiLFxuICAgIFwi44GG44GL44G144KZXCIsXG4gICAgXCLjgYbjgYvjgbjjgpnjgotcIixcbiAgICBcIuOBhuOBjeOCj1wiLFxuICAgIFwi44GG44GP44KJ44GE44GqXCIsXG4gICAgXCLjgYbjgY/jgozjgoxcIixcbiAgICBcIuOBhuOBkeOBn+OBvuOCj+OCi1wiLFxuICAgIFwi44GG44GR44Gk44GRXCIsXG4gICAgXCLjgYbjgZHjgajjgotcIixcbiAgICBcIuOBhuOBkeOCguOBpFwiLFxuICAgIFwi44GG44GR44KLXCIsXG4gICAgXCLjgYbjgZPjgpnjgYvjgZlcIixcbiAgICBcIuOBhuOBk+OCmeOBj1wiLFxuICAgIFwi44GG44GT44KTXCIsXG4gICAgXCLjgYbjgZXjgY3jgplcIixcbiAgICBcIuOBhuOBl+OBquOBhlwiLFxuICAgIFwi44GG44GX44KN44GL44KZ44G/XCIsXG4gICAgXCLjgYbjgZnjgYRcIixcbiAgICBcIuOBhuOBmeOBjeOCmVwiLFxuICAgIFwi44GG44GZ44GP44KZ44KJ44GEXCIsXG4gICAgXCLjgYbjgZnjgoHjgotcIixcbiAgICBcIuOBhuOBm+OBpFwiLFxuICAgIFwi44GG44Gh44GC44KP44GbXCIsXG4gICAgXCLjgYbjgaHjgYvjgpnjgo9cIixcbiAgICBcIuOBhuOBoeOBjVwiLFxuICAgIFwi44GG44Gh44KF44GGXCIsXG4gICAgXCLjgYbjgaPjgYvjgopcIixcbiAgICBcIuOBhuOBpOOBj+OBl+OBhFwiLFxuICAgIFwi44GG44Gj44Gf44GI44KLXCIsXG4gICAgXCLjgYbjgaTjgotcIixcbiAgICBcIuOBhuOBqOOCmeOCk1wiLFxuICAgIFwi44GG44Gq44GN44KZXCIsXG4gICAgXCLjgYbjgarjgZfjgplcIixcbiAgICBcIuOBhuOBquOBmeOCmeOBj1wiLFxuICAgIFwi44GG44Gq44KLXCIsXG4gICAgXCLjgYbjga3jgotcIixcbiAgICBcIuOBhuOBruOBhlwiLFxuICAgIFwi44GG44G144KZ44GR44KZXCIsXG4gICAgXCLjgYbjgbXjgpnjgZPjgpnjgYhcIixcbiAgICBcIuOBhuOBvuOCjOOCi1wiLFxuICAgIFwi44GG44KB44KLXCIsXG4gICAgXCLjgYbjgoLjgYZcIixcbiAgICBcIuOBhuOChOOBvuOBhlwiLFxuICAgIFwi44GG44KI44GPXCIsXG4gICAgXCLjgYbjgonjgYvjgpnjgYjjgZlcIixcbiAgICBcIuOBhuOCieOBj+OCmeOBoVwiLFxuICAgIFwi44GG44KJ44Gq44GEXCIsXG4gICAgXCLjgYbjgorjgYLjgZHjgplcIixcbiAgICBcIuOBhuOCiuOBjeOCjFwiLFxuICAgIFwi44GG44KL44GV44GEXCIsXG4gICAgXCLjgYbjgozjgZfjgYRcIixcbiAgICBcIuOBhuOCjOOChuOBjVwiLFxuICAgIFwi44GG44KM44KLXCIsXG4gICAgXCLjgYbjgo3jgZNcIixcbiAgICBcIuOBhuOCj+OBjVwiLFxuICAgIFwi44GG44KP44GVXCIsXG4gICAgXCLjgYbjgpPjgZPjgYZcIixcbiAgICBcIuOBhuOCk+OBoeOCk1wiLFxuICAgIFwi44GG44KT44Gm44KTXCIsXG4gICAgXCLjgYbjgpPjgajjgpnjgYZcIixcbiAgICBcIuOBiOOBhOOBiOOCk1wiLFxuICAgIFwi44GI44GE44GL44KZXCIsXG4gICAgXCLjgYjjgYTjgY3jgofjgYZcIixcbiAgICBcIuOBiOOBhOOBk+OCmVwiLFxuICAgIFwi44GI44GE44Gb44GEXCIsXG4gICAgXCLjgYjjgYTjgbXjgpnjgpNcIixcbiAgICBcIuOBiOOBhOOCiOOBhlwiLFxuICAgIFwi44GI44GE44KPXCIsXG4gICAgXCLjgYjjgYrjgopcIixcbiAgICBcIuOBiOOBi+OCmeOBilwiLFxuICAgIFwi44GI44GL44KZ44GPXCIsXG4gICAgXCLjgYjjgY3jgZ/jgYRcIixcbiAgICBcIuOBiOOBj+OBm+OCi1wiLFxuICAgIFwi44GI44GX44KD44GPXCIsXG4gICAgXCLjgYjjgZnjgaZcIixcbiAgICBcIuOBiOOBpOOCieOCk1wiLFxuICAgIFwi44GI44Gu44GP44KZXCIsXG4gICAgXCLjgYjjgbvjgYbjgb7jgY1cIixcbiAgICBcIuOBiOOBu+OCk1wiLFxuICAgIFwi44GI44G+44GNXCIsXG4gICAgXCLjgYjjgoLjgZfjgplcIixcbiAgICBcIuOBiOOCguOBrlwiLFxuICAgIFwi44GI44KJ44GEXCIsXG4gICAgXCLjgYjjgonjgbXjgplcIixcbiAgICBcIuOBiOOCiuOBglwiLFxuICAgIFwi44GI44KT44GI44KTXCIsXG4gICAgXCLjgYjjgpPjgYvjgYRcIixcbiAgICBcIuOBiOOCk+OBjeOCmVwiLFxuICAgIFwi44GI44KT44GR44KZ44GNXCIsXG4gICAgXCLjgYjjgpPjgZfjgoXjgYZcIixcbiAgICBcIuOBiOOCk+OBm+OCmeOBpFwiLFxuICAgIFwi44GI44KT44Gd44GPXCIsXG4gICAgXCLjgYjjgpPjgaHjgofjgYZcIixcbiAgICBcIuOBiOOCk+OBqOOBpFwiLFxuICAgIFwi44GK44GE44GL44GR44KLXCIsXG4gICAgXCLjgYrjgYTjgZPjgZlcIixcbiAgICBcIuOBiuOBhOOBl+OBhFwiLFxuICAgIFwi44GK44GE44Gk44GPXCIsXG4gICAgXCLjgYrjgYbjgYjjgpNcIixcbiAgICBcIuOBiuOBhuOBleOBvlwiLFxuICAgIFwi44GK44GG44GX44KZXCIsXG4gICAgXCLjgYrjgYbjgZvjgaRcIixcbiAgICBcIuOBiuOBhuOBn+OBhFwiLFxuICAgIFwi44GK44GG44G144GPXCIsXG4gICAgXCLjgYrjgYbjgbjjgpnjgYRcIixcbiAgICBcIuOBiuOBhuOCiOOBhlwiLFxuICAgIFwi44GK44GI44KLXCIsXG4gICAgXCLjgYrjgYrjgYRcIixcbiAgICBcIuOBiuOBiuOBhlwiLFxuICAgIFwi44GK44GK44Go44KZ44GK44KKXCIsXG4gICAgXCLjgYrjgYrjgoRcIixcbiAgICBcIuOBiuOBiuOCiOOBnVwiLFxuICAgIFwi44GK44GL44GI44KKXCIsXG4gICAgXCLjgYrjgYvjgZnjgplcIixcbiAgICBcIuOBiuOBi+OCmeOCgFwiLFxuICAgIFwi44GK44GL44KP44KKXCIsXG4gICAgXCLjgYrjgY3jgpnjgarjgYZcIixcbiAgICBcIuOBiuOBjeOCi1wiLFxuICAgIFwi44GK44GP44GV44G+XCIsXG4gICAgXCLjgYrjgY/jgZfjgpnjgofjgYZcIixcbiAgICBcIuOBiuOBj+OCiuOBi+OCmeOBqlwiLFxuICAgIFwi44GK44GP44KLXCIsXG4gICAgXCLjgYrjgY/jgozjgotcIixcbiAgICBcIuOBiuOBk+OBmVwiLFxuICAgIFwi44GK44GT44Gq44GGXCIsXG4gICAgXCLjgYrjgZPjgotcIixcbiAgICBcIuOBiuOBleOBiOOCi1wiLFxuICAgIFwi44GK44GV44Gq44GEXCIsXG4gICAgXCLjgYrjgZXjgoHjgotcIixcbiAgICBcIuOBiuOBl+OBhOOCjFwiLFxuICAgIFwi44GK44GX44GI44KLXCIsXG4gICAgXCLjgYrjgZfjgpnjgY3jgplcIixcbiAgICBcIuOBiuOBl+OCmeOBleOCk1wiLFxuICAgIFwi44GK44GX44KD44KMXCIsXG4gICAgXCLjgYrjgZ3jgonjgY9cIixcbiAgICBcIuOBiuOBneOCj+OCi1wiLFxuICAgIFwi44GK44Gf44GL44KZ44GEXCIsXG4gICAgXCLjgYrjgZ/jgY9cIixcbiAgICBcIuOBiuOBn+OCmeOChOOBi1wiLFxuICAgIFwi44GK44Gh44Gk44GPXCIsXG4gICAgXCLjgYrjgaPjgahcIixcbiAgICBcIuOBiuOBpOOCilwiLFxuICAgIFwi44GK44Gm44KZ44GL44GRXCIsXG4gICAgXCLjgYrjgajjgZfjgoLjga5cIixcbiAgICBcIuOBiuOBqOOBquOBl+OBhFwiLFxuICAgIFwi44GK44Go44KZ44KKXCIsXG4gICAgXCLjgYrjgajjgpnjgo3jgYvjgZlcIixcbiAgICBcIuOBiuOBr+OCmeOBleOCk1wiLFxuICAgIFwi44GK44G+44GE44KKXCIsXG4gICAgXCLjgYrjgoHjgabjgpnjgajjgYZcIixcbiAgICBcIuOBiuOCguOBhOOBpuOCmVwiLFxuICAgIFwi44GK44KC44GGXCIsXG4gICAgXCLjgYrjgoLjgZ/jgYRcIixcbiAgICBcIuOBiuOCguOBoeOCg1wiLFxuICAgIFwi44GK44KE44GkXCIsXG4gICAgXCLjgYrjgoTjgobjgbLjgplcIixcbiAgICBcIuOBiuOCiOOBu+OCmeOBmVwiLFxuICAgIFwi44GK44KJ44KT44Gf44KZXCIsXG4gICAgXCLjgYrjgo3jgZlcIixcbiAgICBcIuOBiuOCk+OBi+OCmeOBj1wiLFxuICAgIFwi44GK44KT44GR44GEXCIsXG4gICAgXCLjgYrjgpPjgZfjgoNcIixcbiAgICBcIuOBiuOCk+OBm+OCk1wiLFxuICAgIFwi44GK44KT44Gf44KZ44KTXCIsXG4gICAgXCLjgYrjgpPjgaHjgoXjgYZcIixcbiAgICBcIuOBiuOCk+OBqOOCmeOBkeOBhFwiLFxuICAgIFwi44GL44GC44GkXCIsXG4gICAgXCLjgYvjgYTjgYvjgplcIixcbiAgICBcIuOBi+OCmeOBhOOBjVwiLFxuICAgIFwi44GL44KZ44GE44GR44KTXCIsXG4gICAgXCLjgYvjgpnjgYTjgZPjgYZcIixcbiAgICBcIuOBi+OBhOOBleOBpFwiLFxuICAgIFwi44GL44GE44GX44KDXCIsXG4gICAgXCLjgYvjgYTjgZnjgYTjgojjgY9cIixcbiAgICBcIuOBi+OBhOOBm+OCmeOCk1wiLFxuICAgIFwi44GL44GE44Gd44KZ44GG44Go44KZXCIsXG4gICAgXCLjgYvjgYTjgaTjgYZcIixcbiAgICBcIuOBi+OBhOOBpuOCk1wiLFxuICAgIFwi44GL44GE44Go44GGXCIsXG4gICAgXCLjgYvjgYTjgbXjgY9cIixcbiAgICBcIuOBi+OCmeOBhOOBuOOBjVwiLFxuICAgIFwi44GL44GE44G744GGXCIsXG4gICAgXCLjgYvjgYTjgojjgYZcIixcbiAgICBcIuOBi+OCmeOBhOOCieOBhFwiLFxuICAgIFwi44GL44GE44KPXCIsXG4gICAgXCLjgYvjgYjjgotcIixcbiAgICBcIuOBi+OBiuOCilwiLFxuICAgIFwi44GL44GL44GI44KLXCIsXG4gICAgXCLjgYvjgYvjgpnjgY9cIixcbiAgICBcIuOBi+OBi+OCmeOBl1wiLFxuICAgIFwi44GL44GL44KZ44G/XCIsXG4gICAgXCLjgYvjgY/jgZPjgplcIixcbiAgICBcIuOBi+OBj+OBqOOBj1wiLFxuICAgIFwi44GL44GV44KZ44KLXCIsXG4gICAgXCLjgYvjgpnjgZ3jgpnjgYZcIixcbiAgICBcIuOBi+OBn+OBhFwiLFxuICAgIFwi44GL44Gf44GhXCIsXG4gICAgXCLjgYvjgpnjgaHjgofjgYZcIixcbiAgICBcIuOBi+OCmeOBo+OBjeOCheOBhlwiLFxuICAgIFwi44GL44KZ44Gj44GT44GGXCIsXG4gICAgXCLjgYvjgpnjgaPjgZXjgpNcIixcbiAgICBcIuOBi+OCmeOBo+OBl+OCh+OBhlwiLFxuICAgIFwi44GL44Gq44GV44KZ44KP44GXXCIsXG4gICAgXCLjgYvjga7jgYZcIixcbiAgICBcIuOBi+OCmeOBr+OBj1wiLFxuICAgIFwi44GL44G144KZ44GLXCIsXG4gICAgXCLjgYvjgbvjgYZcIixcbiAgICBcIuOBi+OBu+OBk+OCmVwiLFxuICAgIFwi44GL44G+44GGXCIsXG4gICAgXCLjgYvjgb7jgbvjgpnjgZNcIixcbiAgICBcIuOBi+OCgeOCjOOBiuOCk1wiLFxuICAgIFwi44GL44KG44GEXCIsXG4gICAgXCLjgYvjgojjgYbjgbLjgplcIixcbiAgICBcIuOBi+OCieOBhFwiLFxuICAgIFwi44GL44KL44GEXCIsXG4gICAgXCLjgYvjgo3jgYZcIixcbiAgICBcIuOBi+OCj+OBj1wiLFxuICAgIFwi44GL44KP44KJXCIsXG4gICAgXCLjgYvjgpnjgpPjgYtcIixcbiAgICBcIuOBi+OCk+OBkeOBhFwiLFxuICAgIFwi44GL44KT44GT44GGXCIsXG4gICAgXCLjgYvjgpPjgZfjgoNcIixcbiAgICBcIuOBi+OCk+OBneOBhlwiLFxuICAgIFwi44GL44KT44Gf44KTXCIsXG4gICAgXCLjgYvjgpPjgaFcIixcbiAgICBcIuOBi+OCmeOCk+OBr+OCmeOCi1wiLFxuICAgIFwi44GN44GC44GEXCIsXG4gICAgXCLjgY3jgYLjgaRcIixcbiAgICBcIuOBjeOBhOOCjVwiLFxuICAgIFwi44GN44KZ44GE44KTXCIsXG4gICAgXCLjgY3jgYbjgYRcIixcbiAgICBcIuOBjeOBhuOCk1wiLFxuICAgIFwi44GN44GI44KLXCIsXG4gICAgXCLjgY3jgYrjgYZcIixcbiAgICBcIuOBjeOBiuOBj1wiLFxuICAgIFwi44GN44GK44GhXCIsXG4gICAgXCLjgY3jgYrjgpNcIixcbiAgICBcIuOBjeOBi+OBhFwiLFxuICAgIFwi44GN44GL44GPXCIsXG4gICAgXCLjgY3jgYvjgpPjgZfjgoNcIixcbiAgICBcIuOBjeOBjeOBplwiLFxuICAgIFwi44GN44GP44Gv44KZ44KKXCIsXG4gICAgXCLjgY3jgY/jgonjgZHjgplcIixcbiAgICBcIuOBjeOBkeOCk+OBm+OBhFwiLFxuICAgIFwi44GN44GT44GGXCIsXG4gICAgXCLjgY3jgZPjgYjjgotcIixcbiAgICBcIuOBjeOBk+OBj1wiLFxuICAgIFwi44GN44GV44GEXCIsXG4gICAgXCLjgY3jgZXjgY9cIixcbiAgICBcIuOBjeOBleOBvlwiLFxuICAgIFwi44GN44GV44KJ44GN44KZXCIsXG4gICAgXCLjgY3jgpnjgZfjgpnjgYvjgYvjgpnjgY9cIixcbiAgICBcIuOBjeOCmeOBl+OBjVwiLFxuICAgIFwi44GN44KZ44GX44KZ44Gf44GE44GR44KTXCIsXG4gICAgXCLjgY3jgpnjgZfjgpnjgavjgaPjgabjgYRcIixcbiAgICBcIuOBjeOCmeOBl+OCmeOCheOBpOOBl+OCg1wiLFxuICAgIFwi44GN44GZ44GGXCIsXG4gICAgXCLjgY3jgZvjgYRcIixcbiAgICBcIuOBjeOBm+OBjVwiLFxuICAgIFwi44GN44Gb44GkXCIsXG4gICAgXCLjgY3jgZ3jgYZcIixcbiAgICBcIuOBjeOBneOCmeOBj1wiLFxuICAgIFwi44GN44Gd44KZ44KTXCIsXG4gICAgXCLjgY3jgZ/jgYjjgotcIixcbiAgICBcIuOBjeOBoeOCh+OBhlwiLFxuICAgIFwi44GN44Gk44GI44KTXCIsXG4gICAgXCLjgY3jgpnjgaPjgaHjgopcIixcbiAgICBcIuOBjeOBpOOBpOOBjVwiLFxuICAgIFwi44GN44Gk44GtXCIsXG4gICAgXCLjgY3jgabjgYRcIixcbiAgICBcIuOBjeOBqOOCmeOBhlwiLFxuICAgIFwi44GN44Go44KZ44GPXCIsXG4gICAgXCLjgY3jgarjgYRcIixcbiAgICBcIuOBjeOBquOBi+OCmVwiLFxuICAgIFwi44GN44Gq44GTXCIsXG4gICAgXCLjgY3jgazjgZPjgpnjgZdcIixcbiAgICBcIuOBjeOBreOCk1wiLFxuICAgIFwi44GN44Gu44GGXCIsXG4gICAgXCLjgY3jga7jgZfjgZ9cIixcbiAgICBcIuOBjeOBr+OBj1wiLFxuICAgIFwi44GN44Gy44KZ44GX44GEXCIsXG4gICAgXCLjgY3jgbLjgpNcIixcbiAgICBcIuOBjeOBteOBj1wiLFxuICAgIFwi44GN44G144KZ44KTXCIsXG4gICAgXCLjgY3jgbvjgpnjgYZcIixcbiAgICBcIuOBjeOBu+OCk1wiLFxuICAgIFwi44GN44G+44KLXCIsXG4gICAgXCLjgY3jgb/jgaRcIixcbiAgICBcIuOBjeOCgOOBmeOCmeOBi+OBl+OBhFwiLFxuICAgIFwi44GN44KB44KLXCIsXG4gICAgXCLjgY3jgoLjgZ/jgpnjgoHjgZdcIixcbiAgICBcIuOBjeOCguOBoVwiLFxuICAgIFwi44GN44KC44GuXCIsXG4gICAgXCLjgY3jgoPjgY9cIixcbiAgICBcIuOBjeOChOOBj1wiLFxuICAgIFwi44GN44KZ44KF44GG44Gr44GPXCIsXG4gICAgXCLjgY3jgojjgYZcIixcbiAgICBcIuOBjeOCh+OBhuOCiuOCheOBhlwiLFxuICAgIFwi44GN44KJ44GEXCIsXG4gICAgXCLjgY3jgonjgY9cIixcbiAgICBcIuOBjeOCiuOCk1wiLFxuICAgIFwi44GN44KM44GEXCIsXG4gICAgXCLjgY3jgozjgaRcIixcbiAgICBcIuOBjeOCjeOBj1wiLFxuICAgIFwi44GN44KZ44KN44KTXCIsXG4gICAgXCLjgY3jgo/jgoHjgotcIixcbiAgICBcIuOBjeOCmeOCk+OBhOOCjVwiLFxuICAgIFwi44GN44KT44GL44GP44GX44KZXCIsXG4gICAgXCLjgY3jgpPjgZfjgpnjgodcIixcbiAgICBcIuOBjeOCk+OCiOOBhuOBsuOCmVwiLFxuICAgIFwi44GP44KZ44GC44GEXCIsXG4gICAgXCLjgY/jgYTjgZnjgplcIixcbiAgICBcIuOBj+OBhuOBi+OCk1wiLFxuICAgIFwi44GP44GG44GNXCIsXG4gICAgXCLjgY/jgYbjgY/jgpnjgpNcIixcbiAgICBcIuOBj+OBhuOBk+OBhlwiLFxuICAgIFwi44GP44KZ44GG44Gb44GEXCIsXG4gICAgXCLjgY/jgYbjgZ3jgYZcIixcbiAgICBcIuOBj+OCmeOBhuOBn+OCiVwiLFxuICAgIFwi44GP44GG44G144GPXCIsXG4gICAgXCLjgY/jgYbjgbvjgplcIixcbiAgICBcIuOBj+OBi+OCk1wiLFxuICAgIFwi44GP44GN44KH44GGXCIsXG4gICAgXCLjgY/jgZHjgpnjgpNcIixcbiAgICBcIuOBj+OCmeOBk+OBhlwiLFxuICAgIFwi44GP44GV44GEXCIsXG4gICAgXCLjgY/jgZXjgY1cIixcbiAgICBcIuOBj+OBleOBr+OCmeOBqlwiLFxuICAgIFwi44GP44GV44KLXCIsXG4gICAgXCLjgY/jgZfjgoPjgb9cIixcbiAgICBcIuOBj+OBl+OCh+OBhlwiLFxuICAgIFwi44GP44GZ44Gu44GNXCIsXG4gICAgXCLjgY/jgZnjgorjgobjgbLjgplcIixcbiAgICBcIuOBj+OBm+OBkeOCmVwiLFxuICAgIFwi44GP44Gb44KTXCIsXG4gICAgXCLjgY/jgpnjgZ/jgYTjgabjgY1cIixcbiAgICBcIuOBj+OBn+OCmeOBleOCi1wiLFxuICAgIFwi44GP44Gf44Gy44KZ44KM44KLXCIsXG4gICAgXCLjgY/jgaHjgZPjgb9cIixcbiAgICBcIuOBj+OBoeOBleOBjVwiLFxuICAgIFwi44GP44Gk44GX44GfXCIsXG4gICAgXCLjgY/jgpnjgaPjgZnjgopcIixcbiAgICBcIuOBj+OBpOOCjeOBj+OCmVwiLFxuICAgIFwi44GP44Go44GG44Gm44KTXCIsXG4gICAgXCLjgY/jgajjgpnjgY9cIixcbiAgICBcIuOBj+OBquOCk1wiLFxuICAgIFwi44GP44Gt44GP44GtXCIsXG4gICAgXCLjgY/jga7jgYZcIixcbiAgICBcIuOBj+OBteOBhlwiLFxuICAgIFwi44GP44G/44GC44KP44GbXCIsXG4gICAgXCLjgY/jgb/jgZ/jgabjgotcIixcbiAgICBcIuOBj+OCgeOCi1wiLFxuICAgIFwi44GP44KE44GP44GX44KHXCIsXG4gICAgXCLjgY/jgonjgZlcIixcbiAgICBcIuOBj+OCieOBuOOCmeOCi1wiLFxuICAgIFwi44GP44KL44G+XCIsXG4gICAgXCLjgY/jgozjgotcIixcbiAgICBcIuOBj+OCjeOBhlwiLFxuICAgIFwi44GP44KP44GX44GEXCIsXG4gICAgXCLjgY/jgpnjgpPjgYvjgpNcIixcbiAgICBcIuOBj+OCmeOCk+OBl+OCh+OBj1wiLFxuICAgIFwi44GP44KZ44KT44Gf44GEXCIsXG4gICAgXCLjgY/jgpnjgpPjgaZcIixcbiAgICBcIuOBkeOBguOBqlwiLFxuICAgIFwi44GR44GE44GL44GPXCIsXG4gICAgXCLjgZHjgYTjgZHjgpNcIixcbiAgICBcIuOBkeOBhOOBk1wiLFxuICAgIFwi44GR44GE44GV44GkXCIsXG4gICAgXCLjgZHjgpnjgYTjgZfjgpnjgoXjgaRcIixcbiAgICBcIuOBkeOBhOOBn+OBhFwiLFxuICAgIFwi44GR44KZ44GE44Gu44GG44GX44KZ44KTXCIsXG4gICAgXCLjgZHjgYTjgozjgY1cIixcbiAgICBcIuOBkeOBhOOCjVwiLFxuICAgIFwi44GR44GK44Go44GZXCIsXG4gICAgXCLjgZHjgYrjgorjgoLjga5cIixcbiAgICBcIuOBkeOCmeOBjeOBi1wiLFxuICAgIFwi44GR44KZ44GN44GR44KZ44KTXCIsXG4gICAgXCLjgZHjgpnjgY3jgZ/jgpnjgpNcIixcbiAgICBcIuOBkeOCmeOBjeOBoeOCk1wiLFxuICAgIFwi44GR44KZ44GN44Go44GkXCIsXG4gICAgXCLjgZHjgpnjgY3jga9cIixcbiAgICBcIuOBkeOCmeOBjeOChOOBj1wiLFxuICAgIFwi44GR44KZ44GT44GGXCIsXG4gICAgXCLjgZHjgpnjgZPjgY/jgZfjgpnjgofjgYZcIixcbiAgICBcIuOBkeOCmeOBleOCmeOBhFwiLFxuICAgIFwi44GR44GV44GNXCIsXG4gICAgXCLjgZHjgpnjgZXjgpnjgpNcIixcbiAgICBcIuOBkeOBl+OBjVwiLFxuICAgIFwi44GR44GX44GT44KZ44KAXCIsXG4gICAgXCLjgZHjgZfjgofjgYZcIixcbiAgICBcIuOBkeOCmeOBmeOBqFwiLFxuICAgIFwi44GR44Gf44Gv44KZXCIsXG4gICAgXCLjgZHjgaHjgoPjgaPjgbXjgppcIixcbiAgICBcIuOBkeOBoeOCieOBmVwiLFxuICAgIFwi44GR44Gk44GC44GkXCIsXG4gICAgXCLjgZHjgaTjgYRcIixcbiAgICBcIuOBkeOBpOOBiOOBjVwiLFxuICAgIFwi44GR44Gj44GT44KTXCIsXG4gICAgXCLjgZHjgaTjgZfjgpnjgodcIixcbiAgICBcIuOBkeOBo+OBm+OBjVwiLFxuICAgIFwi44GR44Gj44Gm44GEXCIsXG4gICAgXCLjgZHjgaTjgb7jgaRcIixcbiAgICBcIuOBkeOCmeOBpOOCiOOBhuOBsuOCmVwiLFxuICAgIFwi44GR44KZ44Gk44KM44GEXCIsXG4gICAgXCLjgZHjgaTjgo3jgpNcIixcbiAgICBcIuOBkeOCmeOBqOOCmeOBj1wiLFxuICAgIFwi44GR44Go44Gv44KZ44GZXCIsXG4gICAgXCLjgZHjgajjgotcIixcbiAgICBcIuOBkeOBquOBkeOCmVwiLFxuICAgIFwi44GR44Gq44GZXCIsXG4gICAgXCLjgZHjgarjgb9cIixcbiAgICBcIuOBkeOBrOOBjVwiLFxuICAgIFwi44GR44KZ44Gt44GkXCIsXG4gICAgXCLjgZHjga3jgpNcIixcbiAgICBcIuOBkeOBr+OBhFwiLFxuICAgIFwi44GR44KZ44Gy44KTXCIsXG4gICAgXCLjgZHjgbXjgpnjgYvjgYRcIixcbiAgICBcIuOBkeOCmeOBu+OCmeOBj1wiLFxuICAgIFwi44GR44G+44KKXCIsXG4gICAgXCLjgZHjgb/jgYvjgotcIixcbiAgICBcIuOBkeOCgOOBl1wiLFxuICAgIFwi44GR44KA44KKXCIsXG4gICAgXCLjgZHjgoLjga5cIixcbiAgICBcIuOBkeOCieOBhFwiLFxuICAgIFwi44GR44KN44GR44KNXCIsXG4gICAgXCLjgZHjgo/jgZfjgYRcIixcbiAgICBcIuOBkeOCk+OBhFwiLFxuICAgIFwi44GR44KT44GI44GkXCIsXG4gICAgXCLjgZHjgpPjgYpcIixcbiAgICBcIuOBkeOCk+OBi1wiLFxuICAgIFwi44GR44KZ44KT44GNXCIsXG4gICAgXCLjgZHjgpPjgZHjgpnjgpNcIixcbiAgICBcIuOBkeOCk+OBk+OBhlwiLFxuICAgIFwi44GR44KT44GV44GPXCIsXG4gICAgXCLjgZHjgpPjgZfjgoXjgYZcIixcbiAgICBcIuOBkeOCk+OBmeOBhlwiLFxuICAgIFwi44GR44KZ44KT44Gd44GGXCIsXG4gICAgXCLjgZHjgpPjgaHjgY9cIixcbiAgICBcIuOBkeOCk+OBpuOBhFwiLFxuICAgIFwi44GR44KT44Go44GGXCIsXG4gICAgXCLjgZHjgpPjgarjgYRcIixcbiAgICBcIuOBkeOCk+OBq+OCk1wiLFxuICAgIFwi44GR44KZ44KT44G144KZ44GkXCIsXG4gICAgXCLjgZHjgpPjgb5cIixcbiAgICBcIuOBkeOCk+OBv+OCk1wiLFxuICAgIFwi44GR44KT44KB44GEXCIsXG4gICAgXCLjgZHjgpPjgonjgpNcIixcbiAgICBcIuOBkeOCk+OCilwiLFxuICAgIFwi44GT44GC44GP44G+XCIsXG4gICAgXCLjgZPjgYTjgaxcIixcbiAgICBcIuOBk+OBhOOBsuOCmeOBqFwiLFxuICAgIFwi44GT44KZ44GG44GEXCIsXG4gICAgXCLjgZPjgYbjgYjjgpNcIixcbiAgICBcIuOBk+OBhuOBiuOCk1wiLFxuICAgIFwi44GT44GG44GL44KTXCIsXG4gICAgXCLjgZPjgpnjgYbjgY3jgoXjgYZcIixcbiAgICBcIuOBk+OCmeOBhuOBkeOBhFwiLFxuICAgIFwi44GT44GG44GT44GGXCIsXG4gICAgXCLjgZPjgYbjgZXjgYRcIixcbiAgICBcIuOBk+OBhuOBl+OCmVwiLFxuICAgIFwi44GT44GG44GZ44GEXCIsXG4gICAgXCLjgZPjgpnjgYbjgZvjgYRcIixcbiAgICBcIuOBk+OBhuOBneOBj1wiLFxuICAgIFwi44GT44GG44Gf44GEXCIsXG4gICAgXCLjgZPjgYbjgaHjgoNcIixcbiAgICBcIuOBk+OBhuOBpOOBhlwiLFxuICAgIFwi44GT44GG44Gm44GEXCIsXG4gICAgXCLjgZPjgYbjgajjgpnjgYZcIixcbiAgICBcIuOBk+OBhuOBquOBhFwiLFxuICAgIFwi44GT44GG44Gv44GEXCIsXG4gICAgXCLjgZPjgpnjgYbjgbvjgYZcIixcbiAgICBcIuOBk+OCmeOBhuOBvuOCk1wiLFxuICAgIFwi44GT44GG44KC44GPXCIsXG4gICAgXCLjgZPjgYbjgorjgaRcIixcbiAgICBcIuOBk+OBiOOCi1wiLFxuICAgIFwi44GT44GK44KKXCIsXG4gICAgXCLjgZPjgpnjgYvjgYRcIixcbiAgICBcIuOBk+OCmeOBi+OCmeOBpFwiLFxuICAgIFwi44GT44KZ44GL44KTXCIsXG4gICAgXCLjgZPjgY/jgZPjgplcIixcbiAgICBcIuOBk+OBj+OBleOBhFwiLFxuICAgIFwi44GT44GP44Go44GGXCIsXG4gICAgXCLjgZPjgY/jgarjgYRcIixcbiAgICBcIuOBk+OBj+OBr+OBj1wiLFxuICAgIFwi44GT44GP44KZ44G+XCIsXG4gICAgXCLjgZPjgZHjgYRcIixcbiAgICBcIuOBk+OBkeOCi1wiLFxuICAgIFwi44GT44GT44Gu44GLXCIsXG4gICAgXCLjgZPjgZPjgo1cIixcbiAgICBcIuOBk+OBleOCgVwiLFxuICAgIFwi44GT44GX44GkXCIsXG4gICAgXCLjgZPjgZnjgYZcIixcbiAgICBcIuOBk+OBm+OBhFwiLFxuICAgIFwi44GT44Gb44GNXCIsXG4gICAgXCLjgZPjgZvjgpnjgpNcIixcbiAgICBcIuOBk+OBneOBn+OCmeOBplwiLFxuICAgIFwi44GT44Gf44GEXCIsXG4gICAgXCLjgZPjgZ/jgYjjgotcIixcbiAgICBcIuOBk+OBn+OBpFwiLFxuICAgIFwi44GT44Gh44KH44GGXCIsXG4gICAgXCLjgZPjgaPjgYtcIixcbiAgICBcIuOBk+OBpOOBk+OBpFwiLFxuICAgIFwi44GT44Gk44Gv44KZ44KTXCIsXG4gICAgXCLjgZPjgaTjgbXjgplcIixcbiAgICBcIuOBk+OBpuOBhFwiLFxuICAgIFwi44GT44Gm44KTXCIsXG4gICAgXCLjgZPjgajjgYvjgpnjgolcIixcbiAgICBcIuOBk+OBqOOBl1wiLFxuICAgIFwi44GT44Go44Gv44KZXCIsXG4gICAgXCLjgZPjgajjgopcIixcbiAgICBcIuOBk+OBquOBk+OCmeOBqlwiLFxuICAgIFwi44GT44Gt44GT44GtXCIsXG4gICAgXCLjgZPjga7jgb7jgb5cIixcbiAgICBcIuOBk+OBruOBv1wiLFxuICAgIFwi44GT44Gu44KIXCIsXG4gICAgXCLjgZPjgpnjga/jgpNcIixcbiAgICBcIuOBk+OBsuOBpOOBl+OCmVwiLFxuICAgIFwi44GT44G144GGXCIsXG4gICAgXCLjgZPjgbXjgpNcIixcbiAgICBcIuOBk+OBu+OCmeOCjOOCi1wiLFxuICAgIFwi44GT44KZ44G+44GC44G144KZ44KJXCIsXG4gICAgXCLjgZPjgb7jgYvjgYRcIixcbiAgICBcIuOBk+OCmeOBvuOBmeOCilwiLFxuICAgIFwi44GT44G+44Gk44GqXCIsXG4gICAgXCLjgZPjgb7jgotcIixcbiAgICBcIuOBk+OCgOOBjeOCmeOBk1wiLFxuICAgIFwi44GT44KC44GX44KZXCIsXG4gICAgXCLjgZPjgoLjgaFcIixcbiAgICBcIuOBk+OCguOBrlwiLFxuICAgIFwi44GT44KC44KTXCIsXG4gICAgXCLjgZPjgoTjgY9cIixcbiAgICBcIuOBk+OChOOBvlwiLFxuICAgIFwi44GT44KG44GGXCIsXG4gICAgXCLjgZPjgobjgbLjgplcIixcbiAgICBcIuOBk+OCiOOBhFwiLFxuICAgIFwi44GT44KI44GGXCIsXG4gICAgXCLjgZPjgorjgotcIixcbiAgICBcIuOBk+OCjOOBj+OBl+OCh+OCk1wiLFxuICAgIFwi44GT44KN44Gj44GRXCIsXG4gICAgXCLjgZPjgo/jgoLjgaZcIixcbiAgICBcIuOBk+OCj+OCjOOCi1wiLFxuICAgIFwi44GT44KT44GE44KTXCIsXG4gICAgXCLjgZPjgpPjgYvjgYRcIixcbiAgICBcIuOBk+OCk+OBjVwiLFxuICAgIFwi44GT44KT44GX44KF44GGXCIsXG4gICAgXCLjgZPjgpPjgZnjgYRcIixcbiAgICBcIuOBk+OCk+OBn+OCmeOBplwiLFxuICAgIFwi44GT44KT44Go44KTXCIsXG4gICAgXCLjgZPjgpPjgarjgpNcIixcbiAgICBcIuOBk+OCk+OBsuOCmeOBq1wiLFxuICAgIFwi44GT44KT44G744Ka44KTXCIsXG4gICAgXCLjgZPjgpPjgb7jgZFcIixcbiAgICBcIuOBk+OCk+OChFwiLFxuICAgIFwi44GT44KT44KM44GEXCIsXG4gICAgXCLjgZPjgpPjgo/jgY9cIixcbiAgICBcIuOBleOCmeOBhOOBiOOBjVwiLFxuICAgIFwi44GV44GE44GL44GEXCIsXG4gICAgXCLjgZXjgYTjgY3jgpNcIixcbiAgICBcIuOBleOCmeOBhOOBkeOCmeOCk1wiLFxuICAgIFwi44GV44KZ44GE44GTXCIsXG4gICAgXCLjgZXjgYTjgZfjgodcIixcbiAgICBcIuOBleOBhOOBm+OBhFwiLFxuICAgIFwi44GV44KZ44GE44Gf44GPXCIsXG4gICAgXCLjgZXjgpnjgYTjgaHjgoXjgYZcIixcbiAgICBcIuOBleOBhOOBpuOBjVwiLFxuICAgIFwi44GV44KZ44GE44KK44KH44GGXCIsXG4gICAgXCLjgZXjgYbjgapcIixcbiAgICBcIuOBleOBi+OBhOOBl1wiLFxuICAgIFwi44GV44GL44KZ44GZXCIsXG4gICAgXCLjgZXjgYvjgapcIixcbiAgICBcIuOBleOBi+OBv+OBoVwiLFxuICAgIFwi44GV44GL44KZ44KLXCIsXG4gICAgXCLjgZXjgY3jgpnjgofjgYZcIixcbiAgICBcIuOBleOBj+OBl1wiLFxuICAgIFwi44GV44GP44Gy44KTXCIsXG4gICAgXCLjgZXjgY/jgolcIixcbiAgICBcIuOBleOBk+OBj1wiLFxuICAgIFwi44GV44GT44GkXCIsXG4gICAgXCLjgZXjgZnjgpnjgYvjgotcIixcbiAgICBcIuOBleOCmeOBm+OBjVwiLFxuICAgIFwi44GV44Gf44KTXCIsXG4gICAgXCLjgZXjgaTjgYjjgYRcIixcbiAgICBcIuOBleOCmeOBpOOBiuOCk1wiLFxuICAgIFwi44GV44KZ44Gj44GLXCIsXG4gICAgXCLjgZXjgpnjgaTjgYvjgpnjgY9cIixcbiAgICBcIuOBleOBo+OBjeOCh+OBj1wiLFxuICAgIFwi44GV44KZ44Gj44GXXCIsXG4gICAgXCLjgZXjgaTjgZfjgpnjgpNcIixcbiAgICBcIuOBleOCmeOBo+OBneOBhlwiLFxuICAgIFwi44GV44Gk44Gf44Gv44KZXCIsXG4gICAgXCLjgZXjgaTjgb7jgYTjgoJcIixcbiAgICBcIuOBleOBpuOBhFwiLFxuICAgIFwi44GV44Go44GE44KCXCIsXG4gICAgXCLjgZXjgajjgYZcIixcbiAgICBcIuOBleOBqOOBiuOChFwiLFxuICAgIFwi44GV44Go44GXXCIsXG4gICAgXCLjgZXjgajjgotcIixcbiAgICBcIuOBleOBruOBhlwiLFxuICAgIFwi44GV44Gv44KZ44GPXCIsXG4gICAgXCLjgZXjgbLjgpnjgZfjgYRcIixcbiAgICBcIuOBleOBuOOCmeOBpFwiLFxuICAgIFwi44GV44G744GGXCIsXG4gICAgXCLjgZXjgbvjgajjgplcIixcbiAgICBcIuOBleOBvuOBmVwiLFxuICAgIFwi44GV44G/44GX44GEXCIsXG4gICAgXCLjgZXjgb/jgZ/jgpnjgoxcIixcbiAgICBcIuOBleOCgOOBkVwiLFxuICAgIFwi44GV44KB44KLXCIsXG4gICAgXCLjgZXjgoTjgYjjgpPjgajjgpnjgYZcIixcbiAgICBcIuOBleOChuOBhlwiLFxuICAgIFwi44GV44KI44GGXCIsXG4gICAgXCLjgZXjgojjgY9cIixcbiAgICBcIuOBleOCieOBn+OCmVwiLFxuICAgIFwi44GV44KZ44KL44Gd44Gv44KZXCIsXG4gICAgXCLjgZXjgo/jgoTjgYtcIixcbiAgICBcIuOBleOCj+OCi1wiLFxuICAgIFwi44GV44KT44GE44KTXCIsXG4gICAgXCLjgZXjgpPjgYtcIixcbiAgICBcIuOBleOCk+OBjeOCg+OBj1wiLFxuICAgIFwi44GV44KT44GT44GGXCIsXG4gICAgXCLjgZXjgpPjgZXjgYRcIixcbiAgICBcIuOBleOCmeOCk+OBl+OCh1wiLFxuICAgIFwi44GV44KT44GZ44GGXCIsXG4gICAgXCLjgZXjgpPjgZvjgYRcIixcbiAgICBcIuOBleOCk+OBnVwiLFxuICAgIFwi44GV44KT44GhXCIsXG4gICAgXCLjgZXjgpPjgb5cIixcbiAgICBcIuOBleOCk+OBv1wiLFxuICAgIFwi44GV44KT44KJ44KTXCIsXG4gICAgXCLjgZfjgYLjgYRcIixcbiAgICBcIuOBl+OBguOBkeOCmVwiLFxuICAgIFwi44GX44GC44GV44Gj44GmXCIsXG4gICAgXCLjgZfjgYLjgo/jgZtcIixcbiAgICBcIuOBl+OBhOOBj1wiLFxuICAgIFwi44GX44GE44KTXCIsXG4gICAgXCLjgZfjgYbjgaFcIixcbiAgICBcIuOBl+OBiOOBhFwiLFxuICAgIFwi44GX44GK44GRXCIsXG4gICAgXCLjgZfjgYvjgYRcIixcbiAgICBcIuOBl+OBi+OBj1wiLFxuICAgIFwi44GX44KZ44GL44KTXCIsXG4gICAgXCLjgZfjgZPjgpnjgahcIixcbiAgICBcIuOBl+OBmeOBhlwiLFxuICAgIFwi44GX44KZ44Gf44KZ44GEXCIsXG4gICAgXCLjgZfjgZ/jgYbjgZFcIixcbiAgICBcIuOBl+OBn+OBjeOCmVwiLFxuICAgIFwi44GX44Gf44GmXCIsXG4gICAgXCLjgZfjgZ/jgb9cIixcbiAgICBcIuOBl+OBoeOCh+OBhlwiLFxuICAgIFwi44GX44Gh44KK44KTXCIsXG4gICAgXCLjgZfjgaPjgYvjgopcIixcbiAgICBcIuOBl+OBpOOBl+OCmVwiLFxuICAgIFwi44GX44Gk44KC44KTXCIsXG4gICAgXCLjgZfjgabjgYRcIixcbiAgICBcIuOBl+OBpuOBjVwiLFxuICAgIFwi44GX44Gm44GkXCIsXG4gICAgXCLjgZfjgpnjgabjgpNcIixcbiAgICBcIuOBl+OCmeOBqOOCmeOBhlwiLFxuICAgIFwi44GX44Gq44GN44KZ44KMXCIsXG4gICAgXCLjgZfjgarjgoLjga5cIixcbiAgICBcIuOBl+OBquOCk1wiLFxuICAgIFwi44GX44Gt44G+XCIsXG4gICAgXCLjgZfjga3jgpNcIixcbiAgICBcIuOBl+OBruOBj+OCmVwiLFxuICAgIFwi44GX44Gu44G144KZXCIsXG4gICAgXCLjgZfjga/jgYRcIixcbiAgICBcIuOBl+OBr+OCmeOBi+OCilwiLFxuICAgIFwi44GX44Gv44GkXCIsXG4gICAgXCLjgZfjga/jgonjgYRcIixcbiAgICBcIuOBl+OBr+OCk1wiLFxuICAgIFwi44GX44Gy44KH44GGXCIsXG4gICAgXCLjgZfjgbXjgY9cIixcbiAgICBcIuOBl+OCmeOBteOCmeOCk1wiLFxuICAgIFwi44GX44G444GEXCIsXG4gICAgXCLjgZfjgbvjgYZcIixcbiAgICBcIuOBl+OBu+OCk1wiLFxuICAgIFwi44GX44G+44GGXCIsXG4gICAgXCLjgZfjgb7jgotcIixcbiAgICBcIuOBl+OBv+OCk1wiLFxuICAgIFwi44GX44KA44GR44KLXCIsXG4gICAgXCLjgZfjgpnjgoDjgZfjgodcIixcbiAgICBcIuOBl+OCgeOBhFwiLFxuICAgIFwi44GX44KB44KLXCIsXG4gICAgXCLjgZfjgoLjgpNcIixcbiAgICBcIuOBl+OCg+OBhOOCk1wiLFxuICAgIFwi44GX44KD44GG44KTXCIsXG4gICAgXCLjgZfjgoPjgYrjgpNcIixcbiAgICBcIuOBl+OCmeOCg+OBi+OCmeOBhOOCglwiLFxuICAgIFwi44GX44KE44GP44GX44KHXCIsXG4gICAgXCLjgZfjgoPjgY/jgbvjgYZcIixcbiAgICBcIuOBl+OCg+OBkeOCk1wiLFxuICAgIFwi44GX44KD44GTXCIsXG4gICAgXCLjgZfjgoPjgZXjgpnjgYRcIixcbiAgICBcIuOBl+OCg+OBl+OCk1wiLFxuICAgIFwi44GX44KD44Gb44KTXCIsXG4gICAgXCLjgZfjgoPjgZ3jgYZcIixcbiAgICBcIuOBl+OCg+OBn+OBhFwiLFxuICAgIFwi44GX44KD44Gh44KH44GGXCIsXG4gICAgXCLjgZfjgoPjgaPjgY3jgpNcIixcbiAgICBcIuOBl+OCmeOCg+OBvlwiLFxuICAgIFwi44GX44KD44KK44KTXCIsXG4gICAgXCLjgZfjgoPjgozjgYRcIixcbiAgICBcIuOBl+OCmeOChuOBhlwiLFxuICAgIFwi44GX44KZ44KF44GG44GX44KHXCIsXG4gICAgXCLjgZfjgoXjgY/jga/jgY9cIixcbiAgICBcIuOBl+OCmeOCheOBl+OCk1wiLFxuICAgIFwi44GX44KF44Gj44Gb44GNXCIsXG4gICAgXCLjgZfjgoXjgb9cIixcbiAgICBcIuOBl+OCheOCieOBr+OCmVwiLFxuICAgIFwi44GX44KZ44KF44KT44Gv44KZ44KTXCIsXG4gICAgXCLjgZfjgofjgYbjgYvjgYRcIixcbiAgICBcIuOBl+OCh+OBj+OBn+OBj1wiLFxuICAgIFwi44GX44KH44Gj44GR44KTXCIsXG4gICAgXCLjgZfjgofjgajjgpnjgYZcIixcbiAgICBcIuOBl+OCh+OCguOBpFwiLFxuICAgIFwi44GX44KJ44Gb44KLXCIsXG4gICAgXCLjgZfjgonjgbjjgpnjgotcIixcbiAgICBcIuOBl+OCk+OBi1wiLFxuICAgIFwi44GX44KT44GT44GGXCIsXG4gICAgXCLjgZfjgpnjgpPjgZfjgpnjgoNcIixcbiAgICBcIuOBl+OCk+OBm+OBhOOBl+OCmVwiLFxuICAgIFwi44GX44KT44Gh44GPXCIsXG4gICAgXCLjgZfjgpPjgorjgpNcIixcbiAgICBcIuOBmeOBguOBkeOCmVwiLFxuICAgIFwi44GZ44GC44GXXCIsXG4gICAgXCLjgZnjgYLjgapcIixcbiAgICBcIuOBmeOCmeOBguOCk1wiLFxuICAgIFwi44GZ44GE44GI44GEXCIsXG4gICAgXCLjgZnjgYTjgYtcIixcbiAgICBcIuOBmeOBhOOBqOOBhlwiLFxuICAgIFwi44GZ44KZ44GE44G144KZ44KTXCIsXG4gICAgXCLjgZnjgYTjgojjgYbjgbLjgplcIixcbiAgICBcIuOBmeOBhuOBi+OCmeOBj1wiLFxuICAgIFwi44GZ44GG44GX44KZ44GkXCIsXG4gICAgXCLjgZnjgYbjgZvjgpNcIixcbiAgICBcIuOBmeOBiuOBqOOCmeOCilwiLFxuICAgIFwi44GZ44GN44G+XCIsXG4gICAgXCLjgZnjgY/jgYZcIixcbiAgICBcIuOBmeOBj+OBquOBhFwiLFxuICAgIFwi44GZ44GR44KLXCIsXG4gICAgXCLjgZnjgZPjgpnjgYRcIixcbiAgICBcIuOBmeOBk+OBl1wiLFxuICAgIFwi44GZ44KZ44GV44KTXCIsXG4gICAgXCLjgZnjgZnjgpnjgZfjgYRcIixcbiAgICBcIuOBmeOBmeOCgFwiLFxuICAgIFwi44GZ44GZ44KB44KLXCIsXG4gICAgXCLjgZnjgaPjgYvjgopcIixcbiAgICBcIuOBmeOCmeOBo+OBl+OCilwiLFxuICAgIFwi44GZ44KZ44Gj44GoXCIsXG4gICAgXCLjgZnjgabjgY1cIixcbiAgICBcIuOBmeOBpuOCi1wiLFxuICAgIFwi44GZ44Gt44KLXCIsXG4gICAgXCLjgZnjga7jgZNcIixcbiAgICBcIuOBmeOBr+OBn+OCmVwiLFxuICAgIFwi44GZ44Gv44KZ44KJ44GX44GEXCIsXG4gICAgXCLjgZnjgpnjgbLjgofjgYZcIixcbiAgICBcIuOBmeOCmeOBteOCmeOBrOOCjFwiLFxuICAgIFwi44GZ44G144KZ44KKXCIsXG4gICAgXCLjgZnjgbXjgoxcIixcbiAgICBcIuOBmeOBuOOCmeOBplwiLFxuICAgIFwi44GZ44G444KZ44KLXCIsXG4gICAgXCLjgZnjgpnjgbvjgYZcIixcbiAgICBcIuOBmeOBu+OCmeOCk1wiLFxuICAgIFwi44GZ44G+44GEXCIsXG4gICAgXCLjgZnjgoHjgZdcIixcbiAgICBcIuOBmeOCguOBhlwiLFxuICAgIFwi44GZ44KE44GNXCIsXG4gICAgXCLjgZnjgonjgZnjgolcIixcbiAgICBcIuOBmeOCi+OCgVwiLFxuICAgIFwi44GZ44KM44Gh44GL44KZ44GGXCIsXG4gICAgXCLjgZnjgo3jgaPjgahcIixcbiAgICBcIuOBmeOCj+OCi1wiLFxuICAgIFwi44GZ44KT44Gb44KZ44KTXCIsXG4gICAgXCLjgZnjgpPjgbvjgprjgYZcIixcbiAgICBcIuOBm+OBguOBteOCmeOCiVwiLFxuICAgIFwi44Gb44GE44GL44GkXCIsXG4gICAgXCLjgZvjgYTjgZHjgpnjgpNcIixcbiAgICBcIuOBm+OBhOOBl+OCmVwiLFxuICAgIFwi44Gb44GE44KI44GGXCIsXG4gICAgXCLjgZvjgYrjgYZcIixcbiAgICBcIuOBm+OBi+OBhOOBi+OCk1wiLFxuICAgIFwi44Gb44GN44Gr44KTXCIsXG4gICAgXCLjgZvjgY3jgoBcIixcbiAgICBcIuOBm+OBjeOChlwiLFxuICAgIFwi44Gb44GN44KJ44KT44GG44KTXCIsXG4gICAgXCLjgZvjgZHjgpNcIixcbiAgICBcIuOBm+OBk+OBhlwiLFxuICAgIFwi44Gb44GZ44GX44KZXCIsXG4gICAgXCLjgZvjgZ/jgYRcIixcbiAgICBcIuOBm+OBn+OBkVwiLFxuICAgIFwi44Gb44Gj44GL44GPXCIsXG4gICAgXCLjgZvjgaPjgY3jgoPjgY9cIixcbiAgICBcIuOBm+OCmeOBo+OBj1wiLFxuICAgIFwi44Gb44Gj44GR44KTXCIsXG4gICAgXCLjgZvjgaPjgZPjgaRcIixcbiAgICBcIuOBm+OBo+OBleOBn+OBj+OBvlwiLFxuICAgIFwi44Gb44Gk44Gd44KZ44GPXCIsXG4gICAgXCLjgZvjgaTjgZ/jgpnjgpNcIixcbiAgICBcIuOBm+OBpOOBpuOCmeOCk1wiLFxuICAgIFwi44Gb44Gj44Gv44Ka44KTXCIsXG4gICAgXCLjgZvjgaTjgbLjgplcIixcbiAgICBcIuOBm+OBpOOBteOCmeOCk1wiLFxuICAgIFwi44Gb44Gk44KB44GEXCIsXG4gICAgXCLjgZvjgaTjgorjgaRcIixcbiAgICBcIuOBm+OBquOBi1wiLFxuICAgIFwi44Gb44Gu44Gy44KZXCIsXG4gICAgXCLjgZvjga/jga/jgplcIixcbiAgICBcIuOBm+OBsuOCmeOCjVwiLFxuICAgIFwi44Gb44G744KZ44GtXCIsXG4gICAgXCLjgZvjgb7jgYRcIixcbiAgICBcIuOBm+OBvuOCi1wiLFxuICAgIFwi44Gb44KB44KLXCIsXG4gICAgXCLjgZvjgoLjgZ/jgoxcIixcbiAgICBcIuOBm+OCiuOBtVwiLFxuICAgIFwi44Gb44KZ44KT44GC44GPXCIsXG4gICAgXCLjgZvjgpPjgYRcIixcbiAgICBcIuOBm+OCk+OBiOOBhFwiLFxuICAgIFwi44Gb44KT44GLXCIsXG4gICAgXCLjgZvjgpPjgY3jgodcIixcbiAgICBcIuOBm+OCk+OBj1wiLFxuICAgIFwi44Gb44KT44GR44KZ44KTXCIsXG4gICAgXCLjgZvjgpnjgpPjgZPjgplcIixcbiAgICBcIuOBm+OCk+OBleOBhFwiLFxuICAgIFwi44Gb44KT44GX44KFXCIsXG4gICAgXCLjgZvjgpPjgZnjgYRcIixcbiAgICBcIuOBm+OCk+OBm+OBhFwiLFxuICAgIFwi44Gb44KT44Gd44KZXCIsXG4gICAgXCLjgZvjgpPjgZ/jgY9cIixcbiAgICBcIuOBm+OCk+OBoeOCh+OBhlwiLFxuICAgIFwi44Gb44KT44Gm44GEXCIsXG4gICAgXCLjgZvjgpPjgajjgYZcIixcbiAgICBcIuOBm+OCk+OBrOOBjVwiLFxuICAgIFwi44Gb44KT44Gt44KTXCIsXG4gICAgXCLjgZvjgpPjga/jgprjgYRcIixcbiAgICBcIuOBm+OCmeOCk+OBteOCmVwiLFxuICAgIFwi44Gb44KZ44KT44G744Ka44GGXCIsXG4gICAgXCLjgZvjgpPjgoBcIixcbiAgICBcIuOBm+OCk+OCgeOCk+OBl+OCmeOCh1wiLFxuICAgIFwi44Gb44KT44KC44KTXCIsXG4gICAgXCLjgZvjgpPjgoTjgY9cIixcbiAgICBcIuOBm+OCk+OChuOBhlwiLFxuICAgIFwi44Gb44KT44KI44GGXCIsXG4gICAgXCLjgZvjgpnjgpPjgolcIixcbiAgICBcIuOBm+OCmeOCk+OCiuOCg+OBj1wiLFxuICAgIFwi44Gb44KT44KM44GEXCIsXG4gICAgXCLjgZvjgpPjgo1cIixcbiAgICBcIuOBneOBguOBj1wiLFxuICAgIFwi44Gd44GE44Go44GR44KZ44KLXCIsXG4gICAgXCLjgZ3jgYTjga1cIixcbiAgICBcIuOBneOBhuOBi+OCmeOCk+OBjeOCh+OBhlwiLFxuICAgIFwi44Gd44GG44GNXCIsXG4gICAgXCLjgZ3jgYbjgZPjgplcIixcbiAgICBcIuOBneOBhuOBl+OCk1wiLFxuICAgIFwi44Gd44GG44Gf44KZ44KTXCIsXG4gICAgXCLjgZ3jgYbjgarjgpNcIixcbiAgICBcIuOBneOBhuOBsuOCmVwiLFxuICAgIFwi44Gd44GG44KB44KTXCIsXG4gICAgXCLjgZ3jgYbjgopcIixcbiAgICBcIuOBneOBiOOCguOBrlwiLFxuICAgIFwi44Gd44GI44KTXCIsXG4gICAgXCLjgZ3jgYvjgpnjgYRcIixcbiAgICBcIuOBneOBkeOCmeOBjVwiLFxuICAgIFwi44Gd44GT44GGXCIsXG4gICAgXCLjgZ3jgZPjgZ3jgZNcIixcbiAgICBcIuOBneOBleOCmeOBhFwiLFxuICAgIFwi44Gd44GX44GqXCIsXG4gICAgXCLjgZ3jgZvjgYRcIixcbiAgICBcIuOBneOBm+OCk1wiLFxuICAgIFwi44Gd44Gd44GP44KZXCIsXG4gICAgXCLjgZ3jgZ/jgpnjgabjgotcIixcbiAgICBcIuOBneOBpOOBhlwiLFxuICAgIFwi44Gd44Gk44GI44KTXCIsXG4gICAgXCLjgZ3jgaPjgYvjgpNcIixcbiAgICBcIuOBneOBpOOBjeOCmeOCh+OBhlwiLFxuICAgIFwi44Gd44Gj44GR44GkXCIsXG4gICAgXCLjgZ3jgaPjgZPjgYZcIixcbiAgICBcIuOBneOBo+OBm+OCk1wiLFxuICAgIFwi44Gd44Gj44GoXCIsXG4gICAgXCLjgZ3jgajjgYvjgpnjgo9cIixcbiAgICBcIuOBneOBqOOBpOOCmeOCiVwiLFxuICAgIFwi44Gd44Gq44GI44KLXCIsXG4gICAgXCLjgZ3jgarjgZ9cIixcbiAgICBcIuOBneOBteOBu+OCmVwiLFxuICAgIFwi44Gd44G744KZ44GPXCIsXG4gICAgXCLjgZ3jgbvjgpnjgo1cIixcbiAgICBcIuOBneOBvuOBpFwiLFxuICAgIFwi44Gd44G+44KLXCIsXG4gICAgXCLjgZ3jgoDjgY9cIixcbiAgICBcIuOBneOCgOOCiuOBiFwiLFxuICAgIFwi44Gd44KB44KLXCIsXG4gICAgXCLjgZ3jgoLjgZ3jgoJcIixcbiAgICBcIuOBneOCiOOBi+OBm+OCmVwiLFxuICAgIFwi44Gd44KJ44G+44KBXCIsXG4gICAgXCLjgZ3jgo3jgYZcIixcbiAgICBcIuOBneOCk+OBi+OBhFwiLFxuICAgIFwi44Gd44KT44GR44GEXCIsXG4gICAgXCLjgZ3jgpPjgZXjgpnjgYRcIixcbiAgICBcIuOBneOCk+OBl+OBpFwiLFxuICAgIFwi44Gd44KT44Gd44KZ44GPXCIsXG4gICAgXCLjgZ3jgpPjgaHjgofjgYZcIixcbiAgICBcIuOBneOCmeOCk+OBsuOCmVwiLFxuICAgIFwi44Gd44KZ44KT44G144KZ44KTXCIsXG4gICAgXCLjgZ3jgpPjgb/jgpNcIixcbiAgICBcIuOBn+OBguOBhFwiLFxuICAgIFwi44Gf44GE44GE44KTXCIsXG4gICAgXCLjgZ/jgYTjgYbjgpNcIixcbiAgICBcIuOBn+OBhOOBiOOBjVwiLFxuICAgIFwi44Gf44GE44GK44GGXCIsXG4gICAgXCLjgZ/jgpnjgYTjgYvjgpnjgY9cIixcbiAgICBcIuOBn+OBhOOBjVwiLFxuICAgIFwi44Gf44GE44GP44KZ44GGXCIsXG4gICAgXCLjgZ/jgYTjgZHjgpNcIixcbiAgICBcIuOBn+OBhOOBk1wiLFxuICAgIFwi44Gf44GE44GV44KZ44GEXCIsXG4gICAgXCLjgZ/jgpnjgYTjgZfjgpnjgofjgYbjgbXjgplcIixcbiAgICBcIuOBn+OCmeOBhOOBmeOBjVwiLFxuICAgIFwi44Gf44GE44Gb44GkXCIsXG4gICAgXCLjgZ/jgYTjgZ3jgYZcIixcbiAgICBcIuOBn+OCmeOBhOOBn+OBhFwiLFxuICAgIFwi44Gf44GE44Gh44KH44GGXCIsXG4gICAgXCLjgZ/jgYTjgabjgYRcIixcbiAgICBcIuOBn+OCmeOBhOOBqOOCmeOBk+OCjVwiLFxuICAgIFwi44Gf44GE44Gq44GEXCIsXG4gICAgXCLjgZ/jgYTjga3jgaRcIixcbiAgICBcIuOBn+OBhOOBruOBhlwiLFxuICAgIFwi44Gf44GE44Gv44KTXCIsXG4gICAgXCLjgZ/jgpnjgYTjgbLjgofjgYZcIixcbiAgICBcIuOBn+OBhOOBteOBhlwiLFxuICAgIFwi44Gf44GE44G444KTXCIsXG4gICAgXCLjgZ/jgYTjgbtcIixcbiAgICBcIuOBn+OBhOOBvuOBpOOBr+OCmeOBqlwiLFxuICAgIFwi44Gf44GE44G/44KT44GP44KZXCIsXG4gICAgXCLjgZ/jgYTjgoBcIixcbiAgICBcIuOBn+OBhOOCgeOCk1wiLFxuICAgIFwi44Gf44GE44KE44GNXCIsXG4gICAgXCLjgZ/jgYTjgojjgYZcIixcbiAgICBcIuOBn+OBhOOCiVwiLFxuICAgIFwi44Gf44GE44KK44KH44GPXCIsXG4gICAgXCLjgZ/jgYTjgotcIixcbiAgICBcIuOBn+OBhOOCj+OCk1wiLFxuICAgIFwi44Gf44GG44GIXCIsXG4gICAgXCLjgZ/jgYjjgotcIixcbiAgICBcIuOBn+OBiuOBmVwiLFxuICAgIFwi44Gf44GK44KLXCIsXG4gICAgXCLjgZ/jgYrjgozjgotcIixcbiAgICBcIuOBn+OBi+OBhFwiLFxuICAgIFwi44Gf44GL44GtXCIsXG4gICAgXCLjgZ/jgY3jgbLjgplcIixcbiAgICBcIuOBn+OBj+OBleOCk1wiLFxuICAgIFwi44Gf44GT44GPXCIsXG4gICAgXCLjgZ/jgZPjgoTjgY1cIixcbiAgICBcIuOBn+OBleOBhFwiLFxuICAgIFwi44Gf44GX44GV44KZ44KTXCIsXG4gICAgXCLjgZ/jgpnjgZfjgpnjgoPjgoxcIixcbiAgICBcIuOBn+OBmeOBkeOCi1wiLFxuICAgIFwi44Gf44GZ44KZ44GV44KP44KLXCIsXG4gICAgXCLjgZ/jgZ3jgYvjgpnjgoxcIixcbiAgICBcIuOBn+OBn+OBi+OBhlwiLFxuICAgIFwi44Gf44Gf44GPXCIsXG4gICAgXCLjgZ/jgZ/jgpnjgZfjgYRcIixcbiAgICBcIuOBn+OBn+OBv1wiLFxuICAgIFwi44Gf44Gh44Gv44KZ44GqXCIsXG4gICAgXCLjgZ/jgpnjgaPjgYvjgYRcIixcbiAgICBcIuOBn+OCmeOBo+OBjeOCg+OBj1wiLFxuICAgIFwi44Gf44KZ44Gj44GTXCIsXG4gICAgXCLjgZ/jgpnjgaPjgZfjgoXjgaRcIixcbiAgICBcIuOBn+OCmeOBo+OBn+OBhFwiLFxuICAgIFwi44Gf44Gm44KLXCIsXG4gICAgXCLjgZ/jgajjgYjjgotcIixcbiAgICBcIuOBn+OBquOBr+OCmeOBn1wiLFxuICAgIFwi44Gf44Gr44KTXCIsXG4gICAgXCLjgZ/jgazjgY1cIixcbiAgICBcIuOBn+OBruOBl+OBv1wiLFxuICAgIFwi44Gf44Gv44GkXCIsXG4gICAgXCLjgZ/jgbXjgpnjgpNcIixcbiAgICBcIuOBn+OBuOOCmeOCi1wiLFxuICAgIFwi44Gf44G744KZ44GGXCIsXG4gICAgXCLjgZ/jgb7jgZPjgplcIixcbiAgICBcIuOBn+OBvuOCi1wiLFxuICAgIFwi44Gf44KZ44KA44KLXCIsXG4gICAgXCLjgZ/jgoHjgYTjgY1cIixcbiAgICBcIuOBn+OCgeOBmVwiLFxuICAgIFwi44Gf44KB44KLXCIsXG4gICAgXCLjgZ/jgoLjgaRcIixcbiAgICBcIuOBn+OChOOBmeOBhFwiLFxuICAgIFwi44Gf44KI44KLXCIsXG4gICAgXCLjgZ/jgonjgZlcIixcbiAgICBcIuOBn+OCiuOBjeOBu+OCk+OBi+OCmeOCk1wiLFxuICAgIFwi44Gf44KK44KH44GGXCIsXG4gICAgXCLjgZ/jgorjgotcIixcbiAgICBcIuOBn+OCi+OBqFwiLFxuICAgIFwi44Gf44KM44KLXCIsXG4gICAgXCLjgZ/jgozjgpPjgahcIixcbiAgICBcIuOBn+OCjeOBo+OBqFwiLFxuICAgIFwi44Gf44KP44KA44KM44KLXCIsXG4gICAgXCLjgZ/jgpnjgpPjgYLjgaRcIixcbiAgICBcIuOBn+OCk+OBhFwiLFxuICAgIFwi44Gf44KT44GK44KTXCIsXG4gICAgXCLjgZ/jgpPjgYtcIixcbiAgICBcIuOBn+OCk+OBjVwiLFxuICAgIFwi44Gf44KT44GR44KTXCIsXG4gICAgXCLjgZ/jgpPjgZPjgplcIixcbiAgICBcIuOBn+OCk+OBleOCk1wiLFxuICAgIFwi44Gf44KT44GX44KZ44KH44GG44Gy44KZXCIsXG4gICAgXCLjgZ/jgpnjgpPjgZvjgYRcIixcbiAgICBcIuOBn+OCk+OBneOBj1wiLFxuICAgIFwi44Gf44KT44Gf44GEXCIsXG4gICAgXCLjgZ/jgpnjgpPjgaFcIixcbiAgICBcIuOBn+OCk+OBpuOBhFwiLFxuICAgIFwi44Gf44KT44Go44GGXCIsXG4gICAgXCLjgZ/jgpnjgpPjgapcIixcbiAgICBcIuOBn+OCk+OBq+OCk1wiLFxuICAgIFwi44Gf44KZ44KT44Gt44GkXCIsXG4gICAgXCLjgZ/jgpPjga7jgYZcIixcbiAgICBcIuOBn+OCk+OBsuOCmuOCk1wiLFxuICAgIFwi44Gf44KZ44KT44G744KZ44GGXCIsXG4gICAgXCLjgZ/jgpPjgb7jgaRcIixcbiAgICBcIuOBn+OCk+OCgeOBhFwiLFxuICAgIFwi44Gf44KZ44KT44KM44GkXCIsXG4gICAgXCLjgZ/jgpnjgpPjgo1cIixcbiAgICBcIuOBn+OCmeOCk+OCj1wiLFxuICAgIFwi44Gh44GC44GEXCIsXG4gICAgXCLjgaHjgYLjgpNcIixcbiAgICBcIuOBoeOBhOOBjVwiLFxuICAgIFwi44Gh44GE44GV44GEXCIsXG4gICAgXCLjgaHjgYjjgpNcIixcbiAgICBcIuOBoeOBi+OBhFwiLFxuICAgIFwi44Gh44GL44KJXCIsXG4gICAgXCLjgaHjgY3jgoXjgYZcIixcbiAgICBcIuOBoeOBjeOCk1wiLFxuICAgIFwi44Gh44GR44GE44GZ44KZXCIsXG4gICAgXCLjgaHjgZHjgpNcIixcbiAgICBcIuOBoeOBk+OBj1wiLFxuICAgIFwi44Gh44GV44GEXCIsXG4gICAgXCLjgaHjgZfjgY1cIixcbiAgICBcIuOBoeOBl+OCiuOCh+OBhlwiLFxuICAgIFwi44Gh44Gb44GEXCIsXG4gICAgXCLjgaHjgZ3jgYZcIixcbiAgICBcIuOBoeOBn+OBhFwiLFxuICAgIFwi44Gh44Gf44KTXCIsXG4gICAgXCLjgaHjgaHjgYrjgoRcIixcbiAgICBcIuOBoeOBpOOBl+OCmeOCh1wiLFxuICAgIFwi44Gh44Gm44GNXCIsXG4gICAgXCLjgaHjgabjgpNcIixcbiAgICBcIuOBoeOBrOOBjVwiLFxuICAgIFwi44Gh44Gs44KKXCIsXG4gICAgXCLjgaHjga7jgYZcIixcbiAgICBcIuOBoeOBsuOCh+OBhlwiLFxuICAgIFwi44Gh44G444GE44Gb44KTXCIsXG4gICAgXCLjgaHjgbvjgYZcIixcbiAgICBcIuOBoeOBvuOBn1wiLFxuICAgIFwi44Gh44G/44GkXCIsXG4gICAgXCLjgaHjgb/jgajjgpnjgo1cIixcbiAgICBcIuOBoeOCgeOBhOOBqOOCmVwiLFxuICAgIFwi44Gh44KD44KT44GT44Gq44G444KZXCIsXG4gICAgXCLjgaHjgoXjgYbjgYRcIixcbiAgICBcIuOBoeOChuOCiuOCh+OBj1wiLFxuICAgIFwi44Gh44KH44GG44GXXCIsXG4gICAgXCLjgaHjgofjgZXjgY/jgZHjgpNcIixcbiAgICBcIuOBoeOCieOBl1wiLFxuICAgIFwi44Gh44KJ44G/XCIsXG4gICAgXCLjgaHjgorjgYvjgpnjgb9cIixcbiAgICBcIuOBoeOCiuOCh+OBhlwiLFxuICAgIFwi44Gh44KL44Go44KZXCIsXG4gICAgXCLjgaHjgo/jgo9cIixcbiAgICBcIuOBoeOCk+OBn+OBhFwiLFxuICAgIFwi44Gh44KT44KC44GPXCIsXG4gICAgXCLjgaTjgYTjgYtcIixcbiAgICBcIuOBpOOBhOOBn+OBoVwiLFxuICAgIFwi44Gk44GG44GLXCIsXG4gICAgXCLjgaTjgYbjgZfjgpnjgofjgYZcIixcbiAgICBcIuOBpOOBhuOBr+OCk1wiLFxuICAgIFwi44Gk44GG44KPXCIsXG4gICAgXCLjgaTjgYvjgYZcIixcbiAgICBcIuOBpOOBi+OCjOOCi1wiLFxuICAgIFwi44Gk44GP44GtXCIsXG4gICAgXCLjgaTjgY/jgotcIixcbiAgICBcIuOBpOOBkeOBrVwiLFxuICAgIFwi44Gk44GR44KLXCIsXG4gICAgXCLjgaTjgZPjgpnjgYZcIixcbiAgICBcIuOBpOOBn+OBiOOCi1wiLFxuICAgIFwi44Gk44Gk44KZ44GPXCIsXG4gICAgXCLjgaTjgaTjgZfjgplcIixcbiAgICBcIuOBpOOBpOOCgFwiLFxuICAgIFwi44Gk44Go44KB44KLXCIsXG4gICAgXCLjgaTjgarjgYvjgpnjgotcIixcbiAgICBcIuOBpOOBquOBv1wiLFxuICAgIFwi44Gk44Gt44Gk44KZ44GtXCIsXG4gICAgXCLjgaTjga7jgotcIixcbiAgICBcIuOBpOOBteOCmeOBmVwiLFxuICAgIFwi44Gk44G+44KJ44Gq44GEXCIsXG4gICAgXCLjgaTjgb7jgotcIixcbiAgICBcIuOBpOOBv+OBjVwiLFxuICAgIFwi44Gk44KB44Gf44GEXCIsXG4gICAgXCLjgaTjgoLjgopcIixcbiAgICBcIuOBpOOCguOCi1wiLFxuICAgIFwi44Gk44KI44GEXCIsXG4gICAgXCLjgaTjgovjgbvjgplcIixcbiAgICBcIuOBpOOCi+OBv+OBj1wiLFxuICAgIFwi44Gk44KP44KC44GuXCIsXG4gICAgXCLjgaTjgo/jgopcIixcbiAgICBcIuOBpuOBguOBl1wiLFxuICAgIFwi44Gm44GC44GmXCIsXG4gICAgXCLjgabjgYLjgb9cIixcbiAgICBcIuOBpuOBhOOBiuOCk1wiLFxuICAgIFwi44Gm44GE44GLXCIsXG4gICAgXCLjgabjgYTjgY1cIixcbiAgICBcIuOBpuOBhOOBkeOBhFwiLFxuICAgIFwi44Gm44GE44GT44GPXCIsXG4gICAgXCLjgabjgYTjgZXjgaRcIixcbiAgICBcIuOBpuOBhOOBl1wiLFxuICAgIFwi44Gm44GE44Gb44GEXCIsXG4gICAgXCLjgabjgYTjgZ/jgYRcIixcbiAgICBcIuOBpuOBhOOBqOOCmVwiLFxuICAgIFwi44Gm44GE44Gt44GEXCIsXG4gICAgXCLjgabjgYTjgbLjgofjgYZcIixcbiAgICBcIuOBpuOBhOOBuOOCk1wiLFxuICAgIFwi44Gm44GE44G744KZ44GGXCIsXG4gICAgXCLjgabjgYbjgaFcIixcbiAgICBcIuOBpuOBiuOBj+OCjFwiLFxuICAgIFwi44Gm44GN44Go44GGXCIsXG4gICAgXCLjgabjgY/jgbLjgplcIixcbiAgICBcIuOBpuOCmeOBk+OBu+OCmeOBk1wiLFxuICAgIFwi44Gm44GV44GN44KZ44KH44GGXCIsXG4gICAgXCLjgabjgZXjgZHjgplcIixcbiAgICBcIuOBpuOBmeOCilwiLFxuICAgIFwi44Gm44Gd44GGXCIsXG4gICAgXCLjgabjgaHjgYvjgpnjgYRcIixcbiAgICBcIuOBpuOBoeOCh+OBhlwiLFxuICAgIFwi44Gm44Gk44GL44KZ44GPXCIsXG4gICAgXCLjgabjgaTjgaTjgpnjgY1cIixcbiAgICBcIuOBpuOCmeOBo+OBr+OCmlwiLFxuICAgIFwi44Gm44Gk44G744KZ44GGXCIsXG4gICAgXCLjgabjgaTjgoRcIixcbiAgICBcIuOBpuOCmeOBrOOBi+OBiFwiLFxuICAgIFwi44Gm44Gs44GNXCIsXG4gICAgXCLjgabjgazjgY/jgpnjgYRcIixcbiAgICBcIuOBpuOBruOBsuOCiVwiLFxuICAgIFwi44Gm44Gv44GEXCIsXG4gICAgXCLjgabjgbXjgpnjgY/jgo1cIixcbiAgICBcIuOBpuOBteOBn+OCmVwiLFxuICAgIFwi44Gm44G744Go44KZ44GNXCIsXG4gICAgXCLjgabjgbvjgpNcIixcbiAgICBcIuOBpuOBvuOBiFwiLFxuICAgIFwi44Gm44G+44GN44GZ44KZ44GXXCIsXG4gICAgXCLjgabjgb/jgZfjgpnjgYtcIixcbiAgICBcIuOBpuOBv+OChOOBkeOCmVwiLFxuICAgIFwi44Gm44KJ44GZXCIsXG4gICAgXCLjgabjgozjgbLjgplcIixcbiAgICBcIuOBpuOCj+OBkVwiLFxuICAgIFwi44Gm44KP44Gf44GXXCIsXG4gICAgXCLjgabjgpnjgpPjgYLjgaRcIixcbiAgICBcIuOBpuOCk+OBhOOCk1wiLFxuICAgIFwi44Gm44KT44GL44GEXCIsXG4gICAgXCLjgabjgpPjgY1cIixcbiAgICBcIuOBpuOCk+OBj+OCmVwiLFxuICAgIFwi44Gm44KT44GR44KTXCIsXG4gICAgXCLjgabjgpPjgZPjgpnjgY9cIixcbiAgICBcIuOBpuOCk+OBleOBhFwiLFxuICAgIFwi44Gm44KT44GXXCIsXG4gICAgXCLjgabjgpPjgZnjgYZcIixcbiAgICBcIuOBpuOCmeOCk+OBoVwiLFxuICAgIFwi44Gm44KT44Gm44GNXCIsXG4gICAgXCLjgabjgpPjgajjgYZcIixcbiAgICBcIuOBpuOCk+OBquOBhFwiLFxuICAgIFwi44Gm44KT44G144Ka44KJXCIsXG4gICAgXCLjgabjgpPjgbvjgpnjgYbjgZ/jgpnjgYRcIixcbiAgICBcIuOBpuOCk+OCgeOBpFwiLFxuICAgIFwi44Gm44KT44KJ44KT44GL44GEXCIsXG4gICAgXCLjgabjgpnjgpPjgorjgofjgY9cIixcbiAgICBcIuOBpuOCmeOCk+OCj1wiLFxuICAgIFwi44Go44KZ44GC44GEXCIsXG4gICAgXCLjgajjgYTjgoxcIixcbiAgICBcIuOBqOOCmeOBhuOBi+OCk1wiLFxuICAgIFwi44Go44GG44GN44KF44GGXCIsXG4gICAgXCLjgajjgpnjgYbjgY/jgplcIixcbiAgICBcIuOBqOOBhuOBl1wiLFxuICAgIFwi44Go44GG44KA44GN44KZXCIsXG4gICAgXCLjgajjgYrjgYRcIixcbiAgICBcIuOBqOOBiuOBi1wiLFxuICAgIFwi44Go44GK44GPXCIsXG4gICAgXCLjgajjgYrjgZlcIixcbiAgICBcIuOBqOOBiuOCi1wiLFxuICAgIFwi44Go44GL44GEXCIsXG4gICAgXCLjgajjgYvjgZlcIixcbiAgICBcIuOBqOOBjeOBiuOCilwiLFxuICAgIFwi44Go44GN44Go44KZ44GNXCIsXG4gICAgXCLjgajjgY/jgYRcIixcbiAgICBcIuOBqOOBj+OBl+OCheOBhlwiLFxuICAgIFwi44Go44GP44Gm44KTXCIsXG4gICAgXCLjgajjgY/jgatcIixcbiAgICBcIuOBqOOBj+OBuOOCmeOBpFwiLFxuICAgIFwi44Go44GR44GEXCIsXG4gICAgXCLjgajjgZHjgotcIixcbiAgICBcIuOBqOOBk+OChFwiLFxuICAgIFwi44Go44GV44GLXCIsXG4gICAgXCLjgajjgZfjgofjgYvjgpNcIixcbiAgICBcIuOBqOOBneOBhlwiLFxuICAgIFwi44Go44Gf44KTXCIsXG4gICAgXCLjgajjgaHjgoXjgYZcIixcbiAgICBcIuOBqOOBo+OBjeOCheOBhlwiLFxuICAgIFwi44Go44Gj44GP44KTXCIsXG4gICAgXCLjgajjgaTjgZvjgpnjgpNcIixcbiAgICBcIuOBqOOBpOOBq+OCheOBhlwiLFxuICAgIFwi44Go44Go44KZ44GR44KLXCIsXG4gICAgXCLjgajjgajjga7jgYjjgotcIixcbiAgICBcIuOBqOOBquOBhFwiLFxuICAgIFwi44Go44Gq44GI44KLXCIsXG4gICAgXCLjgajjgarjgopcIixcbiAgICBcIuOBqOOBruOBleOBvlwiLFxuICAgIFwi44Go44Gv44KZ44GZXCIsXG4gICAgXCLjgajjgpnjgbXjgpnjgYvjgpnjgo9cIixcbiAgICBcIuOBqOOBu+OBhlwiLFxuICAgIFwi44Go44G+44KLXCIsXG4gICAgXCLjgajjgoHjgotcIixcbiAgICBcIuOBqOOCguOBn+OCmeOBoVwiLFxuICAgIFwi44Go44KC44KLXCIsXG4gICAgXCLjgajjgpnjgojjgYbjgbLjgplcIixcbiAgICBcIuOBqOOCieOBiOOCi1wiLFxuICAgIFwi44Go44KT44GL44GkXCIsXG4gICAgXCLjgajjgpnjgpPjgbXjgpnjgopcIixcbiAgICBcIuOBquOBhOOBi+OBj1wiLFxuICAgIFwi44Gq44GE44GT44GGXCIsXG4gICAgXCLjgarjgYTjgZfjgodcIixcbiAgICBcIuOBquOBhOOBmVwiLFxuICAgIFwi44Gq44GE44Gb44KTXCIsXG4gICAgXCLjgarjgYTjgZ3jgYZcIixcbiAgICBcIuOBquOBiuOBmVwiLFxuICAgIFwi44Gq44GL44KZ44GEXCIsXG4gICAgXCLjgarjgY/jgZlcIixcbiAgICBcIuOBquOBkeOCmeOCi1wiLFxuICAgIFwi44Gq44GT44GG44Go44KZXCIsXG4gICAgXCLjgarjgZXjgZFcIixcbiAgICBcIuOBquOBn+OBpuOCmeOBk+OBk1wiLFxuICAgIFwi44Gq44Gj44Go44GGXCIsXG4gICAgXCLjgarjgaTjgoTjgZnjgb9cIixcbiAgICBcIuOBquOBquOBiuOBl1wiLFxuICAgIFwi44Gq44Gr44GT44KZ44GoXCIsXG4gICAgXCLjgarjgavjgoLjga5cIixcbiAgICBcIuOBquOBq+OCj1wiLFxuICAgIFwi44Gq44Gu44GLXCIsXG4gICAgXCLjgarjgbXjgZ/jgplcIixcbiAgICBcIuOBquOBvuOBhOOBjVwiLFxuICAgIFwi44Gq44G+44GIXCIsXG4gICAgXCLjgarjgb7jgb9cIixcbiAgICBcIuOBquOBv+OBn+OCmVwiLFxuICAgIFwi44Gq44KB44KJ44GLXCIsXG4gICAgXCLjgarjgoHjgotcIixcbiAgICBcIuOBquOChOOCgFwiLFxuICAgIFwi44Gq44KJ44GGXCIsXG4gICAgXCLjgarjgonjgbLjgplcIixcbiAgICBcIuOBquOCieOBteOCmVwiLFxuICAgIFwi44Gq44KM44KLXCIsXG4gICAgXCLjgarjgo/jgajjgbLjgplcIixcbiAgICBcIuOBquOCj+OBr+OCmeOCilwiLFxuICAgIFwi44Gr44GC44GGXCIsXG4gICAgXCLjgavjgYTjgYvjgpnjgZ9cIixcbiAgICBcIuOBq+OBhuOBkVwiLFxuICAgIFwi44Gr44GK44GEXCIsXG4gICAgXCLjgavjgYvjgYRcIixcbiAgICBcIuOBq+OBi+OCmeOBplwiLFxuICAgIFwi44Gr44GN44Gy44KZXCIsXG4gICAgXCLjgavjgY/jgZfjgb9cIixcbiAgICBcIuOBq+OBj+OBvuOCk1wiLFxuICAgIFwi44Gr44GR44KZ44KLXCIsXG4gICAgXCLjgavjgZXjgpPjgYvjgZ/jgpPjgZ1cIixcbiAgICBcIuOBq+OBl+OBjVwiLFxuICAgIFwi44Gr44Gb44KC44GuXCIsXG4gICAgXCLjgavjgaHjgZfjgpnjgofjgYZcIixcbiAgICBcIuOBq+OBoeOCiOOBhuOBsuOCmVwiLFxuICAgIFwi44Gr44Gj44GLXCIsXG4gICAgXCLjgavjgaPjgY1cIixcbiAgICBcIuOBq+OBo+OBkeOBhFwiLFxuICAgIFwi44Gr44Gj44GT44GGXCIsXG4gICAgXCLjgavjgaPjgZXjgpNcIixcbiAgICBcIuOBq+OBo+OBl+OCh+OBj1wiLFxuICAgIFwi44Gr44Gj44GZ44GGXCIsXG4gICAgXCLjgavjgaPjgZvjgY1cIixcbiAgICBcIuOBq+OBo+OBpuOBhFwiLFxuICAgIFwi44Gr44Gq44GGXCIsXG4gICAgXCLjgavjgbvjgpNcIixcbiAgICBcIuOBq+OBvuOCgVwiLFxuICAgIFwi44Gr44KC44GkXCIsXG4gICAgXCLjgavjgoTjgopcIixcbiAgICBcIuOBq+OCheOBhuOBhOOCk1wiLFxuICAgIFwi44Gr44KK44KT44GX44KDXCIsXG4gICAgXCLjgavjgo/jgajjgopcIixcbiAgICBcIuOBq+OCk+OBhFwiLFxuICAgIFwi44Gr44KT44GLXCIsXG4gICAgXCLjgavjgpPjgY1cIixcbiAgICBcIuOBq+OCk+OBkeOCmeOCk1wiLFxuICAgIFwi44Gr44KT44GX44GNXCIsXG4gICAgXCLjgavjgpPjgZnjgpnjgYZcIixcbiAgICBcIuOBq+OCk+OBneOBhlwiLFxuICAgIFwi44Gr44KT44Gf44GEXCIsXG4gICAgXCLjgavjgpPjgaFcIixcbiAgICBcIuOBq+OCk+OBpuOBhFwiLFxuICAgIFwi44Gr44KT44Gr44GPXCIsXG4gICAgXCLjgavjgpPjgbXjgppcIixcbiAgICBcIuOBq+OCk+OBvuOCilwiLFxuICAgIFwi44Gr44KT44KAXCIsXG4gICAgXCLjgavjgpPjgoHjgYRcIixcbiAgICBcIuOBq+OCk+OCiOOBhlwiLFxuICAgIFwi44Gs44GE44GP44GN44KZXCIsXG4gICAgXCLjgazjgYvjgZlcIixcbiAgICBcIuOBrOOBj+OCmeOBhOOBqOOCi1wiLFxuICAgIFwi44Gs44GP44KZ44GGXCIsXG4gICAgXCLjgazjgY/jgoLjgopcIixcbiAgICBcIuOBrOOBmeOCgFwiLFxuICAgIFwi44Gs44G+44GI44Gy44KZXCIsXG4gICAgXCLjgazjgoHjgopcIixcbiAgICBcIuOBrOOCieOBmVwiLFxuICAgIFwi44Gs44KT44Gh44KD44GPXCIsXG4gICAgXCLjga3jgYLjgZHjgplcIixcbiAgICBcIuOBreOBhOOBjVwiLFxuICAgIFwi44Gt44GE44KLXCIsXG4gICAgXCLjga3jgYTjgo1cIixcbiAgICBcIuOBreOBj+OCmeOBm1wiLFxuICAgIFwi44Gt44GP44Gf44GEXCIsXG4gICAgXCLjga3jgY/jgolcIixcbiAgICBcIuOBreOBk+OBm+OCmVwiLFxuICAgIFwi44Gt44GT44KAXCIsXG4gICAgXCLjga3jgZXjgZHjgplcIixcbiAgICBcIuOBreOBmeOBk+OCmeOBmVwiLFxuICAgIFwi44Gt44Gd44G444KZ44KLXCIsXG4gICAgXCLjga3jgZ/jgpnjgpNcIixcbiAgICBcIuOBreOBpOOBhFwiLFxuICAgIFwi44Gt44Gj44GX44KTXCIsXG4gICAgXCLjga3jgaTjgZ3jgpnjgYZcIixcbiAgICBcIuOBreOBo+OBn+OBhOOBjeOCmeOCh1wiLFxuICAgIFwi44Gt44G144KZ44Gd44GPXCIsXG4gICAgXCLjga3jgbXjgZ/jgplcIixcbiAgICBcIuOBreOBu+OCmeOBhlwiLFxuICAgIFwi44Gt44G744KK44Gv44G744KKXCIsXG4gICAgXCLjga3jgb7jgY1cIixcbiAgICBcIuOBreOBvuOCj+OBl1wiLFxuICAgIFwi44Gt44G/44G/XCIsXG4gICAgXCLjga3jgoDjgYRcIixcbiAgICBcIuOBreOCgOOBn+OBhFwiLFxuICAgIFwi44Gt44KC44GoXCIsXG4gICAgXCLjga3jgonjgYZcIixcbiAgICBcIuOBreOCj+OBleOCmVwiLFxuICAgIFwi44Gt44KT44GE44KKXCIsXG4gICAgXCLjga3jgpPjgYrjgZdcIixcbiAgICBcIuOBreOCk+OBi+OCk1wiLFxuICAgIFwi44Gt44KT44GN44KTXCIsXG4gICAgXCLjga3jgpPjgY/jgplcIixcbiAgICBcIuOBreOCk+OBleOCmVwiLFxuICAgIFwi44Gt44KT44GXXCIsXG4gICAgXCLjga3jgpPjgaHjgoPjgY9cIixcbiAgICBcIuOBreOCk+OBqOOCmVwiLFxuICAgIFwi44Gt44KT44Gy44KaXCIsXG4gICAgXCLjga3jgpPjgbXjgpnjgaRcIixcbiAgICBcIuOBreOCk+OBvuOBpFwiLFxuICAgIFwi44Gt44KT44KK44KH44GGXCIsXG4gICAgXCLjga3jgpPjgozjgYRcIixcbiAgICBcIuOBruOBhOOBmeOCmVwiLFxuICAgIFwi44Gu44GK44Gk44KZ44G+XCIsXG4gICAgXCLjga7jgYvjgpnjgZlcIixcbiAgICBcIuOBruOBjeOBquOBv1wiLFxuICAgIFwi44Gu44GT44GN44KZ44KKXCIsXG4gICAgXCLjga7jgZPjgZlcIixcbiAgICBcIuOBruOBk+OCi1wiLFxuICAgIFwi44Gu44Gb44KLXCIsXG4gICAgXCLjga7jgZ3jgpnjgY9cIixcbiAgICBcIuOBruOBneOCmeOCgFwiLFxuICAgIFwi44Gu44Gf44G+44GGXCIsXG4gICAgXCLjga7jgaHjgbvjgajjgplcIixcbiAgICBcIuOBruOBo+OBj1wiLFxuICAgIFwi44Gu44Gv44KZ44GZXCIsXG4gICAgXCLjga7jga/jgolcIixcbiAgICBcIuOBruOBuOOCmeOCi1wiLFxuICAgIFwi44Gu44G744KZ44KLXCIsXG4gICAgXCLjga7jgb/jgoLjga5cIixcbiAgICBcIuOBruOChOOBvlwiLFxuICAgIFwi44Gu44KJ44GE44GsXCIsXG4gICAgXCLjga7jgonjga3jgZNcIixcbiAgICBcIuOBruOCiuOCguOBrlwiLFxuICAgIFwi44Gu44KK44KG44GNXCIsXG4gICAgXCLjga7jgozjgpNcIixcbiAgICBcIuOBruOCk+OBjVwiLFxuICAgIFwi44Gv44KZ44GC44GEXCIsXG4gICAgXCLjga/jgYLjgY9cIixcbiAgICBcIuOBr+OCmeOBguOBleOCk1wiLFxuICAgIFwi44Gv44KZ44GE44GLXCIsXG4gICAgXCLjga/jgpnjgYTjgY9cIixcbiAgICBcIuOBr+OBhOOBkeOCk1wiLFxuICAgIFwi44Gv44GE44GT44KZXCIsXG4gICAgXCLjga/jgYTjgZfjgpNcIixcbiAgICBcIuOBr+OBhOOBmeOBhFwiLFxuICAgIFwi44Gv44GE44Gb44KTXCIsXG4gICAgXCLjga/jgYTjgZ3jgYZcIixcbiAgICBcIuOBr+OBhOOBoVwiLFxuICAgIFwi44Gv44KZ44GE44Gv44KZ44GEXCIsXG4gICAgXCLjga/jgYTjgozjgaRcIixcbiAgICBcIuOBr+OBiOOCi1wiLFxuICAgIFwi44Gv44GK44KLXCIsXG4gICAgXCLjga/jgYvjgYRcIixcbiAgICBcIuOBr+OCmeOBi+OCilwiLFxuICAgIFwi44Gv44GL44KLXCIsXG4gICAgXCLjga/jgY/jgZfjgoVcIixcbiAgICBcIuOBr+OBkeOCk1wiLFxuICAgIFwi44Gv44GT44G144KZXCIsXG4gICAgXCLjga/jgZXjgb9cIixcbiAgICBcIuOBr+OBleOCk1wiLFxuICAgIFwi44Gv44GX44GT44KZXCIsXG4gICAgXCLjga/jgpnjgZfjgodcIixcbiAgICBcIuOBr+OBl+OCi1wiLFxuICAgIFwi44Gv44Gb44KLXCIsXG4gICAgXCLjga/jgprjgZ3jgZPjgpNcIixcbiAgICBcIuOBr+OBneOCk1wiLFxuICAgIFwi44Gv44Gf44KTXCIsXG4gICAgXCLjga/jgaHjgb/jgaRcIixcbiAgICBcIuOBr+OBpOOBiuOCk1wiLFxuICAgIFwi44Gv44Gj44GL44GPXCIsXG4gICAgXCLjga/jgaTjgpnjgY1cIixcbiAgICBcIuOBr+OBo+OBjeOCilwiLFxuICAgIFwi44Gv44Gj44GP44GkXCIsXG4gICAgXCLjga/jgaPjgZHjgpNcIixcbiAgICBcIuOBr+OBo+OBk+OBhlwiLFxuICAgIFwi44Gv44Gj44GV44KTXCIsXG4gICAgXCLjga/jgaPjgZfjgpNcIixcbiAgICBcIuOBr+OBo+OBn+OBpFwiLFxuICAgIFwi44Gv44Gj44Gh44KF44GGXCIsXG4gICAgXCLjga/jgaPjgabjgpNcIixcbiAgICBcIuOBr+OBo+OBsuOCmuOCh+OBhlwiLFxuICAgIFwi44Gv44Gj44G744Ka44GGXCIsXG4gICAgXCLjga/jgarjgZlcIixcbiAgICBcIuOBr+OBquOBsuOCmVwiLFxuICAgIFwi44Gv44Gr44GL44KAXCIsXG4gICAgXCLjga/jgbXjgpnjgonjgZdcIixcbiAgICBcIuOBr+OBv+OBi+OCmeOBjVwiLFxuICAgIFwi44Gv44KA44GL44GGXCIsXG4gICAgXCLjga/jgoHjgaRcIixcbiAgICBcIuOBr+OChOOBhFwiLFxuICAgIFwi44Gv44KE44GXXCIsXG4gICAgXCLjga/jgonjgYZcIixcbiAgICBcIuOBr+OCjeOBhuOBg+OCk1wiLFxuICAgIFwi44Gv44KP44GEXCIsXG4gICAgXCLjga/jgpPjgYRcIixcbiAgICBcIuOBr+OCk+OBiOOBhFwiLFxuICAgIFwi44Gv44KT44GK44KTXCIsXG4gICAgXCLjga/jgpPjgYvjgY9cIixcbiAgICBcIuOBr+OCk+OBjeOCh+OBhlwiLFxuICAgIFwi44Gv44KZ44KT44GP44KZ44G/XCIsXG4gICAgXCLjga/jgpPjgZNcIixcbiAgICBcIuOBr+OCk+OBl+OCg1wiLFxuICAgIFwi44Gv44KT44GZ44GGXCIsXG4gICAgXCLjga/jgpPjgZ/jgpnjgpNcIixcbiAgICBcIuOBr+OCmuOCk+OBoVwiLFxuICAgIFwi44Gv44Ka44KT44GkXCIsXG4gICAgXCLjga/jgpPjgabjgYRcIixcbiAgICBcIuOBr+OCk+OBqOOBl1wiLFxuICAgIFwi44Gv44KT44Gu44GGXCIsXG4gICAgXCLjga/jgpPjga/jgppcIixcbiAgICBcIuOBr+OCk+OBteOCmeOCk1wiLFxuICAgIFwi44Gv44KT44G444Ka44KTXCIsXG4gICAgXCLjga/jgpPjgbvjgpnjgYbjgY1cIixcbiAgICBcIuOBr+OCk+OCgeOBhFwiLFxuICAgIFwi44Gv44KT44KJ44KTXCIsXG4gICAgXCLjga/jgpPjgo3jgpNcIixcbiAgICBcIuOBsuOBhOOBjVwiLFxuICAgIFwi44Gy44GG44KTXCIsXG4gICAgXCLjgbLjgYjjgotcIixcbiAgICBcIuOBsuOBi+OBj1wiLFxuICAgIFwi44Gy44GL44KKXCIsXG4gICAgXCLjgbLjgYvjgotcIixcbiAgICBcIuOBsuOBi+OCk1wiLFxuICAgIFwi44Gy44GP44GEXCIsXG4gICAgXCLjgbLjgZHjgaRcIixcbiAgICBcIuOBsuOBk+OBhuOBjVwiLFxuICAgIFwi44Gy44GT44GPXCIsXG4gICAgXCLjgbLjgZXjgYRcIixcbiAgICBcIuOBsuOBleOBl+OBteOCmeOCilwiLFxuICAgIFwi44Gy44GV44KTXCIsXG4gICAgXCLjgbLjgpnjgZfjgpnjgoXjgaTjgYvjgpNcIixcbiAgICBcIuOBsuOBl+OCh1wiLFxuICAgIFwi44Gy44Gd44GLXCIsXG4gICAgXCLjgbLjgZ3jgoBcIixcbiAgICBcIuOBsuOBn+OCgOOBjVwiLFxuICAgIFwi44Gy44Gf44KZ44KKXCIsXG4gICAgXCLjgbLjgZ/jgotcIixcbiAgICBcIuOBsuOBpOOBjeOCmVwiLFxuICAgIFwi44Gy44Gj44GT44GXXCIsXG4gICAgXCLjgbLjgaPjgZdcIixcbiAgICBcIuOBsuOBpOOBl+OCmeOCheOBsuOCk1wiLFxuICAgIFwi44Gy44Gj44GZXCIsXG4gICAgXCLjgbLjgaTjgZvjgpnjgpNcIixcbiAgICBcIuOBsuOCmuOBo+OBn+OCilwiLFxuICAgIFwi44Gy44Ka44Gj44Gh44KKXCIsXG4gICAgXCLjgbLjgaTjgojjgYZcIixcbiAgICBcIuOBsuOBpuOBhFwiLFxuICAgIFwi44Gy44Go44GT44KZ44G/XCIsXG4gICAgXCLjgbLjgarjgb7jgaTjgopcIixcbiAgICBcIuOBsuOBquOCk1wiLFxuICAgIFwi44Gy44Gt44KLXCIsXG4gICAgXCLjgbLjga/jgpNcIixcbiAgICBcIuOBsuOBsuOCmeOBj1wiLFxuICAgIFwi44Gy44Gy44KH44GGXCIsXG4gICAgXCLjgbLjgbvjgYZcIixcbiAgICBcIuOBsuOBvuOCj+OCilwiLFxuICAgIFwi44Gy44G+44KTXCIsXG4gICAgXCLjgbLjgb/jgaRcIixcbiAgICBcIuOBsuOCgeOBhFwiLFxuICAgIFwi44Gy44KB44GX44KZ44GXXCIsXG4gICAgXCLjgbLjgoTjgZFcIixcbiAgICBcIuOBsuOChOOBmVwiLFxuICAgIFwi44Gy44KI44GGXCIsXG4gICAgXCLjgbLjgpnjgofjgYbjgY1cIixcbiAgICBcIuOBsuOCieOBi+OCmeOBqlwiLFxuICAgIFwi44Gy44KJ44GPXCIsXG4gICAgXCLjgbLjgorjgaRcIixcbiAgICBcIuOBsuOCiuOCh+OBhlwiLFxuICAgIFwi44Gy44KL44G+XCIsXG4gICAgXCLjgbLjgovjgoTjgZnjgb9cIixcbiAgICBcIuOBsuOCjOOBhFwiLFxuICAgIFwi44Gy44KN44GEXCIsXG4gICAgXCLjgbLjgo3jgYZcIixcbiAgICBcIuOBsuOCjeOBjVwiLFxuICAgIFwi44Gy44KN44KG44GNXCIsXG4gICAgXCLjgbLjgpPjgYvjgY9cIixcbiAgICBcIuOBsuOCk+OBkeOBpFwiLFxuICAgIFwi44Gy44KT44GT44KTXCIsXG4gICAgXCLjgbLjgpPjgZfjgoVcIixcbiAgICBcIuOBsuOCk+OBneOBhlwiLFxuICAgIFwi44Gy44Ka44KT44GhXCIsXG4gICAgXCLjgbLjgpPjga/jgprjgpNcIixcbiAgICBcIuOBsuOCmeOCk+OBu+OCmeOBhlwiLFxuICAgIFwi44G144GC44KTXCIsXG4gICAgXCLjgbXjgYTjgYbjgaFcIixcbiAgICBcIuOBteOBhuOBkeOBhFwiLFxuICAgIFwi44G144GG44Gb44KTXCIsXG4gICAgXCLjgbXjgprjgYbjgZ/jgo3jgYZcIixcbiAgICBcIuOBteOBhuOBqOOBhlwiLFxuICAgIFwi44G144GG44G1XCIsXG4gICAgXCLjgbXjgYjjgotcIixcbiAgICBcIuOBteOBiuOCk1wiLFxuICAgIFwi44G144GL44GEXCIsXG4gICAgXCLjgbXjgY3jgpNcIixcbiAgICBcIuOBteOBj+OBleOCmeOBpFwiLFxuICAgIFwi44G144GP44G144KZ44GP44KNXCIsXG4gICAgXCLjgbXjgZPjgYZcIixcbiAgICBcIuOBteOBleOBhFwiLFxuICAgIFwi44G144GX44GN44KZXCIsXG4gICAgXCLjgbXjgZfjgpnjgb9cIixcbiAgICBcIuOBteOBmeOBvlwiLFxuICAgIFwi44G144Gb44GEXCIsXG4gICAgXCLjgbXjgZvjgY/jgplcIixcbiAgICBcIuOBteOBneOBj1wiLFxuICAgIFwi44G144KZ44Gf44Gr44GPXCIsXG4gICAgXCLjgbXjgZ/jgpNcIixcbiAgICBcIuOBteOBoeOCh+OBhlwiLFxuICAgIFwi44G144Gk44GGXCIsXG4gICAgXCLjgbXjgaTjgYtcIixcbiAgICBcIuOBteOBo+OBi+OBpFwiLFxuICAgIFwi44G144Gj44GNXCIsXG4gICAgXCLjgbXjgaPjgZPjgY9cIixcbiAgICBcIuOBteOCmeOBqOOCmeOBhlwiLFxuICAgIFwi44G144Go44KLXCIsXG4gICAgXCLjgbXjgajjgpNcIixcbiAgICBcIuOBteOBruOBhlwiLFxuICAgIFwi44G144Gv44GEXCIsXG4gICAgXCLjgbXjgbLjgofjgYZcIixcbiAgICBcIuOBteOBuOOCk1wiLFxuICAgIFwi44G144G+44KTXCIsXG4gICAgXCLjgbXjgb/jgpNcIixcbiAgICBcIuOBteOCgeOBpFwiLFxuICAgIFwi44G144KB44KTXCIsXG4gICAgXCLjgbXjgojjgYZcIixcbiAgICBcIuOBteOCiuOBk1wiLFxuICAgIFwi44G144KK44KLXCIsXG4gICAgXCLjgbXjgovjgYRcIixcbiAgICBcIuOBteOCk+OBhOOBjVwiLFxuICAgIFwi44G144KZ44KT44GL44KZ44GPXCIsXG4gICAgXCLjgbXjgpnjgpPjgY/jgplcIixcbiAgICBcIuOBteOCk+OBl+OBpFwiLFxuICAgIFwi44G144KZ44KT44Gb44GNXCIsXG4gICAgXCLjgbXjgpPjgZ3jgYZcIixcbiAgICBcIuOBteOCmeOCk+OBu+OCmuOBhlwiLFxuICAgIFwi44G444GE44GC44KTXCIsXG4gICAgXCLjgbjjgYTjgYrjgpNcIixcbiAgICBcIuOBuOOBhOOBi+OCmeOBhFwiLFxuICAgIFwi44G444GE44GNXCIsXG4gICAgXCLjgbjjgYTjgZHjgpnjgpNcIixcbiAgICBcIuOBuOOBhOOBk+OBhlwiLFxuICAgIFwi44G444GE44GVXCIsXG4gICAgXCLjgbjjgYTjgZfjgoNcIixcbiAgICBcIuOBuOOBhOOBm+OBpFwiLFxuICAgIFwi44G444GE44GdXCIsXG4gICAgXCLjgbjjgYTjgZ/jgY9cIixcbiAgICBcIuOBuOOBhOOBpuOCk1wiLFxuICAgIFwi44G444GE44Gt44GkXCIsXG4gICAgXCLjgbjjgYTjgo9cIixcbiAgICBcIuOBuOOBjeOBi+OCmVwiLFxuICAgIFwi44G444GT44KAXCIsXG4gICAgXCLjgbjjgpnjgavjgYTjgo1cIixcbiAgICBcIuOBuOOCmeOBq+OBl+OCh+OBhuOBi+OCmVwiLFxuICAgIFwi44G444KJ44GZXCIsXG4gICAgXCLjgbjjgpPjgYvjgpNcIixcbiAgICBcIuOBuOOCmeOCk+OBjeOCh+OBhlwiLFxuICAgIFwi44G444KZ44KT44GT44KZ44GXXCIsXG4gICAgXCLjgbjjgpPjgZXjgYRcIixcbiAgICBcIuOBuOOCk+OBn+OBhFwiLFxuICAgIFwi44G444KZ44KT44KKXCIsXG4gICAgXCLjgbvjgYLjgpNcIixcbiAgICBcIuOBu+OBhOOBj1wiLFxuICAgIFwi44G744KZ44GG44GN44KZ44KHXCIsXG4gICAgXCLjgbvjgYbjgZPjgY9cIixcbiAgICBcIuOBu+OBhuOBneOBhlwiLFxuICAgIFwi44G744GG44G744GGXCIsXG4gICAgXCLjgbvjgYbjgoLjgpNcIixcbiAgICBcIuOBu+OBhuOCiuOBpFwiLFxuICAgIFwi44G744GI44KLXCIsXG4gICAgXCLjgbvjgYrjgpNcIixcbiAgICBcIuOBu+OBi+OCk1wiLFxuICAgIFwi44G744GN44KH44GGXCIsXG4gICAgXCLjgbvjgpnjgY3jgpNcIixcbiAgICBcIuOBu+OBj+OCjVwiLFxuICAgIFwi44G744GR44GkXCIsXG4gICAgXCLjgbvjgZHjgpNcIixcbiAgICBcIuOBu+OBk+OBhlwiLFxuICAgIFwi44G744GT44KLXCIsXG4gICAgXCLjgbvjgZfjgYRcIixcbiAgICBcIuOBu+OBl+OBpFwiLFxuICAgIFwi44G744GX44KFXCIsXG4gICAgXCLjgbvjgZfjgofjgYZcIixcbiAgICBcIuOBu+OBm+OBhFwiLFxuICAgIFwi44G744Gd44GEXCIsXG4gICAgXCLjgbvjgZ3jgY9cIixcbiAgICBcIuOBu+OBn+OBplwiLFxuICAgIFwi44G744Gf44KLXCIsXG4gICAgXCLjgbvjgprjgaHjgbXjgpnjgY/jgo1cIixcbiAgICBcIuOBu+OBo+OBjeOCh+OBj1wiLFxuICAgIFwi44G744Gj44GVXCIsXG4gICAgXCLjgbvjgaPjgZ/jgpNcIixcbiAgICBcIuOBu+OBqOOCk+OBqOOCmVwiLFxuICAgIFwi44G744KB44KLXCIsXG4gICAgXCLjgbvjgpPjgYRcIixcbiAgICBcIuOBu+OCk+OBjVwiLFxuICAgIFwi44G744KT44GRXCIsXG4gICAgXCLjgbvjgpPjgZfjgaRcIixcbiAgICBcIuOBu+OCk+OChOOBj1wiLFxuICAgIFwi44G+44GE44Gr44GhXCIsXG4gICAgXCLjgb7jgYvjgYRcIixcbiAgICBcIuOBvuOBi+OBm+OCi1wiLFxuICAgIFwi44G+44GL44KZ44KLXCIsXG4gICAgXCLjgb7jgZHjgotcIixcbiAgICBcIuOBvuOBk+OBqFwiLFxuICAgIFwi44G+44GV44GkXCIsXG4gICAgXCLjgb7jgZfjgpnjgoFcIixcbiAgICBcIuOBvuOBmeOBj1wiLFxuICAgIFwi44G+44Gb44KZ44KLXCIsXG4gICAgXCLjgb7jgaTjgopcIixcbiAgICBcIuOBvuOBqOOCgVwiLFxuICAgIFwi44G+44Gq44G144KZXCIsXG4gICAgXCLjgb7jgazjgZFcIixcbiAgICBcIuOBvuOBreOBj1wiLFxuICAgIFwi44G+44G744GGXCIsXG4gICAgXCLjgb7jgoLjgotcIixcbiAgICBcIuOBvuOChuOBkeOCmVwiLFxuICAgIFwi44G+44KI44GGXCIsXG4gICAgXCLjgb7jgo3jgoTjgYtcIixcbiAgICBcIuOBvuOCj+OBmVwiLFxuICAgIFwi44G+44KP44KKXCIsXG4gICAgXCLjgb7jgo/jgotcIixcbiAgICBcIuOBvuOCk+OBi+OCmVwiLFxuICAgIFwi44G+44KT44GN44GkXCIsXG4gICAgXCLjgb7jgpPjgZ3jgpnjgY9cIixcbiAgICBcIuOBvuOCk+OBquOBi1wiLFxuICAgIFwi44G/44GE44KJXCIsXG4gICAgXCLjgb/jgYbjgaFcIixcbiAgICBcIuOBv+OBiOOCi1wiLFxuICAgIFwi44G/44GL44KZ44GPXCIsXG4gICAgXCLjgb/jgYvjgZ9cIixcbiAgICBcIuOBv+OBi+OCk1wiLFxuICAgIFwi44G/44GR44KTXCIsXG4gICAgXCLjgb/jgZPjgpNcIixcbiAgICBcIuOBv+OBl+OCmeOBi+OBhFwiLFxuICAgIFwi44G/44GZ44GEXCIsXG4gICAgXCLjgb/jgZnjgYjjgotcIixcbiAgICBcIuOBv+OBm+OCi1wiLFxuICAgIFwi44G/44Gj44GLXCIsXG4gICAgXCLjgb/jgaTjgYvjgotcIixcbiAgICBcIuOBv+OBpOOBkeOCi1wiLFxuICAgIFwi44G/44Gm44GEXCIsXG4gICAgXCLjgb/jgajjgoHjgotcIixcbiAgICBcIuOBv+OBquOBqFwiLFxuICAgIFwi44G/44Gq44G/44GL44GV44GEXCIsXG4gICAgXCLjgb/jga3jgonjgotcIixcbiAgICBcIuOBv+OBruOBhlwiLFxuICAgIFwi44G/44Gu44GL44KZ44GZXCIsXG4gICAgXCLjgb/jgbvjgpNcIixcbiAgICBcIuOBv+OCguOBqFwiLFxuICAgIFwi44G/44KE44GR44KZXCIsXG4gICAgXCLjgb/jgonjgYRcIixcbiAgICBcIuOBv+OCiuOCh+OBj1wiLFxuICAgIFwi44G/44KP44GPXCIsXG4gICAgXCLjgb/jgpPjgYtcIixcbiAgICBcIuOBv+OCk+OBneOCmeOBj1wiLFxuICAgIFwi44KA44GE44GLXCIsXG4gICAgXCLjgoDjgYjjgY1cIixcbiAgICBcIuOCgOOBiOOCk1wiLFxuICAgIFwi44KA44GL44GEXCIsXG4gICAgXCLjgoDjgYvjgYZcIixcbiAgICBcIuOCgOOBi+OBiFwiLFxuICAgIFwi44KA44GL44GXXCIsXG4gICAgXCLjgoDjgY3jgpnjgaHjgoNcIixcbiAgICBcIuOCgOOBkeOCi1wiLFxuICAgIFwi44KA44GR44KZ44KTXCIsXG4gICAgXCLjgoDjgZXjgbvjgpnjgotcIixcbiAgICBcIuOCgOOBl+OBguOBpOOBhFwiLFxuICAgIFwi44KA44GX44Gv44KZXCIsXG4gICAgXCLjgoDjgZfjgpnjgoXjgpNcIixcbiAgICBcIuOCgOOBl+OCjVwiLFxuICAgIFwi44KA44GZ44GGXCIsXG4gICAgXCLjgoDjgZnjgZNcIixcbiAgICBcIuOCgOOBmeOBteOCmVwiLFxuICAgIFwi44KA44GZ44KBXCIsXG4gICAgXCLjgoDjgZvjgotcIixcbiAgICBcIuOCgOOBm+OCk1wiLFxuICAgIFwi44KA44Gh44KF44GGXCIsXG4gICAgXCLjgoDjgarjgZfjgYRcIixcbiAgICBcIuOCgOOBruOBhlwiLFxuICAgIFwi44KA44KE44G/XCIsXG4gICAgXCLjgoDjgojjgYZcIixcbiAgICBcIuOCgOOCieOBleOBjVwiLFxuICAgIFwi44KA44KK44KH44GGXCIsXG4gICAgXCLjgoDjgo3jgpNcIixcbiAgICBcIuOCgeOBhOOBguOCk1wiLFxuICAgIFwi44KB44GE44GG44KTXCIsXG4gICAgXCLjgoHjgYTjgYjjgpNcIixcbiAgICBcIuOCgeOBhOOBi+OBj1wiLFxuICAgIFwi44KB44GE44GN44KH44GPXCIsXG4gICAgXCLjgoHjgYTjgZXjgYRcIixcbiAgICBcIuOCgeOBhOOBl1wiLFxuICAgIFwi44KB44GE44Gd44GGXCIsXG4gICAgXCLjgoHjgYTjgbXjgpnjgaRcIixcbiAgICBcIuOCgeOBhOOCjOOBhFwiLFxuICAgIFwi44KB44GE44KP44GPXCIsXG4gICAgXCLjgoHjgY/jgpnjgb7jgozjgotcIixcbiAgICBcIuOCgeOBleOCmeOBmVwiLFxuICAgIFwi44KB44GX44GfXCIsXG4gICAgXCLjgoHjgZnjgpnjgonjgZfjgYRcIixcbiAgICBcIuOCgeOBn+OCmeOBpFwiLFxuICAgIFwi44KB44G+44GEXCIsXG4gICAgXCLjgoHjgoTjgZlcIixcbiAgICBcIuOCgeOCk+OBjeOCh1wiLFxuICAgIFwi44KB44KT44Gb44GNXCIsXG4gICAgXCLjgoHjgpPjgajjgpnjgYZcIixcbiAgICBcIuOCguOBhuOBl+OBguOBkeOCmeOCi1wiLFxuICAgIFwi44KC44GG44Go44KZ44GG44GR44KTXCIsXG4gICAgXCLjgoLjgYjjgotcIixcbiAgICBcIuOCguOBj+OBl1wiLFxuICAgIFwi44KC44GP44Gm44GNXCIsXG4gICAgXCLjgoLjgY/jgojjgYbjgbLjgplcIixcbiAgICBcIuOCguOBoeOCjeOCk1wiLFxuICAgIFwi44KC44Go44KZ44KLXCIsXG4gICAgXCLjgoLjgonjgYZcIixcbiAgICBcIuOCguOCk+OBj1wiLFxuICAgIFwi44KC44KT44Gf44KZ44GEXCIsXG4gICAgXCLjgoTjgYrjgoRcIixcbiAgICBcIuOChOOBkeOCi1wiLFxuICAgIFwi44KE44GV44GEXCIsXG4gICAgXCLjgoTjgZXjgZfjgYRcIixcbiAgICBcIuOChOOBmeOBhFwiLFxuICAgIFwi44KE44GZ44Gf44KN44GGXCIsXG4gICAgXCLjgoTjgZnjgb9cIixcbiAgICBcIuOChOOBm+OCi1wiLFxuICAgIFwi44KE44Gd44GGXCIsXG4gICAgXCLjgoTjgZ/jgYRcIixcbiAgICBcIuOChOOBoeOCk1wiLFxuICAgIFwi44KE44Gj44GoXCIsXG4gICAgXCLjgoTjgaPjga/jgprjgopcIixcbiAgICBcIuOChOOBteOCmeOCi1wiLFxuICAgIFwi44KE44KB44KLXCIsXG4gICAgXCLjgoTjgoTjgZPjgZfjgYRcIixcbiAgICBcIuOChOOCiOOBhFwiLFxuICAgIFwi44KE44KP44KJ44GL44GEXCIsXG4gICAgXCLjgobjgYbjgY1cIixcbiAgICBcIuOChuOBhuOBsuOCmeOCk+OBjeOCh+OBj1wiLFxuICAgIFwi44KG44GG44G444KZXCIsXG4gICAgXCLjgobjgYbjgoHjgYRcIixcbiAgICBcIuOChuOBkeOBpFwiLFxuICAgIFwi44KG44GX44KF44GkXCIsXG4gICAgXCLjgobjgZvjgpNcIixcbiAgICBcIuOChuOBneOBhlwiLFxuICAgIFwi44KG44Gf44GLXCIsXG4gICAgXCLjgobjgaHjgoPjgY9cIixcbiAgICBcIuOChuOBpuOCmeOCi1wiLFxuICAgIFwi44KG44Gr44KF44GGXCIsXG4gICAgXCLjgobjgbLjgpnjgo9cIixcbiAgICBcIuOChuOCieOBhFwiLFxuICAgIFwi44KG44KM44KLXCIsXG4gICAgXCLjgojjgYbjgYRcIixcbiAgICBcIuOCiOOBhuOBi1wiLFxuICAgIFwi44KI44GG44GN44KF44GGXCIsXG4gICAgXCLjgojjgYbjgZfjgplcIixcbiAgICBcIuOCiOOBhuOBmVwiLFxuICAgIFwi44KI44GG44Gh44GI44KTXCIsXG4gICAgXCLjgojjgYvjgZvjgplcIixcbiAgICBcIuOCiOOBi+OCk1wiLFxuICAgIFwi44KI44GN44KTXCIsXG4gICAgXCLjgojjgY/jgZvjgYRcIixcbiAgICBcIuOCiOOBj+OBu+OCmeOBhlwiLFxuICAgIFwi44KI44GR44GEXCIsXG4gICAgXCLjgojjgZPjgpnjgozjgotcIixcbiAgICBcIuOCiOOBleOCk1wiLFxuICAgIFwi44KI44GX44KF44GGXCIsXG4gICAgXCLjgojjgZ3jgYZcIixcbiAgICBcIuOCiOOBneOBj1wiLFxuICAgIFwi44KI44Gj44GLXCIsXG4gICAgXCLjgojjgabjgYRcIixcbiAgICBcIuOCiOOBqOOCmeOBi+OCmeOCj+OBj1wiLFxuICAgIFwi44KI44Gt44GkXCIsXG4gICAgXCLjgojjgoTjgY9cIixcbiAgICBcIuOCiOOChuOBhlwiLFxuICAgIFwi44KI44KN44GT44G144KZXCIsXG4gICAgXCLjgojjgo3jgZfjgYRcIixcbiAgICBcIuOCieOBhOOBhlwiLFxuICAgIFwi44KJ44GP44GL44KZ44GNXCIsXG4gICAgXCLjgonjgY/jgZPjgplcIixcbiAgICBcIuOCieOBj+OBleOBpFwiLFxuICAgIFwi44KJ44GP44Gf44KZXCIsXG4gICAgXCLjgonjgZfjgpPjga/jgpnjgpNcIixcbiAgICBcIuOCieOBm+OCk1wiLFxuICAgIFwi44KJ44Gd44KZ44GPXCIsXG4gICAgXCLjgonjgZ/jgYRcIixcbiAgICBcIuOCieOBo+OBi1wiLFxuICAgIFwi44KJ44KM44GkXCIsXG4gICAgXCLjgorjgYjjgY1cIixcbiAgICBcIuOCiuOBi+OBhFwiLFxuICAgIFwi44KK44GN44GV44GPXCIsXG4gICAgXCLjgorjgY3jgZvjgaRcIixcbiAgICBcIuOCiuOBj+OBj+OCmeOCk1wiLFxuICAgIFwi44KK44GP44GkXCIsXG4gICAgXCLjgorjgZHjgpNcIixcbiAgICBcIuOCiuOBk+OBhlwiLFxuICAgIFwi44KK44Gb44GEXCIsXG4gICAgXCLjgorjgZ3jgYZcIixcbiAgICBcIuOCiuOBneOBj1wiLFxuICAgIFwi44KK44Gm44KTXCIsXG4gICAgXCLjgorjga3jgpNcIixcbiAgICBcIuOCiuOChuOBhlwiLFxuICAgIFwi44KK44KF44GG44GL44KZ44GPXCIsXG4gICAgXCLjgorjgojjgYZcIixcbiAgICBcIuOCiuOCh+OBhuOCilwiLFxuICAgIFwi44KK44KH44GL44KTXCIsXG4gICAgXCLjgorjgofjgY/jgaHjgoNcIixcbiAgICBcIuOCiuOCh+OBk+OBhlwiLFxuICAgIFwi44KK44KK44GPXCIsXG4gICAgXCLjgorjgozjgY1cIixcbiAgICBcIuOCiuOCjeOCk1wiLFxuICAgIFwi44KK44KT44GT44KZXCIsXG4gICAgXCLjgovjgYTjgZHjgYRcIixcbiAgICBcIuOCi+OBhOOBleOBhFwiLFxuICAgIFwi44KL44GE44GX44KZXCIsXG4gICAgXCLjgovjgYTjgZvjgY1cIixcbiAgICBcIuOCi+OBmeOBr+OCmeOCk1wiLFxuICAgIFwi44KL44KK44GL44KZ44KP44KJXCIsXG4gICAgXCLjgozjgYTjgYvjgpNcIixcbiAgICBcIuOCjOOBhOOBjeOCmVwiLFxuICAgIFwi44KM44GE44Gb44GEXCIsXG4gICAgXCLjgozjgYTjgZ3jgpnjgYbjgZNcIixcbiAgICBcIuOCjOOBhOOBqOOBhlwiLFxuICAgIFwi44KM44GE44G744KZ44GGXCIsXG4gICAgXCLjgozjgY3jgZdcIixcbiAgICBcIuOCjOOBjeOBn+OCmeOBhFwiLFxuICAgIFwi44KM44KT44GC44GEXCIsXG4gICAgXCLjgozjgpPjgZHjgYRcIixcbiAgICBcIuOCjOOCk+OBk+OCk1wiLFxuICAgIFwi44KM44KT44GV44GEXCIsXG4gICAgXCLjgozjgpPjgZfjgoXjgYZcIixcbiAgICBcIuOCjOOCk+OBneOCmeOBj1wiLFxuICAgIFwi44KM44KT44KJ44GPXCIsXG4gICAgXCLjgo3jgYbjgYtcIixcbiAgICBcIuOCjeOBhuOBk+OCmVwiLFxuICAgIFwi44KN44GG44GX44KZ44KTXCIsXG4gICAgXCLjgo3jgYbjgZ3jgY9cIixcbiAgICBcIuOCjeOBj+OBi+OCmVwiLFxuICAgIFwi44KN44GT44GkXCIsXG4gICAgXCLjgo3jgZfjgpnjgYbjgolcIixcbiAgICBcIuOCjeOBl+OCheOBpFwiLFxuICAgIFwi44KN44Gb44KTXCIsXG4gICAgXCLjgo3jgabjgpNcIixcbiAgICBcIuOCjeOCgeOCk1wiLFxuICAgIFwi44KN44KM44GkXCIsXG4gICAgXCLjgo3jgpPjgY3jgplcIixcbiAgICBcIuOCjeOCk+OBr+OCmlwiLFxuICAgIFwi44KN44KT44G144KZ44KTXCIsXG4gICAgXCLjgo3jgpPjgopcIixcbiAgICBcIuOCj+OBi+OBmVwiLFxuICAgIFwi44KP44GL44KBXCIsXG4gICAgXCLjgo/jgYvjgoTjgb5cIixcbiAgICBcIuOCj+OBi+OCjOOCi1wiLFxuICAgIFwi44KP44GX44GkXCIsXG4gICAgXCLjgo/jgZfjgpnjgb7jgZdcIixcbiAgICBcIuOCj+OBmeOCjOOCguOBrlwiLFxuICAgIFwi44KP44KJ44GGXCIsXG4gICAgXCLjgo/jgozjgotcIlxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwi4YSA4YWh4YSA4YWn4YaoXCIsXG4gICAgXCLhhIDhhaHhhIHhhbPhhrdcIixcbiAgICBcIuGEgOGFoeGEguGFoeGGq1wiLFxuICAgIFwi4YSA4YWh4YSC4YWz4Ya8XCIsXG4gICAgXCLhhIDhhaHhhIPhhbPhhqhcIixcbiAgICBcIuGEgOGFoeGEheGFs+GEjuGFteGGt1wiLFxuICAgIFwi4YSA4YWh4YSG4YWu4Ya3XCIsXG4gICAgXCLhhIDhhaHhhIfhhaHhhrxcIixcbiAgICBcIuGEgOGFoeGEieGFoeGGvFwiLFxuICAgIFwi4YSA4YWh4YSJ4YWz4Ya3XCIsXG4gICAgXCLhhIDhhaHhhIvhha7hhqvhhIPhhaZcIixcbiAgICBcIuGEgOGFoeGEi+GFs+GGr1wiLFxuICAgIFwi4YSA4YWh4YSL4YW14YSD4YWzXCIsXG4gICAgXCLhhIDhhaHhhIvhhbXhhrhcIixcbiAgICBcIuGEgOGFoeGEjOGFoeGGvFwiLFxuICAgIFwi4YSA4YWh4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIDhhaHhhIzhhanhhqhcIixcbiAgICBcIuGEgOGFoeGEjOGFruGGqFwiLFxuICAgIFwi4YSA4YWh4Yao4YSL4YWpXCIsXG4gICAgXCLhhIDhhaHhhqjhhIzhhaFcIixcbiAgICBcIuGEgOGFoeGGq+GEgOGFp+GGqFwiLFxuICAgIFwi4YSA4YWh4Yar4YSH4YWuXCIsXG4gICAgXCLhhIDhhaHhhqvhhInhhaXhhrhcIixcbiAgICBcIuGEgOGFoeGGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSA4YWh4Yar4YSM4YWl4Ya4XCIsXG4gICAgXCLhhIDhhaHhhqvhhJHhhaHhhqtcIixcbiAgICBcIuGEgOGFoeGGr+GEg+GFs+GGvFwiLFxuICAgIFwi4YSA4YWh4Yav4YSH4YW1XCIsXG4gICAgXCLhhIDhhaHhhq/hhInhhaLhhqhcIixcbiAgICBcIuGEgOGFoeGGr+GEjOGFs+GGvFwiLFxuICAgIFwi4YSA4YWh4Ya34YSA4YWh4YaoXCIsXG4gICAgXCLhhIDhhaHhhrfhhIDhhbVcIixcbiAgICBcIuGEgOGFoeGGt+GEieGFqVwiLFxuICAgIFwi4YSA4YWh4Ya34YSJ4YWu4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIDhhaHhhrfhhIzhhaFcIixcbiAgICBcIuGEgOGFoeGGt+GEjOGFpeGGvFwiLFxuICAgIFwi4YSA4YWh4Ya44YSM4YWh4YSA4YW1XCIsXG4gICAgXCLhhIDhhaHhhrzhhILhhaHhhrdcIixcbiAgICBcIuGEgOGFoeGGvOGEg+GFoeGGvFwiLFxuICAgIFwi4YSA4YWh4Ya84YSD4YWpXCIsXG4gICAgXCLhhIDhhaHhhrzhhIXhhafhhqjhhJLhhbVcIixcbiAgICBcIuGEgOGFoeGGvOGEh+GFp+GGq1wiLFxuICAgIFwi4YSA4YWh4Ya84YSH4YWu4YaoXCIsXG4gICAgXCLhhIDhhaHhhrzhhInhhaFcIixcbiAgICBcIuGEgOGFoeGGvOGEieGFruGEheGFo+GGvFwiLFxuICAgIFwi4YSA4YWh4Ya84YSL4YWh4YSM4YW1XCIsXG4gICAgXCLhhIDhhaHhhrzhhIvhha/hhqvhhIPhhalcIixcbiAgICBcIuGEgOGFoeGGvOGEi+GFtFwiLFxuICAgIFwi4YSA4YWh4Ya84YSM4YWmXCIsXG4gICAgXCLhhIDhhaHhhrzhhIzhhalcIixcbiAgICBcIuGEgOGFoeGHgOGEi+GFtVwiLFxuICAgIFwi4YSA4YWi4YSA4YWu4YSF4YW1XCIsXG4gICAgXCLhhIDhhaLhhILhhaHhhIXhhbVcIixcbiAgICBcIuGEgOGFouGEh+GFoeGGvFwiLFxuICAgIFwi4YSA4YWi4YSH4YWn4YavXCIsXG4gICAgXCLhhIDhhaLhhInhhaXhhqtcIixcbiAgICBcIuGEgOGFouGEieGFpeGGvFwiLFxuICAgIFwi4YSA4YWi4YSL4YW14YarXCIsXG4gICAgXCLhhIDhhaLhhqjhhIDhharhhqvhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFpeGEieGFteGGr1wiLFxuICAgIFwi4YSA4YWl4YSL4YWi4YaoXCIsXG4gICAgXCLhhIDhhaXhhIvhha7hhq9cIixcbiAgICBcIuGEgOGFpeGEjOGFteGGulwiLFxuICAgIFwi4YSA4YWl4YSR4YWu4Ya3XCIsXG4gICAgXCLhhIDhhaXhhqjhhIzhhaXhhrxcIixcbiAgICBcIuGEgOGFpeGGq+GEgOGFoeGGvFwiLFxuICAgIFwi4YSA4YWl4Yar4YSG4YWu4YavXCIsXG4gICAgXCLhhIDhhaXhhqvhhInhhaXhhq9cIixcbiAgICBcIuGEgOGFpeGGq+GEjOGFqVwiLFxuICAgIFwi4YSA4YWl4Yar4YSO4YWu4YaoXCIsXG4gICAgXCLhhIDhhaXhhq/hhIvhhbPhhrdcIixcbiAgICBcIuGEgOGFpeGGt+GEieGFoVwiLFxuICAgIFwi4YSA4YWl4Ya34YSQ4YWpXCIsXG4gICAgXCLhhIDhhabhhInhhbXhhJHhhaHhhqtcIixcbiAgICBcIuGEgOGFpuGEi+GFteGGt1wiLFxuICAgIFwi4YSA4YWn4YSL4YWu4YavXCIsXG4gICAgXCLhhIDhhafhhqvhhJLhhaJcIixcbiAgICBcIuGEgOGFp+GGr+GEgOGFqlwiLFxuICAgIFwi4YSA4YWn4Yav4YSA4YWu4YaoXCIsXG4gICAgXCLhhIDhhafhhq/hhIXhhanhhqtcIixcbiAgICBcIuGEgOGFp+GGr+GEieGFpeGGqFwiLFxuICAgIFwi4YSA4YWn4Yav4YSJ4YWz4Ya8XCIsXG4gICAgXCLhhIDhhafhhq/hhInhhbXhhrdcIixcbiAgICBcIuGEgOGFp+GGr+GEjOGFpeGGvFwiLFxuICAgIFwi4YSA4YWn4Yav4YSS4YWp4YarXCIsXG4gICAgXCLhhIDhhafhhrzhhIDhhahcIixcbiAgICBcIuGEgOGFp+GGvOGEgOGFqVwiLFxuICAgIFwi4YSA4YWn4Ya84YSA4YW1XCIsXG4gICAgXCLhhIDhhafhhrzhhIXhhafhhqhcIixcbiAgICBcIuGEgOGFp+GGvOGEh+GFqeGGqOGEgOGFruGGvFwiLFxuICAgIFwi4YSA4YWn4Ya84YSH4YW1XCIsXG4gICAgXCLhhIDhhafhhrzhhInhhaHhhrzhhIPhhalcIixcbiAgICBcIuGEgOGFp+GGvOGEi+GFp+GGvFwiLFxuICAgIFwi4YSA4YWn4Ya84YSL4YWuXCIsXG4gICAgXCLhhIDhhafhhrzhhIzhhaLhhrxcIixcbiAgICBcIuGEgOGFp+GGvOGEjOGFplwiLFxuICAgIFwi4YSA4YWn4Ya84YSM4YWuXCIsXG4gICAgXCLhhIDhhafhhrzhhI7hhaHhhq9cIixcbiAgICBcIuGEgOGFp+GGvOGEjuGFtVwiLFxuICAgIFwi4YSA4YWn4Ya84YSS4YWj4Ya8XCIsXG4gICAgXCLhhIDhhafhhrzhhJLhhaXhhrdcIixcbiAgICBcIuGEgOGFqOGEgOGFqeGGqFwiLFxuICAgIFwi4YSA4YWo4YSD4YWh4YarXCIsXG4gICAgXCLhhIDhhajhhIXhhaHhhqtcIixcbiAgICBcIuGEgOGFqOGEieGFoeGGq1wiLFxuICAgIFwi4YSA4YWo4YSJ4YWp4YaoXCIsXG4gICAgXCLhhIDhhajhhIvhhaPhhqhcIixcbiAgICBcIuGEgOGFqOGEjOGFpeGGr1wiLFxuICAgIFwi4YSA4YWo4YSO4YWz4Ya8XCIsXG4gICAgXCLhhIDhhajhhJLhhazhhqhcIixcbiAgICBcIuGEgOGFqeGEgOGFouGGqFwiLFxuICAgIFwi4YSA4YWp4YSA4YWu4YSF4YWnXCIsXG4gICAgXCLhhIDhhanhhIDhha7hhrxcIixcbiAgICBcIuGEgOGFqeGEgOGFs+GGuFwiLFxuICAgIFwi4YSA4YWp4YSD4YWz4Ya84YSS4YWh4Yao4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhIDhhanhhIbhha7hhInhhbXhhqtcIixcbiAgICBcIuGEgOGFqeGEhuGFteGGq1wiLFxuICAgIFwi4YSA4YWp4YSL4YWj4Ya84YSL4YW1XCIsXG4gICAgXCLhhIDhhanhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFqeGEjOGFpeGGq1wiLFxuICAgIFwi4YSA4YWp4YSM4YW14Ya4XCIsXG4gICAgXCLhhIDhhanhhI7hha7hhrrhhIDhhaHhhIXhha5cIixcbiAgICBcIuGEgOGFqeGEkOGFqeGGvFwiLFxuICAgIFwi4YSA4YWp4YSS4YWj4Ya8XCIsXG4gICAgXCLhhIDhhanhhqjhhInhhbXhhqhcIixcbiAgICBcIuGEgOGFqeGGr+GEhuGFqeGGqFwiLFxuICAgIFwi4YSA4YWp4Yav4YSN4YWh4YSA4YW1XCIsXG4gICAgXCLhhIDhhanhhq/hhJHhhbNcIixcbiAgICBcIuGEgOGFqeGGvOGEgOGFoeGGq1wiLFxuICAgIFwi4YSA4YWp4Ya84YSA4YWiXCIsXG4gICAgXCLhhIDhhanhhrzhhIDhhafhhqhcIixcbiAgICBcIuGEgOGFqeGGvOGEgOGFruGGq1wiLFxuICAgIFwi4YSA4YWp4Ya84YSA4YWz4Ya4XCIsXG4gICAgXCLhhIDhhanhhrzhhIDhhbVcIixcbiAgICBcIuGEgOGFqeGGvOGEg+GFqeGGvFwiLFxuICAgIFwi4YSA4YWp4Ya84YSG4YWu4YSL4YWv4YarXCIsXG4gICAgXCLhhIDhhanhhrzhhIfhha5cIixcbiAgICBcIuGEgOGFqeGGvOGEieGFoVwiLFxuICAgIFwi4YSA4YWp4Ya84YSJ4YW14YaoXCIsXG4gICAgXCLhhIDhhanhhrzhhIvhhaXhhrhcIixcbiAgICBcIuGEgOGFqeGGvOGEi+GFp+GGq1wiLFxuICAgIFwi4YSA4YWp4Ya84YSL4YWv4YarXCIsXG4gICAgXCLhhIDhhanhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFqeGGvOGEjeGFoVwiLFxuICAgIFwi4YSA4YWp4Ya84YSO4YWi4YaoXCIsXG4gICAgXCLhhIDhhanhhrzhhJDhhanhhrxcIixcbiAgICBcIuGEgOGFqeGGvOGEkeGFqVwiLFxuICAgIFwi4YSA4YWp4Ya84YSS4YWh4Ya8XCIsXG4gICAgXCLhhIDhhanhhrzhhJLhhbLhhIvhhbXhhq9cIixcbiAgICBcIuGEgOGFquGEhuGFqeGGqFwiLFxuICAgIFwi4YSA4YWq4YSL4YW14YavXCIsXG4gICAgXCLhhIDhharhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFquGEjOGFpeGGvFwiLFxuICAgIFwi4YSA4YWq4YSS4YWh4YaoXCIsXG4gICAgXCLhhIDhharhhqvhhIDhhaLhhqhcIixcbiAgICBcIuGEgOGFquGGq+GEgOGFqFwiLFxuICAgIFwi4YSA4YWq4Yar4YSA4YWq4Ya8XCIsXG4gICAgXCLhhIDhharhhqvhhILhhafhhrdcIixcbiAgICBcIuGEgOGFquGGq+GEheGFoeGGt1wiLFxuICAgIFwi4YSA4YWq4Yar4YSF4YWn4YarXCIsXG4gICAgXCLhhIDhharhhqvhhIXhhbVcIixcbiAgICBcIuGEgOGFquGGq+GEieGFs+GGuFwiLFxuICAgIFwi4YSA4YWq4Yar4YSJ4YW14Ya3XCIsXG4gICAgXCLhhIDhharhhqvhhIzhhaXhhrdcIixcbiAgICBcIuGEgOGFquGGq+GEjuGFoeGGr1wiLFxuICAgIFwi4YSA4YWq4Ya84YSA4YWn4Ya8XCIsXG4gICAgXCLhhIDhharhhrzhhIDhhalcIixcbiAgICBcIuGEgOGFquGGvOGEjOGFoeGGvFwiLFxuICAgIFwi4YSA4YWq4Ya84YSM4YWuXCIsXG4gICAgXCLhhIDhhazhhIXhhanhhIvhha7hhrdcIixcbiAgICBcIuGEgOGFrOGGvOGEjOGFoeGGvOGEkuGFtVwiLFxuICAgIFwi4YSA4YWt4YSA4YWq4YSJ4YWlXCIsXG4gICAgXCLhhIDhha3hhIbhha7hhqtcIixcbiAgICBcIuGEgOGFreGEh+GFqeGGqFwiLFxuICAgIFwi4YSA4YWt4YSJ4YW14YavXCIsXG4gICAgXCLhhIDhha3hhIvhhaPhhrxcIixcbiAgICBcIuGEgOGFreGEi+GFsuGGqFwiLFxuICAgIFwi4YSA4YWt4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIDhha3hhIzhhbXhhqhcIixcbiAgICBcIuGEgOGFreGEkOGFqeGGvFwiLFxuICAgIFwi4YSA4YWt4YSS4YWq4YarXCIsXG4gICAgXCLhhIDhha3hhJLhha7hhqtcIixcbiAgICBcIuGEgOGFruGEgOGFp+GGvFwiLFxuICAgIFwi4YSA4YWu4YSF4YWz4Ya3XCIsXG4gICAgXCLhhIDhha7hhIbhhaXhhrxcIixcbiAgICBcIuGEgOGFruGEh+GFp+GGr1wiLFxuICAgIFwi4YSA4YWu4YSH4YWu4YarXCIsXG4gICAgXCLhhIDhha7hhInhhaXhhqhcIixcbiAgICBcIuGEgOGFruGEieGFpeGGvFwiLFxuICAgIFwi4YSA4YWu4YSJ4YWp4YaoXCIsXG4gICAgXCLhhIDhha7hhIvhhafhhqhcIixcbiAgICBcIuGEgOGFruGEi+GFteGGuFwiLFxuICAgIFwi4YSA4YWu4YSO4YWl4Ya8XCIsXG4gICAgXCLhhIDhha7hhI7hhabhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFruGGqOGEgOGFoVwiLFxuICAgIFwi4YSA4YWu4Yao4YSA4YW1XCIsXG4gICAgXCLhhIDhha7hhqjhhILhhaJcIixcbiAgICBcIuGEgOGFruGGqOGEheGFteGGuFwiLFxuICAgIFwi4YSA4YWu4Yao4YSG4YWu4YavXCIsXG4gICAgXCLhhIDhha7hhqjhhIbhhbXhhqtcIixcbiAgICBcIuGEgOGFruGGqOGEieGFrlwiLFxuICAgIFwi4YSA4YWu4Yao4YSL4YWlXCIsXG4gICAgXCLhhIDhha7hhqjhhIvhharhhrxcIixcbiAgICBcIuGEgOGFruGGqOGEjOGFpeGGqFwiLFxuICAgIFwi4YSA4YWu4Yao4YSM4YWmXCIsXG4gICAgXCLhhIDhha7hhqjhhJLhhaxcIixcbiAgICBcIuGEgOGFruGGq+GEg+GFolwiLFxuICAgIFwi4YSA4YWu4Yar4YSJ4YWhXCIsXG4gICAgXCLhhIDhha7hhqvhhIvhhbXhhqtcIixcbiAgICBcIuGEgOGFruGGvOGEgOGFs+GGqOGEjOGFpeGGqFwiLFxuICAgIFwi4YSA4YWv4Yar4YSF4YW1XCIsXG4gICAgXCLhhIDhha/hhqvhhIvhhbFcIixcbiAgICBcIuGEgOGFr+GGq+GEkOGFrlwiLFxuICAgIFwi4YSA4YWx4YSA4YWu4YaoXCIsXG4gICAgXCLhhIDhhbHhhInhhbXhhqtcIixcbiAgICBcIuGEgOGFsuGEjOGFpeGGvFwiLFxuICAgIFwi4YSA4YWy4YSO4YW14YaoXCIsXG4gICAgXCLhhIDhhbLhhqvhhJLhhafhhrxcIixcbiAgICBcIuGEgOGFs+GEguGFoeGGr1wiLFxuICAgIFwi4YSA4YWz4YSC4YWj4Ya8XCIsXG4gICAgXCLhhIDhhbPhhILhhbPhhq9cIixcbiAgICBcIuGEgOGFs+GEheGFpeGEguGFoVwiLFxuICAgIFwi4YSA4YWz4YSF4YWu4Ya4XCIsXG4gICAgXCLhhIDhhbPhhIXhhbPhhrpcIixcbiAgICBcIuGEgOGFs+GEheGFteGGt1wiLFxuICAgIFwi4YSA4YWz4YSM4YWm4YSJ4YWl4YSL4YWjXCIsXG4gICAgXCLhhIDhhbPhhJDhhanhhIXhhanhhqhcIixcbiAgICBcIuGEgOGFs+GGqOGEh+GFqeGGqFwiLFxuICAgIFwi4YSA4YWz4Yao4YSS4YW1XCIsXG4gICAgXCLhhIDhhbPhhqvhhIDhhaVcIixcbiAgICBcIuGEgOGFs+GGq+GEgOGFrVwiLFxuICAgIFwi4YSA4YWz4Yar4YSF4YWiXCIsXG4gICAgXCLhhIDhhbPhhqvhhIXhhalcIixcbiAgICBcIuGEgOGFs+GGq+GEhuGFrlwiLFxuICAgIFwi4YSA4YWz4Yar4YSH4YWp4YarXCIsXG4gICAgXCLhhIDhhbPhhqvhhIvhha/hhqtcIixcbiAgICBcIuGEgOGFs+GGq+GEi+GFsuGGqFwiLFxuICAgIFwi4YSA4YWz4Yar4YSO4YWlXCIsXG4gICAgXCLhhIDhhbPhhq/hhIrhhbVcIixcbiAgICBcIuGEgOGFs+GGr+GEjOGFoVwiLFxuICAgIFwi4YSA4YWz4Ya34YSA4YWh4Ya84YSJ4YWh4YarXCIsXG4gICAgXCLhhIDhhbPhhrfhhIDhhalcIixcbiAgICBcIuGEgOGFs+GGt+GEguGFp+GGq1wiLFxuICAgIFwi4YSA4YWz4Ya34YSG4YWm4YSD4YWh4YavXCIsXG4gICAgXCLhhIDhhbPhhrfhhIvhhaLhhqhcIixcbiAgICBcIuGEgOGFs+GGt+GEi+GFp+GGq1wiLFxuICAgIFwi4YSA4YWz4Ya34YSL4YWt4YSL4YW14YavXCIsXG4gICAgXCLhhIDhhbPhhrfhhIzhhbVcIixcbiAgICBcIuGEgOGFs+GGvOGEjOGFpeGGvOGEjOGFpeGGqFwiLFxuICAgIFwi4YSA4YW14YSA4YWh4YarXCIsXG4gICAgXCLhhIDhhbXhhIDhharhhqtcIixcbiAgICBcIuGEgOGFteGEguGFp+GGt1wiLFxuICAgIFwi4YSA4YW14YSC4YWz4Ya8XCIsXG4gICAgXCLhhIDhhbXhhIPhhanhhqjhhIDhha1cIixcbiAgICBcIuGEgOGFteGEg+GFruGGvFwiLFxuICAgIFwi4YSA4YW14YSF4YWp4YaoXCIsXG4gICAgXCLhhIDhhbXhhIXhhbPhhrdcIixcbiAgICBcIuGEgOGFteGEh+GFpeGGuFwiLFxuICAgIFwi4YSA4YW14YSH4YWp4YarXCIsXG4gICAgXCLhhIDhhbXhhIfhha7hhqtcIixcbiAgICBcIuGEgOGFteGEiOGFs+GGt1wiLFxuICAgIFwi4YSA4YW14YSJ4YWu4Yao4YSJ4YWhXCIsXG4gICAgXCLhhIDhhbXhhInhha7hhq9cIixcbiAgICBcIuGEgOGFteGEi+GFpeGGqFwiLFxuICAgIFwi4YSA4YW14YSL4YWl4Ya4XCIsXG4gICAgXCLhhIDhhbXhhIvhhanhhqtcIixcbiAgICBcIuGEgOGFteGEi+GFruGGq1wiLFxuICAgIFwi4YSA4YW14YSL4YWv4YarXCIsXG4gICAgXCLhhIDhhbXhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFteGEjOGFruGGq1wiLFxuICAgIFwi4YSA4YW14YSO4YW14Ya3XCIsXG4gICAgXCLhhIDhhbXhhJLhhanhhqtcIixcbiAgICBcIuGEgOGFteGEkuGFrOGGqFwiLFxuICAgIFwi4YSA4YW14Yar4YSA4YWz4Ya4XCIsXG4gICAgXCLhhIDhhbXhhqvhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFteGGr+GEi+GFtVwiLFxuICAgIFwi4YSA4YW14Ya34YSH4YWh4Ya4XCIsXG4gICAgXCLhhIDhhbXhhrfhhI7hhbVcIixcbiAgICBcIuGEgOGFteGGt+GEkeGFqeGEgOGFqeGGvOGEkuGFoeGGvFwiLFxuICAgIFwi4YSB4YWh4Yao4YSD4YWu4YSA4YW1XCIsXG4gICAgXCLhhIHhhaHhhrfhhIjhhaHhhqhcIixcbiAgICBcIuGEgeGFouGEg+GFoeGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSB4YWi4YSJ4YWp4YSA4YWz4Ya3XCIsXG4gICAgXCLhhIHhhaXhhrjhhIzhhbXhhq9cIixcbiAgICBcIuGEgeGFqeGGqOGEg+GFouGEgOGFtVwiLFxuICAgIFwi4YSB4YWp4Ya+4YSL4YW14YeBXCIsXG4gICAgXCLhhILhhaHhhIPhhbPhhq/hhIvhhbVcIixcbiAgICBcIuGEguGFoeGEheGFoeGGq+GEkuGFtVwiLFxuICAgIFwi4YSC4YWh4YSG4YWl4YSM4YW1XCIsXG4gICAgXCLhhILhhaHhhIbhha7hhq9cIixcbiAgICBcIuGEguGFoeGEjuGFteGGt+GEh+GFoeGGq1wiLFxuICAgIFwi4YSC4YWh4YSS4YWz4YavXCIsXG4gICAgXCLhhILhhaHhhqjhhIvhhafhhrhcIixcbiAgICBcIuGEguGFoeGGq+GEh+GFoeGGvFwiLFxuICAgIFwi4YSC4YWh4Yav4YSA4YWiXCIsXG4gICAgXCLhhILhhaHhhq/hhIrhhbVcIixcbiAgICBcIuGEguGFoeGGr+GEjeGFoVwiLFxuICAgIFwi4YSC4YWh4Ya34YSC4YWnXCIsXG4gICAgXCLhhILhhaHhhrfhhIPhhaLhhIbhha7hhqtcIixcbiAgICBcIuGEguGFoeGGt+GEhuGFolwiLFxuICAgIFwi4YSC4YWh4Ya34YSJ4YWh4YarXCIsXG4gICAgXCLhhILhhaHhhrfhhIzhhaFcIixcbiAgICBcIuGEguGFoeGGt+GEkeGFp+GGq1wiLFxuICAgIFwi4YSC4YWh4Ya34YSS4YWh4Yao4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhILhhaHhhrzhhIfhhbVcIixcbiAgICBcIuGEguGFoeGHgOGEhuGFoeGGr1wiLFxuICAgIFwi4YSC4YWi4YSC4YWn4YarXCIsXG4gICAgXCLhhILhhaLhhIvhha3hhrxcIixcbiAgICBcIuGEguGFouGEi+GFteGGr1wiLFxuICAgIFwi4YSC4YWi4Ya34YSH4YW1XCIsXG4gICAgXCLhhILhhaLhhrfhhInhhaJcIixcbiAgICBcIuGEguGFouGGuuGEhuGFruGGr1wiLFxuICAgIFwi4YSC4YWi4Ya84YSD4YWp4Ya8XCIsXG4gICAgXCLhhILhhaLhhrzhhIbhhafhhqtcIixcbiAgICBcIuGEguGFouGGvOGEh+GFoeGGvFwiLFxuICAgIFwi4YSC4YWi4Ya84YSM4YWh4Ya84YSA4YWpXCIsXG4gICAgXCLhhILhhabhhqjhhJDhhaHhhIvhhbVcIixcbiAgICBcIuGEguGFpuGGuuGEjeGFolwiLFxuICAgIFwi4YSC4YWp4YSD4YWp4Ya8XCIsXG4gICAgXCLhhILhhanhhIXhhaHhhqvhhInhhaLhhqhcIixcbiAgICBcIuGEguGFqeGEheGFp+GGqFwiLFxuICAgIFwi4YSC4YWp4YSL4YW14YarXCIsXG4gICAgXCLhhILhhanhhqjhhIvhhbPhhrdcIixcbiAgICBcIuGEguGFqeGGqOGEjuGFoVwiLFxuICAgIFwi4YSC4YWp4Yao4YSS4YWqXCIsXG4gICAgXCLhhILhhanhhqvhhIXhhbVcIixcbiAgICBcIuGEguGFqeGGq+GEhuGFruGGq1wiLFxuICAgIFwi4YSC4YWp4Yar4YSM4YWi4Ya8XCIsXG4gICAgXCLhhILhhanhhq/hhIvhhbVcIixcbiAgICBcIuGEguGFqeGGvOGEgOGFrlwiLFxuICAgIFwi4YSC4YWp4Ya84YSD4YWh4Ya3XCIsXG4gICAgXCLhhILhhanhhrzhhIbhhbXhhqtcIixcbiAgICBcIuGEguGFqeGGvOGEh+GFrlwiLFxuICAgIFwi4YSC4YWp4Ya84YSL4YWl4Ya4XCIsXG4gICAgXCLhhILhhanhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEguGFqeGGvOGEjuGFqeGGq1wiLFxuICAgIFwi4YSC4YWp4YeB4YSL4YW1XCIsXG4gICAgXCLhhILhha7hhqvhhIPhhanhhrzhhIzhhaFcIixcbiAgICBcIuGEguGFruGGq+GEhuGFruGGr1wiLFxuICAgIFwi4YSC4YWu4Yar4YSK4YWl4Ya4XCIsXG4gICAgXCLhhILhhbLhhIvhha3hhqhcIixcbiAgICBcIuGEguGFs+GEgeGFteGGt1wiLFxuICAgIFwi4YSC4YWz4Yao4YSD4YWiXCIsXG4gICAgXCLhhILhhbPhhrzhhIPhhanhhrzhhIzhhaXhhqhcIixcbiAgICBcIuGEguGFs+GGvOGEheGFp+GGqFwiLFxuICAgIFwi4YSD4YWh4YSH4YWh4Ya8XCIsXG4gICAgXCLhhIPhhaHhhIvhhaPhhrzhhInhhaXhhrxcIixcbiAgICBcIuGEg+GFoeGEi+GFs+GGt1wiLFxuICAgIFwi4YSD4YWh4YSL4YW14YSL4YWl4YSQ4YWzXCIsXG4gICAgXCLhhIPhhaHhhJLhhaLhhrxcIixcbiAgICBcIuGEg+GFoeGGq+GEgOGFqFwiLFxuICAgIFwi4YSD4YWh4Yar4YSA4YWp4YavXCIsXG4gICAgXCLhhIPhhaHhhqvhhIPhhanhhqhcIixcbiAgICBcIuGEg+GFoeGGq+GEhuGFoeGGulwiLFxuICAgIFwi4YSD4YWh4Yar4YSJ4YWu4YarXCIsXG4gICAgXCLhhIPhhaHhhqvhhIvhhaVcIixcbiAgICBcIuGEg+GFoeGGq+GEi+GFsVwiLFxuICAgIFwi4YSD4YWh4Yar4YSM4YWl4Ya3XCIsXG4gICAgXCLhhIPhhaHhhqvhhI7hhaZcIixcbiAgICBcIuGEg+GFoeGGq+GEjuGFrlwiLFxuICAgIFwi4YSD4YWh4Yar4YSR4YWn4YarXCIsXG4gICAgXCLhhIPhhaHhhqvhhJHhha7hhrxcIixcbiAgICBcIuGEg+GFoeGGr+GEgOGFo+GGr1wiLFxuICAgIFwi4YSD4YWh4Yav4YSF4YWlXCIsXG4gICAgXCLhhIPhhaHhhq/hhIXhhafhhqhcIixcbiAgICBcIuGEg+GFoeGGr+GEheGFtVwiLFxuICAgIFwi4YSD4YWh4Yaw4YSA4YWp4YSA4YW1XCIsXG4gICAgXCLhhIPhhaHhhrfhhIPhhaHhhrxcIixcbiAgICBcIuGEg+GFoeGGt+GEh+GFolwiLFxuICAgIFwi4YSD4YWh4Ya34YSL4YWtXCIsXG4gICAgXCLhhIPhhaHhhrfhhIvhhbXhhrdcIixcbiAgICBcIuGEg+GFoeGGuOGEh+GFp+GGq1wiLFxuICAgIFwi4YSD4YWh4Ya44YSM4YWh4Ya8XCIsXG4gICAgXCLhhIPhhaHhhrzhhIDhhbPhhqtcIixcbiAgICBcIuGEg+GFoeGGvOGEh+GFruGGq+GEgOGFoeGGq1wiLFxuICAgIFwi4YSD4YWh4Ya84YSL4YWn4Yar4YSS4YW1XCIsXG4gICAgXCLhhIPhhaHhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEg+GFouGEgOGFsuGEhuGFqVwiLFxuICAgIFwi4YSD4YWi4YSC4YWh4Ya9XCIsXG4gICAgXCLhhIPhhaLhhIPhhaHhhqvhhJLhhbVcIixcbiAgICBcIuGEg+GFouGEg+GFoeGGuFwiLFxuICAgIFwi4YSD4YWi4YSD4YWp4YSJ4YW1XCIsXG4gICAgXCLhhIPhhaLhhIXhhaPhhqhcIixcbiAgICBcIuGEg+GFouGEheGFo+GGvFwiLFxuICAgIFwi4YSD4YWi4YSF4YWy4YaoXCIsXG4gICAgXCLhhIPhhaLhhIbhha7hhqtcIixcbiAgICBcIuGEg+GFouGEh+GFruGEh+GFruGGq1wiLFxuICAgIFwi4YSD4YWi4YSJ4YW14YarXCIsXG4gICAgXCLhhIPhhaLhhIvhhbPhhrxcIixcbiAgICBcIuGEg+GFouGEjOGFoeGGvFwiLFxuICAgIFwi4YSD4YWi4YSM4YWl4YarXCIsXG4gICAgXCLhhIPhhaLhhIzhhaXhhrhcIixcbiAgICBcIuGEg+GFouGEjOGFruGGvFwiLFxuICAgIFwi4YSD4YWi4YSO4YWi4YaoXCIsXG4gICAgXCLhhIPhhaLhhI7hha7hhq9cIixcbiAgICBcIuGEg+GFouGEjuGFruGGvFwiLFxuICAgIFwi4YSD4YWi4YSQ4YWp4Ya84YSF4YWn4Ya8XCIsXG4gICAgXCLhhIPhhaLhhJLhhaHhhqhcIixcbiAgICBcIuGEg+GFouGEkuGFoeGGq+GEhuGFteGGq+GEgOGFruGGqFwiLFxuICAgIFwi4YSD4YWi4YSS4YWh4Ya44YSJ4YW14YavXCIsXG4gICAgXCLhhIPhhaLhhJLhhafhhrxcIixcbiAgICBcIuGEg+GFpeGGvOGEi+GFpeGEheGFtVwiLFxuICAgIFwi4YSD4YWm4YSL4YW14YSQ4YWzXCIsXG4gICAgXCLhhIPhhanhhIPhhaLhhI7hhaZcIixcbiAgICBcIuGEg+GFqeGEg+GFpeGGqFwiLFxuICAgIFwi4YSD4YWp4YSD4YWu4YaoXCIsXG4gICAgXCLhhIPhhanhhIbhhaHhhrxcIixcbiAgICBcIuGEg+GFqeGEieGFpeGEgOGFquGGq1wiLFxuICAgIFwi4YSD4YWp4YSJ4YW14Ya3XCIsXG4gICAgXCLhhIPhhanhhIvhha7hhrdcIixcbiAgICBcIuGEg+GFqeGEi+GFteGGuFwiLFxuICAgIFwi4YSD4YWp4YSM4YWh4YSA4YW1XCIsXG4gICAgXCLhhIPhhanhhIzhhaXhhJLhhbVcIixcbiAgICBcIuGEg+GFqeGEjOGFpeGGq1wiLFxuICAgIFwi4YSD4YWp4YSM4YWu4Ya8XCIsXG4gICAgXCLhhIPhhanhhI7hhaHhhqhcIixcbiAgICBcIuGEg+GFqeGGqOGEgOGFoeGGt1wiLFxuICAgIFwi4YSD4YWp4Yao4YSF4YW14Ya4XCIsXG4gICAgXCLhhIPhhanhhqjhhInhhaVcIixcbiAgICBcIuGEg+GFqeGGqOGEi+GFteGGr1wiLFxuICAgIFwi4YSD4YWp4Yao4YSO4YWh4Ya84YSM4YWl4YaoXCIsXG4gICAgXCLhhIPhhanhhrzhhJLhharhhI7hhaLhhqhcIixcbiAgICBcIuGEg+GFseGGuuGEhuGFqeGEieGFs+GGuFwiLFxuICAgIFwi4YSD4YWx4Ya64YSJ4YWh4YarXCIsXG4gICAgXCLhhIThhaHhhq/hhIvhhaHhhIvhhbVcIixcbiAgICBcIuGEhuGFoeGEguGFruGEheGFoVwiLFxuICAgIFwi4YSG4YWh4YSC4YWz4YavXCIsXG4gICAgXCLhhIbhhaHhhIPhhaHhhrxcIixcbiAgICBcIuGEhuGFoeGEheGFoeGEkOGFqeGGq1wiLFxuICAgIFwi4YSG4YWh4YSF4YWn4YarXCIsXG4gICAgXCLhhIbhhaHhhIbhha7hhIXhhbVcIixcbiAgICBcIuGEhuGFoeGEieGFoeGEjOGFtVwiLFxuICAgIFwi4YSG4YWh4YSL4YWj4YaoXCIsXG4gICAgXCLhhIbhhaHhhIvhha3hhILhhabhhIzhhbNcIixcbiAgICBcIuGEhuGFoeGEi+GFs+GGr1wiLFxuICAgIFwi4YSG4YWh4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIbhhaHhhIvhhbXhhI/hhbNcIixcbiAgICBcIuGEhuGFoeGEjOGFruGGvFwiLFxuICAgIFwi4YSG4YWh4YSM4YW14YSG4YWh4YaoXCIsXG4gICAgXCLhhIbhhaHhhI7hhaHhhqvhhIDhhaHhhIzhhbVcIixcbiAgICBcIuGEhuGFoeGEjuGFoeGGr1wiLFxuICAgIFwi4YSG4YWh4YSS4YWz4YarXCIsXG4gICAgXCLhhIbhhaHhhqjhhIDhhaXhhq/hhIXhhbVcIixcbiAgICBcIuGEhuGFoeGGqOGEguGFolwiLFxuICAgIFwi4YSG4YWh4Yao4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIbhhaHhhqvhhILhhaHhhrdcIixcbiAgICBcIuGEhuGFoeGGq+GEg+GFrlwiLFxuICAgIFwi4YSG4YWh4Yar4YSJ4YWmXCIsXG4gICAgXCLhhIbhhaHhhqvhhIvhhaPhhqhcIixcbiAgICBcIuGEhuGFoeGGq+GEi+GFteGGr1wiLFxuICAgIFwi4YSG4YWh4Yar4YSM4YWl4Ya3XCIsXG4gICAgXCLhhIbhhaHhhqvhhIzhhanhhqhcIixcbiAgICBcIuGEhuGFoeGGq+GEkuGFqlwiLFxuICAgIFwi4YSG4YWh4Yat4YSL4YW1XCIsXG4gICAgXCLhhIbhhaHhhq/hhIDhhbVcIixcbiAgICBcIuGEhuGFoeGGr+GEiuGFs+GGt1wiLFxuICAgIFwi4YSG4YWh4Yav4YSQ4YWuXCIsXG4gICAgXCLhhIbhhaHhhrfhhIPhhaLhhIXhhalcIixcbiAgICBcIuGEhuGFoeGGvOGEi+GFr+GGq+GEgOGFp+GGvFwiLFxuICAgIFwi4YSG4YWi4YSC4YWn4YarXCIsXG4gICAgXCLhhIbhhaLhhIPhhaHhhq9cIixcbiAgICBcIuGEhuGFouGEheGFp+GGqFwiLFxuICAgIFwi4YSG4YWi4YSH4YWl4YarXCIsXG4gICAgXCLhhIbhhaLhhInhhbPhhI/hhaXhhrdcIixcbiAgICBcIuGEhuGFouGEi+GFteGGr1wiLFxuICAgIFwi4YSG4YWi4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIbhhaLhhqjhhIzhha5cIixcbiAgICBcIuGEhuGFpeGGqOGEi+GFtVwiLFxuICAgIFwi4YSG4YWl4Yar4YSM4YWlXCIsXG4gICAgXCLhhIbhhaXhhqvhhIzhhbVcIixcbiAgICBcIuGEhuGFpeGGr+GEheGFtVwiLFxuICAgIFwi4YSG4YWm4YSL4YW14YavXCIsXG4gICAgXCLhhIbhhafhhILhhbPhhIXhhbVcIixcbiAgICBcIuGEhuGFp+GEjuGFteGGr1wiLFxuICAgIFwi4YSG4YWn4Yar4YSD4YWh4Ya3XCIsXG4gICAgXCLhhIbhhafhhq/hhI7hhbVcIixcbiAgICBcIuGEhuGFp+GGvOGEg+GFoeGGq1wiLFxuICAgIFwi4YSG4YWn4Ya84YSF4YWn4Ya8XCIsXG4gICAgXCLhhIbhhafhhrzhhIvhhahcIixcbiAgICBcIuGEhuGFp+GGvOGEi+GFtFwiLFxuICAgIFwi4YSG4YWn4Ya84YSM4YWl4YavXCIsXG4gICAgXCLhhIbhhafhhrzhhI7hhbXhhrxcIixcbiAgICBcIuGEhuGFp+GGvOGEkuGFoeGGt1wiLFxuICAgIFwi4YSG4YWp4YSA4YWz4Ya3XCIsXG4gICAgXCLhhIbhhanhhILhhbXhhJDhhaVcIixcbiAgICBcIuGEhuGFqeGEg+GFpuGGr1wiLFxuICAgIFwi4YSG4YWp4YSD4YWz4YarXCIsXG4gICAgXCLhhIbhhanhhIfhhaXhhrdcIixcbiAgICBcIuGEhuGFqeGEieGFs+GGuFwiLFxuICAgIFwi4YSG4YWp4YSL4YWj4Ya8XCIsXG4gICAgXCLhhIbhhanhhIvhhbXhhrdcIixcbiAgICBcIuGEhuGFqeGEjOGFqeGEheGFtVwiLFxuICAgIFwi4YSG4YWp4YSM4YW14Ya4XCIsXG4gICAgXCLhhIbhhanhhJDhha7hhrzhhIvhhbVcIixcbiAgICBcIuGEhuGFqeGGqOGEgOGFpeGGr+GEi+GFtVwiLFxuICAgIFwi4YSG4YWp4Yao4YSF4YWp4YaoXCIsXG4gICAgXCLhhIbhhanhhqjhhInhhaFcIixcbiAgICBcIuGEhuGFqeGGqOGEieGFqeGEheGFtVwiLFxuICAgIFwi4YSG4YWp4Yao4YSJ4YWu4Ya3XCIsXG4gICAgXCLhhIbhhanhhqjhhIzhhaXhhqhcIixcbiAgICBcIuGEhuGFqeGGqOGEkeGFrVwiLFxuICAgIFwi4YSG4YWp4Yav4YSF4YWiXCIsXG4gICAgXCLhhIbhhanhhrfhhIbhhaJcIixcbiAgICBcIuGEhuGFqeGGt+GEhuGFruGEgOGFplwiLFxuICAgIFwi4YSG4YWp4Ya34YSJ4YWh4YavXCIsXG4gICAgXCLhhIbhhanhhrfhhInhhanhhqhcIixcbiAgICBcIuGEhuGFqeGGt+GEjOGFteGGulwiLFxuICAgIFwi4YSG4YWp4Ya34YSQ4YWp4Ya8XCIsXG4gICAgXCLhhIbhhanhhrjhhInhhbVcIixcbiAgICBcIuGEhuGFruGEgOGFquGGq+GEieGFteGGt1wiLFxuICAgIFwi4YSG4YWu4YSA4YWu4Ya84YSS4YWqXCIsXG4gICAgXCLhhIbhha7hhIPhhaXhhIvhhbFcIixcbiAgICBcIuGEhuGFruGEg+GFpeGGt1wiLFxuICAgIFwi4YSG4YWu4YSF4YWz4YeBXCIsXG4gICAgXCLhhIbhha7hhInhhbPhhqtcIixcbiAgICBcIuGEhuGFruGEi+GFpeGGulwiLFxuICAgIFwi4YSG4YWu4YSL4YWn4YaoXCIsXG4gICAgXCLhhIbhha7hhIvhha3hhrxcIixcbiAgICBcIuGEhuGFruGEjOGFqeGEgOGFpeGGq1wiLFxuICAgIFwi4YSG4YWu4YSM4YW14YSA4YWiXCIsXG4gICAgXCLhhIbhha7hhI7hhaXhhqhcIixcbiAgICBcIuGEhuGFruGGq+GEgOGFrlwiLFxuICAgIFwi4YSG4YWu4Yar4YSD4YWz4YaoXCIsXG4gICAgXCLhhIbhha7hhqvhhIfhhaXhhrhcIixcbiAgICBcIuGEhuGFruGGq+GEieGFpVwiLFxuICAgIFwi4YSG4YWu4Yar4YSM4YWmXCIsXG4gICAgXCLhhIbhha7hhqvhhJLhhaHhhqhcIixcbiAgICBcIuGEhuGFruGGq+GEkuGFqlwiLFxuICAgIFwi4YSG4YWu4Yav4YSA4YWhXCIsXG4gICAgXCLhhIbhha7hhq/hhIDhhaXhhqtcIixcbiAgICBcIuGEhuGFruGGr+GEgOGFp+GGr1wiLFxuICAgIFwi4YSG4YWu4Yav4YSA4YWp4YSA4YW1XCIsXG4gICAgXCLhhIbhha7hhq/hhIXhhanhhqtcIixcbiAgICBcIuGEhuGFruGGr+GEheGFteGEkuGFoeGGqFwiLFxuICAgIFwi4YSG4YWu4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIbhha7hhq/hhIzhhbXhhq9cIixcbiAgICBcIuGEhuGFruGGr+GEjuGFplwiLFxuICAgIFwi4YSG4YW14YSA4YWu4YaoXCIsXG4gICAgXCLhhIbhhbXhhIPhhbXhhIvhhaVcIixcbiAgICBcIuGEhuGFteGEieGFoeGEi+GFteGGr1wiLFxuICAgIFwi4YSG4YW14YSJ4YWu4YavXCIsXG4gICAgXCLhhIbhhbXhhIvhhafhhqhcIixcbiAgICBcIuGEhuGFteGEi+GFreGGvOGEieGFteGGr1wiLFxuICAgIFwi4YSG4YW14YSL4YWu4Ya3XCIsXG4gICAgXCLhhIbhhbXhhIvhhbXhhqtcIixcbiAgICBcIuGEhuGFteGEkOGFteGGvFwiLFxuICAgIFwi4YSG4YW14YSS4YWp4YarXCIsXG4gICAgXCLhhIbhhbXhhqvhhIDhhaHhhqtcIixcbiAgICBcIuGEhuGFteGGq+GEjOGFqeGGqFwiLFxuICAgIFwi4YSG4YW14Yar4YSM4YWuXCIsXG4gICAgXCLhhIbhhbXhhq7hhIvhhbPhhrdcIixcbiAgICBcIuGEhuGFteGGr+GEgOGFoeGEheGFrlwiLFxuICAgIFwi4YSG4YW14Yav4YSF4YW14YSG4YW14YSQ4YWlXCIsXG4gICAgXCLhhIbhhbXhh4DhhIfhhaHhhIPhhaHhhqhcIixcbiAgICBcIuGEh+GFoeGEgOGFoeGEjOGFtVwiLFxuICAgIFwi4YSH4YWh4YSA4YWu4YSC4YW1XCIsXG4gICAgXCLhhIfhhaHhhILhhaHhhILhhaFcIixcbiAgICBcIuGEh+GFoeGEguGFs+GGr1wiLFxuICAgIFwi4YSH4YWh4YSD4YWh4YaoXCIsXG4gICAgXCLhhIfhhaHhhIPhhaHhhrrhhIDhhaFcIixcbiAgICBcIuGEh+GFoeGEheGFoeGGt1wiLFxuICAgIFwi4YSH4YWh4YSL4YW14YSF4YWl4YSJ4YWzXCIsXG4gICAgXCLhhIfhhaHhhJDhhaHhhrxcIixcbiAgICBcIuGEh+GFoeGGqOGEhuGFruGGr+GEgOGFquGGq1wiLFxuICAgIFwi4YSH4YWh4Yao4YSJ4YWhXCIsXG4gICAgXCLhhIfhhaHhhqjhhInhha5cIixcbiAgICBcIuGEh+GFoeGGq+GEg+GFolwiLFxuICAgIFwi4YSH4YWh4Yar4YSD4YWz4YSJ4YW1XCIsXG4gICAgXCLhhIfhhaHhhqvhhIbhhaHhhq9cIixcbiAgICBcIuGEh+GFoeGGq+GEh+GFoeGGr1wiLFxuICAgIFwi4YSH4YWh4Yar4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIfhhaHhhqvhhIvhhbPhhrxcIixcbiAgICBcIuGEh+GFoeGGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSH4YWh4Yar4YSM4YWu4YaoXCIsXG4gICAgXCLhhIfhhaHhhqvhhIzhhbVcIixcbiAgICBcIuGEh+GFoeGGq+GEjuGFoeGGq1wiLFxuICAgIFwi4YSH4YWh4Yau4YSO4YW14Ya3XCIsXG4gICAgXCLhhIfhhaHhhq/hhIDhhaHhhIXhhaHhhqhcIixcbiAgICBcIuGEh+GFoeGGr+GEgOGFpeGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSH4YWh4Yav4YSA4YWn4YarXCIsXG4gICAgXCLhhIfhhaHhhq/hhIPhhaHhhq9cIixcbiAgICBcIuGEh+GFoeGGr+GEheGFplwiLFxuICAgIFwi4YSH4YWh4Yav4YSG4YWp4YaoXCIsXG4gICAgXCLhhIfhhaHhhq/hhIfhhaHhhIPhhaHhhqhcIixcbiAgICBcIuGEh+GFoeGGr+GEieGFouGGvFwiLFxuICAgIFwi4YSH4YWh4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIfhhaHhhq/hhIzhhaHhhIDhha7hhqhcIixcbiAgICBcIuGEh+GFoeGGr+GEjOGFpeGGq1wiLFxuICAgIFwi4YSH4YWh4Yav4YSQ4YWp4Ya4XCIsXG4gICAgXCLhhIfhhaHhhq/hhJHhha1cIixcbiAgICBcIuGEh+GFoeGGt+GEkuGFoeGEguGFs+GGr1wiLFxuICAgIFwi4YSH4YWh4Ya44YSA4YWz4YSF4YWz4Ya6XCIsXG4gICAgXCLhhIfhhaHhhrjhhIbhhaHhhrpcIixcbiAgICBcIuGEh+GFoeGGuOGEieGFoeGGvFwiLFxuICAgIFwi4YSH4YWh4Ya44YSJ4YWp4YeAXCIsXG4gICAgXCLhhIfhhaHhhrzhhIDhhbPhhrdcIixcbiAgICBcIuGEh+GFoeGGvOGEhuGFp+GGq1wiLFxuICAgIFwi4YSH4YWh4Ya84YSG4YWu4YarXCIsXG4gICAgXCLhhIfhhaHhhrzhhIfhhaHhhIPhhaHhhqhcIixcbiAgICBcIuGEh+GFoeGGvOGEh+GFpeGGuFwiLFxuICAgIFwi4YSH4YWh4Ya84YSJ4YWp4Ya8XCIsXG4gICAgXCLhhIfhhaHhhrzhhInhhbXhhqhcIixcbiAgICBcIuGEh+GFoeGGvOGEi+GFoeGGq1wiLFxuICAgIFwi4YSH4YWh4Ya84YSL4YWu4YavXCIsXG4gICAgXCLhhIfhhaHhhrzhhIzhhbVcIixcbiAgICBcIuGEh+GFoeGGvOGEkuGFoeGGqFwiLFxuICAgIFwi4YSH4YWh4Ya84YSS4YWiXCIsXG4gICAgXCLhhIfhhaHhhrzhhJLhhaPhhrxcIixcbiAgICBcIuGEh+GFouGEgOGFp+GGvFwiLFxuICAgIFwi4YSH4YWi4YSB4YWp4Ya4XCIsXG4gICAgXCLhhIfhhaLhhIPhhaHhhq9cIixcbiAgICBcIuGEh+GFouGEg+GFs+GEhuGFteGGq+GEkOGFpeGGq1wiLFxuICAgIFwi4YSH4YWi4Yao4YSD4YWu4YSJ4YWh4YarXCIsXG4gICAgXCLhhIfhhaLhhqjhhInhhaLhhqhcIixcbiAgICBcIuGEh+GFouGGqOGEieGFpeGGvFwiLFxuICAgIFwi4YSH4YWi4Yao4YSL4YW14YarXCIsXG4gICAgXCLhhIfhhaLhhqjhhIzhhaZcIixcbiAgICBcIuGEh+GFouGGqOGEkuGFquGEjOGFpeGGt1wiLFxuICAgIFwi4YSH4YWl4YSF4YWz4Ya6XCIsXG4gICAgXCLhhIfhhaXhhInhhaXhhrpcIixcbiAgICBcIuGEh+GFpeGEkOGFs+GGq1wiLFxuICAgIFwi4YSH4YWl4Yar4YSA4YWiXCIsXG4gICAgXCLhhIfhhaXhhqvhhIvhhafhhqhcIixcbiAgICBcIuGEh+GFpeGGq+GEjOGFtVwiLFxuICAgIFwi4YSH4YWl4Yar4YSS4YWpXCIsXG4gICAgXCLhhIfhhaXhhq/hhIDhhbPhhrdcIixcbiAgICBcIuGEh+GFpeGGr+GEheGFplwiLFxuICAgIFwi4YSH4YWl4Yav4YSK4YWlXCIsXG4gICAgXCLhhIfhhaXhhrfhhIvhhbFcIixcbiAgICBcIuGEh+GFpeGGt+GEi+GFteGGq1wiLFxuICAgIFwi4YSH4YWl4Ya34YSM4YWsXCIsXG4gICAgXCLhhIfhhaXhhrjhhIXhhbLhhq9cIixcbiAgICBcIuGEh+GFpeGGuOGEi+GFr+GGq1wiLFxuICAgIFwi4YSH4YWl4Ya44YSM4YWl4YaoXCIsXG4gICAgXCLhhIfhhaXhhrjhhI7hhbXhhqhcIixcbiAgICBcIuGEh+GFpuGEi+GFteGEjOGFteGGvFwiLFxuICAgIFwi4YSH4YWm4Yav4YSQ4YWzXCIsXG4gICAgXCLhhIfhhafhhqvhhIDhhafhhrxcIixcbiAgICBcIuGEh+GFp+GGq+GEg+GFqeGGvFwiLFxuICAgIFwi4YSH4YWn4Yar4YSG4YWn4Ya8XCIsXG4gICAgXCLhhIfhhafhhqvhhInhhbXhhqtcIixcbiAgICBcIuGEh+GFp+GGq+GEkuGFqeGEieGFoVwiLFxuICAgIFwi4YSH4YWn4Yar4YSS4YWqXCIsXG4gICAgXCLhhIfhhafhhq/hhIPhhalcIixcbiAgICBcIuGEh+GFp+GGr+GEhuGFp+GGvFwiLFxuICAgIFwi4YSH4YWn4Yav4YSL4YW14YavXCIsXG4gICAgXCLhhIfhhafhhrzhhInhhbXhhq9cIixcbiAgICBcIuGEh+GFp+GGvOGEi+GFoeGEheGFtVwiLFxuICAgIFwi4YSH4YWn4Ya84YSL4YWv4YarXCIsXG4gICAgXCLhhIfhhanhhIDhharhhqtcIixcbiAgICBcIuGEh+GFqeGEguGFpeGEieGFs1wiLFxuICAgIFwi4YSH4YWp4YSF4YWh4YSJ4YWi4YaoXCIsXG4gICAgXCLhhIfhhanhhIXhhaHhhrdcIixcbiAgICBcIuGEh+GFqeGEheGFs+GGt1wiLFxuICAgIFwi4YSH4YWp4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIfhhanhhIvhhaHhhqtcIixcbiAgICBcIuGEh+GFqeGEjOGFoeGEgOGFtVwiLFxuICAgIFwi4YSH4YWp4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIfhhanhhIzhhaXhhqtcIixcbiAgICBcIuGEh+GFqeGEjOGFqeGGq1wiLFxuICAgIFwi4YSH4YWp4YSQ4YWp4Ya8XCIsXG4gICAgXCLhhIfhhanhhJHhhafhhqvhhIzhhaXhhqhcIixcbiAgICBcIuGEh+GFqeGEkuGFpeGGt1wiLFxuICAgIFwi4YSH4YWp4Yao4YSD4YWpXCIsXG4gICAgXCLhhIfhhanhhqjhhInhhaFcIixcbiAgICBcIuGEh+GFqeGGqOGEieGFruGGvOGEi+GFoVwiLFxuICAgIFwi4YSH4YWp4Yao4YSJ4YWz4Ya4XCIsXG4gICAgXCLhhIfhhanhhqnhhIvhhbPhhrdcIixcbiAgICBcIuGEh+GFqeGGq+GEgOGFp+GGqOGEjOGFpeGGqFwiLFxuICAgIFwi4YSH4YWp4Yar4YSF4YWiXCIsXG4gICAgXCLhhIfhhanhhqvhhIfhha5cIixcbiAgICBcIuGEh+GFqeGGq+GEieGFoVwiLFxuICAgIFwi4YSH4YWp4Yar4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIfhhanhhqvhhIvhhbXhhqtcIixcbiAgICBcIuGEh+GFqeGGq+GEjOGFteGGr1wiLFxuICAgIFwi4YSH4YWp4Yav4YSR4YWm4YarXCIsXG4gICAgXCLhhIfhhanhhrzhhInhhaFcIixcbiAgICBcIuGEh+GFqeGGvOGEjOGFtVwiLFxuICAgIFwi4YSH4YWp4Ya84YSQ4YWuXCIsXG4gICAgXCLhhIfhha7hhIDhhbPhhqtcIixcbiAgICBcIuGEh+GFruGEgeGFs+GEheGFpeGEi+GFruGGt1wiLFxuICAgIFwi4YSH4YWu4YSD4YWh4Ya3XCIsXG4gICAgXCLhhIfhha7hhIPhhanhhrzhhInhhaHhhqtcIixcbiAgICBcIuGEh+GFruGEhuGFruGGq1wiLFxuICAgIFwi4YSH4YWu4YSH4YWu4YarXCIsXG4gICAgXCLhhIfhha7hhInhhaHhhqtcIixcbiAgICBcIuGEh+GFruGEieGFoeGGvFwiLFxuICAgIFwi4YSH4YWu4YSL4YWl4Ya/XCIsXG4gICAgXCLhhIfhha7hhIvhhbXhhqtcIixcbiAgICBcIuGEh+GFruGEjOGFoeGGqOGEi+GFreGGvFwiLFxuICAgIFwi4YSH4YWu4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIfhha7hhIzhhaXhhrxcIixcbiAgICBcIuGEh+GFruGEjOGFqeGGqFwiLFxuICAgIFwi4YSH4YWu4YSM4YW14YSF4YWl4Yar4YSS4YW1XCIsXG4gICAgXCLhhIfhha7hhI7hhbXhhqtcIixcbiAgICBcIuGEh+GFruGEkOGFoeGGqFwiLFxuICAgIFwi4YSH4YWu4YSR4YWu4Ya3XCIsXG4gICAgXCLhhIfhha7hhJLhhazhhIzhhaHhhrxcIixcbiAgICBcIuGEh+GFruGGqOGEh+GFrlwiLFxuICAgIFwi4YSH4YWu4Yao4YSS4YWh4YarXCIsXG4gICAgXCLhhIfhha7hhqvhhILhhalcIixcbiAgICBcIuGEh+GFruGGq+GEheGFo+GGvFwiLFxuICAgIFwi4YSH4YWu4Yar4YSF4YW1XCIsXG4gICAgXCLhhIfhha7hhqvhhIbhhafhhrxcIixcbiAgICBcIuGEh+GFruGGq+GEieGFpeGGqFwiLFxuICAgIFwi4YSH4YWu4Yar4YSL4YWjXCIsXG4gICAgXCLhhIfhha7hhqvhhIvhhbHhhIDhhbVcIixcbiAgICBcIuGEh+GFruGGq+GEkeGFteGGr1wiLFxuICAgIFwi4YSH4YWu4Yar4YSS4YWp4Ya84YSJ4YWi4YaoXCIsXG4gICAgXCLhhIfhha7hhq/hhIDhhanhhIDhhbVcIixcbiAgICBcIuGEh+GFruGGr+GEgOGFqlwiLFxuICAgIFwi4YSH4YWu4Yav4YSA4YWtXCIsXG4gICAgXCLhhIfhha7hhq/hhIHhhanhhr5cIixcbiAgICBcIuGEh+GFruGGr+GEhuGFoeGGq1wiLFxuICAgIFwi4YSH4YWu4Yav4YSH4YWl4Ya4XCIsXG4gICAgXCLhhIfhha7hhq/hhIfhhbXhhr5cIixcbiAgICBcIuGEh+GFruGGr+GEi+GFoeGGq1wiLFxuICAgIFwi4YSH4YWu4Yav4YSL4YW14YSL4YW14YaoXCIsXG4gICAgXCLhhIfhha7hhq/hhJLhhaLhhrxcIixcbiAgICBcIuGEh+GFs+GEheGFouGGq+GEg+GFs1wiLFxuICAgIFwi4YSH4YW14YSA4YWz4YaoXCIsXG4gICAgXCLhhIfhhbXhhILhhaHhhqtcIixcbiAgICBcIuGEh+GFteGEguGFteGGr1wiLFxuICAgIFwi4YSH4YW14YSD4YWu4Yav4YSA4YW1XCIsXG4gICAgXCLhhIfhhbXhhIPhhbXhhIvhhalcIixcbiAgICBcIuGEh+GFteGEheGFqeGEieGFqVwiLFxuICAgIFwi4YSH4YW14YSG4YWh4YarXCIsXG4gICAgXCLhhIfhhbXhhIbhhafhhrxcIixcbiAgICBcIuGEh+GFteGEhuGFteGGr1wiLFxuICAgIFwi4YSH4YW14YSH4YWh4YSF4YWh4Ya3XCIsXG4gICAgXCLhhIfhhbXhhIfhhbXhhrfhhIfhhaHhhrhcIixcbiAgICBcIuGEh+GFteGEieGFoeGGvFwiLFxuICAgIFwi4YSH4YW14YSL4YWt4Ya8XCIsXG4gICAgXCLhhIfhhbXhhIvhhbLhhq9cIixcbiAgICBcIuGEh+GFteGEjOGFruGGvFwiLFxuICAgIFwi4YSH4YW14YSQ4YWh4YSG4YW14YarXCIsXG4gICAgXCLhhIfhhbXhhJHhhaHhhqtcIixcbiAgICBcIuGEh+GFteGGr+GEg+GFteGGvFwiLFxuICAgIFwi4YSH4YW14Ya64YSG4YWu4YavXCIsXG4gICAgXCLhhIfhhbXhhrrhhIfhhaHhhrzhhIvhha7hhq9cIixcbiAgICBcIuGEh+GFteGGuuGEjOGFruGGr+GEgOGFtVwiLFxuICAgIFwi4YSH4YW14Ya+4YSB4YWh4YavXCIsXG4gICAgXCLhhIjhhaHhhq/hhIDhhaHhhqvhhInhhaLhhqhcIixcbiAgICBcIuGEiOGFoeGGr+GEheGFolwiLFxuICAgIFwi4YSI4YWh4Yav4YSF4YW1XCIsXG4gICAgXCLhhInhhaHhhIDhhaXhhqtcIixcbiAgICBcIuGEieGFoeGEgOGFqOGEjOGFpeGGr1wiLFxuICAgIFwi4YSJ4YWh4YSC4YWh4YSL4YW1XCIsXG4gICAgXCLhhInhhaHhhILhhaPhhrxcIixcbiAgICBcIuGEieGFoeGEheGFoeGGt1wiLFxuICAgIFwi4YSJ4YWh4YSF4YWh4Ya8XCIsXG4gICAgXCLhhInhhaHhhIXhhbXhhrhcIixcbiAgICBcIuGEieGFoeGEhuGFqeGEguGFteGGt1wiLFxuICAgIFwi4YSJ4YWh4YSG4YWu4YavXCIsXG4gICAgXCLhhInhhaHhhIfhhaHhhrxcIixcbiAgICBcIuGEieGFoeGEieGFoeGGvFwiLFxuICAgIFwi4YSJ4YWh4YSJ4YWi4Ya84YSS4YWq4YavXCIsXG4gICAgXCLhhInhhaHhhInhhaXhhq9cIixcbiAgICBcIuGEieGFoeGEieGFs+GGt1wiLFxuICAgIFwi4YSJ4YWh4YSJ4YW14YavXCIsXG4gICAgXCLhhInhhaHhhIvhhaXhhrhcIixcbiAgICBcIuGEieGFoeGEi+GFreGGvFwiLFxuICAgIFwi4YSJ4YWh4YSL4YWv4YavXCIsXG4gICAgXCLhhInhhaHhhIzhhaHhhrxcIixcbiAgICBcIuGEieGFoeGEjOGFpeGGq1wiLFxuICAgIFwi4YSJ4YWh4YSM4YW14YarXCIsXG4gICAgXCLhhInhhaHhhI7hhanhhqtcIixcbiAgICBcIuGEieGFoeGEjuGFruGGq+GEgOGFtVwiLFxuICAgIFwi4YSJ4YWh4YSQ4YWh4Ya8XCIsXG4gICAgXCLhhInhhaHhhJDhha7hhIXhhbVcIixcbiAgICBcIuGEieGFoeGEkuGFs+GGr1wiLFxuICAgIFwi4YSJ4YWh4Yar4YSA4YW14YavXCIsXG4gICAgXCLhhInhhaHhhqvhhIfhha7hhIvhhbXhhqvhhIDhhapcIixcbiAgICBcIuGEieGFoeGGq+GEi+GFpeGGuFwiLFxuICAgIFwi4YSJ4YWh4Yar4YSO4YWi4YaoXCIsXG4gICAgXCLhhInhhaHhhq/hhIXhhbXhhrdcIixcbiAgICBcIuGEieGFoeGGr+GEi+GFteGGq1wiLFxuICAgIFwi4YSJ4YWh4Yav4YSN4YWh4YaoXCIsXG4gICAgXCLhhInhhaHhhrfhhIDhhajhhJDhhaHhhrxcIixcbiAgICBcIuGEieGFoeGGt+GEgOGFruGGqFwiLFxuICAgIFwi4YSJ4YWh4Ya34YSJ4YW14Ya4XCIsXG4gICAgXCLhhInhhaHhhrfhhIvhha/hhq9cIixcbiAgICBcIuGEieGFoeGGt+GEjuGFqeGGq1wiLFxuICAgIFwi4YSJ4YWh4Ya84YSA4YWq4YarXCIsXG4gICAgXCLhhInhhaHhhrzhhIDhhbPhhrdcIixcbiAgICBcIuGEieGFoeGGvOGEg+GFolwiLFxuICAgIFwi4YSJ4YWh4Ya84YSF4YWyXCIsXG4gICAgXCLhhInhhaHhhrzhhIfhhaHhhqvhhIDhhbVcIixcbiAgICBcIuGEieGFoeGGvOGEieGFoeGGvFwiLFxuICAgIFwi4YSJ4YWh4Ya84YSJ4YW14YaoXCIsXG4gICAgXCLhhInhhaHhhrzhhIvhhaXhhrhcIixcbiAgICBcIuGEieGFoeGGvOGEi+GFteGGq1wiLFxuICAgIFwi4YSJ4YWh4Ya84YSM4YWhXCIsXG4gICAgXCLhhInhhaHhhrzhhIzhhaXhhrdcIixcbiAgICBcIuGEieGFoeGGvOGEjuGFpVwiLFxuICAgIFwi4YSJ4YWh4Ya84YSO4YWuXCIsXG4gICAgXCLhhInhhaHhhrzhhJDhhaJcIixcbiAgICBcIuGEieGFoeGGvOGEkeGFrVwiLFxuICAgIFwi4YSJ4YWh4Ya84YSR4YWu4Ya3XCIsXG4gICAgXCLhhInhhaHhhrzhhJLhharhhrxcIixcbiAgICBcIuGEieGFouGEh+GFp+GGqFwiLFxuICAgIFwi4YSJ4YWi4Yao4YSB4YWh4YavXCIsXG4gICAgXCLhhInhhaLhhqjhhIvhhafhhqvhhJHhhbXhhq9cIixcbiAgICBcIuGEieGFouGGvOGEgOGFoeGGqFwiLFxuICAgIFwi4YSJ4YWi4Ya84YSG4YWn4Ya8XCIsXG4gICAgXCLhhInhhaLhhrzhhIbhha7hhq9cIixcbiAgICBcIuGEieGFouGGvOGEh+GFoeGGvOGEieGFqeGGvFwiLFxuICAgIFwi4YSJ4YWi4Ya84YSJ4YWh4YarXCIsXG4gICAgXCLhhInhhaLhhrzhhInhhaXhhqtcIixcbiAgICBcIuGEieGFouGGvOGEieGFteGGq1wiLFxuICAgIFwi4YSJ4YWi4Ya84YSL4YW14YavXCIsXG4gICAgXCLhhInhhaLhhrzhhJLhharhhq9cIixcbiAgICBcIuGEieGFpeGEheGFoeGGuFwiLFxuICAgIFwi4YSJ4YWl4YSF4YWz4YarXCIsXG4gICAgXCLhhInhhaXhhIbhhafhhrxcIixcbiAgICBcIuGEieGFpeGEhuGFteGGq1wiLFxuICAgIFwi4YSJ4YWl4YSH4YW14YSJ4YWzXCIsXG4gICAgXCLhhInhhaXhhIvhhaPhhrxcIixcbiAgICBcIuGEieGFpeGEi+GFruGGr1wiLFxuICAgIFwi4YSJ4YWl4YSM4YWl4YaoXCIsXG4gICAgXCLhhInhhaXhhIzhhaXhhrdcIixcbiAgICBcIuGEieGFpeGEjeGFqeGGqFwiLFxuICAgIFwi4YSJ4YWl4YSP4YWz4YavXCIsXG4gICAgXCLhhInhhaXhhqjhhInhhaFcIixcbiAgICBcIuGEieGFpeGGqOGEi+GFslwiLFxuICAgIFwi4YSJ4YWl4Yar4YSA4YWlXCIsXG4gICAgXCLhhInhhaXhhqvhhIbhha7hhq9cIixcbiAgICBcIuGEieGFpeGGq+GEh+GFolwiLFxuICAgIFwi4YSJ4YWl4Yar4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhInhhaXhhqvhhInhha5cIixcbiAgICBcIuGEieGFpeGGq+GEi+GFr+GGq1wiLFxuICAgIFwi4YSJ4YWl4Yar4YSM4YWh4Ya8XCIsXG4gICAgXCLhhInhhaXhhqvhhIzhhaXhhqtcIixcbiAgICBcIuGEieGFpeGGq+GEkOGFouGGqFwiLFxuICAgIFwi4YSJ4YWl4Yar4YSR4YWu4Ya84YSA4YW1XCIsXG4gICAgXCLhhInhhaXhhq/hhIDhhaXhhIzhhbVcIixcbiAgICBcIuGEieGFpeGGr+GEguGFoeGGr1wiLFxuICAgIFwi4YSJ4YWl4Yav4YSF4YWl4Ya84YSQ4YWh4Ya8XCIsXG4gICAgXCLhhInhhaXhhq/hhIbhhafhhrxcIixcbiAgICBcIuGEieGFpeGGr+GEhuGFruGGq1wiLFxuICAgIFwi4YSJ4YWl4Yav4YSJ4YWhXCIsXG4gICAgXCLhhInhhaXhhq/hhIvhhaHhhqjhhInhhaHhhqtcIixcbiAgICBcIuGEieGFpeGGr+GEjuGFtVwiLFxuICAgIFwi4YSJ4YWl4Yav4YSQ4YWh4Ya8XCIsXG4gICAgXCLhhInhhaXhhrjhhIrhhbVcIixcbiAgICBcIuGEieGFpeGGvOGEgOGFqeGGvFwiLFxuICAgIFwi4YSJ4YWl4Ya84YSD4YWh4Ya8XCIsXG4gICAgXCLhhInhhaXhhrzhhIbhhafhhrxcIixcbiAgICBcIuGEieGFpeGGvOGEh+GFp+GGr1wiLFxuICAgIFwi4YSJ4YWl4Ya84YSL4YW14YarXCIsXG4gICAgXCLhhInhhaXhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEieGFpeGGvOGEjOGFpeGGqFwiLFxuICAgIFwi4YSJ4YWl4Ya84YSM4YW14YavXCIsXG4gICAgXCLhhInhhaXhhrzhhJLhhaHhhrdcIixcbiAgICBcIuGEieGFpuGEgOGFs+GGt1wiLFxuICAgIFwi4YSJ4YWm4YSG4YW14YSC4YWhXCIsXG4gICAgXCLhhInhhabhhInhhaHhhrxcIixcbiAgICBcIuGEieGFpuGEi+GFr+GGr1wiLFxuICAgIFwi4YSJ4YWm4YSM4YWp4Ya84YSD4YWi4YSL4YWq4Ya8XCIsXG4gICAgXCLhhInhhabhhJDhhaHhhqhcIixcbiAgICBcIuGEieGFpuGGq+GEkOGFpVwiLFxuICAgIFwi4YSJ4YWm4Yar4YSQ4YW14YSG4YW14YSQ4YWlXCIsXG4gICAgXCLhhInhhabhhrrhhI3hhaJcIixcbiAgICBcIuGEieGFqeGEgOGFsuGEhuGFqVwiLFxuICAgIFwi4YSJ4YWp4YSA4YWz4Yao4YSM4YWl4YaoXCIsXG4gICAgXCLhhInhhanhhIDhhbPhhrdcIixcbiAgICBcIuGEieGFqeGEguGFoeGEgOGFtVwiLFxuICAgIFwi4YSJ4YWp4YSC4YWn4YarXCIsXG4gICAgXCLhhInhhanhhIPhhbPhhqhcIixcbiAgICBcIuGEieGFqeGEhuGFoeGGvFwiLFxuICAgIFwi4YSJ4YWp4YSG4YWu4YarXCIsXG4gICAgXCLhhInhhanhhInhhaXhhq9cIixcbiAgICBcIuGEieGFqeGEieGFqeGGqFwiLFxuICAgIFwi4YSJ4YWp4YSL4YWh4YSA4YWqXCIsXG4gICAgXCLhhInhhanhhIvhha3hhrxcIixcbiAgICBcIuGEieGFqeGEi+GFr+GGq1wiLFxuICAgIFwi4YSJ4YWp4YSL4YWz4Ya3XCIsXG4gICAgXCLhhInhhanhhIzhha7hhrzhhJLhhbVcIixcbiAgICBcIuGEieGFqeGEjOGFteGEkeGFruGGt1wiLFxuICAgIFwi4YSJ4YWp4YSM4YW14YavXCIsXG4gICAgXCLhhInhhanhhJHhha7hhrxcIixcbiAgICBcIuGEieGFqeGEkuGFp+GGvFwiLFxuICAgIFwi4YSJ4YWp4Yao4YSD4YWh4Ya3XCIsXG4gICAgXCLhhInhhanhhqjhhIPhhalcIixcbiAgICBcIuGEieGFqeGGqOGEi+GFqeGGulwiLFxuICAgIFwi4YSJ4YWp4Yar4YSA4YWh4YSF4YWh4YaoXCIsXG4gICAgXCLhhInhhanhhqvhhIDhhbXhhq9cIixcbiAgICBcIuGEieGFqeGGq+GEguGFp1wiLFxuICAgIFwi4YSJ4YWp4Yar4YSC4YW14Ya3XCIsXG4gICAgXCLhhInhhanhhqvhhIPhhbPhhrxcIixcbiAgICBcIuGEieGFqeGGq+GEhuGFqeGGqFwiLFxuICAgIFwi4YSJ4YWp4Yar4YSI4YWn4YaoXCIsXG4gICAgXCLhhInhhanhhqvhhInhhbXhhq9cIixcbiAgICBcIuGEieGFqeGGq+GEjOGFteGGr1wiLFxuICAgIFwi4YSJ4YWp4Yar4YSQ4YWp4Ya4XCIsXG4gICAgXCLhhInhhanhhqvhhJLhhaJcIixcbiAgICBcIuGEieGFqeGGr+GEjOGFteGGqOGEkuGFtVwiLFxuICAgIFwi4YSJ4YWp4Ya34YSK4YW1XCIsXG4gICAgXCLhhInhhanhhrzhhIvhhaHhhIzhhbVcIixcbiAgICBcIuGEieGFqeGGvOGEi+GFtVwiLFxuICAgIFwi4YSJ4YWp4Ya84YSR4YWn4YarXCIsXG4gICAgXCLhhInhhazhhIDhhanhhIDhhbVcIixcbiAgICBcIuGEieGFreGEkeGFteGGvFwiLFxuICAgIFwi4YSJ4YWu4YSA4YWl4YarXCIsXG4gICAgXCLhhInhha7hhILhhafhhqtcIixcbiAgICBcIuGEieGFruGEg+GFoeGGq1wiLFxuICAgIFwi4YSJ4YWu4YSD4YWp4Ya64YSG4YWu4YavXCIsXG4gICAgXCLhhInhha7hhIPhhanhhrzhhIzhhaXhhqhcIixcbiAgICBcIuGEieGFruGEhuGFp+GGq1wiLFxuICAgIFwi4YSJ4YWu4YSG4YWn4Ya8XCIsXG4gICAgXCLhhInhha7hhIfhhaHhhqhcIixcbiAgICBcIuGEieGFruGEieGFoeGGvFwiLFxuICAgIFwi4YSJ4YWu4YSJ4YWl4YaoXCIsXG4gICAgXCLhhInhha7hhInhha7hhq9cIixcbiAgICBcIuGEieGFruGEieGFteGEheGFqVwiLFxuICAgIFwi4YSJ4YWu4YSL4YWl4Ya4XCIsXG4gICAgXCLhhInhha7hhIvhhafhhrdcIixcbiAgICBcIuGEieGFruGEi+GFp+GGvFwiLFxuICAgIFwi4YSJ4YWu4YSL4YW14Ya4XCIsXG4gICAgXCLhhInhha7hhIzhha7hhqtcIixcbiAgICBcIuGEieGFruGEjOGFteGGuFwiLFxuICAgIFwi4YSJ4YWu4YSO4YWu4YavXCIsXG4gICAgXCLhhInhha7hhI/hhaXhhrpcIixcbiAgICBcIuGEieGFruGEkeGFteGGr1wiLFxuICAgIFwi4YSJ4YWu4YSS4YWh4YaoXCIsXG4gICAgXCLhhInhha7hhJLhhaXhhrfhhInhhaLhhrxcIixcbiAgICBcIuGEieGFruGEkuGFquGEgOGFtVwiLFxuICAgIFwi4YSJ4YWu4Yao4YSC4YWnXCIsXG4gICAgXCLhhInhha7hhqjhhInhhalcIixcbiAgICBcIuGEieGFruGGqOGEjOGFplwiLFxuICAgIFwi4YSJ4YWu4Yar4YSA4YWh4YarXCIsXG4gICAgXCLhhInhha7hhqvhhInhhaVcIixcbiAgICBcIuGEieGFruGGq+GEieGFrlwiLFxuICAgIFwi4YSJ4YWu4Yar4YSJ4YW14Yao4YSA4YWh4YarXCIsXG4gICAgXCLhhInhha7hhqvhhIvhhbFcIixcbiAgICBcIuGEieGFruGGruGEgOGFoeGEheGFoeGGqFwiLFxuICAgIFwi4YSJ4YWu4Yav4YSH4YWn4Ya8XCIsXG4gICAgXCLhhInhha7hhq/hhIzhhbXhhrhcIixcbiAgICBcIuGEieGFruGGuuGEjOGFoVwiLFxuICAgIFwi4YSJ4YWz4YSC4YW14Ya3XCIsXG4gICAgXCLhhInhhbPhhIbhha7hhq9cIixcbiAgICBcIuGEieGFs+GEieGFs+GEheGFqVwiLFxuICAgIFwi4YSJ4YWz4YSJ4YWz4Ya8XCIsXG4gICAgXCLhhInhhbPhhIvhhbDhhJDhhaVcIixcbiAgICBcIuGEieGFs+GEi+GFseGEjuGFtVwiLFxuICAgIFwi4YSJ4YWz4YSP4YWm4YSL4YW14YSQ4YWzXCIsXG4gICAgXCLhhInhhbPhhJDhhbLhhIPhhbXhhIvhhalcIixcbiAgICBcIuGEieGFs+GEkOGFs+GEheGFpuGEieGFs1wiLFxuICAgIFwi4YSJ4YWz4YSR4YWp4YSO4YWzXCIsXG4gICAgXCLhhInhhbPhhq/hhI3hhaXhhqhcIixcbiAgICBcIuGEieGFs+GGr+GEkeGFs+GGt1wiLFxuICAgIFwi4YSJ4YWz4Ya44YSA4YWq4YarXCIsXG4gICAgXCLhhInhhbPhhrjhhIDhhbVcIixcbiAgICBcIuGEieGFs+GGvOGEgOGFouGGqFwiLFxuICAgIFwi4YSJ4YWz4Ya84YSF4YW1XCIsXG4gICAgXCLhhInhhbPhhrzhhIfhha5cIixcbiAgICBcIuGEieGFs+GGvOGEi+GFreGGvOGEjuGFoVwiLFxuICAgIFwi4YSJ4YWz4Ya84YSM4YW14YarXCIsXG4gICAgXCLhhInhhbXhhIDhhaHhhqhcIixcbiAgICBcIuGEieGFteGEgOGFoeGGq1wiLFxuICAgIFwi4YSJ4YW14YSA4YWp4YavXCIsXG4gICAgXCLhhInhhbXhhIDhhbPhhrfhhI7hhbVcIixcbiAgICBcIuGEieGFteGEguGFoeGEheGFteGEi+GFqVwiLFxuICAgIFwi4YSJ4YW14YSD4YWi4YaoXCIsXG4gICAgXCLhhInhhbXhhIXhhbXhhIzhhbNcIixcbiAgICBcIuGEieGFteGEhuGFpuGGq+GEkOGFs1wiLFxuICAgIFwi4YSJ4YW14YSG4YW14YarXCIsXG4gICAgXCLhhInhhbXhhIfhha7hhIbhhalcIixcbiAgICBcIuGEieGFteGEieGFpeGGq1wiLFxuICAgIFwi4YSJ4YW14YSJ4YWl4YavXCIsXG4gICAgXCLhhInhhbXhhInhhbPhhJDhhabhhrdcIixcbiAgICBcIuGEieGFteGEi+GFoeGEh+GFpeGEjOGFtVwiLFxuICAgIFwi4YSJ4YW14YSL4YWl4YSG4YWl4YSC4YW1XCIsXG4gICAgXCLhhInhhbXhhIvhha/hhq9cIixcbiAgICBcIuGEieGFteGEi+GFteGGq1wiLFxuICAgIFwi4YSJ4YW14YSL4YW14YavXCIsXG4gICAgXCLhhInhhbXhhIzhhaHhhqhcIixcbiAgICBcIuGEieGFteGEjOGFoeGGvFwiLFxuICAgIFwi4YSJ4YW14YSM4YWl4YavXCIsXG4gICAgXCLhhInhhbXhhIzhhaXhhrdcIixcbiAgICBcIuGEieGFteGEjOGFruGGvFwiLFxuICAgIFwi4YSJ4YW14YSM4YWz4YarXCIsXG4gICAgXCLhhInhhbXhhIzhhbXhhrhcIixcbiAgICBcIuGEieGFteGEjuGFpeGGvFwiLFxuICAgIFwi4YSJ4YW14YSS4YWh4Ya4XCIsXG4gICAgXCLhhInhhbXhhJLhhaXhhrdcIixcbiAgICBcIuGEieGFteGGqOGEgOGFrlwiLFxuICAgIFwi4YSJ4YW14Yao4YSA4YW1XCIsXG4gICAgXCLhhInhhbXhhqjhhIPhhaHhhrxcIixcbiAgICBcIuGEieGFteGGqOGEheGFo+GGvFwiLFxuICAgIFwi4YSJ4YW14Yao4YSF4YWt4YSR4YWu4Ya3XCIsXG4gICAgXCLhhInhhbXhhqjhhIbhha7hhq9cIixcbiAgICBcIuGEieGFteGGqOGEiOGFoeGGvFwiLFxuICAgIFwi4YSJ4YW14Yao4YSJ4YWhXCIsXG4gICAgXCLhhInhhbXhhqjhhInhhaLhhrzhhJLhharhhq9cIixcbiAgICBcIuGEieGFteGGqOGEjuGFqVwiLFxuICAgIFwi4YSJ4YW14Yao4YSQ4YWh4YaoXCIsXG4gICAgXCLhhInhhbXhhqjhhJHhha7hhrdcIixcbiAgICBcIuGEieGFteGGq+GEgOGFqVwiLFxuICAgIFwi4YSJ4YW14Yar4YSA4YWyXCIsXG4gICAgXCLhhInhhbXhhqvhhILhhafhhrdcIixcbiAgICBcIuGEieGFteGGq+GEhuGFruGGq1wiLFxuICAgIFwi4YSJ4YW14Yar4YSH4YWh4YavXCIsXG4gICAgXCLhhInhhbXhhqvhhIfhhbVcIixcbiAgICBcIuGEieGFteGGq+GEieGFoVwiLFxuICAgIFwi4YSJ4YW14Yar4YSJ4YWmXCIsXG4gICAgXCLhhInhhbXhhqvhhIvhha3hhrxcIixcbiAgICBcIuGEieGFteGGq+GEjOGFpuGEkeGFruGGt1wiLFxuICAgIFwi4YSJ4YW14Yar4YSO4YWl4Ya8XCIsXG4gICAgXCLhhInhhbXhhqvhhI7hhaZcIixcbiAgICBcIuGEieGFteGGq+GEkuGFqlwiLFxuICAgIFwi4YSJ4YW14Yav4YSA4YWh4Ya3XCIsXG4gICAgXCLhhInhhbXhhq/hhILhhaJcIixcbiAgICBcIuGEieGFteGGr+GEheGFp+GGqFwiLFxuICAgIFwi4YSJ4YW14Yav4YSF4YWoXCIsXG4gICAgXCLhhInhhbXhhq/hhIbhhaHhhrxcIixcbiAgICBcIuGEieGFteGGr+GEieGFrlwiLFxuICAgIFwi4YSJ4YW14Yav4YSJ4YWz4Ya4XCIsXG4gICAgXCLhhInhhbXhhq/hhInhhbVcIixcbiAgICBcIuGEieGFteGGr+GEjOGFoeGGvFwiLFxuICAgIFwi4YSJ4YW14Yav4YSM4YWl4Ya8XCIsXG4gICAgXCLhhInhhbXhhq/hhIzhhbXhhq/hhIzhhaXhhqhcIixcbiAgICBcIuGEieGFteGGr+GEjuGFpeGGq1wiLFxuICAgIFwi4YSJ4YW14Yav4YSO4YWmXCIsXG4gICAgXCLhhInhhbXhhq/hhI/hhaXhhrpcIixcbiAgICBcIuGEieGFteGGr+GEkOGFolwiLFxuICAgIFwi4YSJ4YW14Yav4YSR4YWiXCIsXG4gICAgXCLhhInhhbXhhq/hhJLhhaXhhrdcIixcbiAgICBcIuGEieGFteGGr+GEkuGFp+GGq1wiLFxuICAgIFwi4YSJ4YW14Ya34YSF4YW1XCIsXG4gICAgXCLhhInhhbXhhrfhhIfhha7hhIXhhbPhhrdcIixcbiAgICBcIuGEieGFteGGt+GEieGFoVwiLFxuICAgIFwi4YSJ4YW14Ya34YSM4YWh4Ya8XCIsXG4gICAgXCLhhInhhbXhhrfhhIzhhaXhhrxcIixcbiAgICBcIuGEieGFteGGt+GEkeGFoeGGq1wiLFxuICAgIFwi4YSK4YWh4Ya84YSD4YWu4Ya84YSL4YW1XCIsXG4gICAgXCLhhIrhhbXhhIXhhbPhhrdcIixcbiAgICBcIuGEiuGFteGEi+GFoeGGulwiLFxuICAgIFwi4YSL4YWh4YSA4YWh4YSK4YW1XCIsXG4gICAgXCLhhIvhhaHhhILhhaHhhIvhha7hhqvhhInhhaVcIixcbiAgICBcIuGEi+GFoeGEg+GFs+GEguGFteGGt1wiLFxuICAgIFwi4YSL4YWh4YSD4YWz4YavXCIsXG4gICAgXCLhhIvhhaHhhInhhbHhhIvhha7hhrdcIixcbiAgICBcIuGEi+GFoeGEieGFs+GEkeGFoeGGr+GEkOGFs1wiLFxuICAgIFwi4YSL4YWh4YSJ4YW14YSL4YWhXCIsXG4gICAgXCLhhIvhhaHhhIvhha7hhq/hhIXhhaVcIixcbiAgICBcIuGEi+GFoeGEjOGFpeGEiuGFtVwiLFxuICAgIFwi4YSL4YWh4YSM4YWu4Ya34YSG4YWhXCIsXG4gICAgXCLhhIvhhaHhhIzhhbXhhqhcIixcbiAgICBcIuGEi+GFoeGEjuGFteGGt1wiLFxuICAgIFwi4YSL4YWh4YSR4YWh4YSQ4YWzXCIsXG4gICAgXCLhhIvhhaHhhJHhhbPhhIXhhbXhhI/hhaFcIixcbiAgICBcIuGEi+GFoeGEkeGFs+GGt1wiLFxuICAgIFwi4YSL4YWh4YSS4YWp4Ya4XCIsXG4gICAgXCLhhIvhhaHhhJLhhbPhhqtcIixcbiAgICBcIuGEi+GFoeGGqOGEgOGFtVwiLFxuICAgIFwi4YSL4YWh4Yao4YSG4YWp4Ya8XCIsXG4gICAgXCLhhIvhhaHhhqjhhInhha5cIixcbiAgICBcIuGEi+GFoeGGq+GEgOGFolwiLFxuICAgIFwi4YSL4YWh4Yar4YSA4YWn4Ya8XCIsXG4gICAgXCLhhIvhhaHhhqvhhIDhhapcIixcbiAgICBcIuGEi+GFoeGGq+GEguGFolwiLFxuICAgIFwi4YSL4YWh4Yar4YSC4YWn4Ya8XCIsXG4gICAgXCLhhIvhhaHhhqvhhIPhhanhhrxcIixcbiAgICBcIuGEi+GFoeGGq+GEh+GFoeGGvFwiLFxuICAgIFwi4YSL4YWh4Yar4YSH4YWuXCIsXG4gICAgXCLhhIvhhaHhhqvhhIzhha5cIixcbiAgICBcIuGEi+GFoeGGr+GEheGFruGEhuGFteGEguGFsuGGt1wiLFxuICAgIFwi4YSL4YWh4Yav4YSP4YWp4YSL4YWp4YavXCIsXG4gICAgXCLhhIvhhaHhhrfhhInhhbVcIixcbiAgICBcIuGEi+GFoeGGt+GEj+GFpeGGulwiLFxuICAgIFwi4YSL4YWh4Ya44YSF4YWn4YaoXCIsXG4gICAgXCLhhIvhhaHhh4HhhILhhaHhhq9cIixcbiAgICBcIuGEi+GFoeGHgeGEhuGFruGGq1wiLFxuICAgIFwi4YSL4YWi4YSL4YW14YarXCIsXG4gICAgXCLhhIvhhaLhhIzhhaXhhrxcIixcbiAgICBcIuGEi+GFouGGqOGEieGFrlwiLFxuICAgIFwi4YSL4YWi4Yav4YSH4YWl4Ya3XCIsXG4gICAgXCLhhIvhhaPhhIDhhaHhhqtcIixcbiAgICBcIuGEi+GFo+GEg+GFoeGGq1wiLFxuICAgIFwi4YSL4YWj4YSL4YWp4Ya8XCIsXG4gICAgXCLhhIvhhaPhhqjhhIDhhaHhhqtcIixcbiAgICBcIuGEi+GFo+GGqOGEgOGFruGGqFwiLFxuICAgIFwi4YSL4YWj4Yao4YSJ4YWp4YaoXCIsXG4gICAgXCLhhIvhhaPhhqjhhInhha5cIixcbiAgICBcIuGEi+GFo+GGqOGEjOGFpeGGt1wiLFxuICAgIFwi4YSL4YWj4Yao4YSR4YWu4Ya3XCIsXG4gICAgXCLhhIvhhaPhhqjhhJLhhanhhqvhhILhhadcIixcbiAgICBcIuGEi+GFo+GGvOGEguGFp+GGt1wiLFxuICAgIFwi4YSL4YWj4Ya84YSF4YWn4YaoXCIsXG4gICAgXCLhhIvhhaPhhrzhhIbhhaHhhq9cIixcbiAgICBcIuGEi+GFo+GGvOGEh+GFouGEjuGFrlwiLFxuICAgIFwi4YSL4YWj4Ya84YSM4YWuXCIsXG4gICAgXCLhhIvhhaPhhrzhhJHhhaFcIixcbiAgICBcIuGEi+GFpeGEg+GFruGGt1wiLFxuICAgIFwi4YSL4YWl4YSF4YWn4YSL4YWu4Ya3XCIsXG4gICAgXCLhhIvhhaXhhIXhhbPhhqtcIixcbiAgICBcIuGEi+GFpeGEjOGFpuGGuuGEh+GFoeGGt1wiLFxuICAgIFwi4YSL4YWl4YSN4YWi4Ya74YSD4YWz4YarXCIsXG4gICAgXCLhhIvhhaXhhI3hhaXhhIPhhaHhhIDhhaFcIixcbiAgICBcIuGEi+GFpeGEjeGFpeGGq+GEjOGFtVwiLFxuICAgIFwi4YSL4YWl4Yar4YSC4YW1XCIsXG4gICAgXCLhhIvhhaXhhqvhhIPhhaXhhqhcIixcbiAgICBcIuGEi+GFpeGGq+GEheGFqeGGq1wiLFxuICAgIFwi4YSL4YWl4Yar4YSL4YWlXCIsXG4gICAgXCLhhIvhhaXhhq/hhIDhha7hhq9cIixcbiAgICBcIuGEi+GFpeGGr+GEheGFs+GGq1wiLFxuICAgIFwi4YSL4YWl4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIvhhaXhhq/hhJHhhbXhhrpcIixcbiAgICBcIuGEi+GFpeGGt+GEhuGFoVwiLFxuICAgIFwi4YSL4YWl4Ya44YSG4YWuXCIsXG4gICAgXCLhhIvhhaXhhrjhhIzhhanhhrxcIixcbiAgICBcIuGEi+GFpeGGuOGEjuGFplwiLFxuICAgIFwi4YSL4YWl4Ya84YSD4YWl4Ya84YSL4YW1XCIsXG4gICAgXCLhhIvhhaXhhrzhhIbhhaHhhrxcIixcbiAgICBcIuGEi+GFpeGGvOGEkOGFpeGEheGFtVwiLFxuICAgIFwi4YSL4YWl4Ya94YSA4YWz4YSM4YWmXCIsXG4gICAgXCLhhIvhhabhhILhhaXhhIzhhbVcIixcbiAgICBcIuGEi+GFpuGEi+GFpeGEj+GFpeGGq1wiLFxuICAgIFwi4YSL4YWm4Yar4YSM4YW14YarXCIsXG4gICAgXCLhhIvhhafhhIDhhaXhhqtcIixcbiAgICBcIuGEi+GFp+GEgOGFqeGEieGFouGGvFwiLFxuICAgIFwi4YSL4YWn4YSA4YWq4YarXCIsXG4gICAgXCLhhIvhhafhhIDhha7hhqtcIixcbiAgICBcIuGEi+GFp+GEgOGFr+GGq1wiLFxuICAgIFwi4YSL4YWn4YSD4YWi4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhIvhhafhhIPhhaXhhrJcIixcbiAgICBcIuGEi+GFp+GEg+GFqeGGvOGEieGFouGGvFwiLFxuICAgIFwi4YSL4YWn4YSD4YWz4YarXCIsXG4gICAgXCLhhIvhhafhhIXhhanhhqtcIixcbiAgICBcIuGEi+GFp+GEheGFs+GGt1wiLFxuICAgIFwi4YSL4YWn4YSJ4YWl4Ya6XCIsXG4gICAgXCLhhIvhhafhhInhhaXhhrxcIixcbiAgICBcIuGEi+GFp+GEi+GFquGGvFwiLFxuICAgIFwi4YSL4YWn4YSL4YW14YarXCIsXG4gICAgXCLhhIvhhafhhIzhhaXhhqvhhJLhhbVcIixcbiAgICBcIuGEi+GFp+GEjOGFteGGqOGEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YWn4YSS4YWh4Yao4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhIvhhafhhJLhhaLhhrxcIixcbiAgICBcIuGEi+GFp+GGqOGEieGFoVwiLFxuICAgIFwi4YSL4YWn4Yao4YSJ4YW1XCIsXG4gICAgXCLhhIvhhafhhqjhhJLhhaHhhq9cIixcbiAgICBcIuGEi+GFp+GGq+GEgOGFp+GGr1wiLFxuICAgIFwi4YSL4YWn4Yar4YSA4YWuXCIsXG4gICAgXCLhhIvhhafhhqvhhIDhhbPhhqhcIixcbiAgICBcIuGEi+GFp+GGq+GEgOGFtVwiLFxuICAgIFwi4YSL4YWn4Yar4YSF4YWh4YaoXCIsXG4gICAgXCLhhIvhhafhhqvhhInhhaXhhq9cIixcbiAgICBcIuGEi+GFp+GGq+GEieGFplwiLFxuICAgIFwi4YSL4YWn4Yar4YSJ4YWp4YaoXCIsXG4gICAgXCLhhIvhhafhhqvhhInhhbPhhrhcIixcbiAgICBcIuGEi+GFp+GGq+GEi+GFolwiLFxuICAgIFwi4YSL4YWn4Yar4YSL4YWo4YSL4YW14YarXCIsXG4gICAgXCLhhIvhhafhhqvhhIvhhbXhhqtcIixcbiAgICBcIuGEi+GFp+GGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSL4YWn4Yar4YSM4YWuXCIsXG4gICAgXCLhhIvhhafhhqvhhI7hha7hhq9cIixcbiAgICBcIuGEi+GFp+GGq+GEkeGFteGGr1wiLFxuICAgIFwi4YSL4YWn4Yar4YSS4YWh4Ya4XCIsXG4gICAgXCLhhIvhhafhhqvhhJLhhbJcIixcbiAgICBcIuGEi+GFp+GGr+GEgOGFtVwiLFxuICAgIFwi4YSL4YWn4Yav4YSG4YWiXCIsXG4gICAgXCLhhIvhhafhhq/hhInhhaxcIixcbiAgICBcIuGEi+GFp+GGr+GEieGFteGGt+GEkuGFtVwiLFxuICAgIFwi4YSL4YWn4Yav4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIvhhafhhq/hhI7hhaFcIixcbiAgICBcIuGEi+GFp+GGr+GEkuGFs+GGr1wiLFxuICAgIFwi4YSL4YWn4Ya34YSF4YWnXCIsXG4gICAgXCLhhIvhhafhhrjhhInhhaVcIixcbiAgICBcIuGEi+GFp+GGvOGEgOGFruGGqFwiLFxuICAgIFwi4YSL4YWn4Ya84YSC4YWh4Ya3XCIsXG4gICAgXCLhhIvhhafhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEi+GFp+GGvOGEi+GFo+GGvFwiLFxuICAgIFwi4YSL4YWn4Ya84YSL4YWn4YaoXCIsXG4gICAgXCLhhIvhhafhhrzhhIvhha7hhrxcIixcbiAgICBcIuGEi+GFp+GGvOGEi+GFr+GGq+GEkuGFtVwiLFxuICAgIFwi4YSL4YWn4Ya84YSS4YWhXCIsXG4gICAgXCLhhIvhhafhhrzhhJLhhaPhhrxcIixcbiAgICBcIuGEi+GFp+GGvOGEkuGFqeGGq1wiLFxuICAgIFwi4YSL4YWn4Ya84YSS4YWqXCIsXG4gICAgXCLhhIvhhafhh4HhhIDhha7hhIXhhbVcIixcbiAgICBcIuGEi+GFp+GHgeGEh+GFoeGGvFwiLFxuICAgIFwi4YSL4YWn4YeB4YSM4YW14Ya4XCIsXG4gICAgXCLhhIvhhajhhIDhhaHhhrdcIixcbiAgICBcIuGEi+GFqOGEgOGFs+GGt1wiLFxuICAgIFwi4YSL4YWo4YSH4YWh4Ya8XCIsXG4gICAgXCLhhIvhhajhhInhhaHhhqtcIixcbiAgICBcIuGEi+GFqOGEieGFoeGGvFwiLFxuICAgIFwi4YSL4YWo4YSJ4YWl4YarXCIsXG4gICAgXCLhhIvhhajhhInhha7hhq9cIixcbiAgICBcIuGEi+GFqOGEieGFs+GGuFwiLFxuICAgIFwi4YSL4YWo4YSJ4YW14Yao4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIvhhajhhIvhhaPhhqhcIixcbiAgICBcIuGEi+GFqOGEjOGFpeGGq1wiLFxuICAgIFwi4YSL4YWo4YSM4YWl4YavXCIsXG4gICAgXCLhhIvhhajhhIzhhaXhhrxcIixcbiAgICBcIuGEi+GFqOGEj+GFpeGGq+GEg+GFolwiLFxuICAgIFwi4YSL4YWo4Ya64YSC4YWh4YavXCIsXG4gICAgXCLhhIvhhanhhILhhbPhhq9cIixcbiAgICBcIuGEi+GFqeGEheGFoeGGqFwiLFxuICAgIFwi4YSL4YWp4YSF4YWi4Ya64YSD4YWp4Ya84YSL4YWh4YarXCIsXG4gICAgXCLhhIvhhanhhIXhhabhhqvhhIzhhbVcIixcbiAgICBcIuGEi+GFqeGEheGFqeGEjOGFtVwiLFxuICAgIFwi4YSL4YWp4YSF4YWz4Yar4YSH4YWh4YavXCIsXG4gICAgXCLhhIvhhanhhIfhhbPhhqtcIixcbiAgICBcIuGEi+GFqeGEieGFteGGuFwiLFxuICAgIFwi4YSL4YWp4YSL4YWn4Ya3XCIsXG4gICAgXCLhhIvhhanhhIvhha/hhq9cIixcbiAgICBcIuGEi+GFqeGEjOGFpeGGq1wiLFxuICAgIFwi4YSL4YWp4YSM4YW14YaoXCIsXG4gICAgXCLhhIvhhanhhIzhhbXhhrzhhIvhhaVcIixcbiAgICBcIuGEi+GFqeGEkeGFpuGEheGFoVwiLFxuICAgIFwi4YSL4YWp4YSR4YW14YSJ4YWz4YSQ4YWm4YavXCIsXG4gICAgXCLhhIvhhanhhJLhhbXhhIXhhadcIixcbiAgICBcIuGEi+GFqeGGqOGEieGFoeGGvFwiLFxuICAgIFwi4YSL4YWp4Yao4YSJ4YWu4YSJ4YWuXCIsXG4gICAgXCLhhIvhhanhhqvhhIDhhaHhhr1cIixcbiAgICBcIuGEi+GFqeGGq+GEheGFoeGEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWp4Yar4YSG4YWp4Ya3XCIsXG4gICAgXCLhhIvhhanhhqvhhIzhhanhhrzhhIvhhbXhhq9cIixcbiAgICBcIuGEi+GFqeGGq+GEkOGFqeGGvFwiLFxuICAgIFwi4YSL4YWp4Yav4YSA4YWh4YSL4YWz4YavXCIsXG4gICAgXCLhhIvhhanhhq/hhIXhhbXhhrfhhJHhhbXhhqhcIixcbiAgICBcIuGEi+GFqeGGr+GEkuGFolwiLFxuICAgIFwi4YSL4YWp4Ya64YSO4YWh4YSF4YW14Ya3XCIsXG4gICAgXCLhhIvhharhhIvhhbXhhInhhafhhI7hhbNcIixcbiAgICBcIuGEi+GFquGEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWq4Yar4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIvhharhhqvhhIzhhaXhhqtcIixcbiAgICBcIuGEi+GFquGGvOGEh+GFtVwiLFxuICAgIFwi4YSL4YWq4Ya84YSM4YWhXCIsXG4gICAgXCLhhIvhhavhhILhhaPhhJLhhaHhhIbhhafhhqtcIixcbiAgICBcIuGEi+GFq+GGq+GEjOGFtVwiLFxuICAgIFwi4YSL4YWs4YSA4YWh4Ya64YSM4YW14Ya4XCIsXG4gICAgXCLhhIvhhazhhIDhha7hhqhcIixcbiAgICBcIuGEi+GFrOGEheGFqeGEi+GFruGGt1wiLFxuICAgIFwi4YSL4YWs4YSJ4YWh4Ya34YSO4YWp4YarXCIsXG4gICAgXCLhhIvhhazhhI7hha7hhq9cIixcbiAgICBcIuGEi+GFrOGEjuGFteGGt1wiLFxuICAgIFwi4YSL4YWs4YSS4YWh4Yav4YSG4YWl4YSC4YW1XCIsXG4gICAgXCLhhIvhhazhhqvhhIfhhaHhhq9cIixcbiAgICBcIuGEi+GFrOGGq+GEieGFqeGGq1wiLFxuICAgIFwi4YSL4YWs4Yar4YSN4YWp4YaoXCIsXG4gICAgXCLhhIvhha3hhIDhhbPhhrdcIixcbiAgICBcIuGEi+GFreGEi+GFteGGr1wiLFxuICAgIFwi4YSL4YWt4YSM4YWz4Ya3XCIsXG4gICAgXCLhhIvhha3hhI7hhaXhhrxcIixcbiAgICBcIuGEi+GFreGGvOGEgOGFtVwiLFxuICAgIFwi4YSL4YWt4Ya84YSJ4YWlXCIsXG4gICAgXCLhhIvhha3hhrzhhIvhhaVcIixcbiAgICBcIuGEi+GFruGEieGFoeGGq1wiLFxuICAgIFwi4YSL4YWu4YSJ4YWl4YarXCIsXG4gICAgXCLhhIvhha7hhInhhbPhhrxcIixcbiAgICBcIuGEi+GFruGEi+GFp+GGq+GEkuGFtVwiLFxuICAgIFwi4YSL4YWu4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIvhha7hhI7hhabhhIDhha7hhqhcIixcbiAgICBcIuGEi+GFruGEkeGFp+GGq1wiLFxuICAgIFwi4YSL4YWu4Yar4YSD4YWp4Ya8XCIsXG4gICAgXCLhhIvhha7hhqvhhIbhhafhhrxcIixcbiAgICBcIuGEi+GFruGGq+GEh+GFoeGGq1wiLFxuICAgIFwi4YSL4YWu4Yar4YSM4YWl4YarXCIsXG4gICAgXCLhhIvhha7hhqvhhJLhhaLhhrxcIixcbiAgICBcIuGEi+GFruGGr+GEieGFoeGGq1wiLFxuICAgIFwi4YSL4YWu4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIvhha7hhrfhhIzhhbXhhqjhhIvhhbXhhrdcIixcbiAgICBcIuGEi+GFruGGuuGEi+GFpeGEheGFs+GGq1wiLFxuICAgIFwi4YSL4YWu4Ya64YSL4YWz4Ya3XCIsXG4gICAgXCLhhIvhha/hhILhhaHhhqhcIixcbiAgICBcIuGEi+GFr+GGq+GEgOGFqVwiLFxuICAgIFwi4YSL4YWv4Yar4YSF4YWiXCIsXG4gICAgXCLhhIvhha/hhqvhhInhhaVcIixcbiAgICBcIuGEi+GFr+GGq+GEieGFruGGvOGEi+GFtVwiLFxuICAgIFwi4YSL4YWv4Yar4YSL4YW14YarXCIsXG4gICAgXCLhhIvhha/hhqvhhIzhhaHhhrxcIixcbiAgICBcIuGEi+GFr+GGq+GEkeGFteGEieGFs1wiLFxuICAgIFwi4YSL4YWv4Yav4YSA4YWz4Ya4XCIsXG4gICAgXCLhhIvhha/hhq/hhIPhhbPhhI/hhaXhhrhcIixcbiAgICBcIuGEi+GFr+GGr+GEieGFplwiLFxuICAgIFwi4YSL4YWv4Yav4YSL4YWt4YSL4YW14YavXCIsXG4gICAgXCLhhIvhhbDhhIvhhbXhhJDhhaVcIixcbiAgICBcIuGEi+GFseGEh+GFoeGGq1wiLFxuICAgIFwi4YSL4YWx4YSH4YWl4Ya4XCIsXG4gICAgXCLhhIvhhbHhhInhhaXhhrxcIixcbiAgICBcIuGEi+GFseGEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YWx4YSS4YWl4Ya3XCIsXG4gICAgXCLhhIvhhbHhhJLhhafhhrhcIixcbiAgICBcIuGEi+GFseGGuuGEieGFoeGEheGFoeGGt1wiLFxuICAgIFwi4YSL4YWy4YSC4YWh4Yar4YSS4YW1XCIsXG4gICAgXCLhhIvhhbLhhIXhhaXhhrhcIixcbiAgICBcIuGEi+GFsuGEhuGFp+GGvFwiLFxuICAgIFwi4YSL4YWy4YSG4YWu4YavXCIsXG4gICAgXCLhhIvhhbLhhInhhaHhhqtcIixcbiAgICBcIuGEi+GFsuGEjOGFpeGGqFwiLFxuICAgIFwi4YSL4YWy4YSO4YW14YSL4YWv4YarXCIsXG4gICAgXCLhhIvhhbLhhJLhhaHhhqhcIixcbiAgICBcIuGEi+GFsuGEkuGFouGGvFwiLFxuICAgIFwi4YSL4YWy4YSS4YWn4Ya8XCIsXG4gICAgXCLhhIvhhbLhhqjhhIDhha7hhqtcIixcbiAgICBcIuGEi+GFsuGGqOGEieGFoeGGvFwiLFxuICAgIFwi4YSL4YWy4Yao4YSJ4YW14Ya4XCIsXG4gICAgXCLhhIvhhbLhhqjhhI7hhaZcIixcbiAgICBcIuGEi+GFs+GGq+GEkuGFouGGvFwiLFxuICAgIFwi4YSL4YWz4Ya34YSF4YWn4YaoXCIsXG4gICAgXCLhhIvhhbPhhrfhhIXhha1cIixcbiAgICBcIuGEi+GFs+GGt+GEh+GFoeGGq1wiLFxuICAgIFwi4YSL4YWz4Ya34YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIvhhbPhhrfhhInhhbXhhqhcIixcbiAgICBcIuGEi+GFs+GGt+GEi+GFoeGGqFwiLFxuICAgIFwi4YSL4YWz4Ya34YSM4YWuXCIsXG4gICAgXCLhhIvhhbThhIDhhafhhqtcIixcbiAgICBcIuGEi+GFtOGEguGFqeGGq1wiLFxuICAgIFwi4YSL4YW04YSG4YWu4YarXCIsXG4gICAgXCLhhIvhhbThhIfhhanhhqhcIixcbiAgICBcIuGEi+GFtOGEieGFteGGqFwiLFxuICAgIFwi4YSL4YW04YSJ4YW14Ya3XCIsXG4gICAgXCLhhIvhhbThhIvhhazhhIXhhalcIixcbiAgICBcIuGEi+GFtOGEi+GFreGGqFwiLFxuICAgIFwi4YSL4YW04YSL4YWv4YarXCIsXG4gICAgXCLhhIvhhbThhJLhhaHhhqhcIixcbiAgICBcIuGEi+GFteGEgOGFpeGGulwiLFxuICAgIFwi4YSL4YW14YSA4YWp4Ya6XCIsXG4gICAgXCLhhIvhhbXhhILhhafhhrdcIixcbiAgICBcIuGEi+GFteGEguGFqeGGt1wiLFxuICAgIFwi4YSL4YW14YSD4YWh4YavXCIsXG4gICAgXCLhhIvhhbXhhIPhhaLhhIXhhalcIixcbiAgICBcIuGEi+GFteGEg+GFqeGGvFwiLFxuICAgIFwi4YSL4YW14YSF4YWl4YeC4YSA4YWmXCIsXG4gICAgXCLhhIvhhbXhhIXhhafhhqjhhInhhaVcIixcbiAgICBcIuGEi+GFteGEheGFqeGGq+GEjOGFpeGGqFwiLFxuICAgIFwi4YSL4YW14YSF4YWz4Ya3XCIsXG4gICAgXCLhhIvhhbXhhIbhhbXhhqtcIixcbiAgICBcIuGEi+GFteGEh+GFoeGGr+GEieGFqVwiLFxuICAgIFwi4YSL4YW14YSH4YWn4YavXCIsXG4gICAgXCLhhIvhhbXhhIfhha7hhq9cIixcbiAgICBcIuGEi+GFteGEiOGFoeGGr1wiLFxuICAgIFwi4YSL4YW14YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIvhhbXhhInhhaXhhrxcIixcbiAgICBcIuGEi+GFteGEieGFs+GGr1wiLFxuICAgIFwi4YSL4YW14YSL4YWj4YSA4YW1XCIsXG4gICAgXCLhhIvhhbXhhIvhha3hhrxcIixcbiAgICBcIuGEi+GFteGEi+GFruGGulwiLFxuICAgIFwi4YSL4YW14YSL4YWv4YavXCIsXG4gICAgXCLhhIvhhbXhhIvhhbPhhqjhhIDhhalcIixcbiAgICBcIuGEi+GFteGEi+GFteGGqFwiLFxuICAgIFwi4YSL4YW14YSM4YWl4YarXCIsXG4gICAgXCLhhIvhhbXhhIzhha7hhrxcIixcbiAgICBcIuGEi+GFteGEkOGFs+GGruGEguGFoeGGr1wiLFxuICAgIFwi4YSL4YW14YSQ4YWz4YavXCIsXG4gICAgXCLhhIvhhbXhhJLhhanhhqtcIixcbiAgICBcIuGEi+GFteGGq+GEgOGFoeGGq1wiLFxuICAgIFwi4YSL4YW14Yar4YSA4YWn4YaoXCIsXG4gICAgXCLhhIvhhbXhhqvhhIDhhanhhrxcIixcbiAgICBcIuGEi+GFteGGq+GEgOGFrlwiLFxuICAgIFwi4YSL4YW14Yar4YSA4YWz4YarXCIsXG4gICAgXCLhhIvhhbXhhqvhhIDhhbVcIixcbiAgICBcIuGEi+GFteGGq+GEg+GFqVwiLFxuICAgIFwi4YSL4YW14Yar4YSF4YWyXCIsXG4gICAgXCLhhIvhhbXhhqvhhIbhha7hhq9cIixcbiAgICBcIuGEi+GFteGGq+GEieGFouGGvFwiLFxuICAgIFwi4YSL4YW14Yar4YSJ4YWrXCIsXG4gICAgXCLhhIvhhbXhhqvhhIvhhafhhqtcIixcbiAgICBcIuGEi+GFteGGq+GEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YW14Yar4YSM4YWiXCIsXG4gICAgXCLhhIvhhbXhhqvhhIzhhanhhrxcIixcbiAgICBcIuGEi+GFteGGq+GEjuGFpeGGq1wiLFxuICAgIFwi4YSL4YW14Yar4YSO4YWmXCIsXG4gICAgXCLhhIvhhbXhhqvhhJDhhaXhhILhhabhhrpcIixcbiAgICBcIuGEi+GFteGGq+GEkuGFoVwiLFxuICAgIFwi4YSL4YW14Yar4YSS4YWn4Ya8XCIsXG4gICAgXCLhhIvhhbXhhq/hhIDhhanhhrhcIixcbiAgICBcIuGEi+GFteGGr+GEgOGFtVwiLFxuICAgIFwi4YSL4YW14Yav4YSD4YWh4YarXCIsXG4gICAgXCLhhIvhhbXhhq/hhIPhhaJcIixcbiAgICBcIuGEi+GFteGGr+GEg+GFs+GGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSH4YWh4YarXCIsXG4gICAgXCLhhIvhhbXhhq/hhIfhhanhhqtcIixcbiAgICBcIuGEi+GFteGGr+GEh+GFrlwiLFxuICAgIFwi4YSL4YW14Yav4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIvhhbXhhq/hhInhhaLhhrxcIixcbiAgICBcIuGEi+GFteGGr+GEieGFqeGGq1wiLFxuICAgIFwi4YSL4YW14Yav4YSL4YWt4YSL4YW14YavXCIsXG4gICAgXCLhhIvhhbXhhq/hhIvhha/hhq9cIixcbiAgICBcIuGEi+GFteGGr+GEjOGFpeGGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSM4YWp4Ya8XCIsXG4gICAgXCLhhIvhhbXhhq/hhIzhha7hhIvhhbXhhq9cIixcbiAgICBcIuGEi+GFteGGr+GEjeGFteGGqFwiLFxuICAgIFwi4YSL4YW14Yav4YSO4YWmXCIsXG4gICAgXCLhhIvhhbXhhq/hhI7hhbVcIixcbiAgICBcIuGEi+GFteGGr+GEkuGFouGGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSS4YWs4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIvhhbXhhrfhhIDhhbPhhrdcIixcbiAgICBcIuGEi+GFteGGt+GEhuGFrlwiLFxuICAgIFwi4YSL4YW14Ya44YSD4YWiXCIsXG4gICAgXCLhhIvhhbXhhrjhhIXhhafhhqhcIixcbiAgICBcIuGEi+GFteGGuOGEhuGFoeGGulwiLFxuICAgIFwi4YSL4YW14Ya44YSJ4YWhXCIsXG4gICAgXCLhhIvhhbXhhrjhhInhha7hhq9cIixcbiAgICBcIuGEi+GFteGGuOGEieGFtVwiLFxuICAgIFwi4YSL4YW14Ya44YSL4YWv4YarXCIsXG4gICAgXCLhhIvhhbXhhrjhhIzhhaHhhrxcIixcbiAgICBcIuGEi+GFteGGuOGEkuGFoeGGqFwiLFxuICAgIFwi4YSM4YWh4YSA4YWh4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIzhhaHhhIDhhafhhqhcIixcbiAgICBcIuGEjOGFoeGEgOGFs+GGqFwiLFxuICAgIFwi4YSM4YWh4YSD4YWp4Ya8XCIsXG4gICAgXCLhhIzhhaHhhIXhhaHhhrxcIixcbiAgICBcIuGEjOGFoeGEh+GFruGEieGFteGGt1wiLFxuICAgIFwi4YSM4YWh4YSJ4YW14YaoXCIsXG4gICAgXCLhhIzhhaHhhInhhbXhhqtcIixcbiAgICBcIuGEjOGFoeGEi+GFp+GGq1wiLFxuICAgIFwi4YSM4YWh4YSL4YWv4YarXCIsXG4gICAgXCLhhIzhhaHhhIvhhbLhhq9cIixcbiAgICBcIuGEjOGFoeGEjOGFpeGGq+GEgOGFpVwiLFxuICAgIFwi4YSM4YWh4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIzhhaHhhIzhhanhhqvhhInhhbXhhrdcIixcbiAgICBcIuGEjOGFoeGEkeGFoeGGq1wiLFxuICAgIFwi4YSM4YWh4Yao4YSA4YWhXCIsXG4gICAgXCLhhIzhhaHhhqjhhILhhafhhqtcIixcbiAgICBcIuGEjOGFoeGGqOGEieGFpeGGvFwiLFxuICAgIFwi4YSM4YWh4Yao4YSL4YWl4Ya4XCIsXG4gICAgXCLhhIzhhaHhhqjhhIvhha3hhrxcIixcbiAgICBcIuGEjOGFoeGGqOGEi+GFs+GGq+GEhOGFoeGGr1wiLFxuICAgIFwi4YSM4YWh4Yao4YSR4YWu4Ya3XCIsXG4gICAgXCLhhIzhhaHhhqvhhIPhhbVcIixcbiAgICBcIuGEjOGFoeGGq+GEhOGFs+GGqFwiLFxuICAgIFwi4YSM4YWh4Yar4YSO4YW1XCIsXG4gICAgXCLhhIzhhaHhhq/hhIbhhanhhrpcIixcbiAgICBcIuGEjOGFoeGGt+GEgeGFoeGGq1wiLFxuICAgIFwi4YSM4YWh4Ya34YSJ4YWu4YSS4YWh4Ya3XCIsXG4gICAgXCLhhIzhhaHhhrfhhInhhbVcIixcbiAgICBcIuGEjOGFoeGGt+GEi+GFqeGGulwiLFxuICAgIFwi4YSM4YWh4Ya34YSM4YWh4YSF4YW1XCIsXG4gICAgXCLhhIzhhaHhhrjhhIzhhbVcIixcbiAgICBcIuGEjOGFoeGGvOGEgOGFquGGq1wiLFxuICAgIFwi4YSM4YWh4Ya84YSA4YWu4YarXCIsXG4gICAgXCLhhIzhhaHhhrzhhIDhhbXhhIDhhaHhhqtcIixcbiAgICBcIuGEjOGFoeGGvOGEheGFolwiLFxuICAgIFwi4YSM4YWh4Ya84YSF4YWoXCIsXG4gICAgXCLhhIzhhaHhhrzhhIXhhbNcIixcbiAgICBcIuGEjOGFoeGGvOGEhuGFoVwiLFxuICAgIFwi4YSM4YWh4Ya84YSG4YWn4YarXCIsXG4gICAgXCLhhIzhhaHhhrzhhIbhhalcIixcbiAgICBcIuGEjOGFoeGGvOGEhuGFtVwiLFxuICAgIFwi4YSM4YWh4Ya84YSH4YW1XCIsXG4gICAgXCLhhIzhhaHhhrzhhInhhaFcIixcbiAgICBcIuGEjOGFoeGGvOGEieGFqVwiLFxuICAgIFwi4YSM4YWh4Ya84YSJ4YW14YaoXCIsXG4gICAgXCLhhIzhhaHhhrzhhIvhhaLhhIvhhbXhhqtcIixcbiAgICBcIuGEjOGFoeGGvOGEi+GFteGGq1wiLFxuICAgIFwi4YSM4YWh4Ya84YSM4YWl4Ya3XCIsXG4gICAgXCLhhIzhhaHhhrzhhI7hhaFcIixcbiAgICBcIuGEjOGFoeGGvOGEkuGFoeGGqOGEgOGFs+GGt1wiLFxuICAgIFwi4YSM4YWi4YSC4YWz4Ya8XCIsXG4gICAgXCLhhIzhhaLhhIjhhaHhhq/hhIXhhbVcIixcbiAgICBcIuGEjOGFouGEieGFoeGGq1wiLFxuICAgIFwi4YSM4YWi4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhIzhhaLhhIzhhaHhhqjhhILhhafhhqtcIixcbiAgICBcIuGEjOGFouGEjOGFpeGGvFwiLFxuICAgIFwi4YSM4YWi4YSO4YWi4YSA4YW1XCIsXG4gICAgXCLhhIzhhaLhhJHhhaHhhqtcIixcbiAgICBcIuGEjOGFouGEkuGFoeGGqFwiLFxuICAgIFwi4YSM4YWi4YSS4YWq4Yav4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIzhhaXhhIDhhaXhhrpcIixcbiAgICBcIuGEjOGFpeGEgOGFqeGEheGFtVwiLFxuICAgIFwi4YSM4YWl4YSA4YWp4Ya6XCIsXG4gICAgXCLhhIzhhaXhhILhhafhhqhcIixcbiAgICBcIuGEjOGFpeGEheGFpeGGq1wiLFxuICAgIFwi4YSM4YWl4YSF4YWl4YeC4YSA4YWmXCIsXG4gICAgXCLhhIzhhaXhhIfhhaXhhqtcIixcbiAgICBcIuGEjOGFpeGEi+GFruGGr1wiLFxuICAgIFwi4YSM4YWl4YSM4YWl4Yav4YSF4YWpXCIsXG4gICAgXCLhhIzhhaXhhI7hha7hhqhcIixcbiAgICBcIuGEjOGFpeGGqOGEgOGFs+GGqFwiLFxuICAgIFwi4YSM4YWl4Yao4YSD4YWh4Ya84YSS4YW1XCIsXG4gICAgXCLhhIzhhaXhhqjhhInhhaXhhrxcIixcbiAgICBcIuGEjOGFpeGGqOGEi+GFreGGvFwiLFxuICAgIFwi4YSM4YWl4Yao4YSL4YWz4Ya8XCIsXG4gICAgXCLhhIzhhaXhhqvhhIDhhaJcIixcbiAgICBcIuGEjOGFpeGGq+GEgOGFqeGGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSA4YW1XCIsXG4gICAgXCLhhIzhhaXhhqvhhIPhhaHhhq9cIixcbiAgICBcIuGEjOGFpeGGq+GEheGFoeGEg+GFqVwiLFxuICAgIFwi4YSM4YWl4Yar4YSG4YWh4Ya8XCIsXG4gICAgXCLhhIzhhaXhhqvhhIbhha7hhqtcIixcbiAgICBcIuGEjOGFpeGGq+GEh+GFoeGGq1wiLFxuICAgIFwi4YSM4YWl4Yar4YSH4YWuXCIsXG4gICAgXCLhhIzhhaXhhqvhhInhhaZcIixcbiAgICBcIuGEjOGFpeGGq+GEieGFtVwiLFxuICAgIFwi4YSM4YWl4Yar4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIzhhaXhhqvhhIzhhaFcIixcbiAgICBcIuGEjOGFpeGGq+GEjOGFouGGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSM4YWuXCIsXG4gICAgXCLhhIzhhaXhhqvhhI7hhaXhhq9cIixcbiAgICBcIuGEjOGFpeGGq+GEjuGFplwiLFxuICAgIFwi4YSM4YWl4Yar4YSQ4YWp4Ya8XCIsXG4gICAgXCLhhIzhhaXhhqvhhJLhhadcIixcbiAgICBcIuGEjOGFpeGGq+GEkuGFrlwiLFxuICAgIFwi4YSM4YWl4Yav4YSD4YWiXCIsXG4gICAgXCLhhIzhhaXhhq/hhIbhhaHhhrxcIixcbiAgICBcIuGEjOGFpeGGr+GEh+GFoeGGq1wiLFxuICAgIFwi4YSM4YWl4Yav4YSL4YWj4YaoXCIsXG4gICAgXCLhhIzhhaXhhq/hhI7hhaFcIixcbiAgICBcIuGEjOGFpeGGt+GEgOGFpeGGt1wiLFxuICAgIFwi4YSM4YWl4Ya34YSJ4YWuXCIsXG4gICAgXCLhhIzhhaXhhrfhhInhhbXhhrdcIixcbiAgICBcIuGEjOGFpeGGt+GEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YWl4Ya34YSM4YWl4Ya3XCIsXG4gICAgXCLhhIzhhaXhhrfhhI7hhaFcIixcbiAgICBcIuGEjOGFpeGGuOGEgOGFs+GGq1wiLFxuICAgIFwi4YSM4YWl4Ya44YSJ4YW1XCIsXG4gICAgXCLhhIzhhaXhhrjhhI7hhanhhqhcIixcbiAgICBcIuGEjOGFpeGGuuGEgOGFoeGEheGFoeGGqFwiLFxuICAgIFwi4YSM4YWl4Ya84YSA4YWl4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIzhhaXhhrzhhIPhhalcIixcbiAgICBcIuGEjOGFpeGGvOGEheGFsuGEjOGFoeGGvFwiLFxuICAgIFwi4YSM4YWl4Ya84YSF4YW1XCIsXG4gICAgXCLhhIzhhaXhhrzhhIbhhaHhhq9cIixcbiAgICBcIuGEjOGFpeGGvOGEhuGFp+GGq1wiLFxuICAgIFwi4YSM4YWl4Ya84YSG4YWu4YarXCIsXG4gICAgXCLhhIzhhaXhhrzhhIfhhaHhhqvhhIPhhaJcIixcbiAgICBcIuGEjOGFpeGGvOGEh+GFqVwiLFxuICAgIFwi4YSM4YWl4Ya84YSH4YWuXCIsXG4gICAgXCLhhIzhhaXhhrzhhIfhhbVcIixcbiAgICBcIuGEjOGFpeGGvOGEieGFoeGGvFwiLFxuICAgIFwi4YSM4YWl4Ya84YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIzhhaXhhrzhhIvhhalcIixcbiAgICBcIuGEjOGFpeGGvOGEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YWl4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhIzhhaXhhrzhhIzhhbVcIixcbiAgICBcIuGEjOGFpeGGvOGEjuGFtVwiLFxuICAgIFwi4YSM4YWl4Ya84YSS4YWq4Yao4YSS4YW1XCIsXG4gICAgXCLhhIzhhabhhIDhhanhhrxcIixcbiAgICBcIuGEjOGFpuGEgOGFquGEjOGFpeGGt1wiLFxuICAgIFwi4YSM4YWm4YSD4YWi4YSF4YWpXCIsXG4gICAgXCLhhIzhhabhhIbhhanhhqhcIixcbiAgICBcIuGEjOGFpuGEh+GFoeGGr1wiLFxuICAgIFwi4YSM4YWm4YSH4YWl4Ya4XCIsXG4gICAgXCLhhIzhhabhhInhhaHhhrrhhILhhaHhhq9cIixcbiAgICBcIuGEjOGFpuGEi+GFoeGGq1wiLFxuICAgIFwi4YSM4YWm4YSL4YW14YavXCIsXG4gICAgXCLhhIzhhabhhIzhhaHhhqhcIixcbiAgICBcIuGEjOGFpuGEjOGFruGEg+GFqVwiLFxuICAgIFwi4YSM4YWm4YSO4YWu4YavXCIsXG4gICAgXCLhhIzhhabhhJHhha7hhrdcIixcbiAgICBcIuGEjOGFpuGEkuGFoeGGq1wiLFxuICAgIFwi4YSM4YWp4YSA4YWh4YaoXCIsXG4gICAgXCLhhIzhhanhhIDhhaXhhqtcIixcbiAgICBcIuGEjOGFqeGEgOGFs+GGt1wiLFxuICAgIFwi4YSM4YWp4YSA4YW14Ya8XCIsXG4gICAgXCLhhIzhhanhhIbhhafhhrxcIixcbiAgICBcIuGEjOGFqeGEhuGFteGEheGFrVwiLFxuICAgIFwi4YSM4YWp4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIzhhanhhInhhaXhhqtcIixcbiAgICBcIuGEjOGFqeGEi+GFreGGvOGEkuGFtVwiLFxuICAgIFwi4YSM4YWp4YSM4YWl4YavXCIsXG4gICAgXCLhhIzhhanhhIzhhaXhhrxcIixcbiAgICBcIuGEjOGFqeGEjOGFteGGqFwiLFxuICAgIFwi4YSM4YWp4Yar4YSD4YWi4Ya64YSG4YWh4YavXCIsXG4gICAgXCLhhIzhhanhhqvhhIzhhaJcIixcbiAgICBcIuGEjOGFqeGGr+GEi+GFpeGGuFwiLFxuICAgIFwi4YSM4YWp4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIzhhanhhrzhhIDhha1cIixcbiAgICBcIuGEjOGFqeGGvOGEheGFqVwiLFxuICAgIFwi4YSM4YWp4Ya84YSF4YWyXCIsXG4gICAgXCLhhIzhhanhhrzhhInhhanhhIXhhbVcIixcbiAgICBcIuGEjOGFqeGGvOGEi+GFpeGGuOGEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YWp4Ya84YSM4YWp4Ya8XCIsXG4gICAgXCLhhIzhhanhhrzhhJLhhaHhhrhcIixcbiAgICBcIuGEjOGFquGEieGFpeGGqFwiLFxuICAgIFwi4YSM4YWs4YSL4YW14YarXCIsXG4gICAgXCLhhIzhha7hhIDhharhhqvhhIzhhaXhhqhcIixcbiAgICBcIuGEjOGFruGEheGFs+GGt1wiLFxuICAgIFwi4YSM4YWu4YSG4YWh4YavXCIsXG4gICAgXCLhhIzhha7hhIbhhaXhhILhhbVcIixcbiAgICBcIuGEjOGFruGEhuGFpeGGqFwiLFxuICAgIFwi4YSM4YWu4YSG4YWu4YarXCIsXG4gICAgXCLhhIzhha7hhIbhhbXhhqtcIixcbiAgICBcIuGEjOGFruGEh+GFoeGGvFwiLFxuICAgIFwi4YSM4YWu4YSH4YWn4YarXCIsXG4gICAgXCLhhIzhha7hhInhhbXhhqhcIixcbiAgICBcIuGEjOGFruGEi+GFteGGq1wiLFxuICAgIFwi4YSM4YWu4YSL4YW14YavXCIsXG4gICAgXCLhhIzhha7hhIzhhaHhhrxcIixcbiAgICBcIuGEjOGFruGEjOGFpeGGq+GEjOGFoVwiLFxuICAgIFwi4YSM4YWu4YSQ4YWi4YaoXCIsXG4gICAgXCLhhIzhha7hhqvhhIfhhbVcIixcbiAgICBcIuGEjOGFruGGr+GEgOGFpeGEheGFtVwiLFxuICAgIFwi4YSM4YWu4Yav4YSA4YW1XCIsXG4gICAgXCLhhIzhha7hhq/hhIbhha7hhILhhbRcIixcbiAgICBcIuGEjOGFruGGvOGEgOGFoeGGq1wiLFxuICAgIFwi4YSM4YWu4Ya84YSA4YWo4YSH4YWh4Ya84YSJ4YWp4Ya8XCIsXG4gICAgXCLhhIzhha7hhrzhhIDhha7hhqhcIixcbiAgICBcIuGEjOGFruGGvOGEguGFp+GGq1wiLFxuICAgIFwi4YSM4YWu4Ya84YSD4YWh4YarXCIsXG4gICAgXCLhhIzhha7hhrzhhIPhhanhhqhcIixcbiAgICBcIuGEjOGFruGGvOGEh+GFoeGGq1wiLFxuICAgIFwi4YSM4YWu4Ya84YSH4YWuXCIsXG4gICAgXCLhhIzhha7hhrzhhInhhaZcIixcbiAgICBcIuGEjOGFruGGvOGEieGFqeGEgOGFteGEi+GFpeGGuFwiLFxuICAgIFwi4YSM4YWu4Ya84YSJ4YWu4YarXCIsXG4gICAgXCLhhIzhha7hhrzhhIvhhaHhhrxcIixcbiAgICBcIuGEjOGFruGGvOGEi+GFrVwiLFxuICAgIFwi4YSM4YWu4Ya84YSS4YWh4Yao4YSA4YWtXCIsXG4gICAgXCLhhIzhhbPhhqjhhInhhaXhhqhcIixcbiAgICBcIuGEjOGFs+GGqOGEieGFtVwiLFxuICAgIFwi4YSM4YWz4Yav4YSA4YWl4YSL4YWu4Ya3XCIsXG4gICAgXCLhhIzhhbPhhrzhhIDhhaFcIixcbiAgICBcIuGEjOGFs+GGvOGEgOGFpVwiLFxuICAgIFwi4YSM4YWz4Ya84YSA4YWv4YarXCIsXG4gICAgXCLhhIzhhbPhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEjOGFs+GGvOGEieGFplwiLFxuICAgIFwi4YSM4YW14YSA4YWh4YaoXCIsXG4gICAgXCLhhIzhhbXhhIDhhaHhhrhcIixcbiAgICBcIuGEjOGFteGEgOGFp+GGvFwiLFxuICAgIFwi4YSM4YW14YSA4YWz4Yao4YSS4YW1XCIsXG4gICAgXCLhhIzhhbXhhIDhhbPhhrdcIixcbiAgICBcIuGEjOGFteGEgOGFs+GGuFwiLFxuICAgIFwi4YSM4YW14YSC4YWz4Ya8XCIsXG4gICAgXCLhhIzhhbXhhIXhhbPhhrfhhIDhhbXhhq9cIixcbiAgICBcIuGEjOGFteGEheGFteGEieGFoeGGq1wiLFxuICAgIFwi4YSM4YW14YSH4YWh4Ya8XCIsXG4gICAgXCLhhIzhhbXhhIfhha7hhrxcIixcbiAgICBcIuGEjOGFteGEieGFteGGqFwiLFxuICAgIFwi4YSM4YW14YSL4YWn4YaoXCIsXG4gICAgXCLhhIzhhbXhhIvhha7hhIDhhaJcIixcbiAgICBcIuGEjOGFteGEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YW14YSM4YWl4YaoXCIsXG4gICAgXCLhhIzhhbXhhIzhhaXhhrdcIixcbiAgICBcIuGEjOGFteGEjOGFteGGq1wiLFxuICAgIFwi4YSM4YW14YSO4YWu4YavXCIsXG4gICAgXCLhhIzhhbXhhqjhhInhhaXhhqtcIixcbiAgICBcIuGEjOGFteGGqOGEi+GFpeGGuFwiLFxuICAgIFwi4YSM4YW14Yao4YSL4YWv4YarXCIsXG4gICAgXCLhhIzhhbXhhqjhhIzhhaHhhrxcIixcbiAgICBcIuGEjOGFteGGq+GEgOGFs+GGuFwiLFxuICAgIFwi4YSM4YW14Yar4YSD4YWp4Ya8XCIsXG4gICAgXCLhhIzhhbXhhqvhhIXhhalcIixcbiAgICBcIuGEjOGFteGGq+GEheGFrVwiLFxuICAgIFwi4YSM4YW14Yar4YSF4YW1XCIsXG4gICAgXCLhhIzhhbXhhqvhhI3hhaFcIixcbiAgICBcIuGEjOGFteGGq+GEjuGFoeGGr1wiLFxuICAgIFwi4YSM4YW14Yar4YSO4YWu4YavXCIsXG4gICAgXCLhhIzhhbXhhqvhhJDhhanhhrxcIixcbiAgICBcIuGEjOGFteGGq+GEkuGFouGGvFwiLFxuICAgIFwi4YSM4YW14Yav4YSG4YWu4YarXCIsXG4gICAgXCLhhIzhhbXhhq/hhIfhhafhhrxcIixcbiAgICBcIuGEjOGFteGGr+GEieGFpVwiLFxuICAgIFwi4YSM4YW14Ya34YSM4YWh4YaoXCIsXG4gICAgXCLhhIzhhbXhhrjhhIPhhaHhhqtcIixcbiAgICBcIuGEjOGFteGGuOGEi+GFoeGGq1wiLFxuICAgIFwi4YSM4YW14Ya44YSM4YWu4Ya8XCIsXG4gICAgXCLhhI3hhaHhhIzhhbPhhrxcIixcbiAgICBcIuGEjeGFteGEgeGFpeGEgOGFtVwiLFxuICAgIFwi4YSO4YWh4YSC4YWh4Ya3XCIsXG4gICAgXCLhhI7hhaHhhIXhhaHhhIXhhbVcIixcbiAgICBcIuGEjuGFoeGEheGFo+GGvFwiLFxuICAgIFwi4YSO4YWh4YSF4YW14Ya3XCIsXG4gICAgXCLhhI7hhaHhhIfhhafhhq9cIixcbiAgICBcIuGEjuGFoeGEieGFpeGGq1wiLFxuICAgIFwi4YSO4YWh4YSO4YWz4Ya3XCIsXG4gICAgXCLhhI7hhaHhhqjhhIDhhaHhhqhcIixcbiAgICBcIuGEjuGFoeGGq+GEhuGFruGGr1wiLFxuICAgIFwi4YSO4YWh4Yar4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhI7hhaHhhrfhhIDhhaFcIixcbiAgICBcIuGEjuGFoeGGt+GEgOGFteGEheGFs+GGt1wiLFxuICAgIFwi4YSO4YWh4Ya34YSJ4YWiXCIsXG4gICAgXCLhhI7hhaHhhrfhhInhhaXhhqhcIixcbiAgICBcIuGEjuGFoeGGt+GEi+GFp1wiLFxuICAgIFwi4YSO4YWh4Ya34YSL4YWsXCIsXG4gICAgXCLhhI7hhaHhhrfhhIzhhalcIixcbiAgICBcIuGEjuGFoeGGuuGEjOGFoeGGq1wiLFxuICAgIFwi4YSO4YWh4Ya84YSA4YWhXCIsXG4gICAgXCLhhI7hhaHhhrzhhIDhhalcIixcbiAgICBcIuGEjuGFoeGGvOGEgOGFrlwiLFxuICAgIFwi4YSO4YWh4Ya84YSG4YWu4YarXCIsXG4gICAgXCLhhI7hhaHhhrzhhIfhhaHhhqlcIixcbiAgICBcIuGEjuGFoeGGvOGEjOGFoeGGqFwiLFxuICAgIFwi4YSO4YWh4Ya84YSM4YWpXCIsXG4gICAgXCLhhI7hhaLhhILhhaXhhq9cIixcbiAgICBcIuGEjuGFouGEjOGFpeGGt1wiLFxuICAgIFwi4YSO4YWi4Yao4YSA4YWh4YSH4YWh4Ya8XCIsXG4gICAgXCLhhI7hhaLhhqjhhIfhhaHhhrxcIixcbiAgICBcIuGEjuGFouGGqOGEieGFoeGGvFwiLFxuICAgIFwi4YSO4YWi4Yao4YSL4YW14Ya3XCIsXG4gICAgXCLhhI7hhaLhhrfhhJHhhbXhhIvhhaXhhqtcIixcbiAgICBcIuGEjuGFpeGEh+GFpeGGr1wiLFxuICAgIFwi4YSO4YWl4YSL4YWz4Ya3XCIsXG4gICAgXCLhhI7hhaXhhqvhhIDhha7hhqhcIixcbiAgICBcIuGEjuGFpeGGq+GEg+GFruGGvFwiLFxuICAgIFwi4YSO4YWl4Yar4YSM4YWh4Ya8XCIsXG4gICAgXCLhhI7hhaXhhqvhhIzhhaJcIixcbiAgICBcIuGEjuGFpeGGq+GEjuGFpeGGq+GEkuGFtVwiLFxuICAgIFwi4YSO4YWl4Yav4YSD4YWpXCIsXG4gICAgXCLhhI7hhaXhhq/hhIzhhaXhhJLhhbVcIixcbiAgICBcIuGEjuGFpeGGr+GEkuGFoeGGqFwiLFxuICAgIFwi4YSO4YWl4Ya64YSC4YWh4YavXCIsXG4gICAgXCLhhI7hhaXhhrrhhI3hhaJcIixcbiAgICBcIuGEjuGFpeGGvOGEguGFp+GGq1wiLFxuICAgIFwi4YSO4YWl4Ya84YSH4YWh4YSM4YW1XCIsXG4gICAgXCLhhI7hhaXhhrzhhInhhalcIixcbiAgICBcIuGEjuGFpeGGvOGEjuGFruGGq1wiLFxuICAgIFwi4YSO4YWm4YSA4YWoXCIsXG4gICAgXCLhhI7hhabhhIXhhafhhqhcIixcbiAgICBcIuGEjuGFpuGEi+GFqeGGq1wiLFxuICAgIFwi4YSO4YWm4YSL4YWy4YaoXCIsXG4gICAgXCLhhI7hhabhhIzhha7hhrxcIixcbiAgICBcIuGEjuGFpuGEkuGFpeGGt1wiLFxuICAgIFwi4YSO4YWp4YSD4YWz4Ya84YSS4YWh4Yao4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhI7hhanhhIfhhaHhhqtcIixcbiAgICBcIuGEjuGFqeGEh+GFoeGGuFwiLFxuICAgIFwi4YSO4YWp4YSJ4YWh4Ya84YSS4YWqXCIsXG4gICAgXCLhhI7hhanhhInhha7hhqtcIixcbiAgICBcIuGEjuGFqeGEi+GFp+GEheGFs+GGt1wiLFxuICAgIFwi4YSO4YWp4YSL4YWv4YarXCIsXG4gICAgXCLhhI7hhanhhIzhhaXhhILhhafhhqhcIixcbiAgICBcIuGEjuGFqeGEjOGFpeGGt1wiLFxuICAgIFwi4YSO4YWp4YSO4YWl4Ya8XCIsXG4gICAgXCLhhI7hhanhhI/hhanhhq/hhIXhhbXhhrpcIixcbiAgICBcIuGEjuGFqeGGuuGEh+GFruGGr1wiLFxuICAgIFwi4YSO4YWp4Ya84YSA4YWh4YaoXCIsXG4gICAgXCLhhI7hhanhhrzhhIXhhbVcIixcbiAgICBcIuGEjuGFqeGGvOGEjOGFoeGGvFwiLFxuICAgIFwi4YSO4YWq4Yav4YSL4YWn4Ya8XCIsXG4gICAgXCLhhI7hhazhhIDhhbPhhqtcIixcbiAgICBcIuGEjuGFrOGEieGFoeGGvFwiLFxuICAgIFwi4YSO4YWs4YSJ4YWl4YarXCIsXG4gICAgXCLhhI7hhazhhInhhbXhhqtcIixcbiAgICBcIuGEjuGFrOGEi+GFoeGGqFwiLFxuICAgIFwi4YSO4YWs4YSM4YWp4Ya8XCIsXG4gICAgXCLhhI7hha7hhInhhaXhhqhcIixcbiAgICBcIuGEjuGFruGEi+GFpeGGqFwiLFxuICAgIFwi4YSO4YWu4YSM4YW14YarXCIsXG4gICAgXCLhhI7hha7hhI7hhaXhhqtcIixcbiAgICBcIuGEjuGFruGEjuGFs+GGqFwiLFxuICAgIFwi4YSO4YWu4Yao4YSA4YWuXCIsXG4gICAgXCLhhI7hha7hhqjhhInhhalcIixcbiAgICBcIuGEjuGFruGGqOGEjOGFplwiLFxuICAgIFwi4YSO4YWu4Yao4YSS4YWhXCIsXG4gICAgXCLhhI7hha7hhq/hhIDhhbPhhqtcIixcbiAgICBcIuGEjuGFruGGr+GEh+GFoeGGr1wiLFxuICAgIFwi4YSO4YWu4Yav4YSJ4YWh4YarXCIsXG4gICAgXCLhhI7hha7hhq/hhInhhbXhhqtcIixcbiAgICBcIuGEjuGFruGGr+GEi+GFp+GGq1wiLFxuICAgIFwi4YSO4YWu4Yav4YSL4YW14Ya4XCIsXG4gICAgXCLhhI7hha7hhq/hhIzhhaHhhrxcIixcbiAgICBcIuGEjuGFruGGr+GEkeGFoeGGq1wiLFxuICAgIFwi4YSO4YWu4Ya84YSA4YWn4YaoXCIsXG4gICAgXCLhhI7hha7hhrzhhIDhhalcIixcbiAgICBcIuGEjuGFruGGvOGEg+GFqeGGr1wiLFxuICAgIFwi4YSO4YWu4Ya84YSH4YWu4Yar4YSS4YW1XCIsXG4gICAgXCLhhI7hha7hhrzhhI7hhaXhhrzhhIPhhalcIixcbiAgICBcIuGEjuGFseGEi+GFpeGGuFwiLFxuICAgIFwi4YSO4YWx4YSM4YW14YaoXCIsXG4gICAgXCLhhI7hhbHhhJLhhaPhhrxcIixcbiAgICBcIuGEjuGFteGEi+GFo+GGqFwiLFxuICAgIFwi4YSO4YW14Yar4YSA4YWuXCIsXG4gICAgXCLhhI7hhbXhhqvhhI7hhaXhhqhcIixcbiAgICBcIuGEjuGFteGGr+GEieGFteGGuFwiLFxuICAgIFwi4YSO4YW14Yav4YSL4YWv4YavXCIsXG4gICAgXCLhhI7hhbXhhq/hhJHhhaHhhqtcIixcbiAgICBcIuGEjuGFteGGt+GEg+GFolwiLFxuICAgIFwi4YSO4YW14Ya34YSG4YWu4YaoXCIsXG4gICAgXCLhhI7hhbXhhrfhhInhhbXhhq9cIixcbiAgICBcIuGEjuGFteGGuuGEieGFqeGGr1wiLFxuICAgIFwi4YSO4YW14Ya84YSO4YWh4YarXCIsXG4gICAgXCLhhI/hhaHhhIbhhabhhIXhhaFcIixcbiAgICBcIuGEj+GFoeGEi+GFruGGq+GEkOGFpVwiLFxuICAgIFwi4YSP4YWh4Yav4YSA4YWu4Yao4YSJ4YWuXCIsXG4gICAgXCLhhI/hhaLhhIXhhbXhhqjhhJDhhaVcIixcbiAgICBcIuGEj+GFouGGt+GEkeGFpeGEieGFs1wiLFxuICAgIFwi4YSP4YWi4Ya34YSR4YWm4YSL4YW14YarXCIsXG4gICAgXCLhhI/hhaXhhJDhhbPhhqtcIixcbiAgICBcIuGEj+GFpeGGq+GEg+GFteGEieGFp+GGq1wiLFxuICAgIFwi4YSP4YWl4Yav4YSF4YWlXCIsXG4gICAgXCLhhI/hhaXhhrfhhJHhhbLhhJDhhaVcIixcbiAgICBcIuGEj+GFqeGEgeGFteGEheGFtVwiLFxuICAgIFwi4YSP4YWp4YSG4YW14YSD4YW1XCIsXG4gICAgXCLhhI/hhanhhqvhhInhhaXhhJDhhbNcIixcbiAgICBcIuGEj+GFqeGGr+GEheGFoVwiLFxuICAgIFwi4YSP4YWp4Ya34YSR4YWz4Yav4YSF4YWm4Yao4YSJ4YWzXCIsXG4gICAgXCLhhI/hhanhhrzhhILhhaHhhIbhha7hhq9cIixcbiAgICBcIuGEj+GFq+GEgOGFoeGGt1wiLFxuICAgIFwi4YSP4YWu4YSD4YWm4YSQ4YWhXCIsXG4gICAgXCLhhI/hhbPhhIXhhbXhhrdcIixcbiAgICBcIuGEj+GFs+GGq+GEgOGFteGGr1wiLFxuICAgIFwi4YSP4YWz4Yar4YSE4YWh4YavXCIsXG4gICAgXCLhhI/hhbPhhqvhhInhhanhhIXhhbVcIixcbiAgICBcIuGEj+GFs+GGq+GEi+GFoeGEg+GFs+GGr1wiLFxuICAgIFwi4YSP4YWz4Yar4YSL4YWl4YSG4YWl4YSC4YW1XCIsXG4gICAgXCLhhI/hhbPhhqvhhIvhhbXhhq9cIixcbiAgICBcIuGEj+GFs+GGq+GEjOGFpeGGr1wiLFxuICAgIFwi4YSP4YWz4Yav4YSF4YWi4YSJ4YW14YaoXCIsXG4gICAgXCLhhI/hhbPhhq/hhIXhhaXhhrhcIixcbiAgICBcIuGEj+GFteGGr+GEheGFqVwiLFxuICAgIFwi4YSQ4YWh4YSL4YW14Ya4XCIsXG4gICAgXCLhhJDhhaHhhIzhhaHhhIDhhbVcIixcbiAgICBcIuGEkOGFoeGGqOGEgOGFrlwiLFxuICAgIFwi4YSQ4YWh4Yao4YSM4YWhXCIsXG4gICAgXCLhhJDhhaHhhqvhhInhhaLhhrxcIixcbiAgICBcIuGEkOGFouGEgOGFr+GGq+GEg+GFqVwiLFxuICAgIFwi4YSQ4YWi4YSL4YWj4Ya8XCIsXG4gICAgXCLhhJDhhaLhhJHhha7hhrxcIixcbiAgICBcIuGEkOGFouGGqOGEieGFtVwiLFxuICAgIFwi4YSQ4YWi4Yav4YSF4YWl4Yar4YSQ4YWzXCIsXG4gICAgXCLhhJDhhaXhhILhhaXhhq9cIixcbiAgICBcIuGEkOGFpeGEhuGFteGEguGFpeGGr1wiLFxuICAgIFwi4YSQ4YWm4YSC4YW14YSJ4YWzXCIsXG4gICAgXCLhhJDhhabhhInhhbPhhJDhhbNcIixcbiAgICBcIuGEkOGFpuGEi+GFteGEh+GFs+GGr1wiLFxuICAgIFwi4YSQ4YWm4Yav4YSF4YWm4YSH4YW14YSM4YWl4YarXCIsXG4gICAgXCLhhJDhhanhhIXhhanhhqtcIixcbiAgICBcIuGEkOGFqeGEhuGFoeGEkOGFqVwiLFxuICAgIFwi4YSQ4YWp4YSL4YWt4YSL4YW14YavXCIsXG4gICAgXCLhhJDhhanhhrzhhIDhhahcIixcbiAgICBcIuGEkOGFqeGGvOGEgOGFqlwiLFxuICAgIFwi4YSQ4YWp4Ya84YSF4YWpXCIsXG4gICAgXCLhhJDhhanhhrzhhInhhbXhhqtcIixcbiAgICBcIuGEkOGFqeGGvOGEi+GFp+GGqFwiLFxuICAgIFwi4YSQ4YWp4Ya84YSL4YW14YavXCIsXG4gICAgXCLhhJDhhanhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEkOGFqeGGvOGEjOGFplwiLFxuICAgIFwi4YSQ4YWp4Ya84YSM4YWz4Ya8XCIsXG4gICAgXCLhhJDhhanhhrzhhJLhhaHhhrhcIixcbiAgICBcIuGEkOGFqeGGvOGEkuGFqlwiLFxuICAgIFwi4YSQ4YWs4YSA4YWz4YarXCIsXG4gICAgXCLhhJDhhazhhIvhha/hhqtcIixcbiAgICBcIuGEkOGFrOGEjOGFteGGqOGEgOGFs+GGt1wiLFxuICAgIFwi4YSQ4YWx4YSA4YW14Ya3XCIsXG4gICAgXCLhhJDhhbPhhIXhhaXhhqhcIixcbiAgICBcIuGEkOGFs+GGqOGEgOGFs+GGuFwiLFxuICAgIFwi4YSQ4YWz4Yao4YSH4YWn4YavXCIsXG4gICAgXCLhhJDhhbPhhqjhhInhhaXhhrxcIixcbiAgICBcIuGEkOGFs+GGqOGEieGFrlwiLFxuICAgIFwi4YSQ4YWz4Yao4YSM4YW14Ya8XCIsXG4gICAgXCLhhJDhhbPhhqjhhJLhhbVcIixcbiAgICBcIuGEkOGFs+GGq+GEkOGFs+GGq+GEkuGFtVwiLFxuICAgIFwi4YSQ4YW14YSJ4YWn4YSO4YWzXCIsXG4gICAgXCLhhJHhhaHhhIXhhaHhhqvhhInhhaLhhqhcIixcbiAgICBcIuGEkeGFoeGEi+GFteGGr1wiLFxuICAgIFwi4YSR4YWh4YSO4YWu4Yav4YSJ4YWpXCIsXG4gICAgXCLhhJHhhaHhhqvhhIDhhafhhq9cIixcbiAgICBcIuGEkeGFoeGGq+GEg+GFoeGGq1wiLFxuICAgIFwi4YSR4YWh4Yar4YSG4YWiXCIsXG4gICAgXCLhhJHhhaHhhqvhhInhhaFcIixcbiAgICBcIuGEkeGFoeGGr+GEieGFteGGuFwiLFxuICAgIFwi4YSR4YWh4Yav4YSL4YWv4YavXCIsXG4gICAgXCLhhJHhhaHhhrjhhInhhanhhrxcIixcbiAgICBcIuGEkeGFouGEieGFp+GGq1wiLFxuICAgIFwi4YSR4YWi4Yao4YSJ4YWzXCIsXG4gICAgXCLhhJHhhaLhhqjhhInhhbXhhIbhhbXhhq/hhIXhhbVcIixcbiAgICBcIuGEkeGFouGGq+GEkOGFtVwiLFxuICAgIFwi4YSR4YWl4YSJ4YWm4Yar4YSQ4YWzXCIsXG4gICAgXCLhhJHhhabhhIvhhbXhhqvhhJDhhbNcIixcbiAgICBcIuGEkeGFp+GGq+GEgOGFp+GGq1wiLFxuICAgIFwi4YSR4YWn4Yar4YSL4YW0XCIsXG4gICAgXCLhhJHhhafhhqvhhIzhhbVcIixcbiAgICBcIuGEkeGFp+GGq+GEkuGFtVwiLFxuICAgIFwi4YSR4YWn4Ya84YSA4YWhXCIsXG4gICAgXCLhhJHhhafhhrzhhIDhhbLhhqtcIixcbiAgICBcIuGEkeGFp+GGvOGEieGFouGGvFwiLFxuICAgIFwi4YSR4YWn4Ya84YSJ4YWpXCIsXG4gICAgXCLhhJHhhafhhrzhhIvhhaPhhrxcIixcbiAgICBcIuGEkeGFp+GGvOGEi+GFteGGr1wiLFxuICAgIFwi4YSR4YWn4Ya84YSS4YWqXCIsXG4gICAgXCLhhJHhhanhhInhhbPhhJDhhaVcIixcbiAgICBcIuGEkeGFqeGEi+GFteGGq+GEkOGFs1wiLFxuICAgIFwi4YSR4YWp4YSM4YWh4Ya8XCIsXG4gICAgXCLhhJHhhanhhJLhhaHhhrdcIixcbiAgICBcIuGEkeGFreGEhuGFp+GGq1wiLFxuICAgIFwi4YSR4YWt4YSM4YWl4Ya8XCIsXG4gICAgXCLhhJHhha3hhIzhha7hhqtcIixcbiAgICBcIuGEkeGFreGEkuGFp+GGq1wiLFxuICAgIFwi4YSR4YWu4Ya34YSG4YWp4YaoXCIsXG4gICAgXCLhhJHhha7hhrfhhIzhhbXhhq9cIixcbiAgICBcIuGEkeGFruGGvOGEgOGFp+GGvFwiLFxuICAgIFwi4YSR4YWu4Ya84YSJ4YWp4YaoXCIsXG4gICAgXCLhhJHhha7hhrzhhInhhbPhhrhcIixcbiAgICBcIuGEkeGFs+GEheGFoeGGvOGEieGFs1wiLFxuICAgIFwi4YSR4YWz4YSF4YW14Yar4YSQ4YWlXCIsXG4gICAgXCLhhJHhhbPhhq/hhIXhhaHhhInhhbPhhJDhhbXhhqhcIixcbiAgICBcIuGEkeGFteGEgOGFqeGGq1wiLFxuICAgIFwi4YSR4YW14YSG4YWh4Ya8XCIsXG4gICAgXCLhhJHhhbXhhIvhhaHhhILhhalcIixcbiAgICBcIuGEkeGFteGGr+GEheGFs+GGt1wiLFxuICAgIFwi4YSR4YW14Yav4YSJ4YWuXCIsXG4gICAgXCLhhJHhhbXhhq/hhIvhha1cIixcbiAgICBcIuGEkeGFteGGr+GEjOGFoVwiLFxuICAgIFwi4YSR4YW14Yav4YSQ4YWp4Ya8XCIsXG4gICAgXCLhhJHhhbXhhrzhhIDhhahcIixcbiAgICBcIuGEkuGFoeGEguGFs+GEguGFteGGt1wiLFxuICAgIFwi4YSS4YWh4YSC4YWz4YavXCIsXG4gICAgXCLhhJLhhaHhhIPhhbPhhIvhhbDhhIvhhaVcIixcbiAgICBcIuGEkuGFoeGEheGFruGGuuGEh+GFoeGGt1wiLFxuICAgIFwi4YSS4YWh4YSH4YWh4Yar4YSA4YW1XCIsXG4gICAgXCLhhJLhhaHhhInhha7hhqjhhIzhhbXhhrhcIixcbiAgICBcIuGEkuGFoeGEieGFruGGq1wiLFxuICAgIFwi4YSS4YWh4YSL4YWn4YSQ4YWz4YarXCIsXG4gICAgXCLhhJLhhaHhhIzhhbXhhIbhhaHhhqtcIixcbiAgICBcIuGEkuGFoeGEjuGFpeGGq1wiLFxuICAgIFwi4YSS4YWh4YSR4YWu4Ya3XCIsXG4gICAgXCLhhJLhhaHhhJHhhbXhhq9cIixcbiAgICBcIuGEkuGFoeGGqOGEgOGFqlwiLFxuICAgIFwi4YSS4YWh4Yao4YSA4YWtXCIsXG4gICAgXCLhhJLhhaHhhqjhhIDhhbPhhrhcIixcbiAgICBcIuGEkuGFoeGGqOGEgOGFtVwiLFxuICAgIFwi4YSS4YWh4Yao4YSC4YWn4YarXCIsXG4gICAgXCLhhJLhhaHhhqjhhIXhhafhhqhcIixcbiAgICBcIuGEkuGFoeGGqOGEh+GFpeGGq1wiLFxuICAgIFwi4YSS4YWh4Yao4YSH4YWu4YSG4YWpXCIsXG4gICAgXCLhhJLhhaHhhqjhhIfhhbVcIixcbiAgICBcIuGEkuGFoeGGqOGEieGFouGGvFwiLFxuICAgIFwi4YSS4YWh4Yao4YSJ4YWu4YavXCIsXG4gICAgXCLhhJLhhaHhhqjhhInhhbPhhrhcIixcbiAgICBcIuGEkuGFoeGGqOGEi+GFreGGvOGEkeGFruGGt1wiLFxuICAgIFwi4YSS4YWh4Yao4YSL4YWv4YarXCIsXG4gICAgXCLhhJLhhaHhhqjhhIvhhbFcIixcbiAgICBcIuGEkuGFoeGGqOGEjOGFoVwiLFxuICAgIFwi4YSS4YWh4Yao4YSM4YWl4Ya3XCIsXG4gICAgXCLhhJLhhaHhhqvhhIDhhahcIixcbiAgICBcIuGEkuGFoeGGq+GEgOGFs+GGr1wiLFxuICAgIFwi4YSS4YWh4Yar4YSB4YWl4YSH4YWl4Yar4YSL4YWmXCIsXG4gICAgXCLhhJLhhaHhhqvhhILhhaHhhr1cIixcbiAgICBcIuGEkuGFoeGGq+GEguGFruGGq1wiLFxuICAgIFwi4YSS4YWh4Yar4YSD4YWp4Ya84YSL4YWh4YarXCIsXG4gICAgXCLhhJLhhaHhhqvhhIThhaJcIixcbiAgICBcIuGEkuGFoeGGq+GEheGFoeGEieGFoeGGq1wiLFxuICAgIFwi4YSS4YWh4Yar4YSG4YWh4YSD4YW1XCIsXG4gICAgXCLhhJLhhaHhhqvhhIbhha7hhqtcIixcbiAgICBcIuGEkuGFoeGGq+GEh+GFpeGGq1wiLFxuICAgIFwi4YSS4YWh4Yar4YSH4YWp4YaoXCIsXG4gICAgXCLhhJLhhaHhhqvhhInhhbXhhqhcIixcbiAgICBcIuGEkuGFoeGGq+GEi+GFp+GEheGFs+GGt1wiLFxuICAgIFwi4YSS4YWh4Yar4YSN4YWp4YaoXCIsXG4gICAgXCLhhJLhhaHhhq/hhIbhhaXhhILhhbVcIixcbiAgICBcIuGEkuGFoeGGr+GEi+GFoeGEh+GFpeGEjOGFtVwiLFxuICAgIFwi4YSS4YWh4Yav4YSL4YW14YarXCIsXG4gICAgXCLhhJLhhaHhhrfhhIHhhaZcIixcbiAgICBcIuGEkuGFoeGGt+GEh+GFruGEheGFqVwiLFxuICAgIFwi4YSS4YWh4Ya44YSA4YWn4YaoXCIsXG4gICAgXCLhhJLhhaHhhrjhhIXhhbXhhIzhhaXhhqhcIixcbiAgICBcIuGEkuGFoeGGvOGEgOGFqeGGvFwiLFxuICAgIFwi4YSS4YWh4Ya84YSA4YWuXCIsXG4gICAgXCLhhJLhhaHhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEkuGFoeGGvOGEi+GFtFwiLFxuICAgIFwi4YSS4YWi4YSA4YWn4YavXCIsXG4gICAgXCLhhJLhhaLhhIDhha7hhqtcIixcbiAgICBcIuGEkuGFouGEg+GFoeGGuFwiLFxuICAgIFwi4YSS4YWi4YSD4YWh4Ya8XCIsXG4gICAgXCLhhJLhhaLhhIbhha7hhq9cIixcbiAgICBcIuGEkuGFouGEieGFpeGGqFwiLFxuICAgIFwi4YSS4YWi4YSJ4YWl4YavXCIsXG4gICAgXCLhhJLhhaLhhInhha7hhIvhha3hhqjhhIzhhaHhhrxcIixcbiAgICBcIuGEkuGFouGEi+GFoeGGq1wiLFxuICAgIFwi4YSS4YWi4Yao4YSJ4YW14Ya3XCIsXG4gICAgXCLhhJLhhaLhhqvhhIPhhbPhhIfhhaLhhqhcIixcbiAgICBcIuGEkuGFouGGt+GEh+GFpeGEgOGFpVwiLFxuICAgIFwi4YSS4YWi4Ya64YSH4YWn4YeAXCIsXG4gICAgXCLhhJLhhaLhhrrhhInhhaHhhq9cIixcbiAgICBcIuGEkuGFouGGvOGEg+GFqeGGvFwiLFxuICAgIFwi4YSS4YWi4Ya84YSH4YWp4YaoXCIsXG4gICAgXCLhhJLhhaLhhrzhhInhhaFcIixcbiAgICBcIuGEkuGFouGGvOGEi+GFruGGq1wiLFxuICAgIFwi4YSS4YWi4Ya84YSL4YWxXCIsXG4gICAgXCLhhJLhhaPhhrzhhIDhhbVcIixcbiAgICBcIuGEkuGFo+GGvOGEieGFoeGGvFwiLFxuICAgIFwi4YSS4YWj4Ya84YSJ4YWuXCIsXG4gICAgXCLhhJLhhaXhhIXhhaHhhqhcIixcbiAgICBcIuGEkuGFpeGEi+GFreGGvFwiLFxuICAgIFwi4YSS4YWm4Yav4YSA4YW1XCIsXG4gICAgXCLhhJLhhafhhqvhhIDhharhhqtcIixcbiAgICBcIuGEkuGFp+GGq+GEgOGFs+GGt1wiLFxuICAgIFwi4YSS4YWn4Yar4YSD4YWiXCIsXG4gICAgXCLhhJLhhafhhqvhhInhhaHhhrxcIixcbiAgICBcIuGEkuGFp+GGq+GEieGFteGGr1wiLFxuICAgIFwi4YSS4YWn4Yar4YSM4YWh4Ya8XCIsXG4gICAgXCLhhJLhhafhhqvhhIzhhaJcIixcbiAgICBcIuGEkuGFp+GGq+GEjOGFtVwiLFxuICAgIFwi4YSS4YWn4Yav4YSL4YWi4YaoXCIsXG4gICAgXCLhhJLhhafhhrjhhIXhhafhhqhcIixcbiAgICBcIuGEkuGFp+GGvOGEh+GFrlwiLFxuICAgIFwi4YSS4YWn4Ya84YSJ4YWhXCIsXG4gICAgXCLhhJLhhafhhrzhhInhha5cIixcbiAgICBcIuGEkuGFp+GGvOGEieGFteGGqFwiLFxuICAgIFwi4YSS4YWn4Ya84YSM4YWmXCIsXG4gICAgXCLhhJLhhafhhrzhhJDhhaJcIixcbiAgICBcIuGEkuGFp+GGvOGEkeGFp+GGq1wiLFxuICAgIFwi4YSS4YWo4YSQ4YWi4YaoXCIsXG4gICAgXCLhhJLhhanhhIDhhbXhhInhhbXhhrdcIixcbiAgICBcIuGEkuGFqeGEguGFoeGGt1wiLFxuICAgIFwi4YSS4YWp4YSF4YWh4Ya84YSL4YW1XCIsXG4gICAgXCLhhJLhhanhhIfhhaHhhqhcIixcbiAgICBcIuGEkuGFqeGEkOGFpuGGr1wiLFxuICAgIFwi4YSS4YWp4YSS4YWz4Ya4XCIsXG4gICAgXCLhhJLhhanhhqjhhInhhbVcIixcbiAgICBcIuGEkuGFqeGGr+GEheGFqVwiLFxuICAgIFwi4YSS4YWp4Ya34YSR4YWm4YSL4YW14YSM4YW1XCIsXG4gICAgXCLhhJLhhanhhrzhhIfhhalcIixcbiAgICBcIuGEkuGFqeGGvOGEieGFrlwiLFxuICAgIFwi4YSS4YWp4Ya84YSO4YWhXCIsXG4gICAgXCLhhJLhharhhIbhhafhhqtcIixcbiAgICBcIuGEkuGFquGEh+GFruGGq1wiLFxuICAgIFwi4YSS4YWq4YSJ4YWh4YavXCIsXG4gICAgXCLhhJLhharhhIvhha3hhIvhhbXhhq9cIixcbiAgICBcIuGEkuGFquGEjOGFoeGGvFwiLFxuICAgIFwi4YSS4YWq4YSS4YWh4YaoXCIsXG4gICAgXCLhhJLhharhhqjhhIfhhalcIixcbiAgICBcIuGEkuGFquGGqOGEi+GFteGGq1wiLFxuICAgIFwi4YSS4YWq4Yao4YSM4YWh4Ya8XCIsXG4gICAgXCLhhJLhharhhqjhhIzhhaXhhrxcIixcbiAgICBcIuGEkuGFquGGq+GEgOGFoeGGuFwiLFxuICAgIFwi4YSS4YWq4Yar4YSA4YWn4Ya8XCIsXG4gICAgXCLhhJLhharhhqvhhIvhhafhhrxcIixcbiAgICBcIuGEkuGFquGGq+GEi+GFsuGGr1wiLFxuICAgIFwi4YSS4YWq4Yar4YSM4YWhXCIsXG4gICAgXCLhhJLhharhhq/hhIDhhbVcIixcbiAgICBcIuGEkuGFquGGr+GEg+GFqeGGvFwiLFxuICAgIFwi4YSS4YWq4Yav4YSH4YWh4Yav4YSS4YW1XCIsXG4gICAgXCLhhJLhharhhq/hhIvhha3hhrxcIixcbiAgICBcIuGEkuGFquGGr+GEjeGFoeGGqFwiLFxuICAgIFwi4YSS4YWs4YSA4YWn4YarXCIsXG4gICAgXCLhhJLhhazhhIDhharhhqtcIixcbiAgICBcIuGEkuGFrOGEh+GFqeGGqFwiLFxuICAgIFwi4YSS4YWs4YSJ4YWi4YaoXCIsXG4gICAgXCLhhJLhhazhhIvhha/hhqtcIixcbiAgICBcIuGEkuGFrOGEjOGFoeGGvFwiLFxuICAgIFwi4YSS4YWs4YSM4YWl4YarXCIsXG4gICAgXCLhhJLhhazhhrrhhInhha5cIixcbiAgICBcIuGEkuGFrOGGvOGEg+GFoeGGq+GEh+GFqeGEg+GFqVwiLFxuICAgIFwi4YSS4YWt4YSL4YWy4Yav4YSM4YWl4YaoXCIsXG4gICAgXCLhhJLhha7hhIfhhaHhhqtcIixcbiAgICBcIuGEkuGFruGEjuGFruGGuuGEgOGFoeGEheGFrlwiLFxuICAgIFwi4YSS4YWu4Yar4YSF4YWn4YarXCIsXG4gICAgXCLhhJLhha/hhq/hhIrhhbXhhqtcIixcbiAgICBcIuGEkuGFsuGEieGFteGGqFwiLFxuICAgIFwi4YSS4YWy4YSL4YW14YavXCIsXG4gICAgXCLhhJLhhbLhhrzhhILhhaJcIixcbiAgICBcIuGEkuGFs+GEheGFs+GGt1wiLFxuICAgIFwi4YSS4YWz4Yao4YSH4YWi4YaoXCIsXG4gICAgXCLhhJLhhbPhhqjhhIvhhbXhhqtcIixcbiAgICBcIuGEkuGFs+GGq+GEjOGFpeGGqFwiLFxuICAgIFwi4YSS4YWz4Yar4YSS4YW1XCIsXG4gICAgXCLhhJLhhbPhhrzhhIbhhbVcIixcbiAgICBcIuGEkuGFs+GGvOGEh+GFruGGq1wiLFxuICAgIFwi4YSS4YW04YSA4YWp4YaoXCIsXG4gICAgXCLhhJLhhbThhIbhhaHhhrxcIixcbiAgICBcIuGEkuGFtOGEieGFouGGvFwiLFxuICAgIFwi4YSS4YW04Yar4YSJ4YWi4YaoXCIsXG4gICAgXCLhhJLhhbXhhrfhhIHhhaXhhrpcIlxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwiYcyBYmFjb1wiLFxuICAgIFwiYWJkb21lblwiLFxuICAgIFwiYWJlamFcIixcbiAgICBcImFiaWVydG9cIixcbiAgICBcImFib2dhZG9cIixcbiAgICBcImFib25vXCIsXG4gICAgXCJhYm9ydG9cIixcbiAgICBcImFicmF6b1wiLFxuICAgIFwiYWJyaXJcIixcbiAgICBcImFidWVsb1wiLFxuICAgIFwiYWJ1c29cIixcbiAgICBcImFjYWJhclwiLFxuICAgIFwiYWNhZGVtaWFcIixcbiAgICBcImFjY2Vzb1wiLFxuICAgIFwiYWNjaW/MgW5cIixcbiAgICBcImFjZWl0ZVwiLFxuICAgIFwiYWNlbGdhXCIsXG4gICAgXCJhY2VudG9cIixcbiAgICBcImFjZXB0YXJcIixcbiAgICBcImHMgWNpZG9cIixcbiAgICBcImFjbGFyYXJcIixcbiAgICBcImFjbmXMgVwiLFxuICAgIFwiYWNvZ2VyXCIsXG4gICAgXCJhY29zb1wiLFxuICAgIFwiYWN0aXZvXCIsXG4gICAgXCJhY3RvXCIsXG4gICAgXCJhY3RyaXpcIixcbiAgICBcImFjdHVhclwiLFxuICAgIFwiYWN1ZGlyXCIsXG4gICAgXCJhY3VlcmRvXCIsXG4gICAgXCJhY3VzYXJcIixcbiAgICBcImFkaWN0b1wiLFxuICAgIFwiYWRtaXRpclwiLFxuICAgIFwiYWRvcHRhclwiLFxuICAgIFwiYWRvcm5vXCIsXG4gICAgXCJhZHVhbmFcIixcbiAgICBcImFkdWx0b1wiLFxuICAgIFwiYWXMgXJlb1wiLFxuICAgIFwiYWZlY3RhclwiLFxuICAgIFwiYWZpY2lvzIFuXCIsXG4gICAgXCJhZmluYXJcIixcbiAgICBcImFmaXJtYXJcIixcbiAgICBcImHMgWdpbFwiLFxuICAgIFwiYWdpdGFyXCIsXG4gICAgXCJhZ29uacyBYVwiLFxuICAgIFwiYWdvc3RvXCIsXG4gICAgXCJhZ290YXJcIixcbiAgICBcImFncmVnYXJcIixcbiAgICBcImFncmlvXCIsXG4gICAgXCJhZ3VhXCIsXG4gICAgXCJhZ3Vkb1wiLFxuICAgIFwiYcyBZ3VpbGFcIixcbiAgICBcImFndWphXCIsXG4gICAgXCJhaG9nb1wiLFxuICAgIFwiYWhvcnJvXCIsXG4gICAgXCJhaXJlXCIsXG4gICAgXCJhaXNsYXJcIixcbiAgICBcImFqZWRyZXpcIixcbiAgICBcImFqZW5vXCIsXG4gICAgXCJhanVzdGVcIixcbiAgICBcImFsYWNyYcyBblwiLFxuICAgIFwiYWxhbWJyZVwiLFxuICAgIFwiYWxhcm1hXCIsXG4gICAgXCJhbGJhXCIsXG4gICAgXCJhzIFsYnVtXCIsXG4gICAgXCJhbGNhbGRlXCIsXG4gICAgXCJhbGRlYVwiLFxuICAgIFwiYWxlZ3JlXCIsXG4gICAgXCJhbGVqYXJcIixcbiAgICBcImFsZXJ0YVwiLFxuICAgIFwiYWxldGFcIixcbiAgICBcImFsZmlsZXJcIixcbiAgICBcImFsZ2FcIixcbiAgICBcImFsZ29kb8yBblwiLFxuICAgIFwiYWxpYWRvXCIsXG4gICAgXCJhbGllbnRvXCIsXG4gICAgXCJhbGl2aW9cIixcbiAgICBcImFsbWFcIixcbiAgICBcImFsbWVqYVwiLFxuICAgIFwiYWxtacyBYmFyXCIsXG4gICAgXCJhbHRhclwiLFxuICAgIFwiYWx0ZXphXCIsXG4gICAgXCJhbHRpdm9cIixcbiAgICBcImFsdG9cIixcbiAgICBcImFsdHVyYVwiLFxuICAgIFwiYWx1bW5vXCIsXG4gICAgXCJhbHphclwiLFxuICAgIFwiYW1hYmxlXCIsXG4gICAgXCJhbWFudGVcIixcbiAgICBcImFtYXBvbGFcIixcbiAgICBcImFtYXJnb1wiLFxuICAgIFwiYW1hc2FyXCIsXG4gICAgXCJhzIFtYmFyXCIsXG4gICAgXCJhzIFtYml0b1wiLFxuICAgIFwiYW1lbm9cIixcbiAgICBcImFtaWdvXCIsXG4gICAgXCJhbWlzdGFkXCIsXG4gICAgXCJhbW9yXCIsXG4gICAgXCJhbXBhcm9cIixcbiAgICBcImFtcGxpb1wiLFxuICAgIFwiYW5jaG9cIixcbiAgICBcImFuY2lhbm9cIixcbiAgICBcImFuY2xhXCIsXG4gICAgXCJhbmRhclwiLFxuICAgIFwiYW5kZcyBblwiLFxuICAgIFwiYW5lbWlhXCIsXG4gICAgXCJhzIFuZ3Vsb1wiLFxuICAgIFwiYW5pbGxvXCIsXG4gICAgXCJhzIFuaW1vXCIsXG4gICAgXCJhbmnMgXNcIixcbiAgICBcImFub3RhclwiLFxuICAgIFwiYW50ZW5hXCIsXG4gICAgXCJhbnRpZ3VvXCIsXG4gICAgXCJhbnRvam9cIixcbiAgICBcImFudWFsXCIsXG4gICAgXCJhbnVsYXJcIixcbiAgICBcImFudW5jaW9cIixcbiAgICBcImFuzINhZGlyXCIsXG4gICAgXCJhbsyDZWpvXCIsXG4gICAgXCJhbsyDb1wiLFxuICAgIFwiYXBhZ2FyXCIsXG4gICAgXCJhcGFyYXRvXCIsXG4gICAgXCJhcGV0aXRvXCIsXG4gICAgXCJhcGlvXCIsXG4gICAgXCJhcGxpY2FyXCIsXG4gICAgXCJhcG9kb1wiLFxuICAgIFwiYXBvcnRlXCIsXG4gICAgXCJhcG95b1wiLFxuICAgIFwiYXByZW5kZXJcIixcbiAgICBcImFwcm9iYXJcIixcbiAgICBcImFwdWVzdGFcIixcbiAgICBcImFwdXJvXCIsXG4gICAgXCJhcmFkb1wiLFxuICAgIFwiYXJhbsyDYVwiLFxuICAgIFwiYXJhclwiLFxuICAgIFwiYcyBcmJpdHJvXCIsXG4gICAgXCJhzIFyYm9sXCIsXG4gICAgXCJhcmJ1c3RvXCIsXG4gICAgXCJhcmNoaXZvXCIsXG4gICAgXCJhcmNvXCIsXG4gICAgXCJhcmRlclwiLFxuICAgIFwiYXJkaWxsYVwiLFxuICAgIFwiYXJkdW9cIixcbiAgICBcImHMgXJlYVwiLFxuICAgIFwiYcyBcmlkb1wiLFxuICAgIFwiYXJpZXNcIixcbiAgICBcImFybW9uacyBYVwiLFxuICAgIFwiYXJuZcyBc1wiLFxuICAgIFwiYXJvbWFcIixcbiAgICBcImFycGFcIixcbiAgICBcImFycG/MgW5cIixcbiAgICBcImFycmVnbG9cIixcbiAgICBcImFycm96XCIsXG4gICAgXCJhcnJ1Z2FcIixcbiAgICBcImFydGVcIixcbiAgICBcImFydGlzdGFcIixcbiAgICBcImFzYVwiLFxuICAgIFwiYXNhZG9cIixcbiAgICBcImFzYWx0b1wiLFxuICAgIFwiYXNjZW5zb1wiLFxuICAgIFwiYXNlZ3VyYXJcIixcbiAgICBcImFzZW9cIixcbiAgICBcImFzZXNvclwiLFxuICAgIFwiYXNpZW50b1wiLFxuICAgIFwiYXNpbG9cIixcbiAgICBcImFzaXN0aXJcIixcbiAgICBcImFzbm9cIixcbiAgICBcImFzb21icm9cIixcbiAgICBcImHMgXNwZXJvXCIsXG4gICAgXCJhc3RpbGxhXCIsXG4gICAgXCJhc3Ryb1wiLFxuICAgIFwiYXN0dXRvXCIsXG4gICAgXCJhc3VtaXJcIixcbiAgICBcImFzdW50b1wiLFxuICAgIFwiYXRham9cIixcbiAgICBcImF0YXF1ZVwiLFxuICAgIFwiYXRhclwiLFxuICAgIFwiYXRlbnRvXCIsXG4gICAgXCJhdGVvXCIsXG4gICAgXCJhzIF0aWNvXCIsXG4gICAgXCJhdGxldGFcIixcbiAgICBcImHMgXRvbW9cIixcbiAgICBcImF0cmFlclwiLFxuICAgIFwiYXRyb3pcIixcbiAgICBcImF0dcyBblwiLFxuICAgIFwiYXVkYXpcIixcbiAgICBcImF1ZGlvXCIsXG4gICAgXCJhdWdlXCIsXG4gICAgXCJhdWxhXCIsXG4gICAgXCJhdW1lbnRvXCIsXG4gICAgXCJhdXNlbnRlXCIsXG4gICAgXCJhdXRvclwiLFxuICAgIFwiYXZhbFwiLFxuICAgIFwiYXZhbmNlXCIsXG4gICAgXCJhdmFyb1wiLFxuICAgIFwiYXZlXCIsXG4gICAgXCJhdmVsbGFuYVwiLFxuICAgIFwiYXZlbmFcIixcbiAgICBcImF2ZXN0cnV6XCIsXG4gICAgXCJhdmlvzIFuXCIsXG4gICAgXCJhdmlzb1wiLFxuICAgIFwiYXllclwiLFxuICAgIFwiYXl1ZGFcIixcbiAgICBcImF5dW5vXCIsXG4gICAgXCJhemFmcmHMgW5cIixcbiAgICBcImF6YXJcIixcbiAgICBcImF6b3RlXCIsXG4gICAgXCJhenXMgWNhclwiLFxuICAgIFwiYXp1ZnJlXCIsXG4gICAgXCJhenVsXCIsXG4gICAgXCJiYWJhXCIsXG4gICAgXCJiYWJvclwiLFxuICAgIFwiYmFjaGVcIixcbiAgICBcImJhaGnMgWFcIixcbiAgICBcImJhaWxlXCIsXG4gICAgXCJiYWphclwiLFxuICAgIFwiYmFsYW56YVwiLFxuICAgIFwiYmFsY2/MgW5cIixcbiAgICBcImJhbGRlXCIsXG4gICAgXCJiYW1idcyBXCIsXG4gICAgXCJiYW5jb1wiLFxuICAgIFwiYmFuZGFcIixcbiAgICBcImJhbsyDb1wiLFxuICAgIFwiYmFyYmFcIixcbiAgICBcImJhcmNvXCIsXG4gICAgXCJiYXJuaXpcIixcbiAgICBcImJhcnJvXCIsXG4gICAgXCJiYcyBc2N1bGFcIixcbiAgICBcImJhc3RvzIFuXCIsXG4gICAgXCJiYXN1cmFcIixcbiAgICBcImJhdGFsbGFcIixcbiAgICBcImJhdGVyacyBYVwiLFxuICAgIFwiYmF0aXJcIixcbiAgICBcImJhdHV0YVwiLFxuICAgIFwiYmF1zIFsXCIsXG4gICAgXCJiYXphclwiLFxuICAgIFwiYmViZcyBXCIsXG4gICAgXCJiZWJpZGFcIixcbiAgICBcImJlbGxvXCIsXG4gICAgXCJiZXNhclwiLFxuICAgIFwiYmVzb1wiLFxuICAgIFwiYmVzdGlhXCIsXG4gICAgXCJiaWNob1wiLFxuICAgIFwiYmllblwiLFxuICAgIFwiYmluZ29cIixcbiAgICBcImJsYW5jb1wiLFxuICAgIFwiYmxvcXVlXCIsXG4gICAgXCJibHVzYVwiLFxuICAgIFwiYm9hXCIsXG4gICAgXCJib2JpbmFcIixcbiAgICBcImJvYm9cIixcbiAgICBcImJvY2FcIixcbiAgICBcImJvY2luYVwiLFxuICAgIFwiYm9kYVwiLFxuICAgIFwiYm9kZWdhXCIsXG4gICAgXCJib2luYVwiLFxuICAgIFwiYm9sYVwiLFxuICAgIFwiYm9sZXJvXCIsXG4gICAgXCJib2xzYVwiLFxuICAgIFwiYm9tYmFcIixcbiAgICBcImJvbmRhZFwiLFxuICAgIFwiYm9uaXRvXCIsXG4gICAgXCJib25vXCIsXG4gICAgXCJib25zYcyBaVwiLFxuICAgIFwiYm9yZGVcIixcbiAgICBcImJvcnJhclwiLFxuICAgIFwiYm9zcXVlXCIsXG4gICAgXCJib3RlXCIsXG4gICAgXCJib3RpzIFuXCIsXG4gICAgXCJib8yBdmVkYVwiLFxuICAgIFwiYm96YWxcIixcbiAgICBcImJyYXZvXCIsXG4gICAgXCJicmF6b1wiLFxuICAgIFwiYnJlY2hhXCIsXG4gICAgXCJicmV2ZVwiLFxuICAgIFwiYnJpbGxvXCIsXG4gICAgXCJicmluY29cIixcbiAgICBcImJyaXNhXCIsXG4gICAgXCJicm9jYVwiLFxuICAgIFwiYnJvbWFcIixcbiAgICBcImJyb25jZVwiLFxuICAgIFwiYnJvdGVcIixcbiAgICBcImJydWphXCIsXG4gICAgXCJicnVzY29cIixcbiAgICBcImJydXRvXCIsXG4gICAgXCJidWNlb1wiLFxuICAgIFwiYnVjbGVcIixcbiAgICBcImJ1ZW5vXCIsXG4gICAgXCJidWV5XCIsXG4gICAgXCJidWZhbmRhXCIsXG4gICAgXCJidWZvzIFuXCIsXG4gICAgXCJidcyBaG9cIixcbiAgICBcImJ1aXRyZVwiLFxuICAgIFwiYnVsdG9cIixcbiAgICBcImJ1cmJ1amFcIixcbiAgICBcImJ1cmxhXCIsXG4gICAgXCJidXJyb1wiLFxuICAgIFwiYnVzY2FyXCIsXG4gICAgXCJidXRhY2FcIixcbiAgICBcImJ1em/MgW5cIixcbiAgICBcImNhYmFsbG9cIixcbiAgICBcImNhYmV6YVwiLFxuICAgIFwiY2FiaW5hXCIsXG4gICAgXCJjYWJyYVwiLFxuICAgIFwiY2FjYW9cIixcbiAgICBcImNhZGHMgXZlclwiLFxuICAgIFwiY2FkZW5hXCIsXG4gICAgXCJjYWVyXCIsXG4gICAgXCJjYWZlzIFcIixcbiAgICBcImNhacyBZGFcIixcbiAgICBcImNhaW1hzIFuXCIsXG4gICAgXCJjYWphXCIsXG4gICAgXCJjYWpvzIFuXCIsXG4gICAgXCJjYWxcIixcbiAgICBcImNhbGFtYXJcIixcbiAgICBcImNhbGNpb1wiLFxuICAgIFwiY2FsZG9cIixcbiAgICBcImNhbGlkYWRcIixcbiAgICBcImNhbGxlXCIsXG4gICAgXCJjYWxtYVwiLFxuICAgIFwiY2Fsb3JcIixcbiAgICBcImNhbHZvXCIsXG4gICAgXCJjYW1hXCIsXG4gICAgXCJjYW1iaW9cIixcbiAgICBcImNhbWVsbG9cIixcbiAgICBcImNhbWlub1wiLFxuICAgIFwiY2FtcG9cIixcbiAgICBcImNhzIFuY2VyXCIsXG4gICAgXCJjYW5kaWxcIixcbiAgICBcImNhbmVsYVwiLFxuICAgIFwiY2FuZ3Vyb1wiLFxuICAgIFwiY2FuaWNhXCIsXG4gICAgXCJjYW50b1wiLFxuICAgIFwiY2FuzINhXCIsXG4gICAgXCJjYW7Mg2/MgW5cIixcbiAgICBcImNhb2JhXCIsXG4gICAgXCJjYW9zXCIsXG4gICAgXCJjYXBhelwiLFxuICAgIFwiY2FwaXRhzIFuXCIsXG4gICAgXCJjYXBvdGVcIixcbiAgICBcImNhcHRhclwiLFxuICAgIFwiY2FwdWNoYVwiLFxuICAgIFwiY2FyYVwiLFxuICAgIFwiY2FyYm/MgW5cIixcbiAgICBcImNhzIFyY2VsXCIsXG4gICAgXCJjYXJldGFcIixcbiAgICBcImNhcmdhXCIsXG4gICAgXCJjYXJpbsyDb1wiLFxuICAgIFwiY2FybmVcIixcbiAgICBcImNhcnBldGFcIixcbiAgICBcImNhcnJvXCIsXG4gICAgXCJjYXJ0YVwiLFxuICAgIFwiY2FzYVwiLFxuICAgIFwiY2FzY29cIixcbiAgICBcImNhc2Vyb1wiLFxuICAgIFwiY2FzcGFcIixcbiAgICBcImNhc3RvclwiLFxuICAgIFwiY2F0b3JjZVwiLFxuICAgIFwiY2F0cmVcIixcbiAgICBcImNhdWRhbFwiLFxuICAgIFwiY2F1c2FcIixcbiAgICBcImNhem9cIixcbiAgICBcImNlYm9sbGFcIixcbiAgICBcImNlZGVyXCIsXG4gICAgXCJjZWRyb1wiLFxuICAgIFwiY2VsZGFcIixcbiAgICBcImNlzIFsZWJyZVwiLFxuICAgIFwiY2Vsb3NvXCIsXG4gICAgXCJjZcyBbHVsYVwiLFxuICAgIFwiY2VtZW50b1wiLFxuICAgIFwiY2VuaXphXCIsXG4gICAgXCJjZW50cm9cIixcbiAgICBcImNlcmNhXCIsXG4gICAgXCJjZXJkb1wiLFxuICAgIFwiY2VyZXphXCIsXG4gICAgXCJjZXJvXCIsXG4gICAgXCJjZXJyYXJcIixcbiAgICBcImNlcnRlemFcIixcbiAgICBcImNlzIFzcGVkXCIsXG4gICAgXCJjZXRyb1wiLFxuICAgIFwiY2hhY2FsXCIsXG4gICAgXCJjaGFsZWNvXCIsXG4gICAgXCJjaGFtcHXMgVwiLFxuICAgIFwiY2hhbmNsYVwiLFxuICAgIFwiY2hhcGFcIixcbiAgICBcImNoYXJsYVwiLFxuICAgIFwiY2hpY29cIixcbiAgICBcImNoaXN0ZVwiLFxuICAgIFwiY2hpdm9cIixcbiAgICBcImNob3F1ZVwiLFxuICAgIFwiY2hvemFcIixcbiAgICBcImNodWxldGFcIixcbiAgICBcImNodXBhclwiLFxuICAgIFwiY2ljbG/MgW5cIixcbiAgICBcImNpZWdvXCIsXG4gICAgXCJjaWVsb1wiLFxuICAgIFwiY2llblwiLFxuICAgIFwiY2llcnRvXCIsXG4gICAgXCJjaWZyYVwiLFxuICAgIFwiY2lnYXJyb1wiLFxuICAgIFwiY2ltYVwiLFxuICAgIFwiY2luY29cIixcbiAgICBcImNpbmVcIixcbiAgICBcImNpbnRhXCIsXG4gICAgXCJjaXByZcyBc1wiLFxuICAgIFwiY2lyY29cIixcbiAgICBcImNpcnVlbGFcIixcbiAgICBcImNpc25lXCIsXG4gICAgXCJjaXRhXCIsXG4gICAgXCJjaXVkYWRcIixcbiAgICBcImNsYW1vclwiLFxuICAgIFwiY2xhblwiLFxuICAgIFwiY2xhcm9cIixcbiAgICBcImNsYXNlXCIsXG4gICAgXCJjbGF2ZVwiLFxuICAgIFwiY2xpZW50ZVwiLFxuICAgIFwiY2xpbWFcIixcbiAgICBcImNsacyBbmljYVwiLFxuICAgIFwiY29icmVcIixcbiAgICBcImNvY2Npb8yBblwiLFxuICAgIFwiY29jaGlub1wiLFxuICAgIFwiY29jaW5hXCIsXG4gICAgXCJjb2NvXCIsXG4gICAgXCJjb8yBZGlnb1wiLFxuICAgIFwiY29kb1wiLFxuICAgIFwiY29mcmVcIixcbiAgICBcImNvZ2VyXCIsXG4gICAgXCJjb2hldGVcIixcbiAgICBcImNvamnMgW5cIixcbiAgICBcImNvam9cIixcbiAgICBcImNvbGFcIixcbiAgICBcImNvbGNoYVwiLFxuICAgIFwiY29sZWdpb1wiLFxuICAgIFwiY29sZ2FyXCIsXG4gICAgXCJjb2xpbmFcIixcbiAgICBcImNvbGxhclwiLFxuICAgIFwiY29sbW9cIixcbiAgICBcImNvbHVtbmFcIixcbiAgICBcImNvbWJhdGVcIixcbiAgICBcImNvbWVyXCIsXG4gICAgXCJjb21pZGFcIixcbiAgICBcImNvzIFtb2RvXCIsXG4gICAgXCJjb21wcmFcIixcbiAgICBcImNvbmRlXCIsXG4gICAgXCJjb25lam9cIixcbiAgICBcImNvbmdhXCIsXG4gICAgXCJjb25vY2VyXCIsXG4gICAgXCJjb25zZWpvXCIsXG4gICAgXCJjb250YXJcIixcbiAgICBcImNvcGFcIixcbiAgICBcImNvcGlhXCIsXG4gICAgXCJjb3Jhem/MgW5cIixcbiAgICBcImNvcmJhdGFcIixcbiAgICBcImNvcmNob1wiLFxuICAgIFwiY29yZG/MgW5cIixcbiAgICBcImNvcm9uYVwiLFxuICAgIFwiY29ycmVyXCIsXG4gICAgXCJjb3NlclwiLFxuICAgIFwiY29zbW9zXCIsXG4gICAgXCJjb3N0YVwiLFxuICAgIFwiY3JhzIFuZW9cIixcbiAgICBcImNyYcyBdGVyXCIsXG4gICAgXCJjcmVhclwiLFxuICAgIFwiY3JlY2VyXCIsXG4gICAgXCJjcmVpzIFkb1wiLFxuICAgIFwiY3JlbWFcIixcbiAgICBcImNyacyBYVwiLFxuICAgIFwiY3JpbWVuXCIsXG4gICAgXCJjcmlwdGFcIixcbiAgICBcImNyaXNpc1wiLFxuICAgIFwiY3JvbW9cIixcbiAgICBcImNyb8yBbmljYVwiLFxuICAgIFwiY3JvcXVldGFcIixcbiAgICBcImNydWRvXCIsXG4gICAgXCJjcnV6XCIsXG4gICAgXCJjdWFkcm9cIixcbiAgICBcImN1YXJ0b1wiLFxuICAgIFwiY3VhdHJvXCIsXG4gICAgXCJjdWJvXCIsXG4gICAgXCJjdWJyaXJcIixcbiAgICBcImN1Y2hhcmFcIixcbiAgICBcImN1ZWxsb1wiLFxuICAgIFwiY3VlbnRvXCIsXG4gICAgXCJjdWVyZGFcIixcbiAgICBcImN1ZXN0YVwiLFxuICAgIFwiY3VldmFcIixcbiAgICBcImN1aWRhclwiLFxuICAgIFwiY3VsZWJyYVwiLFxuICAgIFwiY3VscGFcIixcbiAgICBcImN1bHRvXCIsXG4gICAgXCJjdW1icmVcIixcbiAgICBcImN1bXBsaXJcIixcbiAgICBcImN1bmFcIixcbiAgICBcImN1bmV0YVwiLFxuICAgIFwiY3VvdGFcIixcbiAgICBcImN1cG/MgW5cIixcbiAgICBcImN1zIFwdWxhXCIsXG4gICAgXCJjdXJhclwiLFxuICAgIFwiY3VyaW9zb1wiLFxuICAgIFwiY3Vyc29cIixcbiAgICBcImN1cnZhXCIsXG4gICAgXCJjdXRpc1wiLFxuICAgIFwiZGFtYVwiLFxuICAgIFwiZGFuemFcIixcbiAgICBcImRhclwiLFxuICAgIFwiZGFyZG9cIixcbiAgICBcImRhzIF0aWxcIixcbiAgICBcImRlYmVyXCIsXG4gICAgXCJkZcyBYmlsXCIsXG4gICAgXCJkZcyBY2FkYVwiLFxuICAgIFwiZGVjaXJcIixcbiAgICBcImRlZG9cIixcbiAgICBcImRlZmVuc2FcIixcbiAgICBcImRlZmluaXJcIixcbiAgICBcImRlamFyXCIsXG4gICAgXCJkZWxmacyBblwiLFxuICAgIFwiZGVsZ2Fkb1wiLFxuICAgIFwiZGVsaXRvXCIsXG4gICAgXCJkZW1vcmFcIixcbiAgICBcImRlbnNvXCIsXG4gICAgXCJkZW50YWxcIixcbiAgICBcImRlcG9ydGVcIixcbiAgICBcImRlcmVjaG9cIixcbiAgICBcImRlcnJvdGFcIixcbiAgICBcImRlc2F5dW5vXCIsXG4gICAgXCJkZXNlb1wiLFxuICAgIFwiZGVzZmlsZVwiLFxuICAgIFwiZGVzbnVkb1wiLFxuICAgIFwiZGVzdGlub1wiLFxuICAgIFwiZGVzdmnMgW9cIixcbiAgICBcImRldGFsbGVcIixcbiAgICBcImRldGVuZXJcIixcbiAgICBcImRldWRhXCIsXG4gICAgXCJkacyBYVwiLFxuICAgIFwiZGlhYmxvXCIsXG4gICAgXCJkaWFkZW1hXCIsXG4gICAgXCJkaWFtYW50ZVwiLFxuICAgIFwiZGlhbmFcIixcbiAgICBcImRpYXJpb1wiLFxuICAgIFwiZGlidWpvXCIsXG4gICAgXCJkaWN0YXJcIixcbiAgICBcImRpZW50ZVwiLFxuICAgIFwiZGlldGFcIixcbiAgICBcImRpZXpcIixcbiAgICBcImRpZmnMgWNpbFwiLFxuICAgIFwiZGlnbm9cIixcbiAgICBcImRpbGVtYVwiLFxuICAgIFwiZGlsdWlyXCIsXG4gICAgXCJkaW5lcm9cIixcbiAgICBcImRpcmVjdG9cIixcbiAgICBcImRpcmlnaXJcIixcbiAgICBcImRpc2NvXCIsXG4gICAgXCJkaXNlbsyDb1wiLFxuICAgIFwiZGlzZnJhelwiLFxuICAgIFwiZGl2YVwiLFxuICAgIFwiZGl2aW5vXCIsXG4gICAgXCJkb2JsZVwiLFxuICAgIFwiZG9jZVwiLFxuICAgIFwiZG9sb3JcIixcbiAgICBcImRvbWluZ29cIixcbiAgICBcImRvblwiLFxuICAgIFwiZG9uYXJcIixcbiAgICBcImRvcmFkb1wiLFxuICAgIFwiZG9ybWlyXCIsXG4gICAgXCJkb3Jzb1wiLFxuICAgIFwiZG9zXCIsXG4gICAgXCJkb3Npc1wiLFxuICAgIFwiZHJhZ2/MgW5cIixcbiAgICBcImRyb2dhXCIsXG4gICAgXCJkdWNoYVwiLFxuICAgIFwiZHVkYVwiLFxuICAgIFwiZHVlbG9cIixcbiAgICBcImR1ZW7Mg29cIixcbiAgICBcImR1bGNlXCIsXG4gICAgXCJkdcyBb1wiLFxuICAgIFwiZHVxdWVcIixcbiAgICBcImR1cmFyXCIsXG4gICAgXCJkdXJlemFcIixcbiAgICBcImR1cm9cIixcbiAgICBcImXMgWJhbm9cIixcbiAgICBcImVicmlvXCIsXG4gICAgXCJlY2hhclwiLFxuICAgIFwiZWNvXCIsXG4gICAgXCJlY3VhZG9yXCIsXG4gICAgXCJlZGFkXCIsXG4gICAgXCJlZGljaW/MgW5cIixcbiAgICBcImVkaWZpY2lvXCIsXG4gICAgXCJlZGl0b3JcIixcbiAgICBcImVkdWNhclwiLFxuICAgIFwiZWZlY3RvXCIsXG4gICAgXCJlZmljYXpcIixcbiAgICBcImVqZVwiLFxuICAgIFwiZWplbXBsb1wiLFxuICAgIFwiZWxlZmFudGVcIixcbiAgICBcImVsZWdpclwiLFxuICAgIFwiZWxlbWVudG9cIixcbiAgICBcImVsZXZhclwiLFxuICAgIFwiZWxpcHNlXCIsXG4gICAgXCJlzIFsaXRlXCIsXG4gICAgXCJlbGl4aXJcIixcbiAgICBcImVsb2dpb1wiLFxuICAgIFwiZWx1ZGlyXCIsXG4gICAgXCJlbWJ1ZG9cIixcbiAgICBcImVtaXRpclwiLFxuICAgIFwiZW1vY2lvzIFuXCIsXG4gICAgXCJlbXBhdGVcIixcbiAgICBcImVtcGVuzINvXCIsXG4gICAgXCJlbXBsZW9cIixcbiAgICBcImVtcHJlc2FcIixcbiAgICBcImVuYW5vXCIsXG4gICAgXCJlbmNhcmdvXCIsXG4gICAgXCJlbmNodWZlXCIsXG4gICAgXCJlbmNpzIFhXCIsXG4gICAgXCJlbmVtaWdvXCIsXG4gICAgXCJlbmVyb1wiLFxuICAgIFwiZW5mYWRvXCIsXG4gICAgXCJlbmZlcm1vXCIsXG4gICAgXCJlbmdhbsyDb1wiLFxuICAgIFwiZW5pZ21hXCIsXG4gICAgXCJlbmxhY2VcIixcbiAgICBcImVub3JtZVwiLFxuICAgIFwiZW5yZWRvXCIsXG4gICAgXCJlbnNheW9cIixcbiAgICBcImVuc2VuzINhclwiLFxuICAgIFwiZW50ZXJvXCIsXG4gICAgXCJlbnRyYXJcIixcbiAgICBcImVudmFzZVwiLFxuICAgIFwiZW52acyBb1wiLFxuICAgIFwiZcyBcG9jYVwiLFxuICAgIFwiZXF1aXBvXCIsXG4gICAgXCJlcml6b1wiLFxuICAgIFwiZXNjYWxhXCIsXG4gICAgXCJlc2NlbmFcIixcbiAgICBcImVzY29sYXJcIixcbiAgICBcImVzY3JpYmlyXCIsXG4gICAgXCJlc2N1ZG9cIixcbiAgICBcImVzZW5jaWFcIixcbiAgICBcImVzZmVyYVwiLFxuICAgIFwiZXNmdWVyem9cIixcbiAgICBcImVzcGFkYVwiLFxuICAgIFwiZXNwZWpvXCIsXG4gICAgXCJlc3BpzIFhXCIsXG4gICAgXCJlc3Bvc2FcIixcbiAgICBcImVzcHVtYVwiLFxuICAgIFwiZXNxdWnMgVwiLFxuICAgIFwiZXN0YXJcIixcbiAgICBcImVzdGVcIixcbiAgICBcImVzdGlsb1wiLFxuICAgIFwiZXN0dWZhXCIsXG4gICAgXCJldGFwYVwiLFxuICAgIFwiZXRlcm5vXCIsXG4gICAgXCJlzIF0aWNhXCIsXG4gICAgXCJldG5pYVwiLFxuICAgIFwiZXZhZGlyXCIsXG4gICAgXCJldmFsdWFyXCIsXG4gICAgXCJldmVudG9cIixcbiAgICBcImV2aXRhclwiLFxuICAgIFwiZXhhY3RvXCIsXG4gICAgXCJleGFtZW5cIixcbiAgICBcImV4Y2Vzb1wiLFxuICAgIFwiZXhjdXNhXCIsXG4gICAgXCJleGVudG9cIixcbiAgICBcImV4aWdpclwiLFxuICAgIFwiZXhpbGlvXCIsXG4gICAgXCJleGlzdGlyXCIsXG4gICAgXCJlzIF4aXRvXCIsXG4gICAgXCJleHBlcnRvXCIsXG4gICAgXCJleHBsaWNhclwiLFxuICAgIFwiZXhwb25lclwiLFxuICAgIFwiZXh0cmVtb1wiLFxuICAgIFwiZmHMgWJyaWNhXCIsXG4gICAgXCJmYcyBYnVsYVwiLFxuICAgIFwiZmFjaGFkYVwiLFxuICAgIFwiZmHMgWNpbFwiLFxuICAgIFwiZmFjdG9yXCIsXG4gICAgXCJmYWVuYVwiLFxuICAgIFwiZmFqYVwiLFxuICAgIFwiZmFsZGFcIixcbiAgICBcImZhbGxvXCIsXG4gICAgXCJmYWxzb1wiLFxuICAgIFwiZmFsdGFyXCIsXG4gICAgXCJmYW1hXCIsXG4gICAgXCJmYW1pbGlhXCIsXG4gICAgXCJmYW1vc29cIixcbiAgICBcImZhcmFvzIFuXCIsXG4gICAgXCJmYXJtYWNpYVwiLFxuICAgIFwiZmFyb2xcIixcbiAgICBcImZhcnNhXCIsXG4gICAgXCJmYXNlXCIsXG4gICAgXCJmYXRpZ2FcIixcbiAgICBcImZhdW5hXCIsXG4gICAgXCJmYXZvclwiLFxuICAgIFwiZmF4XCIsXG4gICAgXCJmZWJyZXJvXCIsXG4gICAgXCJmZWNoYVwiLFxuICAgIFwiZmVsaXpcIixcbiAgICBcImZlb1wiLFxuICAgIFwiZmVyaWFcIixcbiAgICBcImZlcm96XCIsXG4gICAgXCJmZcyBcnRpbFwiLFxuICAgIFwiZmVydm9yXCIsXG4gICAgXCJmZXN0acyBblwiLFxuICAgIFwiZmlhYmxlXCIsXG4gICAgXCJmaWFuemFcIixcbiAgICBcImZpYXJcIixcbiAgICBcImZpYnJhXCIsXG4gICAgXCJmaWNjaW/MgW5cIixcbiAgICBcImZpY2hhXCIsXG4gICAgXCJmaWRlb1wiLFxuICAgIFwiZmllYnJlXCIsXG4gICAgXCJmaWVsXCIsXG4gICAgXCJmaWVyYVwiLFxuICAgIFwiZmllc3RhXCIsXG4gICAgXCJmaWd1cmFcIixcbiAgICBcImZpamFyXCIsXG4gICAgXCJmaWpvXCIsXG4gICAgXCJmaWxhXCIsXG4gICAgXCJmaWxldGVcIixcbiAgICBcImZpbGlhbFwiLFxuICAgIFwiZmlsdHJvXCIsXG4gICAgXCJmaW5cIixcbiAgICBcImZpbmNhXCIsXG4gICAgXCJmaW5naXJcIixcbiAgICBcImZpbml0b1wiLFxuICAgIFwiZmlybWFcIixcbiAgICBcImZsYWNvXCIsXG4gICAgXCJmbGF1dGFcIixcbiAgICBcImZsZWNoYVwiLFxuICAgIFwiZmxvclwiLFxuICAgIFwiZmxvdGFcIixcbiAgICBcImZsdWlyXCIsXG4gICAgXCJmbHVqb1wiLFxuICAgIFwiZmx1zIFvclwiLFxuICAgIFwiZm9iaWFcIixcbiAgICBcImZvY2FcIixcbiAgICBcImZvZ2F0YVwiLFxuICAgIFwiZm9nb8yBblwiLFxuICAgIFwiZm9saW9cIixcbiAgICBcImZvbGxldG9cIixcbiAgICBcImZvbmRvXCIsXG4gICAgXCJmb3JtYVwiLFxuICAgIFwiZm9ycm9cIixcbiAgICBcImZvcnR1bmFcIixcbiAgICBcImZvcnphclwiLFxuICAgIFwiZm9zYVwiLFxuICAgIFwiZm90b1wiLFxuICAgIFwiZnJhY2Fzb1wiLFxuICAgIFwiZnJhzIFnaWxcIixcbiAgICBcImZyYW5qYVwiLFxuICAgIFwiZnJhc2VcIixcbiAgICBcImZyYXVkZVwiLFxuICAgIFwiZnJlacyBclwiLFxuICAgIFwiZnJlbm9cIixcbiAgICBcImZyZXNhXCIsXG4gICAgXCJmcmnMgW9cIixcbiAgICBcImZyaXRvXCIsXG4gICAgXCJmcnV0YVwiLFxuICAgIFwiZnVlZ29cIixcbiAgICBcImZ1ZW50ZVwiLFxuICAgIFwiZnVlcnphXCIsXG4gICAgXCJmdWdhXCIsXG4gICAgXCJmdW1hclwiLFxuICAgIFwiZnVuY2lvzIFuXCIsXG4gICAgXCJmdW5kYVwiLFxuICAgIFwiZnVyZ2/MgW5cIixcbiAgICBcImZ1cmlhXCIsXG4gICAgXCJmdXNpbFwiLFxuICAgIFwiZnXMgXRib2xcIixcbiAgICBcImZ1dHVyb1wiLFxuICAgIFwiZ2FjZWxhXCIsXG4gICAgXCJnYWZhc1wiLFxuICAgIFwiZ2FpdGFcIixcbiAgICBcImdham9cIixcbiAgICBcImdhbGFcIixcbiAgICBcImdhbGVyacyBYVwiLFxuICAgIFwiZ2FsbG9cIixcbiAgICBcImdhbWJhXCIsXG4gICAgXCJnYW5hclwiLFxuICAgIFwiZ2FuY2hvXCIsXG4gICAgXCJnYW5nYVwiLFxuICAgIFwiZ2Fuc29cIixcbiAgICBcImdhcmFqZVwiLFxuICAgIFwiZ2FyemFcIixcbiAgICBcImdhc29saW5hXCIsXG4gICAgXCJnYXN0YXJcIixcbiAgICBcImdhdG9cIixcbiAgICBcImdhdmlsYcyBblwiLFxuICAgIFwiZ2VtZWxvXCIsXG4gICAgXCJnZW1pclwiLFxuICAgIFwiZ2VuXCIsXG4gICAgXCJnZcyBbmVyb1wiLFxuICAgIFwiZ2VuaW9cIixcbiAgICBcImdlbnRlXCIsXG4gICAgXCJnZXJhbmlvXCIsXG4gICAgXCJnZXJlbnRlXCIsXG4gICAgXCJnZXJtZW5cIixcbiAgICBcImdlc3RvXCIsXG4gICAgXCJnaWdhbnRlXCIsXG4gICAgXCJnaW1uYXNpb1wiLFxuICAgIFwiZ2lyYXJcIixcbiAgICBcImdpcm9cIixcbiAgICBcImdsYWNpYXJcIixcbiAgICBcImdsb2JvXCIsXG4gICAgXCJnbG9yaWFcIixcbiAgICBcImdvbFwiLFxuICAgIFwiZ29sZm9cIixcbiAgICBcImdvbG9zb1wiLFxuICAgIFwiZ29scGVcIixcbiAgICBcImdvbWFcIixcbiAgICBcImdvcmRvXCIsXG4gICAgXCJnb3JpbGFcIixcbiAgICBcImdvcnJhXCIsXG4gICAgXCJnb3RhXCIsXG4gICAgXCJnb3Rlb1wiLFxuICAgIFwiZ296YXJcIixcbiAgICBcImdyYWRhXCIsXG4gICAgXCJncmHMgWZpY29cIixcbiAgICBcImdyYW5vXCIsXG4gICAgXCJncmFzYVwiLFxuICAgIFwiZ3JhdGlzXCIsXG4gICAgXCJncmF2ZVwiLFxuICAgIFwiZ3JpZXRhXCIsXG4gICAgXCJncmlsbG9cIixcbiAgICBcImdyaXBlXCIsXG4gICAgXCJncmlzXCIsXG4gICAgXCJncml0b1wiLFxuICAgIFwiZ3Jvc29yXCIsXG4gICAgXCJncnXMgWFcIixcbiAgICBcImdydWVzb1wiLFxuICAgIFwiZ3J1bW9cIixcbiAgICBcImdydXBvXCIsXG4gICAgXCJndWFudGVcIixcbiAgICBcImd1YXBvXCIsXG4gICAgXCJndWFyZGlhXCIsXG4gICAgXCJndWVycmFcIixcbiAgICBcImd1acyBYVwiLFxuICAgIFwiZ3VpbsyDb1wiLFxuICAgIFwiZ3Vpb25cIixcbiAgICBcImd1aXNvXCIsXG4gICAgXCJndWl0YXJyYVwiLFxuICAgIFwiZ3VzYW5vXCIsXG4gICAgXCJndXN0YXJcIixcbiAgICBcImhhYmVyXCIsXG4gICAgXCJoYcyBYmlsXCIsXG4gICAgXCJoYWJsYXJcIixcbiAgICBcImhhY2VyXCIsXG4gICAgXCJoYWNoYVwiLFxuICAgIFwiaGFkYVwiLFxuICAgIFwiaGFsbGFyXCIsXG4gICAgXCJoYW1hY2FcIixcbiAgICBcImhhcmluYVwiLFxuICAgIFwiaGF6XCIsXG4gICAgXCJoYXphbsyDYVwiLFxuICAgIFwiaGViaWxsYVwiLFxuICAgIFwiaGVicmFcIixcbiAgICBcImhlY2hvXCIsXG4gICAgXCJoZWxhZG9cIixcbiAgICBcImhlbGlvXCIsXG4gICAgXCJoZW1icmFcIixcbiAgICBcImhlcmlyXCIsXG4gICAgXCJoZXJtYW5vXCIsXG4gICAgXCJoZcyBcm9lXCIsXG4gICAgXCJoZXJ2aXJcIixcbiAgICBcImhpZWxvXCIsXG4gICAgXCJoaWVycm9cIixcbiAgICBcImhpzIFnYWRvXCIsXG4gICAgXCJoaWdpZW5lXCIsXG4gICAgXCJoaWpvXCIsXG4gICAgXCJoaW1ub1wiLFxuICAgIFwiaGlzdG9yaWFcIixcbiAgICBcImhvY2ljb1wiLFxuICAgIFwiaG9nYXJcIixcbiAgICBcImhvZ3VlcmFcIixcbiAgICBcImhvamFcIixcbiAgICBcImhvbWJyZVwiLFxuICAgIFwiaG9uZ29cIixcbiAgICBcImhvbm9yXCIsXG4gICAgXCJob25yYVwiLFxuICAgIFwiaG9yYVwiLFxuICAgIFwiaG9ybWlnYVwiLFxuICAgIFwiaG9ybm9cIixcbiAgICBcImhvc3RpbFwiLFxuICAgIFwiaG95b1wiLFxuICAgIFwiaHVlY29cIixcbiAgICBcImh1ZWxnYVwiLFxuICAgIFwiaHVlcnRhXCIsXG4gICAgXCJodWVzb1wiLFxuICAgIFwiaHVldm9cIixcbiAgICBcImh1aWRhXCIsXG4gICAgXCJodWlyXCIsXG4gICAgXCJodW1hbm9cIixcbiAgICBcImh1zIFtZWRvXCIsXG4gICAgXCJodW1pbGRlXCIsXG4gICAgXCJodW1vXCIsXG4gICAgXCJodW5kaXJcIixcbiAgICBcImh1cmFjYcyBblwiLFxuICAgIFwiaHVydG9cIixcbiAgICBcImljb25vXCIsXG4gICAgXCJpZGVhbFwiLFxuICAgIFwiaWRpb21hXCIsXG4gICAgXCJpzIFkb2xvXCIsXG4gICAgXCJpZ2xlc2lhXCIsXG4gICAgXCJpZ2x1zIFcIixcbiAgICBcImlndWFsXCIsXG4gICAgXCJpbGVnYWxcIixcbiAgICBcImlsdXNpb8yBblwiLFxuICAgIFwiaW1hZ2VuXCIsXG4gICAgXCJpbWHMgW5cIixcbiAgICBcImltaXRhclwiLFxuICAgIFwiaW1wYXJcIixcbiAgICBcImltcGVyaW9cIixcbiAgICBcImltcG9uZXJcIixcbiAgICBcImltcHVsc29cIixcbiAgICBcImluY2FwYXpcIixcbiAgICBcImnMgW5kaWNlXCIsXG4gICAgXCJpbmVydGVcIixcbiAgICBcImluZmllbFwiLFxuICAgIFwiaW5mb3JtZVwiLFxuICAgIFwiaW5nZW5pb1wiLFxuICAgIFwiaW5pY2lvXCIsXG4gICAgXCJpbm1lbnNvXCIsXG4gICAgXCJpbm11bmVcIixcbiAgICBcImlubmF0b1wiLFxuICAgIFwiaW5zZWN0b1wiLFxuICAgIFwiaW5zdGFudGVcIixcbiAgICBcImludGVyZcyBc1wiLFxuICAgIFwiacyBbnRpbW9cIixcbiAgICBcImludHVpclwiLFxuICAgIFwiaW51zIF0aWxcIixcbiAgICBcImludmllcm5vXCIsXG4gICAgXCJpcmFcIixcbiAgICBcImlyaXNcIixcbiAgICBcImlyb25pzIFhXCIsXG4gICAgXCJpc2xhXCIsXG4gICAgXCJpc2xvdGVcIixcbiAgICBcImphYmFsacyBXCIsXG4gICAgXCJqYWJvzIFuXCIsXG4gICAgXCJqYW1vzIFuXCIsXG4gICAgXCJqYXJhYmVcIixcbiAgICBcImphcmRpzIFuXCIsXG4gICAgXCJqYXJyYVwiLFxuICAgIFwiamF1bGFcIixcbiAgICBcImphem1pzIFuXCIsXG4gICAgXCJqZWZlXCIsXG4gICAgXCJqZXJpbmdhXCIsXG4gICAgXCJqaW5ldGVcIixcbiAgICBcImpvcm5hZGFcIixcbiAgICBcImpvcm9iYVwiLFxuICAgIFwiam92ZW5cIixcbiAgICBcImpveWFcIixcbiAgICBcImp1ZXJnYVwiLFxuICAgIFwianVldmVzXCIsXG4gICAgXCJqdWV6XCIsXG4gICAgXCJqdWdhZG9yXCIsXG4gICAgXCJqdWdvXCIsXG4gICAgXCJqdWd1ZXRlXCIsXG4gICAgXCJqdWljaW9cIixcbiAgICBcImp1bmNvXCIsXG4gICAgXCJqdW5nbGFcIixcbiAgICBcImp1bmlvXCIsXG4gICAgXCJqdW50YXJcIixcbiAgICBcImp1zIFwaXRlclwiLFxuICAgIFwianVyYXJcIixcbiAgICBcImp1c3RvXCIsXG4gICAgXCJqdXZlbmlsXCIsXG4gICAgXCJqdXpnYXJcIixcbiAgICBcImtpbG9cIixcbiAgICBcImtvYWxhXCIsXG4gICAgXCJsYWJpb1wiLFxuICAgIFwibGFjaW9cIixcbiAgICBcImxhY3JhXCIsXG4gICAgXCJsYWRvXCIsXG4gICAgXCJsYWRyb8yBblwiLFxuICAgIFwibGFnYXJ0b1wiLFxuICAgIFwibGHMgWdyaW1hXCIsXG4gICAgXCJsYWd1bmFcIixcbiAgICBcImxhaWNvXCIsXG4gICAgXCJsYW1lclwiLFxuICAgIFwibGHMgW1pbmFcIixcbiAgICBcImxhzIFtcGFyYVwiLFxuICAgIFwibGFuYVwiLFxuICAgIFwibGFuY2hhXCIsXG4gICAgXCJsYW5nb3N0YVwiLFxuICAgIFwibGFuemFcIixcbiAgICBcImxhzIFwaXpcIixcbiAgICBcImxhcmdvXCIsXG4gICAgXCJsYXJ2YVwiLFxuICAgIFwibGHMgXN0aW1hXCIsXG4gICAgXCJsYXRhXCIsXG4gICAgXCJsYcyBdGV4XCIsXG4gICAgXCJsYXRpclwiLFxuICAgIFwibGF1cmVsXCIsXG4gICAgXCJsYXZhclwiLFxuICAgIFwibGF6b1wiLFxuICAgIFwibGVhbFwiLFxuICAgIFwibGVjY2lvzIFuXCIsXG4gICAgXCJsZWNoZVwiLFxuICAgIFwibGVjdG9yXCIsXG4gICAgXCJsZWVyXCIsXG4gICAgXCJsZWdpb8yBblwiLFxuICAgIFwibGVndW1icmVcIixcbiAgICBcImxlamFub1wiLFxuICAgIFwibGVuZ3VhXCIsXG4gICAgXCJsZW50b1wiLFxuICAgIFwibGVuzINhXCIsXG4gICAgXCJsZW/MgW5cIixcbiAgICBcImxlb3BhcmRvXCIsXG4gICAgXCJsZXNpb8yBblwiLFxuICAgIFwibGV0YWxcIixcbiAgICBcImxldHJhXCIsXG4gICAgXCJsZXZlXCIsXG4gICAgXCJsZXllbmRhXCIsXG4gICAgXCJsaWJlcnRhZFwiLFxuICAgIFwibGlicm9cIixcbiAgICBcImxpY29yXCIsXG4gICAgXCJsacyBZGVyXCIsXG4gICAgXCJsaWRpYXJcIixcbiAgICBcImxpZW56b1wiLFxuICAgIFwibGlnYVwiLFxuICAgIFwibGlnZXJvXCIsXG4gICAgXCJsaW1hXCIsXG4gICAgXCJsacyBbWl0ZVwiLFxuICAgIFwibGltb8yBblwiLFxuICAgIFwibGltcGlvXCIsXG4gICAgXCJsaW5jZVwiLFxuICAgIFwibGluZG9cIixcbiAgICBcImxpzIFuZWFcIixcbiAgICBcImxpbmdvdGVcIixcbiAgICBcImxpbm9cIixcbiAgICBcImxpbnRlcm5hXCIsXG4gICAgXCJsacyBcXVpZG9cIixcbiAgICBcImxpc29cIixcbiAgICBcImxpc3RhXCIsXG4gICAgXCJsaXRlcmFcIixcbiAgICBcImxpdGlvXCIsXG4gICAgXCJsaXRyb1wiLFxuICAgIFwibGxhZ2FcIixcbiAgICBcImxsYW1hXCIsXG4gICAgXCJsbGFudG9cIixcbiAgICBcImxsYXZlXCIsXG4gICAgXCJsbGVnYXJcIixcbiAgICBcImxsZW5hclwiLFxuICAgIFwibGxldmFyXCIsXG4gICAgXCJsbG9yYXJcIixcbiAgICBcImxsb3ZlclwiLFxuICAgIFwibGx1dmlhXCIsXG4gICAgXCJsb2JvXCIsXG4gICAgXCJsb2Npb8yBblwiLFxuICAgIFwibG9jb1wiLFxuICAgIFwibG9jdXJhXCIsXG4gICAgXCJsb8yBZ2ljYVwiLFxuICAgIFwibG9ncm9cIixcbiAgICBcImxvbWJyaXpcIixcbiAgICBcImxvbW9cIixcbiAgICBcImxvbmphXCIsXG4gICAgXCJsb3RlXCIsXG4gICAgXCJsdWNoYVwiLFxuICAgIFwibHVjaXJcIixcbiAgICBcImx1Z2FyXCIsXG4gICAgXCJsdWpvXCIsXG4gICAgXCJsdW5hXCIsXG4gICAgXCJsdW5lc1wiLFxuICAgIFwibHVwYVwiLFxuICAgIFwibHVzdHJvXCIsXG4gICAgXCJsdXRvXCIsXG4gICAgXCJsdXpcIixcbiAgICBcIm1hY2V0YVwiLFxuICAgIFwibWFjaG9cIixcbiAgICBcIm1hZGVyYVwiLFxuICAgIFwibWFkcmVcIixcbiAgICBcIm1hZHVyb1wiLFxuICAgIFwibWFlc3Ryb1wiLFxuICAgIFwibWFmaWFcIixcbiAgICBcIm1hZ2lhXCIsXG4gICAgXCJtYWdvXCIsXG4gICAgXCJtYWnMgXpcIixcbiAgICBcIm1hbGRhZFwiLFxuICAgIFwibWFsZXRhXCIsXG4gICAgXCJtYWxsYVwiLFxuICAgIFwibWFsb1wiLFxuICAgIFwibWFtYcyBXCIsXG4gICAgXCJtYW1ib1wiLFxuICAgIFwibWFtdXRcIixcbiAgICBcIm1hbmNvXCIsXG4gICAgXCJtYW5kb1wiLFxuICAgIFwibWFuZWphclwiLFxuICAgIFwibWFuZ2FcIixcbiAgICBcIm1hbmlxdWnMgVwiLFxuICAgIFwibWFuamFyXCIsXG4gICAgXCJtYW5vXCIsXG4gICAgXCJtYW5zb1wiLFxuICAgIFwibWFudGFcIixcbiAgICBcIm1hbsyDYW5hXCIsXG4gICAgXCJtYXBhXCIsXG4gICAgXCJtYcyBcXVpbmFcIixcbiAgICBcIm1hclwiLFxuICAgIFwibWFyY29cIixcbiAgICBcIm1hcmVhXCIsXG4gICAgXCJtYXJmaWxcIixcbiAgICBcIm1hcmdlblwiLFxuICAgIFwibWFyaWRvXCIsXG4gICAgXCJtYcyBcm1vbFwiLFxuICAgIFwibWFycm/MgW5cIixcbiAgICBcIm1hcnRlc1wiLFxuICAgIFwibWFyem9cIixcbiAgICBcIm1hc2FcIixcbiAgICBcIm1hzIFzY2FyYVwiLFxuICAgIFwibWFzaXZvXCIsXG4gICAgXCJtYXRhclwiLFxuICAgIFwibWF0ZXJpYVwiLFxuICAgIFwibWF0aXpcIixcbiAgICBcIm1hdHJpelwiLFxuICAgIFwibWHMgXhpbW9cIixcbiAgICBcIm1heW9yXCIsXG4gICAgXCJtYXpvcmNhXCIsXG4gICAgXCJtZWNoYVwiLFxuICAgIFwibWVkYWxsYVwiLFxuICAgIFwibWVkaW9cIixcbiAgICBcIm1lzIFkdWxhXCIsXG4gICAgXCJtZWppbGxhXCIsXG4gICAgXCJtZWpvclwiLFxuICAgIFwibWVsZW5hXCIsXG4gICAgXCJtZWxvzIFuXCIsXG4gICAgXCJtZW1vcmlhXCIsXG4gICAgXCJtZW5vclwiLFxuICAgIFwibWVuc2FqZVwiLFxuICAgIFwibWVudGVcIixcbiAgICBcIm1lbnXMgVwiLFxuICAgIFwibWVyY2Fkb1wiLFxuICAgIFwibWVyZW5ndWVcIixcbiAgICBcIm1lzIFyaXRvXCIsXG4gICAgXCJtZXNcIixcbiAgICBcIm1lc2/MgW5cIixcbiAgICBcIm1ldGFcIixcbiAgICBcIm1ldGVyXCIsXG4gICAgXCJtZcyBdG9kb1wiLFxuICAgIFwibWV0cm9cIixcbiAgICBcIm1lemNsYVwiLFxuICAgIFwibWllZG9cIixcbiAgICBcIm1pZWxcIixcbiAgICBcIm1pZW1icm9cIixcbiAgICBcIm1pZ2FcIixcbiAgICBcIm1pbFwiLFxuICAgIFwibWlsYWdyb1wiLFxuICAgIFwibWlsaXRhclwiLFxuICAgIFwibWlsbG/MgW5cIixcbiAgICBcIm1pbW9cIixcbiAgICBcIm1pbmFcIixcbiAgICBcIm1pbmVyb1wiLFxuICAgIFwibWnMgW5pbW9cIixcbiAgICBcIm1pbnV0b1wiLFxuICAgIFwibWlvcGVcIixcbiAgICBcIm1pcmFyXCIsXG4gICAgXCJtaXNhXCIsXG4gICAgXCJtaXNlcmlhXCIsXG4gICAgXCJtaXNpbFwiLFxuICAgIFwibWlzbW9cIixcbiAgICBcIm1pdGFkXCIsXG4gICAgXCJtaXRvXCIsXG4gICAgXCJtb2NoaWxhXCIsXG4gICAgXCJtb2Npb8yBblwiLFxuICAgIFwibW9kYVwiLFxuICAgIFwibW9kZWxvXCIsXG4gICAgXCJtb2hvXCIsXG4gICAgXCJtb2phclwiLFxuICAgIFwibW9sZGVcIixcbiAgICBcIm1vbGVyXCIsXG4gICAgXCJtb2xpbm9cIixcbiAgICBcIm1vbWVudG9cIixcbiAgICBcIm1vbWlhXCIsXG4gICAgXCJtb25hcmNhXCIsXG4gICAgXCJtb25lZGFcIixcbiAgICBcIm1vbmphXCIsXG4gICAgXCJtb250b1wiLFxuICAgIFwibW9uzINvXCIsXG4gICAgXCJtb3JhZGFcIixcbiAgICBcIm1vcmRlclwiLFxuICAgIFwibW9yZW5vXCIsXG4gICAgXCJtb3JpclwiLFxuICAgIFwibW9ycm9cIixcbiAgICBcIm1vcnNhXCIsXG4gICAgXCJtb3J0YWxcIixcbiAgICBcIm1vc2NhXCIsXG4gICAgXCJtb3N0cmFyXCIsXG4gICAgXCJtb3Rpdm9cIixcbiAgICBcIm1vdmVyXCIsXG4gICAgXCJtb8yBdmlsXCIsXG4gICAgXCJtb3pvXCIsXG4gICAgXCJtdWNob1wiLFxuICAgIFwibXVkYXJcIixcbiAgICBcIm11ZWJsZVwiLFxuICAgIFwibXVlbGFcIixcbiAgICBcIm11ZXJ0ZVwiLFxuICAgIFwibXVlc3RyYVwiLFxuICAgIFwibXVncmVcIixcbiAgICBcIm11amVyXCIsXG4gICAgXCJtdWxhXCIsXG4gICAgXCJtdWxldGFcIixcbiAgICBcIm11bHRhXCIsXG4gICAgXCJtdW5kb1wiLFxuICAgIFwibXVuzINlY2FcIixcbiAgICBcIm11cmFsXCIsXG4gICAgXCJtdXJvXCIsXG4gICAgXCJtdcyBc2N1bG9cIixcbiAgICBcIm11c2VvXCIsXG4gICAgXCJtdXNnb1wiLFxuICAgIFwibXXMgXNpY2FcIixcbiAgICBcIm11c2xvXCIsXG4gICAgXCJuYcyBY2FyXCIsXG4gICAgXCJuYWNpb8yBblwiLFxuICAgIFwibmFkYXJcIixcbiAgICBcIm5haXBlXCIsXG4gICAgXCJuYXJhbmphXCIsXG4gICAgXCJuYXJpelwiLFxuICAgIFwibmFycmFyXCIsXG4gICAgXCJuYXNhbFwiLFxuICAgIFwibmF0YWxcIixcbiAgICBcIm5hdGl2b1wiLFxuICAgIFwibmF0dXJhbFwiLFxuICAgIFwibmHMgXVzZWFcIixcbiAgICBcIm5hdmFsXCIsXG4gICAgXCJuYXZlXCIsXG4gICAgXCJuYXZpZGFkXCIsXG4gICAgXCJuZWNpb1wiLFxuICAgIFwibmXMgWN0YXJcIixcbiAgICBcIm5lZ2FyXCIsXG4gICAgXCJuZWdvY2lvXCIsXG4gICAgXCJuZWdyb1wiLFxuICAgIFwibmVvzIFuXCIsXG4gICAgXCJuZXJ2aW9cIixcbiAgICBcIm5ldG9cIixcbiAgICBcIm5ldXRyb1wiLFxuICAgIFwibmV2YXJcIixcbiAgICBcIm5ldmVyYVwiLFxuICAgIFwibmljaG9cIixcbiAgICBcIm5pZG9cIixcbiAgICBcIm5pZWJsYVwiLFxuICAgIFwibmlldG9cIixcbiAgICBcIm5pbsyDZXpcIixcbiAgICBcIm5pbsyDb1wiLFxuICAgIFwibmnMgXRpZG9cIixcbiAgICBcIm5pdmVsXCIsXG4gICAgXCJub2JsZXphXCIsXG4gICAgXCJub2NoZVwiLFxuICAgIFwibm/MgW1pbmFcIixcbiAgICBcIm5vcmlhXCIsXG4gICAgXCJub3JtYVwiLFxuICAgIFwibm9ydGVcIixcbiAgICBcIm5vdGFcIixcbiAgICBcIm5vdGljaWFcIixcbiAgICBcIm5vdmF0b1wiLFxuICAgIFwibm92ZWxhXCIsXG4gICAgXCJub3Zpb1wiLFxuICAgIFwibnViZVwiLFxuICAgIFwibnVjYVwiLFxuICAgIFwibnXMgWNsZW9cIixcbiAgICBcIm51ZGlsbG9cIixcbiAgICBcIm51ZG9cIixcbiAgICBcIm51ZXJhXCIsXG4gICAgXCJudWV2ZVwiLFxuICAgIFwibnVlelwiLFxuICAgIFwibnVsb1wiLFxuICAgIFwibnXMgW1lcm9cIixcbiAgICBcIm51dHJpYVwiLFxuICAgIFwib2FzaXNcIixcbiAgICBcIm9iZXNvXCIsXG4gICAgXCJvYmlzcG9cIixcbiAgICBcIm9iamV0b1wiLFxuICAgIFwib2JyYVwiLFxuICAgIFwib2JyZXJvXCIsXG4gICAgXCJvYnNlcnZhclwiLFxuICAgIFwib2J0ZW5lclwiLFxuICAgIFwib2J2aW9cIixcbiAgICBcIm9jYVwiLFxuICAgIFwib2Nhc29cIixcbiAgICBcIm9jZcyBYW5vXCIsXG4gICAgXCJvY2hlbnRhXCIsXG4gICAgXCJvY2hvXCIsXG4gICAgXCJvY2lvXCIsXG4gICAgXCJvY3JlXCIsXG4gICAgXCJvY3Rhdm9cIixcbiAgICBcIm9jdHVicmVcIixcbiAgICBcIm9jdWx0b1wiLFxuICAgIFwib2N1cGFyXCIsXG4gICAgXCJvY3VycmlyXCIsXG4gICAgXCJvZGlhclwiLFxuICAgIFwib2Rpb1wiLFxuICAgIFwib2Rpc2VhXCIsXG4gICAgXCJvZXN0ZVwiLFxuICAgIFwib2ZlbnNhXCIsXG4gICAgXCJvZmVydGFcIixcbiAgICBcIm9maWNpb1wiLFxuICAgIFwib2ZyZWNlclwiLFxuICAgIFwib2dyb1wiLFxuICAgIFwib2nMgWRvXCIsXG4gICAgXCJvacyBclwiLFxuICAgIFwib2pvXCIsXG4gICAgXCJvbGFcIixcbiAgICBcIm9sZWFkYVwiLFxuICAgIFwib2xmYXRvXCIsXG4gICAgXCJvbGl2b1wiLFxuICAgIFwib2xsYVwiLFxuICAgIFwib2xtb1wiLFxuICAgIFwib2xvclwiLFxuICAgIFwib2x2aWRvXCIsXG4gICAgXCJvbWJsaWdvXCIsXG4gICAgXCJvbmRhXCIsXG4gICAgXCJvbnphXCIsXG4gICAgXCJvcGFjb1wiLFxuICAgIFwib3BjaW/MgW5cIixcbiAgICBcIm/MgXBlcmFcIixcbiAgICBcIm9waW5hclwiLFxuICAgIFwib3BvbmVyXCIsXG4gICAgXCJvcHRhclwiLFxuICAgIFwib8yBcHRpY2FcIixcbiAgICBcIm9wdWVzdG9cIixcbiAgICBcIm9yYWNpb8yBblwiLFxuICAgIFwib3JhZG9yXCIsXG4gICAgXCJvcmFsXCIsXG4gICAgXCJvzIFyYml0YVwiLFxuICAgIFwib3JjYVwiLFxuICAgIFwib3JkZW5cIixcbiAgICBcIm9yZWphXCIsXG4gICAgXCJvzIFyZ2Fub1wiLFxuICAgIFwib3JnacyBYVwiLFxuICAgIFwib3JndWxsb1wiLFxuICAgIFwib3JpZW50ZVwiLFxuICAgIFwib3JpZ2VuXCIsXG4gICAgXCJvcmlsbGFcIixcbiAgICBcIm9yb1wiLFxuICAgIFwib3JxdWVzdGFcIixcbiAgICBcIm9ydWdhXCIsXG4gICAgXCJvc2FkacyBYVwiLFxuICAgIFwib3NjdXJvXCIsXG4gICAgXCJvc2V6bm9cIixcbiAgICBcIm9zb1wiLFxuICAgIFwib3N0cmFcIixcbiAgICBcIm90b27Mg29cIixcbiAgICBcIm90cm9cIixcbiAgICBcIm92ZWphXCIsXG4gICAgXCJvzIF2dWxvXCIsXG4gICAgXCJvzIF4aWRvXCIsXG4gICAgXCJveGnMgWdlbm9cIixcbiAgICBcIm95ZW50ZVwiLFxuICAgIFwib3pvbm9cIixcbiAgICBcInBhY3RvXCIsXG4gICAgXCJwYWRyZVwiLFxuICAgIFwicGFlbGxhXCIsXG4gICAgXCJwYcyBZ2luYVwiLFxuICAgIFwicGFnb1wiLFxuICAgIFwicGFpzIFzXCIsXG4gICAgXCJwYcyBamFyb1wiLFxuICAgIFwicGFsYWJyYVwiLFxuICAgIFwicGFsY29cIixcbiAgICBcInBhbGV0YVwiLFxuICAgIFwicGHMgWxpZG9cIixcbiAgICBcInBhbG1hXCIsXG4gICAgXCJwYWxvbWFcIixcbiAgICBcInBhbHBhclwiLFxuICAgIFwicGFuXCIsXG4gICAgXCJwYW5hbFwiLFxuICAgIFwicGHMgW5pY29cIixcbiAgICBcInBhbnRlcmFcIixcbiAgICBcInBhbsyDdWVsb1wiLFxuICAgIFwicGFwYcyBXCIsXG4gICAgXCJwYXBlbFwiLFxuICAgIFwicGFwaWxsYVwiLFxuICAgIFwicGFxdWV0ZVwiLFxuICAgIFwicGFyYXJcIixcbiAgICBcInBhcmNlbGFcIixcbiAgICBcInBhcmVkXCIsXG4gICAgXCJwYXJpclwiLFxuICAgIFwicGFyb1wiLFxuICAgIFwicGHMgXJwYWRvXCIsXG4gICAgXCJwYXJxdWVcIixcbiAgICBcInBhzIFycmFmb1wiLFxuICAgIFwicGFydGVcIixcbiAgICBcInBhc2FyXCIsXG4gICAgXCJwYXNlb1wiLFxuICAgIFwicGFzaW/MgW5cIixcbiAgICBcInBhc29cIixcbiAgICBcInBhc3RhXCIsXG4gICAgXCJwYXRhXCIsXG4gICAgXCJwYXRpb1wiLFxuICAgIFwicGF0cmlhXCIsXG4gICAgXCJwYXVzYVwiLFxuICAgIFwicGF1dGFcIixcbiAgICBcInBhdm9cIixcbiAgICBcInBheWFzb1wiLFxuICAgIFwicGVhdG/MgW5cIixcbiAgICBcInBlY2Fkb1wiLFxuICAgIFwicGVjZXJhXCIsXG4gICAgXCJwZWNob1wiLFxuICAgIFwicGVkYWxcIixcbiAgICBcInBlZGlyXCIsXG4gICAgXCJwZWdhclwiLFxuICAgIFwicGVpbmVcIixcbiAgICBcInBlbGFyXCIsXG4gICAgXCJwZWxkYW7Mg29cIixcbiAgICBcInBlbGVhXCIsXG4gICAgXCJwZWxpZ3JvXCIsXG4gICAgXCJwZWxsZWpvXCIsXG4gICAgXCJwZWxvXCIsXG4gICAgXCJwZWx1Y2FcIixcbiAgICBcInBlbmFcIixcbiAgICBcInBlbnNhclwiLFxuICAgIFwicGVuzINvzIFuXCIsXG4gICAgXCJwZW/MgW5cIixcbiAgICBcInBlb3JcIixcbiAgICBcInBlcGlub1wiLFxuICAgIFwicGVxdWVuzINvXCIsXG4gICAgXCJwZXJhXCIsXG4gICAgXCJwZXJjaGFcIixcbiAgICBcInBlcmRlclwiLFxuICAgIFwicGVyZXphXCIsXG4gICAgXCJwZXJmaWxcIixcbiAgICBcInBlcmljb1wiLFxuICAgIFwicGVybGFcIixcbiAgICBcInBlcm1pc29cIixcbiAgICBcInBlcnJvXCIsXG4gICAgXCJwZXJzb25hXCIsXG4gICAgXCJwZXNhXCIsXG4gICAgXCJwZXNjYVwiLFxuICAgIFwicGXMgXNpbW9cIixcbiAgICBcInBlc3RhbsyDYVwiLFxuICAgIFwicGXMgXRhbG9cIixcbiAgICBcInBldHJvzIFsZW9cIixcbiAgICBcInBlelwiLFxuICAgIFwicGV6dW7Mg2FcIixcbiAgICBcInBpY2FyXCIsXG4gICAgXCJwaWNob8yBblwiLFxuICAgIFwicGllXCIsXG4gICAgXCJwaWVkcmFcIixcbiAgICBcInBpZXJuYVwiLFxuICAgIFwicGllemFcIixcbiAgICBcInBpamFtYVwiLFxuICAgIFwicGlsYXJcIixcbiAgICBcInBpbG90b1wiLFxuICAgIFwicGltaWVudGFcIixcbiAgICBcInBpbm9cIixcbiAgICBcInBpbnRvclwiLFxuICAgIFwicGluemFcIixcbiAgICBcInBpbsyDYVwiLFxuICAgIFwicGlvam9cIixcbiAgICBcInBpcGFcIixcbiAgICBcInBpcmF0YVwiLFxuICAgIFwicGlzYXJcIixcbiAgICBcInBpc2NpbmFcIixcbiAgICBcInBpc29cIixcbiAgICBcInBpc3RhXCIsXG4gICAgXCJwaXRvzIFuXCIsXG4gICAgXCJwaXpjYVwiLFxuICAgIFwicGxhY2FcIixcbiAgICBcInBsYW5cIixcbiAgICBcInBsYXRhXCIsXG4gICAgXCJwbGF5YVwiLFxuICAgIFwicGxhemFcIixcbiAgICBcInBsZWl0b1wiLFxuICAgIFwicGxlbm9cIixcbiAgICBcInBsb21vXCIsXG4gICAgXCJwbHVtYVwiLFxuICAgIFwicGx1cmFsXCIsXG4gICAgXCJwb2JyZVwiLFxuICAgIFwicG9jb1wiLFxuICAgIFwicG9kZXJcIixcbiAgICBcInBvZGlvXCIsXG4gICAgXCJwb2VtYVwiLFxuICAgIFwicG9lc2nMgWFcIixcbiAgICBcInBvZXRhXCIsXG4gICAgXCJwb2xlblwiLFxuICAgIFwicG9saWNpzIFhXCIsXG4gICAgXCJwb2xsb1wiLFxuICAgIFwicG9sdm9cIixcbiAgICBcInBvbWFkYVwiLFxuICAgIFwicG9tZWxvXCIsXG4gICAgXCJwb21vXCIsXG4gICAgXCJwb21wYVwiLFxuICAgIFwicG9uZXJcIixcbiAgICBcInBvcmNpb8yBblwiLFxuICAgIFwicG9ydGFsXCIsXG4gICAgXCJwb3NhZGFcIixcbiAgICBcInBvc2VlclwiLFxuICAgIFwicG9zaWJsZVwiLFxuICAgIFwicG9zdGVcIixcbiAgICBcInBvdGVuY2lhXCIsXG4gICAgXCJwb3Ryb1wiLFxuICAgIFwicG96b1wiLFxuICAgIFwicHJhZG9cIixcbiAgICBcInByZWNvelwiLFxuICAgIFwicHJlZ3VudGFcIixcbiAgICBcInByZW1pb1wiLFxuICAgIFwicHJlbnNhXCIsXG4gICAgXCJwcmVzb1wiLFxuICAgIFwicHJldmlvXCIsXG4gICAgXCJwcmltb1wiLFxuICAgIFwicHJpzIFuY2lwZVwiLFxuICAgIFwicHJpc2lvzIFuXCIsXG4gICAgXCJwcml2YXJcIixcbiAgICBcInByb2FcIixcbiAgICBcInByb2JhclwiLFxuICAgIFwicHJvY2Vzb1wiLFxuICAgIFwicHJvZHVjdG9cIixcbiAgICBcInByb2V6YVwiLFxuICAgIFwicHJvZmVzb3JcIixcbiAgICBcInByb2dyYW1hXCIsXG4gICAgXCJwcm9sZVwiLFxuICAgIFwicHJvbWVzYVwiLFxuICAgIFwicHJvbnRvXCIsXG4gICAgXCJwcm9waW9cIixcbiAgICBcInByb8yBeGltb1wiLFxuICAgIFwicHJ1ZWJhXCIsXG4gICAgXCJwdcyBYmxpY29cIixcbiAgICBcInB1Y2hlcm9cIixcbiAgICBcInB1ZG9yXCIsXG4gICAgXCJwdWVibG9cIixcbiAgICBcInB1ZXJ0YVwiLFxuICAgIFwicHVlc3RvXCIsXG4gICAgXCJwdWxnYVwiLFxuICAgIFwicHVsaXJcIixcbiAgICBcInB1bG1vzIFuXCIsXG4gICAgXCJwdWxwb1wiLFxuICAgIFwicHVsc29cIixcbiAgICBcInB1bWFcIixcbiAgICBcInB1bnRvXCIsXG4gICAgXCJwdW7Mg2FsXCIsXG4gICAgXCJwdW7Mg29cIixcbiAgICBcInB1cGFcIixcbiAgICBcInB1cGlsYVwiLFxuICAgIFwicHVyZcyBXCIsXG4gICAgXCJxdWVkYXJcIixcbiAgICBcInF1ZWphXCIsXG4gICAgXCJxdWVtYXJcIixcbiAgICBcInF1ZXJlclwiLFxuICAgIFwicXVlc29cIixcbiAgICBcInF1aWV0b1wiLFxuICAgIFwicXVpzIFtaWNhXCIsXG4gICAgXCJxdWluY2VcIixcbiAgICBcInF1aXRhclwiLFxuICAgIFwicmHMgWJhbm9cIixcbiAgICBcInJhYmlhXCIsXG4gICAgXCJyYWJvXCIsXG4gICAgXCJyYWNpb8yBblwiLFxuICAgIFwicmFkaWNhbFwiLFxuICAgIFwicmFpzIF6XCIsXG4gICAgXCJyYW1hXCIsXG4gICAgXCJyYW1wYVwiLFxuICAgIFwicmFuY2hvXCIsXG4gICAgXCJyYW5nb1wiLFxuICAgIFwicmFwYXpcIixcbiAgICBcInJhzIFwaWRvXCIsXG4gICAgXCJyYXB0b1wiLFxuICAgIFwicmFzZ29cIixcbiAgICBcInJhc3BhXCIsXG4gICAgXCJyYXRvXCIsXG4gICAgXCJyYXlvXCIsXG4gICAgXCJyYXphXCIsXG4gICAgXCJyYXpvzIFuXCIsXG4gICAgXCJyZWFjY2lvzIFuXCIsXG4gICAgXCJyZWFsaWRhZFwiLFxuICAgIFwicmViYW7Mg29cIixcbiAgICBcInJlYm90ZVwiLFxuICAgIFwicmVjYWVyXCIsXG4gICAgXCJyZWNldGFcIixcbiAgICBcInJlY2hhem9cIixcbiAgICBcInJlY29nZXJcIixcbiAgICBcInJlY3Jlb1wiLFxuICAgIFwicmVjdG9cIixcbiAgICBcInJlY3Vyc29cIixcbiAgICBcInJlZFwiLFxuICAgIFwicmVkb25kb1wiLFxuICAgIFwicmVkdWNpclwiLFxuICAgIFwicmVmbGVqb1wiLFxuICAgIFwicmVmb3JtYVwiLFxuICAgIFwicmVmcmHMgW5cIixcbiAgICBcInJlZnVnaW9cIixcbiAgICBcInJlZ2Fsb1wiLFxuICAgIFwicmVnaXJcIixcbiAgICBcInJlZ2xhXCIsXG4gICAgXCJyZWdyZXNvXCIsXG4gICAgXCJyZWhlzIFuXCIsXG4gICAgXCJyZWlub1wiLFxuICAgIFwicmVpzIFyXCIsXG4gICAgXCJyZWphXCIsXG4gICAgXCJyZWxhdG9cIixcbiAgICBcInJlbGV2b1wiLFxuICAgIFwicmVsaWV2ZVwiLFxuICAgIFwicmVsbGVub1wiLFxuICAgIFwicmVsb2pcIixcbiAgICBcInJlbWFyXCIsXG4gICAgXCJyZW1lZGlvXCIsXG4gICAgXCJyZW1vXCIsXG4gICAgXCJyZW5jb3JcIixcbiAgICBcInJlbmRpclwiLFxuICAgIFwicmVudGFcIixcbiAgICBcInJlcGFydG9cIixcbiAgICBcInJlcGV0aXJcIixcbiAgICBcInJlcG9zb1wiLFxuICAgIFwicmVwdGlsXCIsXG4gICAgXCJyZXNcIixcbiAgICBcInJlc2NhdGVcIixcbiAgICBcInJlc2luYVwiLFxuICAgIFwicmVzcGV0b1wiLFxuICAgIFwicmVzdG9cIixcbiAgICBcInJlc3VtZW5cIixcbiAgICBcInJldGlyb1wiLFxuICAgIFwicmV0b3Jub1wiLFxuICAgIFwicmV0cmF0b1wiLFxuICAgIFwicmV1bmlyXCIsXG4gICAgXCJyZXZlzIFzXCIsXG4gICAgXCJyZXZpc3RhXCIsXG4gICAgXCJyZXlcIixcbiAgICBcInJlemFyXCIsXG4gICAgXCJyaWNvXCIsXG4gICAgXCJyaWVnb1wiLFxuICAgIFwicmllbmRhXCIsXG4gICAgXCJyaWVzZ29cIixcbiAgICBcInJpZmFcIixcbiAgICBcInJpzIFnaWRvXCIsXG4gICAgXCJyaWdvclwiLFxuICAgIFwicmluY2/MgW5cIixcbiAgICBcInJpbsyDb8yBblwiLFxuICAgIFwicmnMgW9cIixcbiAgICBcInJpcXVlemFcIixcbiAgICBcInJpc2FcIixcbiAgICBcInJpdG1vXCIsXG4gICAgXCJyaXRvXCIsXG4gICAgXCJyaXpvXCIsXG4gICAgXCJyb2JsZVwiLFxuICAgIFwicm9jZVwiLFxuICAgIFwicm9jaWFyXCIsXG4gICAgXCJyb2RhclwiLFxuICAgIFwicm9kZW9cIixcbiAgICBcInJvZGlsbGFcIixcbiAgICBcInJvZXJcIixcbiAgICBcInJvaml6b1wiLFxuICAgIFwicm9qb1wiLFxuICAgIFwicm9tZXJvXCIsXG4gICAgXCJyb21wZXJcIixcbiAgICBcInJvblwiLFxuICAgIFwicm9uY29cIixcbiAgICBcInJvbmRhXCIsXG4gICAgXCJyb3BhXCIsXG4gICAgXCJyb3Blcm9cIixcbiAgICBcInJvc2FcIixcbiAgICBcInJvc2NhXCIsXG4gICAgXCJyb3N0cm9cIixcbiAgICBcInJvdGFyXCIsXG4gICAgXCJydWJpzIFcIixcbiAgICBcInJ1Ym9yXCIsXG4gICAgXCJydWRvXCIsXG4gICAgXCJydWVkYVwiLFxuICAgIFwicnVnaXJcIixcbiAgICBcInJ1aWRvXCIsXG4gICAgXCJydWluYVwiLFxuICAgIFwicnVsZXRhXCIsXG4gICAgXCJydWxvXCIsXG4gICAgXCJydW1ib1wiLFxuICAgIFwicnVtb3JcIixcbiAgICBcInJ1cHR1cmFcIixcbiAgICBcInJ1dGFcIixcbiAgICBcInJ1dGluYVwiLFxuICAgIFwic2HMgWJhZG9cIixcbiAgICBcInNhYmVyXCIsXG4gICAgXCJzYWJpb1wiLFxuICAgIFwic2FibGVcIixcbiAgICBcInNhY2FyXCIsXG4gICAgXCJzYWdhelwiLFxuICAgIFwic2FncmFkb1wiLFxuICAgIFwic2FsYVwiLFxuICAgIFwic2FsZG9cIixcbiAgICBcInNhbGVyb1wiLFxuICAgIFwic2FsaXJcIixcbiAgICBcInNhbG1vzIFuXCIsXG4gICAgXCJzYWxvzIFuXCIsXG4gICAgXCJzYWxzYVwiLFxuICAgIFwic2FsdG9cIixcbiAgICBcInNhbHVkXCIsXG4gICAgXCJzYWx2YXJcIixcbiAgICBcInNhbWJhXCIsXG4gICAgXCJzYW5jaW/MgW5cIixcbiAgICBcInNhbmRpzIFhXCIsXG4gICAgXCJzYW5lYXJcIixcbiAgICBcInNhbmdyZVwiLFxuICAgIFwic2FuaWRhZFwiLFxuICAgIFwic2Fub1wiLFxuICAgIFwic2FudG9cIixcbiAgICBcInNhcG9cIixcbiAgICBcInNhcXVlXCIsXG4gICAgXCJzYXJkaW5hXCIsXG4gICAgXCJzYXJ0ZcyBblwiLFxuICAgIFwic2FzdHJlXCIsXG4gICAgXCJzYXRhzIFuXCIsXG4gICAgXCJzYXVuYVwiLFxuICAgIFwic2F4b2ZvzIFuXCIsXG4gICAgXCJzZWNjaW/MgW5cIixcbiAgICBcInNlY29cIixcbiAgICBcInNlY3JldG9cIixcbiAgICBcInNlY3RhXCIsXG4gICAgXCJzZWRcIixcbiAgICBcInNlZ3VpclwiLFxuICAgIFwic2Vpc1wiLFxuICAgIFwic2VsbG9cIixcbiAgICBcInNlbHZhXCIsXG4gICAgXCJzZW1hbmFcIixcbiAgICBcInNlbWlsbGFcIixcbiAgICBcInNlbmRhXCIsXG4gICAgXCJzZW5zb3JcIixcbiAgICBcInNlbsyDYWxcIixcbiAgICBcInNlbsyDb3JcIixcbiAgICBcInNlcGFyYXJcIixcbiAgICBcInNlcGlhXCIsXG4gICAgXCJzZXF1acyBYVwiLFxuICAgIFwic2VyXCIsXG4gICAgXCJzZXJpZVwiLFxuICAgIFwic2VybW/MgW5cIixcbiAgICBcInNlcnZpclwiLFxuICAgIFwic2VzZW50YVwiLFxuICAgIFwic2VzaW/MgW5cIixcbiAgICBcInNldGFcIixcbiAgICBcInNldGVudGFcIixcbiAgICBcInNldmVyb1wiLFxuICAgIFwic2V4b1wiLFxuICAgIFwic2V4dG9cIixcbiAgICBcInNpZHJhXCIsXG4gICAgXCJzaWVzdGFcIixcbiAgICBcInNpZXRlXCIsXG4gICAgXCJzaWdsb1wiLFxuICAgIFwic2lnbm9cIixcbiAgICBcInNpzIFsYWJhXCIsXG4gICAgXCJzaWxiYXJcIixcbiAgICBcInNpbGVuY2lvXCIsXG4gICAgXCJzaWxsYVwiLFxuICAgIFwic2nMgW1ib2xvXCIsXG4gICAgXCJzaW1pb1wiLFxuICAgIFwic2lyZW5hXCIsXG4gICAgXCJzaXN0ZW1hXCIsXG4gICAgXCJzaXRpb1wiLFxuICAgIFwic2l0dWFyXCIsXG4gICAgXCJzb2JyZVwiLFxuICAgIFwic29jaW9cIixcbiAgICBcInNvZGlvXCIsXG4gICAgXCJzb2xcIixcbiAgICBcInNvbGFwYVwiLFxuICAgIFwic29sZGFkb1wiLFxuICAgIFwic29sZWRhZFwiLFxuICAgIFwic2/MgWxpZG9cIixcbiAgICBcInNvbHRhclwiLFxuICAgIFwic29sdWNpb8yBblwiLFxuICAgIFwic29tYnJhXCIsXG4gICAgXCJzb25kZW9cIixcbiAgICBcInNvbmlkb1wiLFxuICAgIFwic29ub3JvXCIsXG4gICAgXCJzb25yaXNhXCIsXG4gICAgXCJzb3BhXCIsXG4gICAgXCJzb3BsYXJcIixcbiAgICBcInNvcG9ydGVcIixcbiAgICBcInNvcmRvXCIsXG4gICAgXCJzb3JwcmVzYVwiLFxuICAgIFwic29ydGVvXCIsXG4gICAgXCJzb3N0ZcyBblwiLFxuICAgIFwic2/MgXRhbm9cIixcbiAgICBcInN1YXZlXCIsXG4gICAgXCJzdWJpclwiLFxuICAgIFwic3VjZXNvXCIsXG4gICAgXCJzdWRvclwiLFxuICAgIFwic3VlZ3JhXCIsXG4gICAgXCJzdWVsb1wiLFxuICAgIFwic3VlbsyDb1wiLFxuICAgIFwic3VlcnRlXCIsXG4gICAgXCJzdWZyaXJcIixcbiAgICBcInN1amV0b1wiLFxuICAgIFwic3VsdGHMgW5cIixcbiAgICBcInN1bWFyXCIsXG4gICAgXCJzdXBlcmFyXCIsXG4gICAgXCJzdXBsaXJcIixcbiAgICBcInN1cG9uZXJcIixcbiAgICBcInN1cHJlbW9cIixcbiAgICBcInN1clwiLFxuICAgIFwic3VyY29cIixcbiAgICBcInN1cmVuzINvXCIsXG4gICAgXCJzdXJnaXJcIixcbiAgICBcInN1c3RvXCIsXG4gICAgXCJzdXRpbFwiLFxuICAgIFwidGFiYWNvXCIsXG4gICAgXCJ0YWJpcXVlXCIsXG4gICAgXCJ0YWJsYVwiLFxuICAgIFwidGFidcyBXCIsXG4gICAgXCJ0YWNvXCIsXG4gICAgXCJ0YWN0b1wiLFxuICAgIFwidGFqb1wiLFxuICAgIFwidGFsYXJcIixcbiAgICBcInRhbGNvXCIsXG4gICAgXCJ0YWxlbnRvXCIsXG4gICAgXCJ0YWxsYVwiLFxuICAgIFwidGFsb8yBblwiLFxuICAgIFwidGFtYW7Mg29cIixcbiAgICBcInRhbWJvclwiLFxuICAgIFwidGFuZ29cIixcbiAgICBcInRhbnF1ZVwiLFxuICAgIFwidGFwYVwiLFxuICAgIFwidGFwZXRlXCIsXG4gICAgXCJ0YXBpYVwiLFxuICAgIFwidGFwb8yBblwiLFxuICAgIFwidGFxdWlsbGFcIixcbiAgICBcInRhcmRlXCIsXG4gICAgXCJ0YXJlYVwiLFxuICAgIFwidGFyaWZhXCIsXG4gICAgXCJ0YXJqZXRhXCIsXG4gICAgXCJ0YXJvdFwiLFxuICAgIFwidGFycm9cIixcbiAgICBcInRhcnRhXCIsXG4gICAgXCJ0YXR1YWplXCIsXG4gICAgXCJ0YXVyb1wiLFxuICAgIFwidGF6YVwiLFxuICAgIFwidGF6b8yBblwiLFxuICAgIFwidGVhdHJvXCIsXG4gICAgXCJ0ZWNob1wiLFxuICAgIFwidGVjbGFcIixcbiAgICBcInRlzIFjbmljYVwiLFxuICAgIFwidGVqYWRvXCIsXG4gICAgXCJ0ZWplclwiLFxuICAgIFwidGVqaWRvXCIsXG4gICAgXCJ0ZWxhXCIsXG4gICAgXCJ0ZWxlzIFmb25vXCIsXG4gICAgXCJ0ZW1hXCIsXG4gICAgXCJ0ZW1vclwiLFxuICAgIFwidGVtcGxvXCIsXG4gICAgXCJ0ZW5helwiLFxuICAgIFwidGVuZGVyXCIsXG4gICAgXCJ0ZW5lclwiLFxuICAgIFwidGVuaXNcIixcbiAgICBcInRlbnNvXCIsXG4gICAgXCJ0ZW9yacyBYVwiLFxuICAgIFwidGVyYXBpYVwiLFxuICAgIFwidGVyY29cIixcbiAgICBcInRlzIFybWlub1wiLFxuICAgIFwidGVybnVyYVwiLFxuICAgIFwidGVycm9yXCIsXG4gICAgXCJ0ZXNpc1wiLFxuICAgIFwidGVzb3JvXCIsXG4gICAgXCJ0ZXN0aWdvXCIsXG4gICAgXCJ0ZXRlcmFcIixcbiAgICBcInRleHRvXCIsXG4gICAgXCJ0ZXpcIixcbiAgICBcInRpYmlvXCIsXG4gICAgXCJ0aWJ1cm/MgW5cIixcbiAgICBcInRpZW1wb1wiLFxuICAgIFwidGllbmRhXCIsXG4gICAgXCJ0aWVycmFcIixcbiAgICBcInRpZXNvXCIsXG4gICAgXCJ0aWdyZVwiLFxuICAgIFwidGlqZXJhXCIsXG4gICAgXCJ0aWxkZVwiLFxuICAgIFwidGltYnJlXCIsXG4gICAgXCJ0acyBbWlkb1wiLFxuICAgIFwidGltb1wiLFxuICAgIFwidGludGFcIixcbiAgICBcInRpzIFvXCIsXG4gICAgXCJ0acyBcGljb1wiLFxuICAgIFwidGlwb1wiLFxuICAgIFwidGlyYVwiLFxuICAgIFwidGlyb8yBblwiLFxuICAgIFwidGl0YcyBblwiLFxuICAgIFwidGnMgXRlcmVcIixcbiAgICBcInRpzIF0dWxvXCIsXG4gICAgXCJ0aXphXCIsXG4gICAgXCJ0b2FsbGFcIixcbiAgICBcInRvYmlsbG9cIixcbiAgICBcInRvY2FyXCIsXG4gICAgXCJ0b2Npbm9cIixcbiAgICBcInRvZG9cIixcbiAgICBcInRvZ2FcIixcbiAgICBcInRvbGRvXCIsXG4gICAgXCJ0b21hclwiLFxuICAgIFwidG9ub1wiLFxuICAgIFwidG9udG9cIixcbiAgICBcInRvcGFyXCIsXG4gICAgXCJ0b3BlXCIsXG4gICAgXCJ0b3F1ZVwiLFxuICAgIFwidG/MgXJheFwiLFxuICAgIFwidG9yZXJvXCIsXG4gICAgXCJ0b3JtZW50YVwiLFxuICAgIFwidG9ybmVvXCIsXG4gICAgXCJ0b3JvXCIsXG4gICAgXCJ0b3JwZWRvXCIsXG4gICAgXCJ0b3JyZVwiLFxuICAgIFwidG9yc29cIixcbiAgICBcInRvcnR1Z2FcIixcbiAgICBcInRvc1wiLFxuICAgIFwidG9zY29cIixcbiAgICBcInRvc2VyXCIsXG4gICAgXCJ0b8yBeGljb1wiLFxuICAgIFwidHJhYmFqb1wiLFxuICAgIFwidHJhY3RvclwiLFxuICAgIFwidHJhZXJcIixcbiAgICBcInRyYcyBZmljb1wiLFxuICAgIFwidHJhZ29cIixcbiAgICBcInRyYWplXCIsXG4gICAgXCJ0cmFtb1wiLFxuICAgIFwidHJhbmNlXCIsXG4gICAgXCJ0cmF0b1wiLFxuICAgIFwidHJhdW1hXCIsXG4gICAgXCJ0cmF6YXJcIixcbiAgICBcInRyZcyBYm9sXCIsXG4gICAgXCJ0cmVndWFcIixcbiAgICBcInRyZWludGFcIixcbiAgICBcInRyZW5cIixcbiAgICBcInRyZXBhclwiLFxuICAgIFwidHJlc1wiLFxuICAgIFwidHJpYnVcIixcbiAgICBcInRyaWdvXCIsXG4gICAgXCJ0cmlwYVwiLFxuICAgIFwidHJpc3RlXCIsXG4gICAgXCJ0cml1bmZvXCIsXG4gICAgXCJ0cm9mZW9cIixcbiAgICBcInRyb21wYVwiLFxuICAgIFwidHJvbmNvXCIsXG4gICAgXCJ0cm9wYVwiLFxuICAgIFwidHJvdGVcIixcbiAgICBcInRyb3pvXCIsXG4gICAgXCJ0cnVjb1wiLFxuICAgIFwidHJ1ZW5vXCIsXG4gICAgXCJ0cnVmYVwiLFxuICAgIFwidHViZXJpzIFhXCIsXG4gICAgXCJ0dWJvXCIsXG4gICAgXCJ0dWVydG9cIixcbiAgICBcInR1bWJhXCIsXG4gICAgXCJ0dW1vclwiLFxuICAgIFwidHXMgW5lbFwiLFxuICAgIFwidHXMgW5pY2FcIixcbiAgICBcInR1cmJpbmFcIixcbiAgICBcInR1cmlzbW9cIixcbiAgICBcInR1cm5vXCIsXG4gICAgXCJ0dXRvclwiLFxuICAgIFwidWJpY2FyXCIsXG4gICAgXCJ1zIFsY2VyYVwiLFxuICAgIFwidW1icmFsXCIsXG4gICAgXCJ1bmlkYWRcIixcbiAgICBcInVuaXJcIixcbiAgICBcInVuaXZlcnNvXCIsXG4gICAgXCJ1bm9cIixcbiAgICBcInVudGFyXCIsXG4gICAgXCJ1bsyDYVwiLFxuICAgIFwidXJiYW5vXCIsXG4gICAgXCJ1cmJlXCIsXG4gICAgXCJ1cmdlbnRlXCIsXG4gICAgXCJ1cm5hXCIsXG4gICAgXCJ1c2FyXCIsXG4gICAgXCJ1c3VhcmlvXCIsXG4gICAgXCJ1zIF0aWxcIixcbiAgICBcInV0b3BpzIFhXCIsXG4gICAgXCJ1dmFcIixcbiAgICBcInZhY2FcIixcbiAgICBcInZhY2nMgW9cIixcbiAgICBcInZhY3VuYVwiLFxuICAgIFwidmFnYXJcIixcbiAgICBcInZhZ29cIixcbiAgICBcInZhaW5hXCIsXG4gICAgXCJ2YWppbGxhXCIsXG4gICAgXCJ2YWxlXCIsXG4gICAgXCJ2YcyBbGlkb1wiLFxuICAgIFwidmFsbGVcIixcbiAgICBcInZhbG9yXCIsXG4gICAgXCJ2YcyBbHZ1bGFcIixcbiAgICBcInZhbXBpcm9cIixcbiAgICBcInZhcmFcIixcbiAgICBcInZhcmlhclwiLFxuICAgIFwidmFyb8yBblwiLFxuICAgIFwidmFzb1wiLFxuICAgIFwidmVjaW5vXCIsXG4gICAgXCJ2ZWN0b3JcIixcbiAgICBcInZlaGnMgWN1bG9cIixcbiAgICBcInZlaW50ZVwiLFxuICAgIFwidmVqZXpcIixcbiAgICBcInZlbGFcIixcbiAgICBcInZlbGVyb1wiLFxuICAgIFwidmVsb3pcIixcbiAgICBcInZlbmFcIixcbiAgICBcInZlbmNlclwiLFxuICAgIFwidmVuZGFcIixcbiAgICBcInZlbmVub1wiLFxuICAgIFwidmVuZ2FyXCIsXG4gICAgXCJ2ZW5pclwiLFxuICAgIFwidmVudGFcIixcbiAgICBcInZlbnVzXCIsXG4gICAgXCJ2ZXJcIixcbiAgICBcInZlcmFub1wiLFxuICAgIFwidmVyYm9cIixcbiAgICBcInZlcmRlXCIsXG4gICAgXCJ2ZXJlZGFcIixcbiAgICBcInZlcmphXCIsXG4gICAgXCJ2ZXJzb1wiLFxuICAgIFwidmVydGVyXCIsXG4gICAgXCJ2acyBYVwiLFxuICAgIFwidmlhamVcIixcbiAgICBcInZpYnJhclwiLFxuICAgIFwidmljaW9cIixcbiAgICBcInZpzIFjdGltYVwiLFxuICAgIFwidmlkYVwiLFxuICAgIFwidmnMgWRlb1wiLFxuICAgIFwidmlkcmlvXCIsXG4gICAgXCJ2aWVqb1wiLFxuICAgIFwidmllcm5lc1wiLFxuICAgIFwidmlnb3JcIixcbiAgICBcInZpbFwiLFxuICAgIFwidmlsbGFcIixcbiAgICBcInZpbmFncmVcIixcbiAgICBcInZpbm9cIixcbiAgICBcInZpbsyDZWRvXCIsXG4gICAgXCJ2aW9sacyBblwiLFxuICAgIFwidmlyYWxcIixcbiAgICBcInZpcmdvXCIsXG4gICAgXCJ2aXJ0dWRcIixcbiAgICBcInZpc29yXCIsXG4gICAgXCJ2acyBc3BlcmFcIixcbiAgICBcInZpc3RhXCIsXG4gICAgXCJ2aXRhbWluYVwiLFxuICAgIFwidml1ZG9cIixcbiAgICBcInZpdmF6XCIsXG4gICAgXCJ2aXZlcm9cIixcbiAgICBcInZpdmlyXCIsXG4gICAgXCJ2aXZvXCIsXG4gICAgXCJ2b2xjYcyBblwiLFxuICAgIFwidm9sdW1lblwiLFxuICAgIFwidm9sdmVyXCIsXG4gICAgXCJ2b3JhelwiLFxuICAgIFwidm90YXJcIixcbiAgICBcInZvdG9cIixcbiAgICBcInZvelwiLFxuICAgIFwidnVlbG9cIixcbiAgICBcInZ1bGdhclwiLFxuICAgIFwieWFjZXJcIixcbiAgICBcInlhdGVcIixcbiAgICBcInllZ3VhXCIsXG4gICAgXCJ5ZW1hXCIsXG4gICAgXCJ5ZXJub1wiLFxuICAgIFwieWVzb1wiLFxuICAgIFwieW9kb1wiLFxuICAgIFwieW9nYVwiLFxuICAgIFwieW9ndXJcIixcbiAgICBcInphZmlyb1wiLFxuICAgIFwiemFuamFcIixcbiAgICBcInphcGF0b1wiLFxuICAgIFwiemFyemFcIixcbiAgICBcInpvbmFcIixcbiAgICBcInpvcnJvXCIsXG4gICAgXCJ6dW1vXCIsXG4gICAgXCJ6dXJkb1wiXG5dXG4iLCIvLyBSZWZlcmVuY2UgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2lcbi8vIEZvcm1hdDogMHgzMCBbdG90YWwtbGVuZ3RoXSAweDAyIFtSLWxlbmd0aF0gW1JdIDB4MDIgW1MtbGVuZ3RoXSBbU11cbi8vIE5PVEU6IFNJR0hBU0ggYnl0ZSBpZ25vcmVkIEFORCByZXN0cmljdGVkLCB0cnVuY2F0ZSBiZWZvcmUgdXNlXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBjaGVjayAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIDwgOCkgcmV0dXJuIGZhbHNlXG4gIGlmIChidWZmZXIubGVuZ3RoID4gNzIpIHJldHVybiBmYWxzZVxuICBpZiAoYnVmZmVyWzBdICE9PSAweDMwKSByZXR1cm4gZmFsc2VcbiAgaWYgKGJ1ZmZlclsxXSAhPT0gYnVmZmVyLmxlbmd0aCAtIDIpIHJldHVybiBmYWxzZVxuICBpZiAoYnVmZmVyWzJdICE9PSAweDAyKSByZXR1cm4gZmFsc2VcblxuICB2YXIgbGVuUiA9IGJ1ZmZlclszXVxuICBpZiAobGVuUiA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICg1ICsgbGVuUiA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiBmYWxzZVxuXG4gIHZhciBsZW5TID0gYnVmZmVyWzUgKyBsZW5SXVxuICBpZiAobGVuUyA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICgoNiArIGxlblIgKyBsZW5TKSAhPT0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGJ1ZmZlcls0XSAmIDB4ODApIHJldHVybiBmYWxzZVxuICBpZiAobGVuUiA+IDEgJiYgKGJ1ZmZlcls0XSA9PT0gMHgwMCkgJiYgIShidWZmZXJbNV0gJiAweDgwKSkgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGJ1ZmZlcltsZW5SICsgNl0gJiAweDgwKSByZXR1cm4gZmFsc2VcbiAgaWYgKGxlblMgPiAxICYmIChidWZmZXJbbGVuUiArIDZdID09PSAweDAwKSAmJiAhKGJ1ZmZlcltsZW5SICsgN10gJiAweDgwKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIDwgOCkgdGhyb3cgbmV3IEVycm9yKCdERVIgc2VxdWVuY2UgbGVuZ3RoIGlzIHRvbyBzaG9ydCcpXG4gIGlmIChidWZmZXIubGVuZ3RoID4gNzIpIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyB0b28gbG9uZycpXG4gIGlmIChidWZmZXJbMF0gIT09IDB4MzApIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIHNlcXVlbmNlJylcbiAgaWYgKGJ1ZmZlclsxXSAhPT0gYnVmZmVyLmxlbmd0aCAtIDIpIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyBpbnZhbGlkJylcbiAgaWYgKGJ1ZmZlclsyXSAhPT0gMHgwMikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBERVIgaW50ZWdlcicpXG5cbiAgdmFyIGxlblIgPSBidWZmZXJbM11cbiAgaWYgKGxlblIgPT09IDApIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgemVybycpXG4gIGlmICg1ICsgbGVuUiA+PSBidWZmZXIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIGludGVnZXIgKDIpJylcblxuICB2YXIgbGVuUyA9IGJ1ZmZlcls1ICsgbGVuUl1cbiAgaWYgKGxlblMgPT09IDApIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgemVybycpXG4gIGlmICgoNiArIGxlblIgKyBsZW5TKSAhPT0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyBpbnZhbGlkJylcblxuICBpZiAoYnVmZmVyWzRdICYgMHg4MCkgdGhyb3cgbmV3IEVycm9yKCdSIHZhbHVlIGlzIG5lZ2F0aXZlJylcbiAgaWYgKGxlblIgPiAxICYmIChidWZmZXJbNF0gPT09IDB4MDApICYmICEoYnVmZmVyWzVdICYgMHg4MCkpIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKVxuXG4gIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MCkgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGlzIG5lZ2F0aXZlJylcbiAgaWYgKGxlblMgPiAxICYmIChidWZmZXJbbGVuUiArIDZdID09PSAweDAwKSAmJiAhKGJ1ZmZlcltsZW5SICsgN10gJiAweDgwKSkgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpXG5cbiAgLy8gbm9uLUJJUDY2IC0gZXh0cmFjdCBSLCBTIHZhbHVlc1xuICByZXR1cm4ge1xuICAgIHI6IGJ1ZmZlci5zbGljZSg0LCA0ICsgbGVuUiksXG4gICAgczogYnVmZmVyLnNsaWNlKDYgKyBsZW5SKVxuICB9XG59XG5cbi8qXG4gKiBFeHBlY3RzIHIgYW5kIHMgdG8gYmUgcG9zaXRpdmUgREVSIGludGVnZXJzLlxuICpcbiAqIFRoZSBERVIgZm9ybWF0IHVzZXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGFzIGEgc2lnbiBiaXQgKCYgMHg4MCkuXG4gKiBJZiB0aGUgc2lnbmlmaWNhbnQgYml0IGlzIHNldCBBTkQgdGhlIGludGVnZXIgaXMgcG9zaXRpdmUsIGEgMHgwMCBpcyBwcmVwZW5kZWQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAwID0+ICAgICAweDAwXG4gKiAgICAgIDEgPT4gICAgIDB4MDFcbiAqICAgICAtMSA9PiAgICAgMHhmZlxuICogICAgMTI3ID0+ICAgICAweDdmXG4gKiAgIC0xMjcgPT4gICAgIDB4ODFcbiAqICAgIDEyOCA9PiAgIDB4MDA4MFxuICogICAtMTI4ID0+ICAgICAweDgwXG4gKiAgICAyNTUgPT4gICAweDAwZmZcbiAqICAgLTI1NSA9PiAgIDB4ZmYwMVxuICogIDE2MzAwID0+ICAgMHgzZmFjXG4gKiAtMTYzMDAgPT4gICAweGMwNTRcbiAqICA2MjMwMCA9PiAweDAwZjM1Y1xuICogLTYyMzAwID0+IDB4ZmYwY2E0XG4qL1xuZnVuY3Rpb24gZW5jb2RlIChyLCBzKSB7XG4gIHZhciBsZW5SID0gci5sZW5ndGhcbiAgdmFyIGxlblMgPSBzLmxlbmd0aFxuICBpZiAobGVuUiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdSIGxlbmd0aCBpcyB6ZXJvJylcbiAgaWYgKGxlblMgPT09IDApIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgemVybycpXG4gIGlmIChsZW5SID4gMzMpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKVxuICBpZiAobGVuUyA+IDMzKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgaWYgKHJbMF0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKVxuICBpZiAoc1swXSAmIDB4ODApIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBpcyBuZWdhdGl2ZScpXG4gIGlmIChsZW5SID4gMSAmJiAoclswXSA9PT0gMHgwMCkgJiYgIShyWzFdICYgMHg4MCkpIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKVxuICBpZiAobGVuUyA+IDEgJiYgKHNbMF0gPT09IDB4MDApICYmICEoc1sxXSAmIDB4ODApKSB0aHJvdyBuZXcgRXJyb3IoJ1MgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJylcblxuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDYgKyBsZW5SICsgbGVuUylcblxuICAvLyAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuICBzaWduYXR1cmVbMF0gPSAweDMwXG4gIHNpZ25hdHVyZVsxXSA9IHNpZ25hdHVyZS5sZW5ndGggLSAyXG4gIHNpZ25hdHVyZVsyXSA9IDB4MDJcbiAgc2lnbmF0dXJlWzNdID0gci5sZW5ndGhcbiAgci5jb3B5KHNpZ25hdHVyZSwgNClcbiAgc2lnbmF0dXJlWzQgKyBsZW5SXSA9IDB4MDJcbiAgc2lnbmF0dXJlWzUgKyBsZW5SXSA9IHMubGVuZ3RoXG4gIHMuY29weShzaWduYXR1cmUsIDYgKyBsZW5SKVxuXG4gIHJldHVybiBzaWduYXR1cmVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrOiBjaGVjayxcbiAgZGVjb2RlOiBkZWNvZGUsXG4gIGVuY29kZTogZW5jb2RlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiT1BfRkFMU0VcIjogMCxcbiAgXCJPUF8wXCI6IDAsXG4gIFwiT1BfUFVTSERBVEExXCI6IDc2LFxuICBcIk9QX1BVU0hEQVRBMlwiOiA3NyxcbiAgXCJPUF9QVVNIREFUQTRcIjogNzgsXG4gIFwiT1BfMU5FR0FURVwiOiA3OSxcbiAgXCJPUF9SRVNFUlZFRFwiOiA4MCxcbiAgXCJPUF9UUlVFXCI6IDgxLFxuICBcIk9QXzFcIjogODEsXG4gIFwiT1BfMlwiOiA4MixcbiAgXCJPUF8zXCI6IDgzLFxuICBcIk9QXzRcIjogODQsXG4gIFwiT1BfNVwiOiA4NSxcbiAgXCJPUF82XCI6IDg2LFxuICBcIk9QXzdcIjogODcsXG4gIFwiT1BfOFwiOiA4OCxcbiAgXCJPUF85XCI6IDg5LFxuICBcIk9QXzEwXCI6IDkwLFxuICBcIk9QXzExXCI6IDkxLFxuICBcIk9QXzEyXCI6IDkyLFxuICBcIk9QXzEzXCI6IDkzLFxuICBcIk9QXzE0XCI6IDk0LFxuICBcIk9QXzE1XCI6IDk1LFxuICBcIk9QXzE2XCI6IDk2LFxuXG4gIFwiT1BfTk9QXCI6IDk3LFxuICBcIk9QX1ZFUlwiOiA5OCxcbiAgXCJPUF9JRlwiOiA5OSxcbiAgXCJPUF9OT1RJRlwiOiAxMDAsXG4gIFwiT1BfVkVSSUZcIjogMTAxLFxuICBcIk9QX1ZFUk5PVElGXCI6IDEwMixcbiAgXCJPUF9FTFNFXCI6IDEwMyxcbiAgXCJPUF9FTkRJRlwiOiAxMDQsXG4gIFwiT1BfVkVSSUZZXCI6IDEwNSxcbiAgXCJPUF9SRVRVUk5cIjogMTA2LFxuXG4gIFwiT1BfVE9BTFRTVEFDS1wiOiAxMDcsXG4gIFwiT1BfRlJPTUFMVFNUQUNLXCI6IDEwOCxcbiAgXCJPUF8yRFJPUFwiOiAxMDksXG4gIFwiT1BfMkRVUFwiOiAxMTAsXG4gIFwiT1BfM0RVUFwiOiAxMTEsXG4gIFwiT1BfMk9WRVJcIjogMTEyLFxuICBcIk9QXzJST1RcIjogMTEzLFxuICBcIk9QXzJTV0FQXCI6IDExNCxcbiAgXCJPUF9JRkRVUFwiOiAxMTUsXG4gIFwiT1BfREVQVEhcIjogMTE2LFxuICBcIk9QX0RST1BcIjogMTE3LFxuICBcIk9QX0RVUFwiOiAxMTgsXG4gIFwiT1BfTklQXCI6IDExOSxcbiAgXCJPUF9PVkVSXCI6IDEyMCxcbiAgXCJPUF9QSUNLXCI6IDEyMSxcbiAgXCJPUF9ST0xMXCI6IDEyMixcbiAgXCJPUF9ST1RcIjogMTIzLFxuICBcIk9QX1NXQVBcIjogMTI0LFxuICBcIk9QX1RVQ0tcIjogMTI1LFxuXG4gIFwiT1BfQ0FUXCI6IDEyNixcbiAgXCJPUF9TVUJTVFJcIjogMTI3LFxuICBcIk9QX0xFRlRcIjogMTI4LFxuICBcIk9QX1JJR0hUXCI6IDEyOSxcbiAgXCJPUF9TSVpFXCI6IDEzMCxcblxuICBcIk9QX0lOVkVSVFwiOiAxMzEsXG4gIFwiT1BfQU5EXCI6IDEzMixcbiAgXCJPUF9PUlwiOiAxMzMsXG4gIFwiT1BfWE9SXCI6IDEzNCxcbiAgXCJPUF9FUVVBTFwiOiAxMzUsXG4gIFwiT1BfRVFVQUxWRVJJRllcIjogMTM2LFxuICBcIk9QX1JFU0VSVkVEMVwiOiAxMzcsXG4gIFwiT1BfUkVTRVJWRUQyXCI6IDEzOCxcblxuICBcIk9QXzFBRERcIjogMTM5LFxuICBcIk9QXzFTVUJcIjogMTQwLFxuICBcIk9QXzJNVUxcIjogMTQxLFxuICBcIk9QXzJESVZcIjogMTQyLFxuICBcIk9QX05FR0FURVwiOiAxNDMsXG4gIFwiT1BfQUJTXCI6IDE0NCxcbiAgXCJPUF9OT1RcIjogMTQ1LFxuICBcIk9QXzBOT1RFUVVBTFwiOiAxNDYsXG4gIFwiT1BfQUREXCI6IDE0NyxcbiAgXCJPUF9TVUJcIjogMTQ4LFxuICBcIk9QX01VTFwiOiAxNDksXG4gIFwiT1BfRElWXCI6IDE1MCxcbiAgXCJPUF9NT0RcIjogMTUxLFxuICBcIk9QX0xTSElGVFwiOiAxNTIsXG4gIFwiT1BfUlNISUZUXCI6IDE1MyxcblxuICBcIk9QX0JPT0xBTkRcIjogMTU0LFxuICBcIk9QX0JPT0xPUlwiOiAxNTUsXG4gIFwiT1BfTlVNRVFVQUxcIjogMTU2LFxuICBcIk9QX05VTUVRVUFMVkVSSUZZXCI6IDE1NyxcbiAgXCJPUF9OVU1OT1RFUVVBTFwiOiAxNTgsXG4gIFwiT1BfTEVTU1RIQU5cIjogMTU5LFxuICBcIk9QX0dSRUFURVJUSEFOXCI6IDE2MCxcbiAgXCJPUF9MRVNTVEhBTk9SRVFVQUxcIjogMTYxLFxuICBcIk9QX0dSRUFURVJUSEFOT1JFUVVBTFwiOiAxNjIsXG4gIFwiT1BfTUlOXCI6IDE2MyxcbiAgXCJPUF9NQVhcIjogMTY0LFxuXG4gIFwiT1BfV0lUSElOXCI6IDE2NSxcblxuICBcIk9QX1JJUEVNRDE2MFwiOiAxNjYsXG4gIFwiT1BfU0hBMVwiOiAxNjcsXG4gIFwiT1BfU0hBMjU2XCI6IDE2OCxcbiAgXCJPUF9IQVNIMTYwXCI6IDE2OSxcbiAgXCJPUF9IQVNIMjU2XCI6IDE3MCxcbiAgXCJPUF9DT0RFU0VQQVJBVE9SXCI6IDE3MSxcbiAgXCJPUF9DSEVDS1NJR1wiOiAxNzIsXG4gIFwiT1BfQ0hFQ0tTSUdWRVJJRllcIjogMTczLFxuICBcIk9QX0NIRUNLTVVMVElTSUdcIjogMTc0LFxuICBcIk9QX0NIRUNLTVVMVElTSUdWRVJJRllcIjogMTc1LFxuXG4gIFwiT1BfTk9QMVwiOiAxNzYsXG4gIFxuICBcIk9QX05PUDJcIjogMTc3LFxuICBcIk9QX0NIRUNLTE9DS1RJTUVWRVJJRllcIjogMTc3LFxuXG4gIFwiT1BfTk9QM1wiOiAxNzgsXG4gIFwiT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWVwiOiAxNzgsXG4gIFxuICBcIk9QX05PUDRcIjogMTc5LFxuICBcIk9QX05PUDVcIjogMTgwLFxuICBcIk9QX05PUDZcIjogMTgxLFxuICBcIk9QX05PUDdcIjogMTgyLFxuICBcIk9QX05PUDhcIjogMTgzLFxuICBcIk9QX05PUDlcIjogMTg0LFxuICBcIk9QX05PUDEwXCI6IDE4NSxcblxuICBcIk9QX1BVQktFWUhBU0hcIjogMjUzLFxuICBcIk9QX1BVQktFWVwiOiAyNTQsXG4gIFwiT1BfSU5WQUxJRE9QQ09ERVwiOiAyNTVcbn1cbiIsInZhciBPUFMgPSByZXF1aXJlKCcuL2luZGV4Lmpzb24nKVxuXG52YXIgbWFwID0ge31cbmZvciAodmFyIG9wIGluIE9QUykge1xuICB2YXIgY29kZSA9IE9QU1tvcF1cbiAgbWFwW2NvZGVdID0gb3Bcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IGJlY2gzMiA9IHJlcXVpcmUoJ2JlY2gzMicpO1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG5jb25zdCB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmZ1bmN0aW9uIGZyb21CYXNlNThDaGVjayhhZGRyZXNzKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBiczU4Y2hlY2suZGVjb2RlKGFkZHJlc3MpO1xuICAvLyBUT0RPOiA0LjAuMCwgbW92ZSB0byBcInRvT3V0cHV0U2NyaXB0XCJcbiAgaWYgKHBheWxvYWQubGVuZ3RoIDwgMjEpIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIHNob3J0Jyk7XG4gIGlmIChwYXlsb2FkLmxlbmd0aCA+IDIxKSB0aHJvdyBuZXcgVHlwZUVycm9yKGFkZHJlc3MgKyAnIGlzIHRvbyBsb25nJyk7XG4gIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgY29uc3QgaGFzaCA9IHBheWxvYWQuc2xpY2UoMSk7XG4gIHJldHVybiB7IHZlcnNpb24sIGhhc2ggfTtcbn1cbmV4cG9ydHMuZnJvbUJhc2U1OENoZWNrID0gZnJvbUJhc2U1OENoZWNrO1xuZnVuY3Rpb24gZnJvbUJlY2gzMihhZGRyZXNzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGJlY2gzMi5kZWNvZGUoYWRkcmVzcyk7XG4gIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcy5zbGljZSgxKSk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogcmVzdWx0LndvcmRzWzBdLFxuICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICBkYXRhOiBCdWZmZXIuZnJvbShkYXRhKSxcbiAgfTtcbn1cbmV4cG9ydHMuZnJvbUJlY2gzMiA9IGZyb21CZWNoMzI7XG5mdW5jdGlvbiB0b0Jhc2U1OENoZWNrKGhhc2gsIHZlcnNpb24pIHtcbiAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkhhc2gxNjBiaXQsIHR5cGVzLlVJbnQ4KSwgYXJndW1lbnRzKTtcbiAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMSk7XG4gIHBheWxvYWQud3JpdGVVSW50OCh2ZXJzaW9uLCAwKTtcbiAgaGFzaC5jb3B5KHBheWxvYWQsIDEpO1xuICByZXR1cm4gYnM1OGNoZWNrLmVuY29kZShwYXlsb2FkKTtcbn1cbmV4cG9ydHMudG9CYXNlNThDaGVjayA9IHRvQmFzZTU4Q2hlY2s7XG5mdW5jdGlvbiB0b0JlY2gzMihkYXRhLCB2ZXJzaW9uLCBwcmVmaXgpIHtcbiAgY29uc3Qgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5leHBvcnRzLnRvQmVjaDMyID0gdG9CZWNoMzI7XG5mdW5jdGlvbiBmcm9tT3V0cHV0U2NyaXB0KG91dHB1dCwgbmV0d29yaykge1xuICAvLyBUT0RPOiBOZXR3b3JrXG4gIG5ldHdvcmsgPSBuZXR3b3JrIHx8IG5ldHdvcmtzLmJpdGNvaW47XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAycGtoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyc2goeyBvdXRwdXQsIG5ldHdvcmsgfSkuYWRkcmVzcztcbiAgfSBjYXRjaCAoZSkge31cbiAgdHJ5IHtcbiAgICByZXR1cm4gcGF5bWVudHMucDJ3cGtoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyd3NoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRocm93IG5ldyBFcnJvcihic2NyaXB0LnRvQVNNKG91dHB1dCkgKyAnIGhhcyBubyBtYXRjaGluZyBBZGRyZXNzJyk7XG59XG5leHBvcnRzLmZyb21PdXRwdXRTY3JpcHQgPSBmcm9tT3V0cHV0U2NyaXB0O1xuZnVuY3Rpb24gdG9PdXRwdXRTY3JpcHQoYWRkcmVzcywgbmV0d29yaykge1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBuZXR3b3Jrcy5iaXRjb2luO1xuICBsZXQgZGVjb2RlQmFzZTU4O1xuICBsZXQgZGVjb2RlQmVjaDMyO1xuICB0cnkge1xuICAgIGRlY29kZUJhc2U1OCA9IGZyb21CYXNlNThDaGVjayhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKGRlY29kZUJhc2U1OCkge1xuICAgIGlmIChkZWNvZGVCYXNlNTgudmVyc2lvbiA9PT0gbmV0d29yay5wdWJLZXlIYXNoKVxuICAgICAgcmV0dXJuIHBheW1lbnRzLnAycGtoKHsgaGFzaDogZGVjb2RlQmFzZTU4Lmhhc2ggfSkub3V0cHV0O1xuICAgIGlmIChkZWNvZGVCYXNlNTgudmVyc2lvbiA9PT0gbmV0d29yay5zY3JpcHRIYXNoKVxuICAgICAgcmV0dXJuIHBheW1lbnRzLnAyc2goeyBoYXNoOiBkZWNvZGVCYXNlNTguaGFzaCB9KS5vdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZUJlY2gzMiA9IGZyb21CZWNoMzIoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoZGVjb2RlQmVjaDMyKSB7XG4gICAgICBpZiAoZGVjb2RlQmVjaDMyLnByZWZpeCAhPT0gbmV0d29yay5iZWNoMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgYW4gaW52YWxpZCBwcmVmaXgnKTtcbiAgICAgIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMCkge1xuICAgICAgICBpZiAoZGVjb2RlQmVjaDMyLmRhdGEubGVuZ3RoID09PSAyMClcbiAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3cGtoKHsgaGFzaDogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgICBpZiAoZGVjb2RlQmVjaDMyLmRhdGEubGVuZ3RoID09PSAzMilcbiAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3c2goeyBoYXNoOiBkZWNvZGVCZWNoMzIuZGF0YSB9KS5vdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgbm8gbWF0Y2hpbmcgU2NyaXB0Jyk7XG59XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID0gdG9PdXRwdXRTY3JpcHQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgZmFzdE1lcmtsZVJvb3QgPSByZXF1aXJlKCdtZXJrbGUtbGliL2Zhc3RSb290Jyk7XG5jb25zdCB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCd2YXJ1aW50LWJpdGNvaW4nKTtcbmNvbnN0IGVycm9yTWVya2xlTm9UeGVzID0gbmV3IFR5cGVFcnJvcihcbiAgJ0Nhbm5vdCBjb21wdXRlIG1lcmtsZSByb290IGZvciB6ZXJvIHRyYW5zYWN0aW9ucycsXG4pO1xuY29uc3QgZXJyb3JXaXRuZXNzTm90U2Vnd2l0ID0gbmV3IFR5cGVFcnJvcihcbiAgJ0Nhbm5vdCBjb21wdXRlIHdpdG5lc3MgY29tbWl0IGZvciBub24tc2Vnd2l0IGJsb2NrJyxcbik7XG5jbGFzcyBCbG9jayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5wcmV2SGFzaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lcmtsZVJvb3QgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lc3RhbXAgPSAwO1xuICAgIHRoaXMud2l0bmVzc0NvbW1pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJpdHMgPSAwO1xuICAgIHRoaXMubm9uY2UgPSAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgODApIHRocm93IG5ldyBFcnJvcignQnVmZmVyIHRvbyBzbWFsbCAoPCA4MCBieXRlcyknKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCByZWFkU2xpY2UgPSBuID0+IHtcbiAgICAgIG9mZnNldCArPSBuO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShvZmZzZXQgLSBuLCBvZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3QgcmVhZFVJbnQzMiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG4gICAgY29uc3QgcmVhZEludDMyID0gKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKCk7XG4gICAgYmxvY2sudmVyc2lvbiA9IHJlYWRJbnQzMigpO1xuICAgIGJsb2NrLnByZXZIYXNoID0gcmVhZFNsaWNlKDMyKTtcbiAgICBibG9jay5tZXJrbGVSb290ID0gcmVhZFNsaWNlKDMyKTtcbiAgICBibG9jay50aW1lc3RhbXAgPSByZWFkVUludDMyKCk7XG4gICAgYmxvY2suYml0cyA9IHJlYWRVSW50MzIoKTtcbiAgICBibG9jay5ub25jZSA9IHJlYWRVSW50MzIoKTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gODApIHJldHVybiBibG9jaztcbiAgICBjb25zdCByZWFkVmFySW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmkgPSB2YXJ1aW50LmRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdmFydWludC5kZWNvZGUuYnl0ZXM7XG4gICAgICByZXR1cm4gdmk7XG4gICAgfTtcbiAgICBjb25zdCByZWFkVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB0eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihcbiAgICAgICAgYnVmZmVyLnNsaWNlKG9mZnNldCksXG4gICAgICAgIHRydWUsXG4gICAgICApO1xuICAgICAgb2Zmc2V0ICs9IHR4LmJ5dGVMZW5ndGgoKTtcbiAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IG5UcmFuc2FjdGlvbnMgPSByZWFkVmFySW50KCk7XG4gICAgYmxvY2sudHJhbnNhY3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuVHJhbnNhY3Rpb25zOyArK2kpIHtcbiAgICAgIGNvbnN0IHR4ID0gcmVhZFRyYW5zYWN0aW9uKCk7XG4gICAgICBibG9jay50cmFuc2FjdGlvbnMucHVzaCh0eCk7XG4gICAgfVxuICAgIGNvbnN0IHdpdG5lc3NDb21taXQgPSBibG9jay5nZXRXaXRuZXNzQ29tbWl0KCk7XG4gICAgLy8gVGhpcyBCbG9jayBjb250YWlucyBhIHdpdG5lc3MgY29tbWl0XG4gICAgaWYgKHdpdG5lc3NDb21taXQpIGJsb2NrLndpdG5lc3NDb21taXQgPSB3aXRuZXNzQ29tbWl0O1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gQmxvY2suZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShoZXgsICdoZXgnKSk7XG4gIH1cbiAgc3RhdGljIGNhbGN1bGF0ZVRhcmdldChiaXRzKSB7XG4gICAgY29uc3QgZXhwb25lbnQgPSAoKGJpdHMgJiAweGZmMDAwMDAwKSA+PiAyNCkgLSAzO1xuICAgIGNvbnN0IG1hbnRpc3NhID0gYml0cyAmIDB4MDA3ZmZmZmY7XG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB0YXJnZXQud3JpdGVVSW50QkUobWFudGlzc2EsIDI5IC0gZXhwb25lbnQsIDMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgc3RhdGljIGNhbGN1bGF0ZU1lcmtsZVJvb3QodHJhbnNhY3Rpb25zLCBmb3JXaXRuZXNzKSB7XG4gICAgdHlwZWZvcmNlKFt7IGdldEhhc2g6IHR5cGVzLkZ1bmN0aW9uIH1dLCB0cmFuc2FjdGlvbnMpO1xuICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB0aHJvdyBlcnJvck1lcmtsZU5vVHhlcztcbiAgICBpZiAoZm9yV2l0bmVzcyAmJiAhdHhlc0hhdmVXaXRuZXNzQ29tbWl0KHRyYW5zYWN0aW9ucykpXG4gICAgICB0aHJvdyBlcnJvcldpdG5lc3NOb3RTZWd3aXQ7XG4gICAgY29uc3QgaGFzaGVzID0gdHJhbnNhY3Rpb25zLm1hcCh0cmFuc2FjdGlvbiA9PlxuICAgICAgdHJhbnNhY3Rpb24uZ2V0SGFzaChmb3JXaXRuZXNzKSxcbiAgICApO1xuICAgIGNvbnN0IHJvb3RIYXNoID0gZmFzdE1lcmtsZVJvb3QoaGFzaGVzLCBiY3J5cHRvLmhhc2gyNTYpO1xuICAgIHJldHVybiBmb3JXaXRuZXNzXG4gICAgICA/IGJjcnlwdG8uaGFzaDI1NihcbiAgICAgICAgICBCdWZmZXIuY29uY2F0KFtyb290SGFzaCwgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzWzBdXSksXG4gICAgICAgIClcbiAgICAgIDogcm9vdEhhc2g7XG4gIH1cbiAgZ2V0V2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0aGlzLnRyYW5zYWN0aW9ucykpIHJldHVybiBudWxsO1xuICAgIC8vIFRoZSBtZXJrbGUgcm9vdCBmb3IgdGhlIHdpdG5lc3MgZGF0YSBpcyBpbiBhbiBPUF9SRVRVUk4gb3V0cHV0LlxuICAgIC8vIFRoZXJlIGlzIG5vIHJ1bGUgZm9yIHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0LCBzbyB1c2UgZmlsdGVyIHRvIGZpbmQgaXQuXG4gICAgLy8gVGhlIHJvb3QgaXMgcHJlcGVuZGVkIHdpdGggMHhhYTIxYTllZCBzbyBjaGVjayBmb3IgMHg2YTI0YWEyMWE5ZWRcbiAgICAvLyBJZiBtdWx0aXBsZSBjb21taXRzIGFyZSBmb3VuZCwgdGhlIG91dHB1dCB3aXRoIGhpZ2hlc3QgaW5kZXggaXMgYXNzdW1lZC5cbiAgICBjb25zdCB3aXRuZXNzQ29tbWl0cyA9IHRoaXMudHJhbnNhY3Rpb25zWzBdLm91dHNcbiAgICAgIC5maWx0ZXIob3V0ID0+XG4gICAgICAgIG91dC5zY3JpcHQuc2xpY2UoMCwgNikuZXF1YWxzKEJ1ZmZlci5mcm9tKCc2YTI0YWEyMWE5ZWQnLCAnaGV4JykpLFxuICAgICAgKVxuICAgICAgLm1hcChvdXQgPT4gb3V0LnNjcmlwdC5zbGljZSg2LCAzOCkpO1xuICAgIGlmICh3aXRuZXNzQ29tbWl0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIC8vIFVzZSB0aGUgY29tbWl0IHdpdGggdGhlIGhpZ2hlc3Qgb3V0cHV0IChzaG91bGQgb25seSBiZSBvbmUgdGhvdWdoKVxuICAgIGNvbnN0IHJlc3VsdCA9IHdpdG5lc3NDb21taXRzW3dpdG5lc3NDb21taXRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIEJ1ZmZlciAmJiByZXN1bHQubGVuZ3RoID09PSAzMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLndpdG5lc3NDb21taXQgaW5zdGFuY2VvZiBCdWZmZXIgJiZcbiAgICAgIHRoaXMud2l0bmVzc0NvbW1pdC5sZW5ndGggPT09IDMyXG4gICAgKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZ2V0V2l0bmVzc0NvbW1pdCgpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzV2l0bmVzcygpIHtcbiAgICByZXR1cm4gYW55VHhIYXNXaXRuZXNzKHRoaXMudHJhbnNhY3Rpb25zKTtcbiAgfVxuICB3ZWlnaHQoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSwgZmFsc2UpO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5ieXRlTGVuZ3RoKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm4gYmFzZSAqIDMgKyB0b3RhbDtcbiAgfVxuICBieXRlTGVuZ3RoKGhlYWRlcnNPbmx5LCBhbGxvd1dpdG5lc3MgPSB0cnVlKSB7XG4gICAgaWYgKGhlYWRlcnNPbmx5IHx8ICF0aGlzLnRyYW5zYWN0aW9ucykgcmV0dXJuIDgwO1xuICAgIHJldHVybiAoXG4gICAgICA4MCArXG4gICAgICB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCkgK1xuICAgICAgdGhpcy50cmFuc2FjdGlvbnMucmVkdWNlKChhLCB4KSA9PiBhICsgeC5ieXRlTGVuZ3RoKGFsbG93V2l0bmVzcyksIDApXG4gICAgKTtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGhpcy50b0J1ZmZlcih0cnVlKSk7XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcih0aGlzLmdldEhhc2goKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIGdldFVUQ0RhdGUoKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDApOyAvLyBlcG9jaFxuICAgIGRhdGUuc2V0VVRDU2Vjb25kcyh0aGlzLnRpbWVzdGFtcCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgLy8gVE9ETzogYnVmZmVyLCBvZmZzZXQgY29tcGF0aWJpbGl0eVxuICB0b0J1ZmZlcihoZWFkZXJzT25seSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLmJ5dGVMZW5ndGgoaGVhZGVyc09ubHkpKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCB3cml0ZVNsaWNlID0gc2xpY2UgPT4ge1xuICAgICAgc2xpY2UuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gc2xpY2UubGVuZ3RoO1xuICAgIH07XG4gICAgY29uc3Qgd3JpdGVJbnQzMiA9IGkgPT4ge1xuICAgICAgYnVmZmVyLndyaXRlSW50MzJMRShpLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfTtcbiAgICBjb25zdCB3cml0ZVVJbnQzMiA9IGkgPT4ge1xuICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoaSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH07XG4gICAgd3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgIHdyaXRlU2xpY2UodGhpcy5wcmV2SGFzaCk7XG4gICAgd3JpdGVTbGljZSh0aGlzLm1lcmtsZVJvb3QpO1xuICAgIHdyaXRlVUludDMyKHRoaXMudGltZXN0YW1wKTtcbiAgICB3cml0ZVVJbnQzMih0aGlzLmJpdHMpO1xuICAgIHdyaXRlVUludDMyKHRoaXMubm9uY2UpO1xuICAgIGlmIChoZWFkZXJzT25seSB8fCAhdGhpcy50cmFuc2FjdGlvbnMpIHJldHVybiBidWZmZXI7XG4gICAgdmFydWludC5lbmNvZGUodGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoLCBidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RlLmJ5dGVzO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zLmZvckVhY2godHggPT4ge1xuICAgICAgY29uc3QgdHhTaXplID0gdHguYnl0ZUxlbmd0aCgpOyAvLyBUT0RPOiBleHRyYWN0IGZyb20gdG9CdWZmZXI/XG4gICAgICB0eC50b0J1ZmZlcihidWZmZXIsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdHhTaXplO1xuICAgIH0pO1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgdG9IZXgoaGVhZGVyc09ubHkpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihoZWFkZXJzT25seSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIGNoZWNrVHhSb290cygpIHtcbiAgICAvLyBJZiB0aGUgQmxvY2sgaGFzIHNlZ3dpdCB0cmFuc2FjdGlvbnMgYnV0IG5vIHdpdG5lc3MgY29tbWl0LFxuICAgIC8vIHRoZXJlJ3Mgbm8gd2F5IGl0IGNhbiBiZSB2YWxpZCwgc28gZmFpbCB0aGUgY2hlY2suXG4gICAgY29uc3QgaGFzV2l0bmVzc0NvbW1pdCA9IHRoaXMuaGFzV2l0bmVzc0NvbW1pdCgpO1xuICAgIGlmICghaGFzV2l0bmVzc0NvbW1pdCAmJiB0aGlzLmhhc1dpdG5lc3MoKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9fY2hlY2tNZXJrbGVSb290KCkgJiZcbiAgICAgIChoYXNXaXRuZXNzQ29tbWl0ID8gdGhpcy5fX2NoZWNrV2l0bmVzc0NvbW1pdCgpIDogdHJ1ZSlcbiAgICApO1xuICB9XG4gIGNoZWNrUHJvb2ZPZldvcmsoKSB7XG4gICAgY29uc3QgaGFzaCA9IGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcih0aGlzLmdldEhhc2goKSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gQmxvY2suY2FsY3VsYXRlVGFyZ2V0KHRoaXMuYml0cyk7XG4gICAgcmV0dXJuIGhhc2guY29tcGFyZSh0YXJnZXQpIDw9IDA7XG4gIH1cbiAgX19jaGVja01lcmtsZVJvb3QoKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9ucykgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgY29uc3QgYWN0dWFsTWVya2xlUm9vdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QodGhpcy50cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm1lcmtsZVJvb3QuY29tcGFyZShhY3R1YWxNZXJrbGVSb290KSA9PT0gMDtcbiAgfVxuICBfX2NoZWNrV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb25zKSB0aHJvdyBlcnJvck1lcmtsZU5vVHhlcztcbiAgICBpZiAoIXRoaXMuaGFzV2l0bmVzc0NvbW1pdCgpKSB0aHJvdyBlcnJvcldpdG5lc3NOb3RTZWd3aXQ7XG4gICAgY29uc3QgYWN0dWFsV2l0bmVzc0NvbW1pdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QoXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucyxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy53aXRuZXNzQ29tbWl0LmNvbXBhcmUoYWN0dWFsV2l0bmVzc0NvbW1pdCkgPT09IDA7XG4gIH1cbn1cbmV4cG9ydHMuQmxvY2sgPSBCbG9jaztcbmZ1bmN0aW9uIHR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0cmFuc2FjdGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICB0cmFuc2FjdGlvbnMgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXS5pbnMgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdLndpdG5lc3MubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gYW55VHhIYXNXaXRuZXNzKHRyYW5zYWN0aW9ucykge1xuICByZXR1cm4gKFxuICAgIHRyYW5zYWN0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgdHJhbnNhY3Rpb25zLnNvbWUoXG4gICAgICB0eCA9PlxuICAgICAgICB0eXBlb2YgdHggPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR4LmlucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgICAgIHR4Lmlucy5zb21lKFxuICAgICAgICAgIGlucHV0ID0+XG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3MubGVuZ3RoID4gMCxcbiAgICAgICAgKSxcbiAgICApXG4gICk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDExMjdcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICBpZiAodmFsdWUgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgaWYgKHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIGIgKj0gMHgxMDAwMDAwMDA7XG4gIHZlcmlmdWludChiICsgYSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICB2ZXJpZnVpbnQodmFsdWUsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gIGJ1ZmZlci53cml0ZUludDMyTEUodmFsdWUgJiAtMSwgb2Zmc2V0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWx1ZSAvIDB4MTAwMDAwMDAwKSwgb2Zmc2V0ICsgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA4O1xufVxuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcbmZ1bmN0aW9uIHJldmVyc2VCdWZmZXIoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMSkgcmV0dXJuIGJ1ZmZlcjtcbiAgbGV0IGogPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgbGV0IHRtcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRtcCA9IGJ1ZmZlcltpXTtcbiAgICBidWZmZXJbaV0gPSBidWZmZXJbal07XG4gICAgYnVmZmVyW2pdID0gdG1wO1xuICAgIGotLTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gcmV2ZXJzZUJ1ZmZlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCBtdWx0aXNpZyA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL211bHRpc2lnJyk7XG5jb25zdCBudWxsRGF0YSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL251bGxkYXRhJyk7XG5jb25zdCBwdWJLZXkgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9wdWJrZXknKTtcbmNvbnN0IHB1YktleUhhc2ggPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9wdWJrZXloYXNoJyk7XG5jb25zdCBzY3JpcHRIYXNoID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvc2NyaXB0aGFzaCcpO1xuY29uc3Qgd2l0bmVzc0NvbW1pdG1lbnQgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy93aXRuZXNzY29tbWl0bWVudCcpO1xuY29uc3Qgd2l0bmVzc1B1YktleUhhc2ggPSByZXF1aXJlKCcuL3RlbXBsYXRlcy93aXRuZXNzcHVia2V5aGFzaCcpO1xuY29uc3Qgd2l0bmVzc1NjcmlwdEhhc2ggPSByZXF1aXJlKCcuL3RlbXBsYXRlcy93aXRuZXNzc2NyaXB0aGFzaCcpO1xuY29uc3QgdHlwZXMgPSB7XG4gIFAyTVM6ICdtdWx0aXNpZycsXG4gIE5PTlNUQU5EQVJEOiAnbm9uc3RhbmRhcmQnLFxuICBOVUxMREFUQTogJ251bGxkYXRhJyxcbiAgUDJQSzogJ3B1YmtleScsXG4gIFAyUEtIOiAncHVia2V5aGFzaCcsXG4gIFAyU0g6ICdzY3JpcHRoYXNoJyxcbiAgUDJXUEtIOiAnd2l0bmVzc3B1YmtleWhhc2gnLFxuICBQMldTSDogJ3dpdG5lc3NzY3JpcHRoYXNoJyxcbiAgV0lUTkVTU19DT01NSVRNRU5UOiAnd2l0bmVzc2NvbW1pdG1lbnQnLFxufTtcbmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbmZ1bmN0aW9uIGNsYXNzaWZ5T3V0cHV0KHNjcmlwdCkge1xuICBpZiAod2l0bmVzc1B1YktleUhhc2gub3V0cHV0LmNoZWNrKHNjcmlwdCkpIHJldHVybiB0eXBlcy5QMldQS0g7XG4gIGlmICh3aXRuZXNzU2NyaXB0SGFzaC5vdXRwdXQuY2hlY2soc2NyaXB0KSkgcmV0dXJuIHR5cGVzLlAyV1NIO1xuICBpZiAocHViS2V5SGFzaC5vdXRwdXQuY2hlY2soc2NyaXB0KSkgcmV0dXJuIHR5cGVzLlAyUEtIO1xuICBpZiAoc2NyaXB0SGFzaC5vdXRwdXQuY2hlY2soc2NyaXB0KSkgcmV0dXJuIHR5cGVzLlAyU0g7XG4gIC8vIFhYWDogb3B0aW1pemF0aW9uLCBiZWxvdyBmdW5jdGlvbnMgLmRlY29tcGlsZSBiZWZvcmUgdXNlXG4gIGNvbnN0IGNodW5rcyA9IHNjcmlwdF8xLmRlY29tcGlsZShzY3JpcHQpO1xuICBpZiAoIWNodW5rcykgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY3JpcHQnKTtcbiAgaWYgKG11bHRpc2lnLm91dHB1dC5jaGVjayhjaHVua3MpKSByZXR1cm4gdHlwZXMuUDJNUztcbiAgaWYgKHB1YktleS5vdXRwdXQuY2hlY2soY2h1bmtzKSkgcmV0dXJuIHR5cGVzLlAyUEs7XG4gIGlmICh3aXRuZXNzQ29tbWl0bWVudC5vdXRwdXQuY2hlY2soY2h1bmtzKSkgcmV0dXJuIHR5cGVzLldJVE5FU1NfQ09NTUlUTUVOVDtcbiAgaWYgKG51bGxEYXRhLm91dHB1dC5jaGVjayhjaHVua3MpKSByZXR1cm4gdHlwZXMuTlVMTERBVEE7XG4gIHJldHVybiB0eXBlcy5OT05TVEFOREFSRDtcbn1cbmV4cG9ydHMub3V0cHV0ID0gY2xhc3NpZnlPdXRwdXQ7XG5mdW5jdGlvbiBjbGFzc2lmeUlucHV0KHNjcmlwdCwgYWxsb3dJbmNvbXBsZXRlKSB7XG4gIC8vIFhYWDogb3B0aW1pemF0aW9uLCBiZWxvdyBmdW5jdGlvbnMgLmRlY29tcGlsZSBiZWZvcmUgdXNlXG4gIGNvbnN0IGNodW5rcyA9IHNjcmlwdF8xLmRlY29tcGlsZShzY3JpcHQpO1xuICBpZiAoIWNodW5rcykgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY3JpcHQnKTtcbiAgaWYgKHB1YktleUhhc2guaW5wdXQuY2hlY2soY2h1bmtzKSkgcmV0dXJuIHR5cGVzLlAyUEtIO1xuICBpZiAoc2NyaXB0SGFzaC5pbnB1dC5jaGVjayhjaHVua3MsIGFsbG93SW5jb21wbGV0ZSkpIHJldHVybiB0eXBlcy5QMlNIO1xuICBpZiAobXVsdGlzaWcuaW5wdXQuY2hlY2soY2h1bmtzLCBhbGxvd0luY29tcGxldGUpKSByZXR1cm4gdHlwZXMuUDJNUztcbiAgaWYgKHB1YktleS5pbnB1dC5jaGVjayhjaHVua3MpKSByZXR1cm4gdHlwZXMuUDJQSztcbiAgcmV0dXJuIHR5cGVzLk5PTlNUQU5EQVJEO1xufVxuZXhwb3J0cy5pbnB1dCA9IGNsYXNzaWZ5SW5wdXQ7XG5mdW5jdGlvbiBjbGFzc2lmeVdpdG5lc3Moc2NyaXB0LCBhbGxvd0luY29tcGxldGUpIHtcbiAgLy8gWFhYOiBvcHRpbWl6YXRpb24sIGJlbG93IGZ1bmN0aW9ucyAuZGVjb21waWxlIGJlZm9yZSB1c2VcbiAgY29uc3QgY2h1bmtzID0gc2NyaXB0XzEuZGVjb21waWxlKHNjcmlwdCk7XG4gIGlmICghY2h1bmtzKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjcmlwdCcpO1xuICBpZiAod2l0bmVzc1B1YktleUhhc2guaW5wdXQuY2hlY2soY2h1bmtzKSkgcmV0dXJuIHR5cGVzLlAyV1BLSDtcbiAgaWYgKHdpdG5lc3NTY3JpcHRIYXNoLmlucHV0LmNoZWNrKGNodW5rcywgYWxsb3dJbmNvbXBsZXRlKSlcbiAgICByZXR1cm4gdHlwZXMuUDJXU0g7XG4gIHJldHVybiB0eXBlcy5OT05TVEFOREFSRDtcbn1cbmV4cG9ydHMud2l0bmVzcyA9IGNsYXNzaWZ5V2l0bmVzcztcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbmZ1bmN0aW9uIHJpcGVtZDE2MChidWZmZXIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgncm1kMTYwJylcbiAgICAgIC51cGRhdGUoYnVmZmVyKVxuICAgICAgLmRpZ2VzdCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgncmlwZW1kMTYwJylcbiAgICAgIC51cGRhdGUoYnVmZmVyKVxuICAgICAgLmRpZ2VzdCgpO1xuICB9XG59XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbmZ1bmN0aW9uIHNoYTEoYnVmZmVyKSB7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAudXBkYXRlKGJ1ZmZlcilcbiAgICAuZGlnZXN0KCk7XG59XG5leHBvcnRzLnNoYTEgPSBzaGExO1xuZnVuY3Rpb24gc2hhMjU2KGJ1ZmZlcikge1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAudXBkYXRlKGJ1ZmZlcilcbiAgICAuZGlnZXN0KCk7XG59XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcbmZ1bmN0aW9uIGhhc2gxNjAoYnVmZmVyKSB7XG4gIHJldHVybiByaXBlbWQxNjAoc2hhMjU2KGJ1ZmZlcikpO1xufVxuZXhwb3J0cy5oYXNoMTYwID0gaGFzaDE2MDtcbmZ1bmN0aW9uIGhhc2gyNTYoYnVmZmVyKSB7XG4gIHJldHVybiBzaGEyNTYoc2hhMjU2KGJ1ZmZlcikpO1xufVxuZXhwb3J0cy5oYXNoMjU2ID0gaGFzaDI1NjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBORVRXT1JLUyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgZWNjID0gcmVxdWlyZSgndGlueS1zZWNwMjU2azEnKTtcbmNvbnN0IHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbmNvbnN0IHR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3Qgd2lmID0gcmVxdWlyZSgnd2lmJyk7XG5jb25zdCBpc09wdGlvbnMgPSB0eXBlZm9yY2UubWF5YmUoXG4gIHR5cGVmb3JjZS5jb21waWxlKHtcbiAgICBjb21wcmVzc2VkOiB0eXBlcy5tYXliZSh0eXBlcy5Cb29sZWFuKSxcbiAgICBuZXR3b3JrOiB0eXBlcy5tYXliZSh0eXBlcy5OZXR3b3JrKSxcbiAgfSksXG4pO1xuY2xhc3MgRUNQYWlyIHtcbiAgY29uc3RydWN0b3IoX19ELCBfX1EsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9fRCA9IF9fRDtcbiAgICB0aGlzLl9fUSA9IF9fUTtcbiAgICB0aGlzLmxvd1IgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG4gICAgdGhpcy5jb21wcmVzc2VkID1cbiAgICAgIG9wdGlvbnMuY29tcHJlc3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuY29tcHJlc3NlZDtcbiAgICB0aGlzLm5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcmsgfHwgTkVUV09SS1MuYml0Y29pbjtcbiAgICBpZiAoX19RICE9PSB1bmRlZmluZWQpIHRoaXMuX19RID0gZWNjLnBvaW50Q29tcHJlc3MoX19RLCB0aGlzLmNvbXByZXNzZWQpO1xuICB9XG4gIGdldCBwcml2YXRlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9fRDtcbiAgfVxuICBnZXQgcHVibGljS2V5KCkge1xuICAgIGlmICghdGhpcy5fX1EpIHRoaXMuX19RID0gZWNjLnBvaW50RnJvbVNjYWxhcih0aGlzLl9fRCwgdGhpcy5jb21wcmVzc2VkKTtcbiAgICByZXR1cm4gdGhpcy5fX1E7XG4gIH1cbiAgdG9XSUYoKSB7XG4gICAgaWYgKCF0aGlzLl9fRCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgcmV0dXJuIHdpZi5lbmNvZGUodGhpcy5uZXR3b3JrLndpZiwgdGhpcy5fX0QsIHRoaXMuY29tcHJlc3NlZCk7XG4gIH1cbiAgc2lnbihoYXNoLCBsb3dSKSB7XG4gICAgaWYgKCF0aGlzLl9fRCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgaWYgKGxvd1IgPT09IHVuZGVmaW5lZCkgbG93UiA9IHRoaXMubG93UjtcbiAgICBpZiAobG93UiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBlY2Muc2lnbihoYXNoLCB0aGlzLl9fRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzaWcgPSBlY2Muc2lnbihoYXNoLCB0aGlzLl9fRCk7XG4gICAgICBjb25zdCBleHRyYURhdGEgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgLy8gaWYgZmlyc3QgdHJ5IGlzIGxvd1IsIHNraXAgdGhlIGxvb3BcbiAgICAgIC8vIGZvciBzZWNvbmQgdHJ5IGFuZCBvbiwgYWRkIGV4dHJhIGVudHJvcHkgY291bnRpbmcgdXBcbiAgICAgIHdoaWxlIChzaWdbMF0gPiAweDdmKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgZXh0cmFEYXRhLndyaXRlVUludExFKGNvdW50ZXIsIDAsIDYpO1xuICAgICAgICBzaWcgPSBlY2Muc2lnbldpdGhFbnRyb3B5KGhhc2gsIHRoaXMuX19ELCBleHRyYURhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBlY2MudmVyaWZ5KGhhc2gsIHRoaXMucHVibGljS2V5LCBzaWduYXR1cmUpO1xuICB9XG59XG5mdW5jdGlvbiBmcm9tUHJpdmF0ZUtleShidWZmZXIsIG9wdGlvbnMpIHtcbiAgdHlwZWZvcmNlKHR5cGVzLkJ1ZmZlcjI1NmJpdCwgYnVmZmVyKTtcbiAgaWYgKCFlY2MuaXNQcml2YXRlKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBrZXkgbm90IGluIHJhbmdlIFsxLCBuKScpO1xuICB0eXBlZm9yY2UoaXNPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBFQ1BhaXIoYnVmZmVyLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tUHJpdmF0ZUtleSA9IGZyb21Qcml2YXRlS2V5O1xuZnVuY3Rpb24gZnJvbVB1YmxpY0tleShidWZmZXIsIG9wdGlvbnMpIHtcbiAgdHlwZWZvcmNlKGVjYy5pc1BvaW50LCBidWZmZXIpO1xuICB0eXBlZm9yY2UoaXNPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBFQ1BhaXIodW5kZWZpbmVkLCBidWZmZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tUHVibGljS2V5ID0gZnJvbVB1YmxpY0tleTtcbmZ1bmN0aW9uIGZyb21XSUYod2lmU3RyaW5nLCBuZXR3b3JrKSB7XG4gIGNvbnN0IGRlY29kZWQgPSB3aWYuZGVjb2RlKHdpZlN0cmluZyk7XG4gIGNvbnN0IHZlcnNpb24gPSBkZWNvZGVkLnZlcnNpb247XG4gIC8vIGxpc3Qgb2YgbmV0d29ya3M/XG4gIGlmICh0eXBlcy5BcnJheShuZXR3b3JrKSkge1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrXG4gICAgICAuZmlsdGVyKHggPT4ge1xuICAgICAgICByZXR1cm4gdmVyc2lvbiA9PT0geC53aWY7XG4gICAgICB9KVxuICAgICAgLnBvcCgpO1xuICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5ldHdvcmsgdmVyc2lvbicpO1xuICAgIC8vIG90aGVyd2lzZSwgYXNzdW1lIGEgbmV0d29yayBvYmplY3QgKG9yIGRlZmF1bHQgdG8gYml0Y29pbilcbiAgfSBlbHNlIHtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBORVRXT1JLUy5iaXRjb2luO1xuICAgIGlmICh2ZXJzaW9uICE9PSBuZXR3b3JrLndpZikgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldHdvcmsgdmVyc2lvbicpO1xuICB9XG4gIHJldHVybiBmcm9tUHJpdmF0ZUtleShkZWNvZGVkLnByaXZhdGVLZXksIHtcbiAgICBjb21wcmVzc2VkOiBkZWNvZGVkLmNvbXByZXNzZWQsXG4gICAgbmV0d29yazogbmV0d29yayxcbiAgfSk7XG59XG5leHBvcnRzLmZyb21XSUYgPSBmcm9tV0lGO1xuZnVuY3Rpb24gbWFrZVJhbmRvbShvcHRpb25zKSB7XG4gIHR5cGVmb3JjZShpc09wdGlvbnMsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG4gIGNvbnN0IHJuZyA9IG9wdGlvbnMucm5nIHx8IHJhbmRvbUJ5dGVzO1xuICBsZXQgZDtcbiAgZG8ge1xuICAgIGQgPSBybmcoMzIpO1xuICAgIHR5cGVmb3JjZSh0eXBlcy5CdWZmZXIyNTZiaXQsIGQpO1xuICB9IHdoaWxlICghZWNjLmlzUHJpdmF0ZShkKSk7XG4gIHJldHVybiBmcm9tUHJpdmF0ZUtleShkLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubWFrZVJhbmRvbSA9IG1ha2VSYW5kb207XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmlwMzIgPSByZXF1aXJlKCdiaXAzMicpO1xuZXhwb3J0cy5iaXAzMiA9IGJpcDMyO1xuY29uc3QgYWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xuZXhwb3J0cy5hZGRyZXNzID0gYWRkcmVzcztcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJyk7XG5leHBvcnRzLmNyeXB0byA9IGNyeXB0bztcbmNvbnN0IEVDUGFpciA9IHJlcXVpcmUoJy4vZWNwYWlyJyk7XG5leHBvcnRzLkVDUGFpciA9IEVDUGFpcjtcbmNvbnN0IG5ldHdvcmtzID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xuZXhwb3J0cy5uZXR3b3JrcyA9IG5ldHdvcmtzO1xuY29uc3QgcGF5bWVudHMgPSByZXF1aXJlKCcuL3BheW1lbnRzJyk7XG5leHBvcnRzLnBheW1lbnRzID0gcGF5bWVudHM7XG5jb25zdCBzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuZXhwb3J0cy5zY3JpcHQgPSBzY3JpcHQ7XG52YXIgYmxvY2tfMSA9IHJlcXVpcmUoJy4vYmxvY2snKTtcbmV4cG9ydHMuQmxvY2sgPSBibG9ja18xLkJsb2NrO1xudmFyIHBzYnRfMSA9IHJlcXVpcmUoJy4vcHNidCcpO1xuZXhwb3J0cy5Qc2J0ID0gcHNidF8xLlBzYnQ7XG52YXIgc2NyaXB0XzEgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuZXhwb3J0cy5vcGNvZGVzID0gc2NyaXB0XzEuT1BTO1xudmFyIHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbjtcbnZhciB0cmFuc2FjdGlvbl9idWlsZGVyXzEgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uX2J1aWxkZXInKTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25CdWlsZGVyID0gdHJhbnNhY3Rpb25fYnVpbGRlcl8xLlRyYW5zYWN0aW9uQnVpbGRlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpdGNvaW4gPSB7XG4gIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgYmVjaDMyOiAnYmMnLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogMHgwNDg4YjIxZSxcbiAgICBwcml2YXRlOiAweDA0ODhhZGU0LFxuICB9LFxuICBwdWJLZXlIYXNoOiAweDAwLFxuICBzY3JpcHRIYXNoOiAweDA1LFxuICB3aWY6IDB4ODAsXG59O1xuZXhwb3J0cy5yZWd0ZXN0ID0ge1xuICBtZXNzYWdlUHJlZml4OiAnXFx4MThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicsXG4gIGJlY2gzMjogJ2JjcnQnLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogMHgwNDM1ODdjZixcbiAgICBwcml2YXRlOiAweDA0MzU4Mzk0LFxuICB9LFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB3aWY6IDB4ZWYsXG59O1xuZXhwb3J0cy50ZXN0bmV0ID0ge1xuICBtZXNzYWdlUHJlZml4OiAnXFx4MThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicsXG4gIGJlY2gzMjogJ3RiJyxcbiAgYmlwMzI6IHtcbiAgICBwdWJsaWM6IDB4MDQzNTg3Y2YsXG4gICAgcHJpdmF0ZTogMHgwNDM1ODM5NCxcbiAgfSxcbiAgcHViS2V5SGFzaDogMHg2ZixcbiAgc2NyaXB0SGFzaDogMHhjNCxcbiAgd2lmOiAweGVmLFxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IHR5cGVmID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgfSk7XG59XG4vLyBvdXRwdXQ6IE9QX1JFVFVSTiAuLi5cbmZ1bmN0aW9uIHAyZGF0YShhLCBvcHRzKSB7XG4gIGlmICghYS5kYXRhICYmICFhLm91dHB1dCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gIHR5cGVmKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVmLm1heWJlKHR5cGVmLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlciksXG4gICAgICBkYXRhOiB0eXBlZi5tYXliZSh0eXBlZi5hcnJheU9mKHR5cGVmLkJ1ZmZlcikpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdlbWJlZCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmRhdGEpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfUkVUVVJOXS5jb25jYXQoYS5kYXRhKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2RhdGEnLCAoKSA9PiB7XG4gICAgaWYgKCFhLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCkuc2xpY2UoMSk7XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCk7XG4gICAgICBpZiAoY2h1bmtzWzBdICE9PSBPUFMuT1BfUkVUVVJOKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFjaHVua3Muc2xpY2UoMSkuZXZlcnkodHlwZWYuQnVmZmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChhLmRhdGEgJiYgIXN0YWNrc0VxdWFsKGEuZGF0YSwgby5kYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJkYXRhID0gcDJkYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVtYmVkXzEgPSByZXF1aXJlKCcuL2VtYmVkJyk7XG5leHBvcnRzLmVtYmVkID0gZW1iZWRfMS5wMmRhdGE7XG5jb25zdCBwMm1zXzEgPSByZXF1aXJlKCcuL3AybXMnKTtcbmV4cG9ydHMucDJtcyA9IHAybXNfMS5wMm1zO1xuY29uc3QgcDJwa18xID0gcmVxdWlyZSgnLi9wMnBrJyk7XG5leHBvcnRzLnAycGsgPSBwMnBrXzEucDJwaztcbmNvbnN0IHAycGtoXzEgPSByZXF1aXJlKCcuL3AycGtoJyk7XG5leHBvcnRzLnAycGtoID0gcDJwa2hfMS5wMnBraDtcbmNvbnN0IHAyc2hfMSA9IHJlcXVpcmUoJy4vcDJzaCcpO1xuZXhwb3J0cy5wMnNoID0gcDJzaF8xLnAyc2g7XG5jb25zdCBwMndwa2hfMSA9IHJlcXVpcmUoJy4vcDJ3cGtoJyk7XG5leHBvcnRzLnAyd3BraCA9IHAyd3BraF8xLnAyd3BraDtcbmNvbnN0IHAyd3NoXzEgPSByZXF1aXJlKCcuL3Ayd3NoJyk7XG5leHBvcnRzLnAyd3NoID0gcDJ3c2hfMS5wMndzaDtcbi8vIFRPRE9cbi8vIHdpdG5lc3MgY29tbWl0bWVudFxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHByb3Aob2JqZWN0LCBuYW1lLCBmKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBfdmFsdWUgPSBmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzW25hbWVdID0gX3ZhbHVlO1xuICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICB9LFxuICAgIHNldChfdmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9LFxuICB9KTtcbn1cbmV4cG9ydHMucHJvcCA9IHByb3A7XG5mdW5jdGlvbiB2YWx1ZShmKSB7XG4gIGxldCBfdmFsdWU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gX3ZhbHVlO1xuICAgIF92YWx1ZSA9IGYoKTtcbiAgICByZXR1cm4gX3ZhbHVlO1xuICB9O1xufVxuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5jb25zdCB0eXBlZiA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgZWNjID0gcmVxdWlyZSgndGlueS1zZWNwMjU2azEnKTtcbmNvbnN0IE9QX0lOVF9CQVNFID0gT1BTLk9QX1JFU0VSVkVEOyAvLyBPUF8xIC0gMVxuZnVuY3Rpb24gc3RhY2tzRXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBhLmV2ZXJ5KCh4LCBpKSA9PiB7XG4gICAgcmV0dXJuIHguZXF1YWxzKGJbaV0pO1xuICB9KTtcbn1cbi8vIGlucHV0OiBPUF8wIFtzaWduYXR1cmVzIC4uLl1cbi8vIG91dHB1dDogbSBbcHViS2V5cyAuLi5dIG4gT1BfQ0hFQ0tNVUxUSVNJR1xuZnVuY3Rpb24gcDJtcyhhLCBvcHRzKSB7XG4gIGlmIChcbiAgICAhYS5pbnB1dCAmJlxuICAgICFhLm91dHB1dCAmJlxuICAgICEoYS5wdWJrZXlzICYmIGEubSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICFhLnNpZ25hdHVyZXNcbiAgKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICBmdW5jdGlvbiBpc0FjY2VwdGFibGVTaWduYXR1cmUoeCkge1xuICAgIHJldHVybiAoXG4gICAgICBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKHgpIHx8XG4gICAgICAob3B0cy5hbGxvd0luY29tcGxldGUgJiYgeCA9PT0gT1BTLk9QXzApICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG4gIHR5cGVmKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVmLm1heWJlKHR5cGVmLk9iamVjdCksXG4gICAgICBtOiB0eXBlZi5tYXliZSh0eXBlZi5OdW1iZXIpLFxuICAgICAgbjogdHlwZWYubWF5YmUodHlwZWYuTnVtYmVyKSxcbiAgICAgIG91dHB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyKSxcbiAgICAgIHB1YmtleXM6IHR5cGVmLm1heWJlKHR5cGVmLmFycmF5T2YoZWNjLmlzUG9pbnQpKSxcbiAgICAgIHNpZ25hdHVyZXM6IHR5cGVmLm1heWJlKHR5cGVmLmFycmF5T2YoaXNBY2NlcHRhYmxlU2lnbmF0dXJlKSksXG4gICAgICBpbnB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gIGxldCBjaHVua3MgPSBbXTtcbiAgbGV0IGRlY29kZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVjb2RlKG91dHB1dCkge1xuICAgIGlmIChkZWNvZGVkKSByZXR1cm47XG4gICAgZGVjb2RlZCA9IHRydWU7XG4gICAgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUob3V0cHV0KTtcbiAgICBvLm0gPSBjaHVua3NbMF0gLSBPUF9JTlRfQkFTRTtcbiAgICBvLm4gPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdIC0gT1BfSU5UX0JBU0U7XG4gICAgby5wdWJrZXlzID0gY2h1bmtzLnNsaWNlKDEsIC0yKTtcbiAgfVxuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEubSkgcmV0dXJuO1xuICAgIGlmICghby5uKSByZXR1cm47XG4gICAgaWYgKCFhLnB1YmtleXMpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFxuICAgICAgW10uY29uY2F0KFxuICAgICAgICBPUF9JTlRfQkFTRSArIGEubSxcbiAgICAgICAgYS5wdWJrZXlzLFxuICAgICAgICBPUF9JTlRfQkFTRSArIG8ubixcbiAgICAgICAgT1BTLk9QX0NIRUNLTVVMVElTSUcsXG4gICAgICApLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ20nLCAoKSA9PiB7XG4gICAgaWYgKCFvLm91dHB1dCkgcmV0dXJuO1xuICAgIGRlY29kZShvLm91dHB1dCk7XG4gICAgcmV0dXJuIG8ubTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbicsICgpID0+IHtcbiAgICBpZiAoIW8ucHVia2V5cykgcmV0dXJuO1xuICAgIHJldHVybiBvLnB1YmtleXMubGVuZ3RoO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXlzJywgKCkgPT4ge1xuICAgIGlmICghYS5vdXRwdXQpIHJldHVybjtcbiAgICBkZWNvZGUoYS5vdXRwdXQpO1xuICAgIHJldHVybiBvLnB1YmtleXM7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZXMnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpLnNsaWNlKDEpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEuc2lnbmF0dXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wXS5jb25jYXQoYS5zaWduYXR1cmVzKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICduYW1lJywgKCkgPT4ge1xuICAgIGlmICghby5tIHx8ICFvLm4pIHJldHVybjtcbiAgICByZXR1cm4gYHAybXMoJHtvLm19IG9mICR7by5ufSlgO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgZGVjb2RlKGEub3V0cHV0KTtcbiAgICAgIGlmICghdHlwZWYuTnVtYmVyKGNodW5rc1swXSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIXR5cGVmLk51bWJlcihjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdICE9PSBPUFMuT1BfQ0hFQ0tNVUxUSVNJRylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChvLm0gPD0gMCB8fCBvLm4gPiAxNiB8fCBvLm0gPiBvLm4gfHwgby5uICE9PSBjaHVua3MubGVuZ3RoIC0gMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghby5wdWJrZXlzLmV2ZXJ5KHggPT4gZWNjLmlzUG9pbnQoeCkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gby5tKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5uICE9PSB1bmRlZmluZWQgJiYgYS5uICE9PSBvLm4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ24gbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChhLnB1YmtleXMgJiYgIXN0YWNrc0VxdWFsKGEucHVia2V5cywgby5wdWJrZXlzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5cyBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXlzKSB7XG4gICAgICBpZiAoYS5uICE9PSB1bmRlZmluZWQgJiYgYS5uICE9PSBhLnB1YmtleXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgY291bnQgbWlzbWF0Y2gnKTtcbiAgICAgIG8ubiA9IGEucHVia2V5cy5sZW5ndGg7XG4gICAgICBpZiAoby5uIDwgby5tKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgY291bnQgY2Fubm90IGJlIGxlc3MgdGhhbiBtJyk7XG4gICAgfVxuICAgIGlmIChhLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChhLnNpZ25hdHVyZXMubGVuZ3RoIDwgby5tKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIHNpZ25hdHVyZXMgcHJvdmlkZWQnKTtcbiAgICAgIGlmIChhLnNpZ25hdHVyZXMubGVuZ3RoID4gby5tKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb28gbWFueSBzaWduYXR1cmVzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGlmIChhLmlucHV0KSB7XG4gICAgICBpZiAoYS5pbnB1dFswXSAhPT0gT1BTLk9QXzApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChcbiAgICAgICAgby5zaWduYXR1cmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAhby5zaWduYXR1cmVzLmV2ZXJ5KGlzQWNjZXB0YWJsZVNpZ25hdHVyZSlcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlKHMpJyk7XG4gICAgICBpZiAoYS5zaWduYXR1cmVzICYmICFzdGFja3NFcXVhbChhLnNpZ25hdHVyZXMsIG8uc2lnbmF0dXJlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gYS5zaWduYXR1cmVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIGNvdW50IG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMm1zID0gcDJtcztcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IHR5cGVmID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IGVjYyA9IHJlcXVpcmUoJ3Rpbnktc2VjcDI1NmsxJyk7XG4vLyBpbnB1dDoge3NpZ25hdHVyZX1cbi8vIG91dHB1dDoge3B1YktleX0gT1BfQ0hFQ0tTSUdcbmZ1bmN0aW9uIHAycGsoYSwgb3B0cykge1xuICBpZiAoIWEuaW5wdXQgJiYgIWEub3V0cHV0ICYmICFhLnB1YmtleSAmJiAhYS5pbnB1dCAmJiAhYS5zaWduYXR1cmUpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gIHR5cGVmKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVmLm1heWJlKHR5cGVmLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlciksXG4gICAgICBwdWJrZXk6IHR5cGVmLm1heWJlKGVjYy5pc1BvaW50KSxcbiAgICAgIHNpZ25hdHVyZTogdHlwZWYubWF5YmUoYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSksXG4gICAgICBpbnB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9jaHVua3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gIH0pO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ3AycGsnLCBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghYS5wdWJrZXkpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnB1YmtleSwgT1BTLk9QX0NIRUNLU0lHXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoIWEub3V0cHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDEsIC0xKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmICghYS5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBfY2h1bmtzKClbMF07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghYS5zaWduYXR1cmUpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnNpZ25hdHVyZV0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChhLm91dHB1dFthLm91dHB1dC5sZW5ndGggLSAxXSAhPT0gT1BTLk9QX0NIRUNLU0lHKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFlY2MuaXNQb2ludChvLnB1YmtleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBwdWJrZXkgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoby5wdWJrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKGEuc2lnbmF0dXJlKSB7XG4gICAgICBpZiAoYS5pbnB1dCAmJiAhYS5pbnB1dC5lcXVhbHMoby5pbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgaWYgKF9jaHVua3MoKS5sZW5ndGggIT09IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShvLnNpZ25hdHVyZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJwayA9IHAycGs7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4uL2NyeXB0bycpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCB0eXBlZiA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5jb25zdCBlY2MgPSByZXF1aXJlKCd0aW55LXNlY3AyNTZrMScpO1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG4vLyBpbnB1dDoge3NpZ25hdHVyZX0ge3B1YmtleX1cbi8vIG91dHB1dDogT1BfRFVQIE9QX0hBU0gxNjAge2hhc2gxNjAocHVia2V5KX0gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbmZ1bmN0aW9uIHAycGtoKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmFkZHJlc3MgJiYgIWEuaGFzaCAmJiAhYS5vdXRwdXQgJiYgIWEucHVia2V5ICYmICFhLmlucHV0KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICB0eXBlZihcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlZi5tYXliZSh0eXBlZi5PYmplY3QpLFxuICAgICAgYWRkcmVzczogdHlwZWYubWF5YmUodHlwZWYuU3RyaW5nKSxcbiAgICAgIGhhc2g6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlck4oMjApKSxcbiAgICAgIG91dHB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyTigyNSkpLFxuICAgICAgcHVia2V5OiB0eXBlZi5tYXliZShlY2MuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVmLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgaW5wdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlciksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHBheWxvYWQucmVhZFVJbnQ4KDApO1xuICAgIGNvbnN0IGhhc2ggPSBwYXlsb2FkLnNsaWNlKDEpO1xuICAgIHJldHVybiB7IHZlcnNpb24sIGhhc2ggfTtcbiAgfSk7XG4gIGNvbnN0IF9jaHVua3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gIH0pO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ3AycGtoJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIxKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgobmV0d29yay5wdWJLZXlIYXNoLCAwKTtcbiAgICBvLmhhc2guY29weShwYXlsb2FkLCAxKTtcbiAgICByZXR1cm4gYnM1OGNoZWNrLmVuY29kZShwYXlsb2FkKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICBpZiAoYS5vdXRwdXQpIHJldHVybiBhLm91dHB1dC5zbGljZSgzLCAyMyk7XG4gICAgaWYgKGEuYWRkcmVzcykgcmV0dXJuIF9hZGRyZXNzKCkuaGFzaDtcbiAgICBpZiAoYS5wdWJrZXkgfHwgby5wdWJrZXkpIHJldHVybiBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkgfHwgby5wdWJrZXkpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtcbiAgICAgIE9QUy5PUF9EVVAsXG4gICAgICBPUFMuT1BfSEFTSDE2MCxcbiAgICAgIG8uaGFzaCxcbiAgICAgIE9QUy5PUF9FUVVBTFZFUklGWSxcbiAgICAgIE9QUy5PUF9DSEVDS1NJRyxcbiAgICBdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgIGlmICghYS5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBfY2h1bmtzKClbMV07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZScsICgpID0+IHtcbiAgICBpZiAoIWEuaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gX2NodW5rcygpWzBdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEucHVia2V5KSByZXR1cm47XG4gICAgaWYgKCFhLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW2Euc2lnbmF0dXJlLCBhLnB1YmtleV0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBsZXQgaGFzaCA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSBuZXR3b3JrLnB1YktleUhhc2gpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBvciBOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5oYXNoLmxlbmd0aCAhPT0gMjApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgaGFzaCA9IF9hZGRyZXNzKCkuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEuaGFzaCkge1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gYS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5vdXRwdXQubGVuZ3RoICE9PSAyNSB8fFxuICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QX0RVUCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gT1BTLk9QX0hBU0gxNjAgfHxcbiAgICAgICAgYS5vdXRwdXRbMl0gIT09IDB4MTQgfHxcbiAgICAgICAgYS5vdXRwdXRbMjNdICE9PSBPUFMuT1BfRVFVQUxWRVJJRlkgfHxcbiAgICAgICAgYS5vdXRwdXRbMjRdICE9PSBPUFMuT1BfQ0hFQ0tTSUdcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNvbnN0IGhhc2gyID0gYS5vdXRwdXQuc2xpY2UoMywgMjMpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICB9XG4gICAgaWYgKGEucHVia2V5KSB7XG4gICAgICBjb25zdCBwa2ggPSBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gcGtoO1xuICAgIH1cbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgaWYgKGNodW5rcy5sZW5ndGggIT09IDIpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShjaHVua3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIGlmICghZWNjLmlzUG9pbnQoY2h1bmtzWzFdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgcHVia2V5Jyk7XG4gICAgICBpZiAoYS5zaWduYXR1cmUgJiYgIWEuc2lnbmF0dXJlLmVxdWFscyhjaHVua3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChhLnB1YmtleSAmJiAhYS5wdWJrZXkuZXF1YWxzKGNodW5rc1sxXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgY29uc3QgcGtoID0gYmNyeXB0by5oYXNoMTYwKGNodW5rc1sxXSk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnBraCA9IHAycGtoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgdHlwZWYgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGEuZXZlcnkoKHgsIGkpID0+IHtcbiAgICByZXR1cm4geC5lcXVhbHMoYltpXSk7XG4gIH0pO1xufVxuLy8gaW5wdXQ6IFtyZWRlZW1TY3JpcHRTaWcgLi4uXSB7cmVkZWVtU2NyaXB0fVxuLy8gd2l0bmVzczogPD8+XG4vLyBvdXRwdXQ6IE9QX0hBU0gxNjAge2hhc2gxNjAocmVkZWVtU2NyaXB0KX0gT1BfRVFVQUxcbmZ1bmN0aW9uIHAyc2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEuaW5wdXQpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gIHR5cGVmKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVmLm1heWJlKHR5cGVmLk9iamVjdCksXG4gICAgICBhZGRyZXNzOiB0eXBlZi5tYXliZSh0eXBlZi5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyTigyMCkpLFxuICAgICAgb3V0cHV0OiB0eXBlZi5tYXliZSh0eXBlZi5CdWZmZXJOKDIzKSksXG4gICAgICByZWRlZW06IHR5cGVmLm1heWJlKHtcbiAgICAgICAgbmV0d29yazogdHlwZWYubWF5YmUodHlwZWYuT2JqZWN0KSxcbiAgICAgICAgb3V0cHV0OiB0eXBlZi5tYXliZSh0eXBlZi5CdWZmZXIpLFxuICAgICAgICBpbnB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyKSxcbiAgICAgICAgd2l0bmVzczogdHlwZWYubWF5YmUodHlwZWYuYXJyYXlPZih0eXBlZi5CdWZmZXIpKSxcbiAgICAgIH0pLFxuICAgICAgaW5wdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlciksXG4gICAgICB3aXRuZXNzOiB0eXBlZi5tYXliZSh0eXBlZi5hcnJheU9mKHR5cGVmLkJ1ZmZlcikpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgbGV0IG5ldHdvcmsgPSBhLm5ldHdvcms7XG4gIGlmICghbmV0d29yaykge1xuICAgIG5ldHdvcmsgPSAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ubmV0d29yaykgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICB9XG4gIGNvbnN0IG8gPSB7IG5ldHdvcmsgfTtcbiAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gYnM1OGNoZWNrLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgX3JlZGVlbSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV0d29yayxcbiAgICAgIG91dHB1dDogY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSxcbiAgICAgIGlucHV0OiBic2NyaXB0LmNvbXBpbGUoY2h1bmtzLnNsaWNlKDAsIC0xKSksXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3MgfHwgW10sXG4gICAgfTtcbiAgfSk7XG4gIC8vIG91dHB1dCBkZXBlbmRlbnRzXG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChvLm5ldHdvcmsuc2NyaXB0SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgb2YgbGVhc3QgZWZmb3J0XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChvLnJlZGVlbS5vdXRwdXQpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfSEFTSDE2MCwgby5oYXNoLCBPUFMuT1BfRVFVQUxdKTtcbiAgfSk7XG4gIC8vIGlucHV0IGRlcGVuZGVudHNcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9yZWRlZW0oKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnJlZGVlbSB8fCAhYS5yZWRlZW0uaW5wdXQgfHwgIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBbXS5jb25jYXQoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0uaW5wdXQpLCBhLnJlZGVlbS5vdXRwdXQpLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLndpdG5lc3MpIHJldHVybiBvLnJlZGVlbS53aXRuZXNzO1xuICAgIGlmIChvLmlucHV0KSByZXR1cm4gW107XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMnNoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQpIG5hbWVQYXJ0cy5wdXNoKG8ucmVkZWVtLm5hbWUpO1xuICAgIHJldHVybiBuYW1lUGFydHMuam9pbignLScpO1xuICB9KTtcbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBsZXQgaGFzaCA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSBuZXR3b3JrLnNjcmlwdEhhc2gpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBvciBOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5oYXNoLmxlbmd0aCAhPT0gMjApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgaGFzaCA9IF9hZGRyZXNzKCkuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEuaGFzaCkge1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gYS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5vdXRwdXQubGVuZ3RoICE9PSAyMyB8fFxuICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QX0hBU0gxNjAgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IDB4MTQgfHxcbiAgICAgICAgYS5vdXRwdXRbMjJdICE9PSBPUFMuT1BfRVFVQUxcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNvbnN0IGhhc2gyID0gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICB9XG4gICAgLy8gaW5saW5lZCB0byBwcmV2ZW50ICduby1pbm5lci1kZWNsYXJhdGlvbnMnIGZhaWxpbmdcbiAgICBjb25zdCBjaGVja1JlZGVlbSA9IHJlZGVlbSA9PiB7XG4gICAgICAvLyBpcyB0aGUgcmVkZWVtIG91dHB1dCBlbXB0eS9pbnZhbGlkP1xuICAgICAgaWYgKHJlZGVlbS5vdXRwdXQpIHtcbiAgICAgICAgY29uc3QgZGVjb21waWxlID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLm91dHB1dCk7XG4gICAgICAgIGlmICghZGVjb21waWxlIHx8IGRlY29tcGlsZS5sZW5ndGggPCAxKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgdG9vIHNob3J0Jyk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5oYXNoMTYwKHJlZGVlbS5vdXRwdXQpO1xuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZW0uaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaGFzSW5wdXQgPSByZWRlZW0uaW5wdXQubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzcyA9IHJlZGVlbS53aXRuZXNzICYmIHJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaGFzSW5wdXQgJiYgIWhhc1dpdG5lc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtcHR5IGlucHV0Jyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCAmJiBoYXNXaXRuZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGFuZCB3aXRuZXNzIHByb3ZpZGVkJyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHJpY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLmlucHV0KTtcbiAgICAgICAgICBpZiAoIWJzY3JpcHQuaXNQdXNoT25seShyaWNodW5rcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24gcHVzaC1vbmx5IHNjcmlwdFNpZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoX3JlZGVlbSgpLm91dHB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNoZWNrUmVkZWVtKF9yZWRlZW0oKSk7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLm5ldHdvcmsgJiYgYS5yZWRlZW0ubmV0d29yayAhPT0gbmV0d29yaylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVkZWVtID0gX3JlZGVlbSgpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHJlZGVlbS5vdXRwdXQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFhLnJlZGVlbS5pbnB1dC5lcXVhbHMocmVkZWVtLmlucHV0KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0uaW5wdXQgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrUmVkZWVtKGEucmVkZWVtKTtcbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgaWYgKFxuICAgICAgICBhLnJlZGVlbSAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICFzdGFja3NFcXVhbChhLnJlZGVlbS53aXRuZXNzLCBhLndpdG5lc3MpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS53aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnNoID0gcDJzaDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IHR5cGVmID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IGVjYyA9IHJlcXVpcmUoJ3Rpbnktc2VjcDI1NmsxJyk7XG5jb25zdCBiZWNoMzIgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcbi8vIHdpdG5lc3M6IHtzaWduYXR1cmV9IHtwdWJLZXl9XG4vLyBpbnB1dDogPD5cbi8vIG91dHB1dDogT1BfMCB7cHViS2V5SGFzaH1cbmZ1bmN0aW9uIHAyd3BraChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnB1YmtleSAmJiAhYS53aXRuZXNzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICB0eXBlZihcbiAgICB7XG4gICAgICBhZGRyZXNzOiB0eXBlZi5tYXliZSh0eXBlZi5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyTigyMCkpLFxuICAgICAgaW5wdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlck4oMCkpLFxuICAgICAgbmV0d29yazogdHlwZWYubWF5YmUodHlwZWYuT2JqZWN0KSxcbiAgICAgIG91dHB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyTigyMikpLFxuICAgICAgcHVia2V5OiB0eXBlZi5tYXliZShlY2MuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVmLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgd2l0bmVzczogdHlwZWYubWF5YmUodHlwZWYuYXJyYXlPZih0eXBlZi5CdWZmZXIpKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmVjaDMyLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZXN1bHQud29yZHMuc2hpZnQoKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgcHJlZml4OiByZXN1bHQucHJlZml4LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuYW1lOiAncDJ3cGtoJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICBjb25zdCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKG8uaGFzaCk7XG4gICAgd29yZHMudW5zaGlmdCgweDAwKTtcbiAgICByZXR1cm4gYmVjaDMyLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIsIDIyKTtcbiAgICBpZiAoYS5hZGRyZXNzKSByZXR1cm4gX2FkZHJlc3MoKS5kYXRhO1xuICAgIGlmIChhLnB1YmtleSB8fCBvLnB1YmtleSkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSB8fCBvLnB1YmtleSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wLCBvLmhhc2hdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgIGlmIChhLnB1YmtleSkgcmV0dXJuIGEucHVia2V5O1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIGEud2l0bmVzc1sxXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIGEud2l0bmVzc1swXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghYS5wdWJrZXkpIHJldHVybjtcbiAgICBpZiAoIWEuc2lnbmF0dXJlKSByZXR1cm47XG4gICAgcmV0dXJuIFthLnNpZ25hdHVyZSwgYS5wdWJrZXldO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChuZXR3b3JrICYmIG5ldHdvcmsuYmVjaDMyICE9PSBfYWRkcmVzcygpLnByZWZpeClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAyMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIGRhdGEnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmRhdGE7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMjIgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8wIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSAweDE0XG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLm91dHB1dC5zbGljZSgyKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXkpIHtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBwa2g7XG4gICAgfVxuICAgIGlmIChhLndpdG5lc3MpIHtcbiAgICAgIGlmIChhLndpdG5lc3MubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShhLndpdG5lc3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgaWYgKCFlY2MuaXNQb2ludChhLndpdG5lc3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGhhcyBpbnZhbGlkIHB1YmtleScpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMoYS53aXRuZXNzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5wdWJrZXkgJiYgIWEucHVia2V5LmVxdWFscyhhLndpdG5lc3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLndpdG5lc3NbMV0pO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJ3cGtoID0gcDJ3cGtoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgdHlwZWYgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgYmVjaDMyID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBFTVBUWV9CVUZGRVIgPSBCdWZmZXIuYWxsb2MoMCk7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGEuZXZlcnkoKHgsIGkpID0+IHtcbiAgICByZXR1cm4geC5lcXVhbHMoYltpXSk7XG4gIH0pO1xufVxuLy8gaW5wdXQ6IDw+XG4vLyB3aXRuZXNzOiBbcmVkZWVtU2NyaXB0U2lnIC4uLl0ge3JlZGVlbVNjcmlwdH1cbi8vIG91dHB1dDogT1BfMCB7c2hhMjU2KHJlZGVlbVNjcmlwdCl9XG5mdW5jdGlvbiBwMndzaChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnJlZGVlbSAmJiAhYS53aXRuZXNzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICB0eXBlZihcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlZi5tYXliZSh0eXBlZi5PYmplY3QpLFxuICAgICAgYWRkcmVzczogdHlwZWYubWF5YmUodHlwZWYuU3RyaW5nKSxcbiAgICAgIGhhc2g6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlck4oMzIpKSxcbiAgICAgIG91dHB1dDogdHlwZWYubWF5YmUodHlwZWYuQnVmZmVyTigzNCkpLFxuICAgICAgcmVkZWVtOiB0eXBlZi5tYXliZSh7XG4gICAgICAgIGlucHV0OiB0eXBlZi5tYXliZSh0eXBlZi5CdWZmZXIpLFxuICAgICAgICBuZXR3b3JrOiB0eXBlZi5tYXliZSh0eXBlZi5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVmLm1heWJlKHR5cGVmLkJ1ZmZlciksXG4gICAgICAgIHdpdG5lc3M6IHR5cGVmLm1heWJlKHR5cGVmLmFycmF5T2YodHlwZWYuQnVmZmVyKSksXG4gICAgICB9KSxcbiAgICAgIGlucHV0OiB0eXBlZi5tYXliZSh0eXBlZi5CdWZmZXJOKDApKSxcbiAgICAgIHdpdG5lc3M6IHR5cGVmLm1heWJlKHR5cGVmLmFycmF5T2YodHlwZWYuQnVmZmVyKSksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlY2gzMi5kZWNvZGUoYS5hZGRyZXNzKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gcmVzdWx0LndvcmRzLnNoaWZ0KCk7XG4gICAgY29uc3QgZGF0YSA9IGJlY2gzMi5mcm9tV29yZHMocmVzdWx0LndvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbixcbiAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBfcmNodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5pbnB1dCk7XG4gIH0pO1xuICBsZXQgbmV0d29yayA9IGEubmV0d29yaztcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IChhLnJlZGVlbSAmJiBhLnJlZGVlbS5uZXR3b3JrKSB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIH1cbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICBjb25zdCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKG8uaGFzaCk7XG4gICAgd29yZHMudW5zaGlmdCgweDAwKTtcbiAgICByZXR1cm4gYmVjaDMyLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmRhdGE7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uc2hhMjU2KG8ucmVkZWVtLm91dHB1dCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wLCBvLmhhc2hdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncmVkZWVtJywgKCkgPT4ge1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogYS53aXRuZXNzW2Eud2l0bmVzcy5sZW5ndGggLSAxXSxcbiAgICAgIGlucHV0OiBFTVBUWV9CVUZGRVIsXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3Muc2xpY2UoMCwgLTEpLFxuICAgIH07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghby53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICAvLyB0cmFuc2Zvcm0gcmVkZWVtIGlucHV0IHRvIHdpdG5lc3Mgc3RhY2s/XG4gICAgaWYgKFxuICAgICAgYS5yZWRlZW0gJiZcbiAgICAgIGEucmVkZWVtLmlucHV0ICYmXG4gICAgICBhLnJlZGVlbS5pbnB1dC5sZW5ndGggPiAwICYmXG4gICAgICBhLnJlZGVlbS5vdXRwdXQgJiZcbiAgICAgIGEucmVkZWVtLm91dHB1dC5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBjb25zdCBzdGFjayA9IGJzY3JpcHQudG9TdGFjayhfcmNodW5rcygpKTtcbiAgICAgIC8vIGFzc2lnbiwgYW5kIGJsYW5rIHRoZSBleGlzdGluZyBpbnB1dFxuICAgICAgby5yZWRlZW0gPSBPYmplY3QuYXNzaWduKHsgd2l0bmVzczogc3RhY2sgfSwgYS5yZWRlZW0pO1xuICAgICAgby5yZWRlZW0uaW5wdXQgPSBFTVBUWV9CVUZGRVI7XG4gICAgICByZXR1cm4gW10uY29uY2F0KHN0YWNrLCBhLnJlZGVlbS5vdXRwdXQpO1xuICAgIH1cbiAgICBpZiAoIWEucmVkZWVtKSByZXR1cm47XG4gICAgaWYgKCFhLnJlZGVlbS5vdXRwdXQpIHJldHVybjtcbiAgICBpZiAoIWEucmVkZWVtLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gW10uY29uY2F0KGEucmVkZWVtLndpdG5lc3MsIGEucmVkZWVtLm91dHB1dCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMndzaCddO1xuICAgIGlmIChvLnJlZGVlbSAhPT0gdW5kZWZpbmVkKSBuYW1lUGFydHMucHVzaChvLnJlZGVlbS5uYW1lKTtcbiAgICByZXR1cm4gbmFtZVBhcnRzLmpvaW4oJy0nKTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBsZXQgaGFzaCA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHByZWZpeCBvciBOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSAweDAwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdmVyc2lvbicpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkuZGF0YS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgZGF0YScpO1xuICAgICAgaGFzaCA9IF9hZGRyZXNzKCkuZGF0YTtcbiAgICB9XG4gICAgaWYgKGEuaGFzaCkge1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gYS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5vdXRwdXQubGVuZ3RoICE9PSAzNCB8fFxuICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QXzAgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IDB4MjBcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNvbnN0IGhhc2gyID0gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgIH1cbiAgICBpZiAoYS5yZWRlZW0pIHtcbiAgICAgIGlmIChhLnJlZGVlbS5uZXR3b3JrICYmIGEucmVkZWVtLm5ldHdvcmsgIT09IG5ldHdvcmspXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIC8vIGlzIHRoZXJlIHR3byByZWRlZW0gc291cmNlcz9cbiAgICAgIGlmIChcbiAgICAgICAgYS5yZWRlZW0uaW5wdXQgJiZcbiAgICAgICAgYS5yZWRlZW0uaW5wdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgIGEucmVkZWVtLndpdG5lc3MubGVuZ3RoID4gMFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbWJpZ3VvdXMgd2l0bmVzcyBzb3VyY2UnKTtcbiAgICAgIC8vIGlzIHRoZSByZWRlZW0gb3V0cHV0IG5vbi1lbXB0eT9cbiAgICAgIGlmIChhLnJlZGVlbS5vdXRwdXQpIHtcbiAgICAgICAgaWYgKGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLm91dHB1dCkubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAvLyBtYXRjaCBoYXNoIGFnYWluc3Qgb3RoZXIgc291cmNlc1xuICAgICAgICBjb25zdCBoYXNoMiA9IGJjcnlwdG8uc2hhMjU2KGEucmVkZWVtLm91dHB1dCk7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgICAgfVxuICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFic2NyaXB0LmlzUHVzaE9ubHkoX3JjaHVua3MoKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vbiBwdXNoLW9ubHkgc2NyaXB0U2lnJyk7XG4gICAgICBpZiAoXG4gICAgICAgIGEud2l0bmVzcyAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICFzdGFja3NFcXVhbChhLndpdG5lc3MsIGEucmVkZWVtLndpdG5lc3MpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS53aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmIChhLndpdG5lc3MpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5yZWRlZW0gJiZcbiAgICAgICAgYS5yZWRlZW0ub3V0cHV0ICYmXG4gICAgICAgICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKGEud2l0bmVzc1thLndpdG5lc3MubGVuZ3RoIC0gMV0pXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyd3NoID0gcDJ3c2g7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmlwMTc0XzEgPSByZXF1aXJlKCdiaXAxNzQnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCdiaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdmFyaW50Jyk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZSgnYmlwMTc0L3NyYy9saWIvdXRpbHMnKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmNvbnN0IGVjcGFpcl8xID0gcmVxdWlyZSgnLi9lY3BhaXInKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbi8qKlxuICogVGhlc2UgYXJlIHRoZSBkZWZhdWx0IGFyZ3VtZW50cyBmb3IgYSBQc2J0IGluc3RhbmNlLlxuICovXG5jb25zdCBERUZBVUxUX09QVFMgPSB7XG4gIC8qKlxuICAgKiBBIGJpdGNvaW5qcyBOZXR3b3JrIG9iamVjdC4gVGhpcyBpcyBvbmx5IHVzZWQgaWYgeW91IHBhc3MgYW4gYGFkZHJlc3NgXG4gICAqIHBhcmFtZXRlciB0byBhZGRPdXRwdXQuIE90aGVyd2lzZSBpdCBpcyBub3QgbmVlZGVkIGFuZCBjYW4gYmUgbGVmdCBkZWZhdWx0LlxuICAgKi9cbiAgbmV0d29yazogbmV0d29ya3NfMS5iaXRjb2luLFxuICAvKipcbiAgICogV2hlbiBleHRyYWN0VHJhbnNhY3Rpb24gaXMgY2FsbGVkLCB0aGUgZmVlIHJhdGUgaXMgY2hlY2tlZC5cbiAgICogVEhJUyBJUyBOT1QgVE8gQkUgUkVMSUVEIE9OLlxuICAgKiBJdCBpcyBvbmx5IGhlcmUgYXMgYSBsYXN0IGRpdGNoIGVmZm9ydCB0byBwcmV2ZW50IHNlbmRpbmcgYSA1MDAgQlRDIGZlZSBldGMuXG4gICAqL1xuICBtYXhpbXVtRmVlUmF0ZTogNTAwMCxcbn07XG4vKipcbiAqIFBzYnQgY2xhc3MgY2FuIHBhcnNlIGFuZCBnZW5lcmF0ZSBhIFBTQlQgYmluYXJ5IGJhc2VkIG9mZiBvZiB0aGUgQklQMTc0LlxuICogVGhlcmUgYXJlIDYgcm9sZXMgdGhhdCB0aGlzIGNsYXNzIGZ1bGZpbGxzLiAoRXhwbGFpbmVkIGluIEJJUDE3NClcbiAqXG4gKiBDcmVhdG9yOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYG5ldyBQc2J0KClgXG4gKiBVcGRhdGVyOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYHBzYnQuYWRkSW5wdXQoaW5wdXQpYCwgYHBzYnQuYWRkSW5wdXRzKGlucHV0cylgLFxuICogICBgcHNidC5hZGRPdXRwdXQob3V0cHV0KWAsIGBwc2J0LmFkZE91dHB1dHMob3V0cHV0cylgIHdoZW4geW91IGFyZSBsb29raW5nIHRvXG4gKiAgIGFkZCBuZXcgaW5wdXRzIGFuZCBvdXRwdXRzIHRvIHRoZSBQU0JULCBhbmQgYHBzYnQudXBkYXRlR2xvYmFsKGl0ZW1PYmplY3QpYCxcbiAqICAgYHBzYnQudXBkYXRlSW5wdXQoaXRlbU9iamVjdClgLCBgcHNidC51cGRhdGVPdXRwdXQoaXRlbU9iamVjdClgXG4gKiAgIGFkZElucHV0IHJlcXVpcmVzIGhhc2g6IEJ1ZmZlciB8IHN0cmluZzsgYW5kIGluZGV4OiBudW1iZXI7IGFzIGF0dHJpYnV0ZXNcbiAqICAgYW5kIGNhbiBhbHNvIGluY2x1ZGUgYW55IGF0dHJpYnV0ZXMgdGhhdCBhcmUgdXNlZCBpbiB1cGRhdGVJbnB1dCBtZXRob2QuXG4gKiAgIGFkZE91dHB1dCByZXF1aXJlcyBzY3JpcHQ6IEJ1ZmZlcjsgYW5kIHZhbHVlOiBudW1iZXI7IGFuZCBsaWtld2lzZSBjYW4gaW5jbHVkZVxuICogICBkYXRhIGZvciB1cGRhdGVPdXRwdXQuXG4gKiAgIEZvciBhIGxpc3Qgb2Ygd2hhdCBhdHRyaWJ1dGVzIHNob3VsZCBiZSB3aGF0IHR5cGVzLiBDaGVjayB0aGUgYmlwMTc0IGxpYnJhcnkuXG4gKiAgIEFsc28sIGNoZWNrIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0cyBmb3Igc29tZSBleGFtcGxlcyBvZiB1c2FnZS5cbiAqIFNpZ25lcjogVGhlcmUgYXJlIGEgZmV3IG1ldGhvZHMuIHNpZ25BbGxJbnB1dHMgYW5kIHNpZ25BbGxJbnB1dHNBc3luYywgd2hpY2ggd2lsbCBzZWFyY2ggYWxsIGlucHV0XG4gKiAgIGluZm9ybWF0aW9uIGZvciB5b3VyIHB1YmtleSBvciBwdWJrZXloYXNoLCBhbmQgb25seSBzaWduIGlucHV0cyB3aGVyZSBpdCBmaW5kc1xuICogICB5b3VyIGluZm8uIE9yIHlvdSBjYW4gZXhwbGljaXRseSBzaWduIGEgc3BlY2lmaWMgaW5wdXQgd2l0aCBzaWduSW5wdXQgYW5kXG4gKiAgIHNpZ25JbnB1dEFzeW5jLiBGb3IgdGhlIGFzeW5jIG1ldGhvZHMgeW91IGNhbiBjcmVhdGUgYSBTaWduZXJBc3luYyBvYmplY3RcbiAqICAgYW5kIHVzZSBzb21ldGhpbmcgbGlrZSBhIGhhcmR3YXJlIHdhbGxldCB0byBzaWduIHdpdGguIChZb3UgbXVzdCBpbXBsZW1lbnQgdGhpcylcbiAqIENvbWJpbmVyOiBwc2J0cyBjYW4gYmUgY29tYmluZWQgZWFzaWx5IHdpdGggYHBzYnQuY29tYmluZShwc2J0MiwgcHNidDMsIHBzYnQ0IC4uLilgXG4gKiAgIHRoZSBwc2J0IGNhbGxpbmcgY29tYmluZSB3aWxsIGFsd2F5cyBoYXZlIHByZWNlZGVuY2Ugd2hlbiBhIGNvbmZsaWN0IG9jY3Vycy5cbiAqICAgQ29tYmluZSBjaGVja3MgaWYgdGhlIGludGVybmFsIGJpdGNvaW4gdHJhbnNhY3Rpb24gaXMgdGhlIHNhbWUsIHNvIGJlIHN1cmUgdGhhdFxuICogICBhbGwgc2VxdWVuY2VzLCB2ZXJzaW9uLCBsb2NrdGltZSwgZXRjLiBhcmUgdGhlIHNhbWUgYmVmb3JlIGNvbWJpbmluZy5cbiAqIElucHV0IEZpbmFsaXplcjogVGhpcyByb2xlIGlzIGZhaXJseSBpbXBvcnRhbnQuIE5vdCBvbmx5IGRvZXMgaXQgbmVlZCB0byBjb25zdHJ1Y3RcbiAqICAgdGhlIGlucHV0IHNjcmlwdFNpZ3MgYW5kIHdpdG5lc3NlcywgYnV0IGl0IFNIT1VMRCB2ZXJpZnkgdGhlIHNpZ25hdHVyZXMgZXRjLlxuICogICBCZWZvcmUgcnVubmluZyBgcHNidC5maW5hbGl6ZUFsbElucHV0cygpYCBwbGVhc2UgcnVuIGBwc2J0LnZhbGlkYXRlU2lnbmF0dXJlc09mQWxsSW5wdXRzKClgXG4gKiAgIFJ1bm5pbmcgYW55IGZpbmFsaXplIG1ldGhvZCB3aWxsIGRlbGV0ZSBhbnkgZGF0YSBpbiB0aGUgaW5wdXQocykgdGhhdCBhcmUgbm8gbG9uZ2VyXG4gKiAgIG5lZWRlZCBkdWUgdG8gdGhlIGZpbmFsaXplZCBzY3JpcHRzIGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uLlxuICogVHJhbnNhY3Rpb24gRXh0cmFjdG9yOiBUaGlzIHJvbGUgd2lsbCBwZXJmb3JtIHNvbWUgY2hlY2tzIGJlZm9yZSByZXR1cm5pbmcgYVxuICogICBUcmFuc2FjdGlvbiBvYmplY3QuIFN1Y2ggYXMgZmVlIHJhdGUgbm90IGJlaW5nIGxhcmdlciB0aGFuIG1heGltdW1GZWVSYXRlIGV0Yy5cbiAqL1xuY2xhc3MgUHNidCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSwgZGF0YSA9IG5ldyBiaXAxNzRfMS5Qc2J0KG5ldyBQc2J0VHJhbnNhY3Rpb24oKSkpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUUywgb3B0cyk7XG4gICAgdGhpcy5fX0NBQ0hFID0ge1xuICAgICAgX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFOiBbXSxcbiAgICAgIF9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEU6IFtdLFxuICAgICAgX19UWF9JTl9DQUNIRToge30sXG4gICAgICBfX1RYOiB0aGlzLmRhdGEuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudHgsXG4gICAgfTtcbiAgICBpZiAodGhpcy5kYXRhLmlucHV0cy5sZW5ndGggPT09IDApIHRoaXMuc2V0VmVyc2lvbigyKTtcbiAgICAvLyBNYWtlIGRhdGEgaGlkZGVuIHdoZW4gZW51bWVyYXRpbmdcbiAgICBjb25zdCBkcGV3ID0gKG9iaiwgYXR0ciwgZW51bWVyYWJsZSwgd3JpdGFibGUpID0+XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBhdHRyLCB7XG4gICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgIHdyaXRhYmxlLFxuICAgICAgfSk7XG4gICAgZHBldyh0aGlzLCAnX19DQUNIRScsIGZhbHNlLCB0cnVlKTtcbiAgICBkcGV3KHRoaXMsICdvcHRzJywgZmFsc2UsIHRydWUpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmFzZTY0KGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgb3B0cyk7XG4gIH1cbiAgc3RhdGljIGZyb21IZXgoZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCBvcHRzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHBzYnRCYXNlID0gYmlwMTc0XzEuUHNidC5mcm9tQnVmZmVyKGJ1ZmZlciwgdHJhbnNhY3Rpb25Gcm9tQnVmZmVyKTtcbiAgICBjb25zdCBwc2J0ID0gbmV3IFBzYnQob3B0cywgcHNidEJhc2UpO1xuICAgIGNoZWNrVHhGb3JEdXBlSW5zKHBzYnQuX19DQUNIRS5fX1RYLCBwc2J0Ll9fQ0FDSEUpO1xuICAgIHJldHVybiBwc2J0O1xuICB9XG4gIGdldCBpbnB1dENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aDtcbiAgfVxuICBjb21iaW5lKC4uLnRob3NlKSB7XG4gICAgdGhpcy5kYXRhLmNvbWJpbmUoLi4udGhvc2UubWFwKG8gPT4gby5kYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgY2xvbmluZ1xuICAgIGNvbnN0IHJlcyA9IFBzYnQuZnJvbUJ1ZmZlcih0aGlzLmRhdGEudG9CdWZmZXIoKSk7XG4gICAgcmVzLm9wdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0cykpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgc2V0TWF4aW11bUZlZVJhdGUoc2F0b3NoaVBlckJ5dGUpIHtcbiAgICBjaGVjazMyQml0KHNhdG9zaGlQZXJCeXRlKTsgLy8gNDIuOSBCVEMgcGVyIGJ5dGUgSVMgZXhjZXNzaXZlLi4uIHNvIHRocm93XG4gICAgdGhpcy5vcHRzLm1heGltdW1GZWVSYXRlID0gc2F0b3NoaVBlckJ5dGU7XG4gIH1cbiAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgY2hlY2szMkJpdCh2ZXJzaW9uKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ3NldFZlcnNpb24nKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIGMuX19UWC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldExvY2t0aW1lKGxvY2t0aW1lKSB7XG4gICAgY2hlY2szMkJpdChsb2NrdGltZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRMb2NrdGltZScpO1xuICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgYy5fX1RYLmxvY2t0aW1lID0gbG9ja3RpbWU7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRJbnB1dFNlcXVlbmNlKGlucHV0SW5kZXgsIHNlcXVlbmNlKSB7XG4gICAgY2hlY2szMkJpdChzZXF1ZW5jZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRJbnB1dFNlcXVlbmNlJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoYy5fX1RYLmlucy5sZW5ndGggPD0gaW5wdXRJbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpbmRleCB0b28gaGlnaCcpO1xuICAgIH1cbiAgICBjLl9fVFguaW5zW2lucHV0SW5kZXhdLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dHMoaW5wdXREYXRhcykge1xuICAgIGlucHV0RGF0YXMuZm9yRWFjaChpbnB1dERhdGEgPT4gdGhpcy5hZGRJbnB1dChpbnB1dERhdGEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dChpbnB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIWlucHV0RGF0YSB8fFxuICAgICAgaW5wdXREYXRhLmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXREYXRhLmluZGV4ID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LmFkZElucHV0LiBgICtcbiAgICAgICAgICBgUmVxdWlyZXMgc2luZ2xlIG9iamVjdCB3aXRoIGF0IGxlYXN0IFtoYXNoXSBhbmQgW2luZGV4XWAsXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZElucHV0Jyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICB0aGlzLmRhdGEuYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICBjb25zdCB0eEluID0gYy5fX1RYLmluc1tjLl9fVFguaW5zLmxlbmd0aCAtIDFdO1xuICAgIGNoZWNrVHhJbnB1dENhY2hlKGMsIHR4SW4pO1xuICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUodGhpcy5fX0NBQ0hFLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgfVxuICAgIGMuX19GRUUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0cyhvdXRwdXREYXRhcykge1xuICAgIG91dHB1dERhdGFzLmZvckVhY2gob3V0cHV0RGF0YSA9PiB0aGlzLmFkZE91dHB1dChvdXRwdXREYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIW91dHB1dERhdGEgfHxcbiAgICAgIG91dHB1dERhdGEudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKG91dHB1dERhdGEuYWRkcmVzcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dERhdGEuc2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC5hZGRPdXRwdXQuIGAgK1xuICAgICAgICAgIGBSZXF1aXJlcyBzaW5nbGUgb2JqZWN0IHdpdGggYXQgbGVhc3QgW3NjcmlwdCBvciBhZGRyZXNzXSBhbmQgW3ZhbHVlXWAsXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZE91dHB1dCcpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gb3V0cHV0RGF0YTtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7IG5ldHdvcmsgfSA9IHRoaXMub3B0cztcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGFkZHJlc3NfMS50b091dHB1dFNjcmlwdChhZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgIG91dHB1dERhdGEgPSBPYmplY3QuYXNzaWduKG91dHB1dERhdGEsIHsgc2NyaXB0IH0pO1xuICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIHRoaXMuZGF0YS5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICBjLl9fRkVFX1JBVEUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBleHRyYWN0VHJhbnNhY3Rpb24oZGlzYWJsZUZlZUNoZWNrKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSkgdGhyb3cgbmV3IEVycm9yKCdOb3QgZmluYWxpemVkJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoIWRpc2FibGVGZWVDaGVjaykge1xuICAgICAgY2hlY2tGZWVzKHRoaXMsIGMsIHRoaXMub3B0cyk7XG4gICAgfVxuICAgIGlmIChjLl9fRVhUUkFDVEVEX1RYKSByZXR1cm4gYy5fX0VYVFJBQ1RFRF9UWDtcbiAgICBjb25zdCB0eCA9IGMuX19UWC5jbG9uZSgpO1xuICAgIGlucHV0RmluYWxpemVHZXRBbXRzKHRoaXMuZGF0YS5pbnB1dHMsIHR4LCBjLCB0cnVlKTtcbiAgICByZXR1cm4gdHg7XG4gIH1cbiAgZ2V0RmVlUmF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0VHhDYWNoZVZhbHVlKFxuICAgICAgJ19fRkVFX1JBVEUnLFxuICAgICAgJ2ZlZSByYXRlJyxcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgKTtcbiAgfVxuICBnZXRGZWUoKSB7XG4gICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZSgnX19GRUUnLCAnZmVlJywgdGhpcy5kYXRhLmlucHV0cywgdGhpcy5fX0NBQ0hFKTtcbiAgfVxuICBmaW5hbGl6ZUFsbElucHV0cygpIHtcbiAgICB1dGlsc18xLmNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpLmZvckVhY2goaWR4ID0+IHRoaXMuZmluYWxpemVJbnB1dChpZHgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaW5hbGl6ZUlucHV0KGlucHV0SW5kZXgsIGZpbmFsU2NyaXB0c0Z1bmMgPSBnZXRGaW5hbFNjcmlwdHMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHV0aWxzXzEuY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCB7IHNjcmlwdCwgaXNQMlNILCBpc1AyV1NILCBpc1NlZ3dpdCB9ID0gZ2V0U2NyaXB0RnJvbUlucHV0KFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICk7XG4gICAgaWYgKCFzY3JpcHQpIHRocm93IG5ldyBFcnJvcihgTm8gc2NyaXB0IGZvdW5kIGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fWApO1xuICAgIGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyhpbnB1dCk7XG4gICAgY29uc3QgeyBmaW5hbFNjcmlwdFNpZywgZmluYWxTY3JpcHRXaXRuZXNzIH0gPSBmaW5hbFNjcmlwdHNGdW5jKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAgc2NyaXB0LFxuICAgICAgaXNTZWd3aXQsXG4gICAgICBpc1AyU0gsXG4gICAgICBpc1AyV1NILFxuICAgICk7XG4gICAgaWYgKGZpbmFsU2NyaXB0U2lnKSB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFNpZyB9KTtcbiAgICBpZiAoZmluYWxTY3JpcHRXaXRuZXNzKVxuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIGlmICghZmluYWxTY3JpcHRTaWcgJiYgIWZpbmFsU2NyaXB0V2l0bmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlcnJvciBmaW5hbGl6aW5nIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFsaWRhdGVTaWduYXR1cmVzT2ZBbGxJbnB1dHMoKSB7XG4gICAgdXRpbHNfMS5jaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIDApOyAvLyBtYWtpbmcgc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZVxuICAgIGNvbnN0IHJlc3VsdHMgPSByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkubWFwKGlkeCA9PlxuICAgICAgdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlkeCksXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGZpbmFsLCByZXMpID0+IHJlcyA9PT0gdHJ1ZSAmJiBmaW5hbCwgdHJ1ZSk7XG4gIH1cbiAgdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgY29uc3QgcGFydGlhbFNpZyA9IChpbnB1dCB8fCB7fSkucGFydGlhbFNpZztcbiAgICBpZiAoIWlucHV0IHx8ICFwYXJ0aWFsU2lnIHx8IHBhcnRpYWxTaWcubGVuZ3RoIDwgMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZScpO1xuICAgIGNvbnN0IG15U2lncyA9IHB1YmtleVxuICAgICAgPyBwYXJ0aWFsU2lnLmZpbHRlcihzaWcgPT4gc2lnLnB1YmtleS5lcXVhbHMocHVia2V5KSlcbiAgICAgIDogcGFydGlhbFNpZztcbiAgICBpZiAobXlTaWdzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgbGV0IGhhc2hDYWNoZTtcbiAgICBsZXQgc2NyaXB0Q2FjaGU7XG4gICAgbGV0IHNpZ2hhc2hDYWNoZTtcbiAgICBmb3IgKGNvbnN0IHBTaWcgb2YgbXlTaWdzKSB7XG4gICAgICBjb25zdCBzaWcgPSBic2NyaXB0LnNpZ25hdHVyZS5kZWNvZGUocFNpZy5zaWduYXR1cmUpO1xuICAgICAgY29uc3QgeyBoYXNoLCBzY3JpcHQgfSA9XG4gICAgICAgIHNpZ2hhc2hDYWNoZSAhPT0gc2lnLmhhc2hUeXBlXG4gICAgICAgICAgPyBnZXRIYXNoRm9yU2lnKFxuICAgICAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBpbnB1dCwgeyBzaWdoYXNoVHlwZTogc2lnLmhhc2hUeXBlIH0pLFxuICAgICAgICAgICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiB7IGhhc2g6IGhhc2hDYWNoZSwgc2NyaXB0OiBzY3JpcHRDYWNoZSB9O1xuICAgICAgc2lnaGFzaENhY2hlID0gc2lnLmhhc2hUeXBlO1xuICAgICAgaGFzaENhY2hlID0gaGFzaDtcbiAgICAgIHNjcmlwdENhY2hlID0gc2NyaXB0O1xuICAgICAgY2hlY2tTY3JpcHRGb3JQdWJrZXkocFNpZy5wdWJrZXksIHNjcmlwdCwgJ3ZlcmlmeScpO1xuICAgICAgY29uc3Qga2V5cGFpciA9IGVjcGFpcl8xLmZyb21QdWJsaWNLZXkocFNpZy5wdWJrZXkpO1xuICAgICAgcmVzdWx0cy5wdXNoKGtleXBhaXIudmVyaWZ5KGhhc2gsIHNpZy5zaWduYXR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuZXZlcnkocmVzID0+IHJlcyA9PT0gdHJ1ZSk7XG4gIH1cbiAgc2lnbkFsbElucHV0c0hEKFxuICAgIGhkS2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBIRFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNpZ25JbnB1dEhEKGksIGhkS2V5UGFpciwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaWduQWxsSW5wdXRzSERBc3luYyhcbiAgICBoZEtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTmVlZCBIRFNpZ25lciB0byBzaWduIGlucHV0JykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICB0aGlzLnNpZ25JbnB1dEhEQXN5bmMoaSwgaGRLZXlQYWlyLCBzaWdoYXNoVHlwZXMpLnRoZW4oXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0cy5ldmVyeSh2ID0+IHYgPT09IGZhbHNlKSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdObyBpbnB1dHMgd2VyZSBzaWduZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc2lnbklucHV0SEQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBoZEtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gZ2V0U2lnbmVyc0Zyb21IRChpbnB1dEluZGV4LCB0aGlzLmRhdGEuaW5wdXRzLCBoZEtleVBhaXIpO1xuICAgIHNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4gdGhpcy5zaWduSW5wdXQoaW5wdXRJbmRleCwgc2lnbmVyLCBzaWdoYXNoVHlwZXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaWduSW5wdXRIREFzeW5jKFxuICAgIGlucHV0SW5kZXgsXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25lcnMgPSBnZXRTaWduZXJzRnJvbUhEKGlucHV0SW5kZXgsIHRoaXMuZGF0YS5pbnB1dHMsIGhkS2V5UGFpcik7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IHNpZ25lcnMubWFwKHNpZ25lciA9PlxuICAgICAgICB0aGlzLnNpZ25JbnB1dEFzeW5jKGlucHV0SW5kZXgsIHNpZ25lciwgc2lnaGFzaFR5cGVzKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHNpZ25BbGxJbnB1dHMoXG4gICAga2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAvLyBUT0RPOiBBZGQgYSBwdWJrZXkvcHVia2V5aGFzaCBjYWNoZSB0byBlYWNoIGlucHV0XG4gICAgLy8gYXMgaW5wdXQgaW5mb3JtYXRpb24gaXMgYWRkZWQsIHRoZW4gZXZlbnR1YWxseVxuICAgIC8vIG9wdGltaXplIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNpZ25JbnB1dChpLCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNBc3luYyhcbiAgICBrZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0JykpO1xuICAgICAgLy8gVE9ETzogQWRkIGEgcHVia2V5L3B1YmtleWhhc2ggY2FjaGUgdG8gZWFjaCBpbnB1dFxuICAgICAgLy8gYXMgaW5wdXQgaW5mb3JtYXRpb24gaXMgYWRkZWQsIHRoZW4gZXZlbnR1YWxseVxuICAgICAgLy8gb3B0aW1pemUgdGhpcyBtZXRob2QuXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbaV0gb2YgdGhpcy5kYXRhLmlucHV0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICB0aGlzLnNpZ25JbnB1dEFzeW5jKGksIGtleVBhaXIsIHNpZ2hhc2hUeXBlcykudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBzaWduSW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBrZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIGNvbnN0IHsgaGFzaCwgc2lnaGFzaFR5cGUgfSA9IGdldEhhc2hBbmRTaWdoYXNoVHlwZShcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAga2V5UGFpci5wdWJsaWNLZXksXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICBzaWdoYXNoVHlwZXMsXG4gICAgKTtcbiAgICBjb25zdCBwYXJ0aWFsU2lnID0gW1xuICAgICAge1xuICAgICAgICBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5LFxuICAgICAgICBzaWduYXR1cmU6IGJzY3JpcHQuc2lnbmF0dXJlLmVuY29kZShrZXlQYWlyLnNpZ24oaGFzaCksIHNpZ2hhc2hUeXBlKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBwYXJ0aWFsU2lnIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25JbnB1dEFzeW5jKFxuICAgIGlucHV0SW5kZXgsXG4gICAga2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpKTtcbiAgICAgIGNvbnN0IHsgaGFzaCwgc2lnaGFzaFR5cGUgfSA9IGdldEhhc2hBbmRTaWdoYXNoVHlwZShcbiAgICAgICAgdGhpcy5kYXRhLmlucHV0cyxcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAga2V5UGFpci5wdWJsaWNLZXksXG4gICAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZShrZXlQYWlyLnNpZ24oaGFzaCkpLnRoZW4oc2lnbmF0dXJlID0+IHtcbiAgICAgICAgY29uc3QgcGFydGlhbFNpZyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBic2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBzaWdoYXNoVHlwZSksXG4gICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgcGFydGlhbFNpZyB9KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdG9CdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50b0J1ZmZlcigpO1xuICB9XG4gIHRvSGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEudG9IZXgoKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRvQmFzZTY0KCk7XG4gIH1cbiAgdXBkYXRlR2xvYmFsKHVwZGF0ZURhdGEpIHtcbiAgICB0aGlzLmRhdGEudXBkYXRlR2xvYmFsKHVwZGF0ZURhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdXBkYXRlRGF0YSk7XG4gICAgaWYgKHVwZGF0ZURhdGEubm9uV2l0bmVzc1V0eG8pIHtcbiAgICAgIGFkZE5vbldpdG5lc3NUeENhY2hlKFxuICAgICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICAgIHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF0sXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGRhdGVPdXRwdXQob3V0cHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICB0aGlzLmRhdGEudXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb0dsb2JhbChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpIHtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZXhwb3J0cy5Qc2J0ID0gUHNidDtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgdG8gcGFzcyB0byB0aGUgYmlwMTc0IGJhc2UgY2xhc3MncyBmcm9tQnVmZmVyLlxuICogSXQgdGFrZXMgdGhlIFwidHJhbnNhY3Rpb24gYnVmZmVyXCIgcG9ydGlvbiBvZiB0aGUgcHNidCBidWZmZXIgYW5kIHJldHVybnMgYVxuICogVHJhbnNhY3Rpb24gKEZyb20gdGhlIGJpcDE3NCBsaWJyYXJ5KSBpbnRlcmZhY2UuXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uRnJvbUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgUHNidFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgVHJhbnNhY3Rpb24gaW50ZXJmYWNlIGZyb20gYmlwMTc0IGxpYnJhcnkuXG4gKiBJdCBjb250YWlucyBhIGJpdGNvaW5qcy1saWIgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICovXG5jbGFzcyBQc2J0VHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihidWZmZXIgPSBCdWZmZXIuZnJvbShbMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pKSB7XG4gICAgdGhpcy50eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgIGNoZWNrVHhFbXB0eSh0aGlzLnR4KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICBnZXRJbnB1dE91dHB1dENvdW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRDb3VudDogdGhpcy50eC5pbnMubGVuZ3RoLFxuICAgICAgb3V0cHV0Q291bnQ6IHRoaXMudHgub3V0cy5sZW5ndGgsXG4gICAgfTtcbiAgfVxuICBhZGRJbnB1dChpbnB1dCkge1xuICAgIGlmIChcbiAgICAgIGlucHV0Lmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXQuaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQuaGFzaCkgJiYgdHlwZW9mIGlucHV0Lmhhc2ggIT09ICdzdHJpbmcnKSB8fFxuICAgICAgdHlwZW9mIGlucHV0LmluZGV4ICE9PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgaW5wdXQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPVxuICAgICAgdHlwZW9mIGlucHV0Lmhhc2ggPT09ICdzdHJpbmcnXG4gICAgICAgID8gYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKGlucHV0Lmhhc2gsICdoZXgnKSlcbiAgICAgICAgOiBpbnB1dC5oYXNoO1xuICAgIHRoaXMudHguYWRkSW5wdXQoaGFzaCwgaW5wdXQuaW5kZXgsIGlucHV0LnNlcXVlbmNlKTtcbiAgfVxuICBhZGRPdXRwdXQob3V0cHV0KSB7XG4gICAgaWYgKFxuICAgICAgb3V0cHV0LnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBvdXRwdXQudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihvdXRwdXQuc2NyaXB0KSB8fFxuICAgICAgdHlwZW9mIG91dHB1dC52YWx1ZSAhPT0gJ251bWJlcidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG91dHB1dC4nKTtcbiAgICB9XG4gICAgdGhpcy50eC5hZGRPdXRwdXQob3V0cHV0LnNjcmlwdCwgb3V0cHV0LnZhbHVlKTtcbiAgfVxuICB0b0J1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy50eC50b0J1ZmZlcigpO1xuICB9XG59XG5mdW5jdGlvbiBjYW5GaW5hbGl6ZShpbnB1dCwgc2NyaXB0LCBzY3JpcHRUeXBlKSB7XG4gIHN3aXRjaCAoc2NyaXB0VHlwZSkge1xuICAgIGNhc2UgJ3B1YmtleSc6XG4gICAgY2FzZSAncHVia2V5aGFzaCc6XG4gICAgY2FzZSAnd2l0bmVzc3B1YmtleWhhc2gnOlxuICAgICAgcmV0dXJuIGhhc1NpZ3MoMSwgaW5wdXQucGFydGlhbFNpZyk7XG4gICAgY2FzZSAnbXVsdGlzaWcnOlxuICAgICAgY29uc3QgcDJtcyA9IHBheW1lbnRzLnAybXMoeyBvdXRwdXQ6IHNjcmlwdCB9KTtcbiAgICAgIHJldHVybiBoYXNTaWdzKHAybXMubSwgaW5wdXQucGFydGlhbFNpZywgcDJtcy5wdWJrZXlzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBoYXNTaWdzKG5lZWRlZFNpZ3MsIHBhcnRpYWxTaWcsIHB1YmtleXMpIHtcbiAgaWYgKCFwYXJ0aWFsU2lnKSByZXR1cm4gZmFsc2U7XG4gIGxldCBzaWdzO1xuICBpZiAocHVia2V5cykge1xuICAgIHNpZ3MgPSBwdWJrZXlzXG4gICAgICAubWFwKHBrZXkgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBlY3BhaXJfMS5mcm9tUHVibGljS2V5KHBrZXksIHsgY29tcHJlc3NlZDogdHJ1ZSB9KVxuICAgICAgICAgIC5wdWJsaWNLZXk7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsU2lnLmZpbmQocFNpZyA9PiBwU2lnLnB1YmtleS5lcXVhbHMocHVia2V5KSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcih2ID0+ICEhdik7XG4gIH0gZWxzZSB7XG4gICAgc2lncyA9IHBhcnRpYWxTaWc7XG4gIH1cbiAgaWYgKHNpZ3MubGVuZ3RoID4gbmVlZGVkU2lncykgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSBzaWduYXR1cmVzJyk7XG4gIHJldHVybiBzaWdzLmxlbmd0aCA9PT0gbmVlZGVkU2lncztcbn1cbmZ1bmN0aW9uIGlzRmluYWxpemVkKGlucHV0KSB7XG4gIHJldHVybiAhIWlucHV0LmZpbmFsU2NyaXB0U2lnIHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xufVxuZnVuY3Rpb24gaXNQYXltZW50RmFjdG9yeShwYXltZW50KSB7XG4gIHJldHVybiBzY3JpcHQgPT4ge1xuICAgIHRyeSB7XG4gICAgICBwYXltZW50KHsgb3V0cHV0OiBzY3JpcHQgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1AyTVMgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAybXMpO1xuY29uc3QgaXNQMlBLID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMnBrKTtcbmNvbnN0IGlzUDJQS0ggPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAycGtoKTtcbmNvbnN0IGlzUDJXUEtIID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMndwa2gpO1xuY29uc3QgaXNQMldTSFNjcmlwdCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ3c2gpO1xuZnVuY3Rpb24gY2hlY2szMkJpdChudW0pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8XG4gICAgbnVtICE9PSBNYXRoLmZsb29yKG51bSkgfHxcbiAgICBudW0gPiAweGZmZmZmZmZmIHx8XG4gICAgbnVtIDwgMFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgMzIgYml0IGludGVnZXInKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tGZWVzKHBzYnQsIGNhY2hlLCBvcHRzKSB7XG4gIGNvbnN0IGZlZVJhdGUgPSBjYWNoZS5fX0ZFRV9SQVRFIHx8IHBzYnQuZ2V0RmVlUmF0ZSgpO1xuICBjb25zdCB2c2l6ZSA9IGNhY2hlLl9fRVhUUkFDVEVEX1RYLnZpcnR1YWxTaXplKCk7XG4gIGNvbnN0IHNhdG9zaGlzID0gZmVlUmF0ZSAqIHZzaXplO1xuICBpZiAoZmVlUmF0ZSA+PSBvcHRzLm1heGltdW1GZWVSYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFdhcm5pbmc6IFlvdSBhcmUgcGF5aW5nIGFyb3VuZCAkeyhzYXRvc2hpcyAvIDFlOCkudG9GaXhlZCg4KX0gaW4gYCArXG4gICAgICAgIGBmZWVzLCB3aGljaCBpcyAke2ZlZVJhdGV9IHNhdG9zaGkgcGVyIGJ5dGUgZm9yIGEgdHJhbnNhY3Rpb24gYCArXG4gICAgICAgIGB3aXRoIGEgVlNpemUgb2YgJHt2c2l6ZX0gYnl0ZXMgKHNlZ3dpdCBjb3VudGVkIGFzIDAuMjUgYnl0ZSBwZXIgYCArXG4gICAgICAgIGBieXRlKS4gVXNlIHNldE1heGltdW1GZWVSYXRlIG1ldGhvZCB0byByYWlzZSB5b3VyIHRocmVzaG9sZCwgb3IgYCArXG4gICAgICAgIGBwYXNzIHRydWUgdG8gdGhlIGZpcnN0IGFyZyBvZiBleHRyYWN0VHJhbnNhY3Rpb24uYCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcoaW5wdXRzLCBhY3Rpb24pIHtcbiAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgIGxldCB0aHJvd3MgPSBmYWxzZTtcbiAgICBsZXQgcFNpZ3MgPSBbXTtcbiAgICBpZiAoKGlucHV0LnBhcnRpYWxTaWcgfHwgW10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCFpbnB1dC5maW5hbFNjcmlwdFNpZyAmJiAhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSByZXR1cm47XG4gICAgICBwU2lncyA9IGdldFBzaWdzRnJvbUlucHV0RmluYWxTY3JpcHRzKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcFNpZ3MgPSBpbnB1dC5wYXJ0aWFsU2lnO1xuICAgIH1cbiAgICBwU2lncy5mb3JFYWNoKHBTaWcgPT4ge1xuICAgICAgY29uc3QgeyBoYXNoVHlwZSB9ID0gYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlKHBTaWcuc2lnbmF0dXJlKTtcbiAgICAgIGNvbnN0IHdoaXRlbGlzdCA9IFtdO1xuICAgICAgY29uc3QgaXNBbnlvbmVDYW5QYXkgPVxuICAgICAgICBoYXNoVHlwZSAmIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVk7XG4gICAgICBpZiAoaXNBbnlvbmVDYW5QYXkpIHdoaXRlbGlzdC5wdXNoKCdhZGRJbnB1dCcpO1xuICAgICAgY29uc3QgaGFzaE1vZCA9IGhhc2hUeXBlICYgMHgxZjtcbiAgICAgIHN3aXRjaCAoaGFzaE1vZCkge1xuICAgICAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRTpcbiAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORTpcbiAgICAgICAgICB3aGl0ZWxpc3QucHVzaCgnYWRkT3V0cHV0Jyk7XG4gICAgICAgICAgd2hpdGVsaXN0LnB1c2goJ3NldElucHV0U2VxdWVuY2UnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh3aGl0ZWxpc3QuaW5kZXhPZihhY3Rpb24pID09PSAtMSkge1xuICAgICAgICB0aHJvd3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aHJvd3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBtb2RpZnkgdHJhbnNhY3Rpb24sIHNpZ25hdHVyZXMgZXhpc3QuJyk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyhpbnB1dCkge1xuICBpZiAoIWlucHV0LnNpZ2hhc2hUeXBlIHx8ICFpbnB1dC5wYXJ0aWFsU2lnKSByZXR1cm47XG4gIGNvbnN0IHsgcGFydGlhbFNpZywgc2lnaGFzaFR5cGUgfSA9IGlucHV0O1xuICBwYXJ0aWFsU2lnLmZvckVhY2gocFNpZyA9PiB7XG4gICAgY29uc3QgeyBoYXNoVHlwZSB9ID0gYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlKHBTaWcuc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnaGFzaFR5cGUgIT09IGhhc2hUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBzaWdoYXNoIGRvZXMgbm90IG1hdGNoIGlucHV0IHNpZ2hhc2ggdHlwZScpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1NjcmlwdEZvclB1YmtleShwdWJrZXksIHNjcmlwdCwgYWN0aW9uKSB7XG4gIGNvbnN0IHB1YmtleUhhc2ggPSBjcnlwdG9fMS5oYXNoMTYwKHB1YmtleSk7XG4gIGNvbnN0IGRlY29tcGlsZWQgPSBic2NyaXB0LmRlY29tcGlsZShzY3JpcHQpO1xuICBpZiAoZGVjb21waWxlZCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHNjcmlwdCBlcnJvcicpO1xuICBjb25zdCBoYXNLZXkgPSBkZWNvbXBpbGVkLnNvbWUoZWxlbWVudCA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBlbGVtZW50LmVxdWFscyhwdWJrZXkpIHx8IGVsZW1lbnQuZXF1YWxzKHB1YmtleUhhc2gpO1xuICB9KTtcbiAgaWYgKCFoYXNLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2FuIG5vdCAke2FjdGlvbn0gZm9yIHRoaXMgaW5wdXQgd2l0aCB0aGUga2V5ICR7cHVia2V5LnRvU3RyaW5nKCdoZXgnKX1gLFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVHhFbXB0eSh0eCkge1xuICBjb25zdCBpc0VtcHR5ID0gdHguaW5zLmV2ZXJ5KFxuICAgIGlucHV0ID0+XG4gICAgICBpbnB1dC5zY3JpcHQgJiZcbiAgICAgIGlucHV0LnNjcmlwdC5sZW5ndGggPT09IDAgJiZcbiAgICAgIGlucHV0LndpdG5lc3MgJiZcbiAgICAgIGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAwLFxuICApO1xuICBpZiAoIWlzRW1wdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogVHJhbnNhY3Rpb24gU2NyaXB0U2lncyBhcmUgbm90IGVtcHR5Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVHhGb3JEdXBlSW5zKHR4LCBjYWNoZSkge1xuICB0eC5pbnMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgY2hlY2tUeElucHV0Q2FjaGUoY2FjaGUsIGlucHV0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1R4SW5wdXRDYWNoZShjYWNoZSwgaW5wdXQpIHtcbiAgY29uc3Qga2V5ID1cbiAgICBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCkpLnRvU3RyaW5nKCdoZXgnKSArXG4gICAgJzonICtcbiAgICBpbnB1dC5pbmRleDtcbiAgaWYgKGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSkgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgaW5wdXQgZGV0ZWN0ZWQuJyk7XG4gIGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSA9IDE7XG59XG5mdW5jdGlvbiBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50LCBwYXltZW50U2NyaXB0TmFtZSkge1xuICByZXR1cm4gKGlucHV0SW5kZXgsIHNjcmlwdFB1YktleSwgcmVkZWVtU2NyaXB0KSA9PiB7XG4gICAgY29uc3QgcmVkZWVtU2NyaXB0T3V0cHV0ID0gcGF5bWVudCh7XG4gICAgICByZWRlZW06IHsgb3V0cHV0OiByZWRlZW1TY3JpcHQgfSxcbiAgICB9KS5vdXRwdXQ7XG4gICAgaWYgKCFzY3JpcHRQdWJLZXkuZXF1YWxzKHJlZGVlbVNjcmlwdE91dHB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7cGF5bWVudFNjcmlwdE5hbWV9IGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fSBkb2Vzbid0IG1hdGNoIHRoZSBzY3JpcHRQdWJLZXkgaW4gdGhlIHByZXZvdXRgLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjaGVja1JlZGVlbVNjcmlwdCA9IHNjcmlwdENoZWNrZXJGYWN0b3J5KHBheW1lbnRzLnAyc2gsICdSZWRlZW0gc2NyaXB0Jyk7XG5jb25zdCBjaGVja1dpdG5lc3NTY3JpcHQgPSBzY3JpcHRDaGVja2VyRmFjdG9yeShcbiAgcGF5bWVudHMucDJ3c2gsXG4gICdXaXRuZXNzIHNjcmlwdCcsXG4pO1xuZnVuY3Rpb24gZ2V0VHhDYWNoZVZhbHVlKGtleSwgbmFtZSwgaW5wdXRzLCBjKSB7XG4gIGlmICghaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBTQlQgbXVzdCBiZSBmaW5hbGl6ZWQgdG8gY2FsY3VsYXRlICR7bmFtZX1gKTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFX1JBVEUnICYmIGMuX19GRUVfUkFURSkgcmV0dXJuIGMuX19GRUVfUkFURTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFJyAmJiBjLl9fRkVFKSByZXR1cm4gYy5fX0ZFRTtcbiAgbGV0IHR4O1xuICBsZXQgbXVzdEZpbmFsaXplID0gdHJ1ZTtcbiAgaWYgKGMuX19FWFRSQUNURURfVFgpIHtcbiAgICB0eCA9IGMuX19FWFRSQUNURURfVFg7XG4gICAgbXVzdEZpbmFsaXplID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdHggPSBjLl9fVFguY2xvbmUoKTtcbiAgfVxuICBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjLCBtdXN0RmluYWxpemUpO1xuICBpZiAoa2V5ID09PSAnX19GRUVfUkFURScpIHJldHVybiBjLl9fRkVFX1JBVEU7XG4gIGVsc2UgaWYgKGtleSA9PT0gJ19fRkVFJykgcmV0dXJuIGMuX19GRUU7XG59XG5mdW5jdGlvbiBnZXRGaW5hbFNjcmlwdHMoaW5wdXRJbmRleCwgaW5wdXQsIHNjcmlwdCwgaXNTZWd3aXQsIGlzUDJTSCwgaXNQMldTSCkge1xuICBjb25zdCBzY3JpcHRUeXBlID0gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KTtcbiAgaWYgKCFjYW5GaW5hbGl6ZShpbnB1dCwgc2NyaXB0LCBzY3JpcHRUeXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZmluYWxpemUgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgcmV0dXJuIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gICAgc2NyaXB0LFxuICAgIHNjcmlwdFR5cGUsXG4gICAgaW5wdXQucGFydGlhbFNpZyxcbiAgICBpc1NlZ3dpdCxcbiAgICBpc1AyU0gsXG4gICAgaXNQMldTSCxcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gIHNjcmlwdCxcbiAgc2NyaXB0VHlwZSxcbiAgcGFydGlhbFNpZyxcbiAgaXNTZWd3aXQsXG4gIGlzUDJTSCxcbiAgaXNQMldTSCxcbikge1xuICBsZXQgZmluYWxTY3JpcHRTaWc7XG4gIGxldCBmaW5hbFNjcmlwdFdpdG5lc3M7XG4gIC8vIFdvdywgdGhlIHBheW1lbnRzIEFQSSBpcyB2ZXJ5IGhhbmR5XG4gIGNvbnN0IHBheW1lbnQgPSBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZyk7XG4gIGNvbnN0IHAyd3NoID0gIWlzUDJXU0ggPyBudWxsIDogcGF5bWVudHMucDJ3c2goeyByZWRlZW06IHBheW1lbnQgfSk7XG4gIGNvbnN0IHAyc2ggPSAhaXNQMlNIID8gbnVsbCA6IHBheW1lbnRzLnAyc2goeyByZWRlZW06IHAyd3NoIHx8IHBheW1lbnQgfSk7XG4gIGlmIChpc1NlZ3dpdCkge1xuICAgIGlmIChwMndzaCkge1xuICAgICAgZmluYWxTY3JpcHRXaXRuZXNzID0gd2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKHAyd3NoLndpdG5lc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbFNjcmlwdFdpdG5lc3MgPSB3aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MocGF5bWVudC53aXRuZXNzKTtcbiAgICB9XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxTY3JpcHRTaWcgPSBwYXltZW50LmlucHV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsU2NyaXB0U2lnLFxuICAgIGZpbmFsU2NyaXB0V2l0bmVzcyxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhc2hBbmRTaWdoYXNoVHlwZShcbiAgaW5wdXRzLFxuICBpbnB1dEluZGV4LFxuICBwdWJrZXksXG4gIGNhY2hlLFxuICBzaWdoYXNoVHlwZXMsXG4pIHtcbiAgY29uc3QgaW5wdXQgPSB1dGlsc18xLmNoZWNrRm9ySW5wdXQoaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSwgc2NyaXB0IH0gPSBnZXRIYXNoRm9yU2lnKFxuICAgIGlucHV0SW5kZXgsXG4gICAgaW5wdXQsXG4gICAgY2FjaGUsXG4gICAgc2lnaGFzaFR5cGVzLFxuICApO1xuICBjaGVja1NjcmlwdEZvclB1YmtleShwdWJrZXksIHNjcmlwdCwgJ3NpZ24nKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNoLFxuICAgIHNpZ2hhc2hUeXBlLFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFzaEZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUsIHNpZ2hhc2hUeXBlcykge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3Qgc2lnaGFzaFR5cGUgPVxuICAgIGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gIGlmIChzaWdoYXNoVHlwZXMgJiYgc2lnaGFzaFR5cGVzLmluZGV4T2Yoc2lnaGFzaFR5cGUpIDwgMCkge1xuICAgIGNvbnN0IHN0ciA9IHNpZ2hhc2hUeXBlVG9TdHJpbmcoc2lnaGFzaFR5cGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTaWdoYXNoIHR5cGUgaXMgbm90IGFsbG93ZWQuIFJldHJ5IHRoZSBzaWduIG1ldGhvZCBwYXNzaW5nIHRoZSBgICtcbiAgICAgICAgYHNpZ2hhc2hUeXBlcyBhcnJheSBvZiB3aGl0ZWxpc3RlZCB0eXBlcy4gU2lnaGFzaCB0eXBlOiAke3N0cn1gLFxuICAgICk7XG4gIH1cbiAgbGV0IGhhc2g7XG4gIGxldCBzY3JpcHQ7XG4gIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKFxuICAgICAgY2FjaGUsXG4gICAgICBpbnB1dCxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgKTtcbiAgICBjb25zdCBwcmV2b3V0SGFzaCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmhhc2g7XG4gICAgY29uc3QgdXR4b0hhc2ggPSBub25XaXRuZXNzVXR4b1R4LmdldEhhc2goKTtcbiAgICAvLyBJZiBhIG5vbi13aXRuZXNzIFVUWE8gaXMgcHJvdmlkZWQsIGl0cyBoYXNoIG11c3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0XG4gICAgaWYgKCFwcmV2b3V0SGFzaC5lcXVhbHModXR4b0hhc2gpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24td2l0bmVzcyBVVFhPIGhhc2ggZm9yIGlucHV0ICMke2lucHV0SW5kZXh9IGRvZXNuJ3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZvdXRJbmRleCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmluZGV4O1xuICAgIGNvbnN0IHByZXZvdXQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XTtcbiAgICBpZiAoaW5wdXQucmVkZWVtU2NyaXB0KSB7XG4gICAgICAvLyBJZiBhIHJlZGVlbVNjcmlwdCBpcyBwcm92aWRlZCwgdGhlIHNjcmlwdFB1YktleSBtdXN0IGJlIGZvciB0aGF0IHJlZGVlbVNjcmlwdFxuICAgICAgY2hlY2tSZWRlZW1TY3JpcHQoaW5wdXRJbmRleCwgcHJldm91dC5zY3JpcHQsIGlucHV0LnJlZGVlbVNjcmlwdCk7XG4gICAgICBzY3JpcHQgPSBpbnB1dC5yZWRlZW1TY3JpcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdCA9IHByZXZvdXQuc2NyaXB0O1xuICAgIH1cbiAgICBpZiAoaXNQMldTSFNjcmlwdChzY3JpcHQpKSB7XG4gICAgICBpZiAoIWlucHV0LndpdG5lc3NTY3JpcHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vnd2l0IGlucHV0IG5lZWRzIHdpdG5lc3NTY3JpcHQgaWYgbm90IFAyV1BLSCcpO1xuICAgICAgY2hlY2tXaXRuZXNzU2NyaXB0KGlucHV0SW5kZXgsIHNjcmlwdCwgaW5wdXQud2l0bmVzc1NjcmlwdCk7XG4gICAgICBoYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YwKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dC53aXRuZXNzU2NyaXB0LFxuICAgICAgICBwcmV2b3V0LnZhbHVlLFxuICAgICAgICBzaWdoYXNoVHlwZSxcbiAgICAgICk7XG4gICAgICBzY3JpcHQgPSBpbnB1dC53aXRuZXNzU2NyaXB0O1xuICAgIH0gZWxzZSBpZiAoaXNQMldQS0goc2NyaXB0KSkge1xuICAgICAgLy8gUDJXUEtIIHVzZXMgdGhlIFAyUEtIIHRlbXBsYXRlIGZvciBwcmV2b3V0U2NyaXB0IHdoZW4gc2lnbmluZ1xuICAgICAgY29uc3Qgc2lnbmluZ1NjcmlwdCA9IHBheW1lbnRzLnAycGtoKHsgaGFzaDogc2NyaXB0LnNsaWNlKDIpIH0pLm91dHB1dDtcbiAgICAgIGhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JXaXRuZXNzVjAoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHNpZ25pbmdTY3JpcHQsXG4gICAgICAgIHByZXZvdXQudmFsdWUsXG4gICAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvclNpZ25hdHVyZShpbnB1dEluZGV4LCBzY3JpcHQsIHNpZ2hhc2hUeXBlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQud2l0bmVzc1V0eG8pIHtcbiAgICBsZXQgX3NjcmlwdDsgLy8gc28gd2UgZG9uJ3Qgc2hhZG93IHRoZSBgbGV0IHNjcmlwdGAgYWJvdmVcbiAgICBpZiAoaW5wdXQucmVkZWVtU2NyaXB0KSB7XG4gICAgICAvLyBJZiBhIHJlZGVlbVNjcmlwdCBpcyBwcm92aWRlZCwgdGhlIHNjcmlwdFB1YktleSBtdXN0IGJlIGZvciB0aGF0IHJlZGVlbVNjcmlwdFxuICAgICAgY2hlY2tSZWRlZW1TY3JpcHQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgICAgaW5wdXQucmVkZWVtU2NyaXB0LFxuICAgICAgKTtcbiAgICAgIF9zY3JpcHQgPSBpbnB1dC5yZWRlZW1TY3JpcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JpcHQgPSBpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQ7XG4gICAgfVxuICAgIGlmIChpc1AyV1BLSChfc2NyaXB0KSkge1xuICAgICAgLy8gUDJXUEtIIHVzZXMgdGhlIFAyUEtIIHRlbXBsYXRlIGZvciBwcmV2b3V0U2NyaXB0IHdoZW4gc2lnbmluZ1xuICAgICAgY29uc3Qgc2lnbmluZ1NjcmlwdCA9IHBheW1lbnRzLnAycGtoKHsgaGFzaDogX3NjcmlwdC5zbGljZSgyKSB9KS5vdXRwdXQ7XG4gICAgICBoYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YwKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBzaWduaW5nU2NyaXB0LFxuICAgICAgICBpbnB1dC53aXRuZXNzVXR4by52YWx1ZSxcbiAgICAgICAgc2lnaGFzaFR5cGUsXG4gICAgICApO1xuICAgICAgc2NyaXB0ID0gX3NjcmlwdDtcbiAgICB9IGVsc2UgaWYgKGlzUDJXU0hTY3JpcHQoX3NjcmlwdCkpIHtcbiAgICAgIGlmICghaW5wdXQud2l0bmVzc1NjcmlwdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWd3aXQgaW5wdXQgbmVlZHMgd2l0bmVzc1NjcmlwdCBpZiBub3QgUDJXUEtIJyk7XG4gICAgICBjaGVja1dpdG5lc3NTY3JpcHQoaW5wdXRJbmRleCwgX3NjcmlwdCwgaW5wdXQud2l0bmVzc1NjcmlwdCk7XG4gICAgICBoYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YwKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dC53aXRuZXNzU2NyaXB0LFxuICAgICAgICBpbnB1dC53aXRuZXNzVXR4by52YWx1ZSxcbiAgICAgICAgc2lnaGFzaFR5cGUsXG4gICAgICApO1xuICAgICAgLy8gd2FudCB0byBtYWtlIHN1cmUgdGhlIHNjcmlwdCB3ZSByZXR1cm4gaXMgdGhlIGFjdHVhbCBtZWFuaW5nZnVsIHNjcmlwdFxuICAgICAgc2NyaXB0ID0gaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW5wdXQgIyR7aW5wdXRJbmRleH0gaGFzIHdpdG5lc3NVdHhvIGJ1dCBub24tc2Vnd2l0IHNjcmlwdDogYCArXG4gICAgICAgICAgYCR7X3NjcmlwdC50b1N0cmluZygnaGV4Jyl9YCxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBhIFV0eG8gaW5wdXQgaXRlbSBmb3Igc2lnbmluZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NyaXB0LFxuICAgIHNpZ2hhc2hUeXBlLFxuICAgIGhhc2gsXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZykge1xuICBsZXQgcGF5bWVudDtcbiAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgY2FzZSAnbXVsdGlzaWcnOlxuICAgICAgY29uc3Qgc2lncyA9IGdldFNvcnRlZFNpZ3Moc2NyaXB0LCBwYXJ0aWFsU2lnKTtcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMm1zKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHNpZ25hdHVyZXM6IHNpZ3MsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3B1YmtleSc6XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJwayh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMnBraCh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBwdWJrZXk6IHBhcnRpYWxTaWdbMF0ucHVia2V5LFxuICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3aXRuZXNzcHVia2V5aGFzaCc6XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJ3cGtoKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHB1YmtleTogcGFydGlhbFNpZ1swXS5wdWJrZXksXG4gICAgICAgIHNpZ25hdHVyZTogcGFydGlhbFNpZ1swXS5zaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBwYXltZW50O1xufVxuZnVuY3Rpb24gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpIHtcbiAgY29uc3Qgc2NyaXB0SXRlbXMgPSAhaW5wdXQuZmluYWxTY3JpcHRTaWdcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFNpZykgfHwgW107XG4gIGNvbnN0IHdpdG5lc3NJdGVtcyA9ICFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3NcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpIHx8IFtdO1xuICByZXR1cm4gc2NyaXB0SXRlbXNcbiAgICAuY29uY2F0KHdpdG5lc3NJdGVtcylcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSAmJiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGl0ZW0pO1xuICAgIH0pXG4gICAgLm1hcChzaWcgPT4gKHsgc2lnbmF0dXJlOiBzaWcgfSkpO1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0RnJvbUlucHV0KGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3QgcmVzID0ge1xuICAgIHNjcmlwdDogbnVsbCxcbiAgICBpc1NlZ3dpdDogZmFsc2UsXG4gICAgaXNQMlNIOiBmYWxzZSxcbiAgICBpc1AyV1NIOiBmYWxzZSxcbiAgfTtcbiAgcmVzLmlzUDJTSCA9ICEhaW5wdXQucmVkZWVtU2NyaXB0O1xuICByZXMuaXNQMldTSCA9ICEhaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQpIHtcbiAgICByZXMuc2NyaXB0ID0gaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgfSBlbHNlIGlmIChpbnB1dC5yZWRlZW1TY3JpcHQpIHtcbiAgICByZXMuc2NyaXB0ID0gaW5wdXQucmVkZWVtU2NyaXB0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgY29uc3Qgbm9uV2l0bmVzc1V0eG9UeCA9IG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2b3V0SW5kZXggPSB1bnNpZ25lZFR4Lmluc1tpbnB1dEluZGV4XS5pbmRleDtcbiAgICAgIHJlcy5zY3JpcHQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XS5zY3JpcHQ7XG4gICAgfSBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgcmVzLnNjcmlwdCA9IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQgfHwgaXNQMldQS0gocmVzLnNjcmlwdCkpIHtcbiAgICByZXMuaXNTZWd3aXQgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRTaWduZXJzRnJvbUhEKGlucHV0SW5kZXgsIGlucHV0cywgaGRLZXlQYWlyKSB7XG4gIGNvbnN0IGlucHV0ID0gdXRpbHNfMS5jaGVja0ZvcklucHV0KGlucHV0cywgaW5wdXRJbmRleCk7XG4gIGlmICghaW5wdXQuYmlwMzJEZXJpdmF0aW9uIHx8IGlucHV0LmJpcDMyRGVyaXZhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYmlwMzJEZXJpdmF0aW9uIHRvIHNpZ24gd2l0aCBIRCcpO1xuICB9XG4gIGNvbnN0IG15RGVyaXZhdGlvbnMgPSBpbnB1dC5iaXAzMkRlcml2YXRpb25cbiAgICAubWFwKGJpcER2ID0+IHtcbiAgICAgIGlmIChiaXBEdi5tYXN0ZXJGaW5nZXJwcmludC5lcXVhbHMoaGRLZXlQYWlyLmZpbmdlcnByaW50KSkge1xuICAgICAgICByZXR1cm4gYmlwRHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKHYgPT4gISF2KTtcbiAgaWYgKG15RGVyaXZhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ05lZWQgb25lIGJpcDMyRGVyaXZhdGlvbiBtYXN0ZXJGaW5nZXJwcmludCB0byBtYXRjaCB0aGUgSERTaWduZXIgZmluZ2VycHJpbnQnLFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2lnbmVycyA9IG15RGVyaXZhdGlvbnMubWFwKGJpcER2ID0+IHtcbiAgICBjb25zdCBub2RlID0gaGRLZXlQYWlyLmRlcml2ZVBhdGgoYmlwRHYucGF0aCk7XG4gICAgaWYgKCFiaXBEdi5wdWJrZXkuZXF1YWxzKG5vZGUucHVibGljS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJrZXkgZGlkIG5vdCBtYXRjaCBiaXAzMkRlcml2YXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xuICByZXR1cm4gc2lnbmVycztcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZFNpZ3Moc2NyaXB0LCBwYXJ0aWFsU2lnKSB7XG4gIGNvbnN0IHAybXMgPSBwYXltZW50cy5wMm1zKHsgb3V0cHV0OiBzY3JpcHQgfSk7XG4gIC8vIGZvciBlYWNoIHB1YmtleSBpbiBvcmRlciBvZiBwMm1zIHNjcmlwdFxuICByZXR1cm4gcDJtcy5wdWJrZXlzXG4gICAgLm1hcChwayA9PiB7XG4gICAgICAvLyBmaWx0ZXIgcGFydGlhbFNpZyBhcnJheSBieSBwdWJrZXkgYmVpbmcgZXF1YWxcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhcnRpYWxTaWcuZmlsdGVyKHBzID0+IHtcbiAgICAgICAgICByZXR1cm4gcHMucHVia2V5LmVxdWFscyhwayk7XG4gICAgICAgIH0pWzBdIHx8IHt9XG4gICAgICApLnNpZ25hdHVyZTtcbiAgICAgIC8vIEFueSBwdWJrZXkgd2l0aG91dCBhIG1hdGNoIHdpbGwgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgLy8gdGhpcyBsYXN0IGZpbHRlciByZW1vdmVzIGFsbCB0aGUgdW5kZWZpbmVkIGl0ZW1zIGluIHRoZSBhcnJheS5cbiAgICB9KVxuICAgIC5maWx0ZXIodiA9PiAhIXYpO1xufVxuZnVuY3Rpb24gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKGJ1ZmZlcikge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZnVuY3Rpb24gcmVhZFNsaWNlKG4pIHtcbiAgICBvZmZzZXQgKz0gbjtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKG9mZnNldCAtIG4sIG9mZnNldCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFZhckludCgpIHtcbiAgICBjb25zdCB2aSA9IHZhcnVpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdmFydWludC5kZWNvZGUuYnl0ZXM7XG4gICAgcmV0dXJuIHZpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRWYXJTbGljZSgpIHtcbiAgICByZXR1cm4gcmVhZFNsaWNlKHJlYWRWYXJJbnQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFZlY3RvcigpIHtcbiAgICBjb25zdCBjb3VudCA9IHJlYWRWYXJJbnQoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHZlY3Rvci5wdXNoKHJlYWRWYXJTbGljZSgpKTtcbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG4gIHJldHVybiByZWFkVmVjdG9yKCk7XG59XG5mdW5jdGlvbiBzaWdoYXNoVHlwZVRvU3RyaW5nKHNpZ2hhc2hUeXBlKSB7XG4gIGxldCB0ZXh0ID1cbiAgICBzaWdoYXNoVHlwZSAmIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVlcbiAgICAgID8gJ1NJR0hBU0hfQU5ZT05FQ0FOUEFZIHwgJ1xuICAgICAgOiAnJztcbiAgY29uc3Qgc2lnTW9kID0gc2lnaGFzaFR5cGUgJiAweDFmO1xuICBzd2l0Y2ggKHNpZ01vZCkge1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDpcbiAgICAgIHRleHQgKz0gJ1NJR0hBU0hfQUxMJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRTpcbiAgICAgIHRleHQgKz0gJ1NJR0hBU0hfU0lOR0xFJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU6XG4gICAgICB0ZXh0ICs9ICdTSUdIQVNIX05PTkUnO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiB3aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3Mod2l0bmVzcykge1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICBmdW5jdGlvbiB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShzbGljZSldKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhckludChpKSB7XG4gICAgY29uc3QgY3VycmVudExlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgdmFyaW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChpKTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIEJ1ZmZlci5hbGxvY1Vuc2FmZSh2YXJpbnRMZW4pXSk7XG4gICAgdmFydWludC5lbmNvZGUoaSwgYnVmZmVyLCBjdXJyZW50TGVuKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgd3JpdGVWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICB3cml0ZVNsaWNlKHNsaWNlKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZlY3Rvcih2ZWN0b3IpIHtcbiAgICB3cml0ZVZhckludCh2ZWN0b3IubGVuZ3RoKTtcbiAgICB2ZWN0b3IuZm9yRWFjaCh3cml0ZVZhclNsaWNlKTtcbiAgfVxuICB3cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGFkZE5vbldpdG5lc3NUeENhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCkge1xuICBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW2lucHV0SW5kZXhdID0gaW5wdXQubm9uV2l0bmVzc1V0eG87XG4gIGNvbnN0IHR4ID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tQnVmZmVyKGlucHV0Lm5vbldpdG5lc3NVdHhvKTtcbiAgY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFW2lucHV0SW5kZXhdID0gdHg7XG4gIGNvbnN0IHNlbGYgPSBjYWNoZTtcbiAgY29uc3Qgc2VsZkluZGV4ID0gaW5wdXRJbmRleDtcbiAgZGVsZXRlIGlucHV0Lm5vbldpdG5lc3NVdHhvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdub25XaXRuZXNzVXR4bycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdO1xuICAgICAgY29uc3QgdHhDYWNoZSA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFW3NlbGZJbmRleF07XG4gICAgICBpZiAoYnVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZiA9IHR4Q2FjaGUudG9CdWZmZXIoKTtcbiAgICAgICAgc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW3NlbGZJbmRleF0gPSBuZXdCdWY7XG4gICAgICAgIHJldHVybiBuZXdCdWY7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQoZGF0YSkge1xuICAgICAgc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW3NlbGZJbmRleF0gPSBkYXRhO1xuICAgIH0sXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5wdXRGaW5hbGl6ZUdldEFtdHMoaW5wdXRzLCB0eCwgY2FjaGUsIG11c3RGaW5hbGl6ZSkge1xuICBsZXQgaW5wdXRBbW91bnQgPSAwO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgIGlmIChtdXN0RmluYWxpemUgJiYgaW5wdXQuZmluYWxTY3JpcHRTaWcpXG4gICAgICB0eC5pbnNbaWR4XS5zY3JpcHQgPSBpbnB1dC5maW5hbFNjcmlwdFNpZztcbiAgICBpZiAobXVzdEZpbmFsaXplICYmIGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcykge1xuICAgICAgdHguaW5zW2lkeF0ud2l0bmVzcyA9IHNjcmlwdFdpdG5lc3NUb1dpdG5lc3NTdGFjayhcbiAgICAgICAgaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICBpbnB1dEFtb3VudCArPSBpbnB1dC53aXRuZXNzVXR4by52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBjb25zdCBud1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShjYWNoZSwgaW5wdXQsIGlkeCk7XG4gICAgICBjb25zdCB2b3V0ID0gdHguaW5zW2lkeF0uaW5kZXg7XG4gICAgICBjb25zdCBvdXQgPSBud1R4Lm91dHNbdm91dF07XG4gICAgICBpbnB1dEFtb3VudCArPSBvdXQudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0cHV0QW1vdW50ID0gdHgub3V0cy5yZWR1Y2UoKHRvdGFsLCBvKSA9PiB0b3RhbCArIG8udmFsdWUsIDApO1xuICBjb25zdCBmZWUgPSBpbnB1dEFtb3VudCAtIG91dHB1dEFtb3VudDtcbiAgaWYgKGZlZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dHMgYXJlIHNwZW5kaW5nIG1vcmUgdGhhbiBJbnB1dHMnKTtcbiAgfVxuICBjb25zdCBieXRlcyA9IHR4LnZpcnR1YWxTaXplKCk7XG4gIGNhY2hlLl9fRkVFID0gZmVlO1xuICBjYWNoZS5fX0VYVFJBQ1RFRF9UWCA9IHR4O1xuICBjYWNoZS5fX0ZFRV9SQVRFID0gTWF0aC5mbG9vcihmZWUgLyBieXRlcyk7XG59XG5mdW5jdGlvbiBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCkge1xuICBjb25zdCBjID0gY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFO1xuICBpZiAoIWNbaW5wdXRJbmRleF0pIHtcbiAgICBhZGROb25XaXRuZXNzVHhDYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpO1xuICB9XG4gIHJldHVybiBjW2lucHV0SW5kZXhdO1xufVxuZnVuY3Rpb24gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KSB7XG4gIGlmIChpc1AyV1BLSChzY3JpcHQpKSByZXR1cm4gJ3dpdG5lc3NwdWJrZXloYXNoJztcbiAgaWYgKGlzUDJQS0goc2NyaXB0KSkgcmV0dXJuICdwdWJrZXloYXNoJztcbiAgaWYgKGlzUDJNUyhzY3JpcHQpKSByZXR1cm4gJ211bHRpc2lnJztcbiAgaWYgKGlzUDJQSyhzY3JpcHQpKSByZXR1cm4gJ3B1YmtleSc7XG4gIHJldHVybiAnbm9uc3RhbmRhcmQnO1xufVxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICByZXR1cm4gWy4uLkFycmF5KG4pLmtleXMoKV07XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2NyaXB0TnVtYmVyID0gcmVxdWlyZSgnLi9zY3JpcHRfbnVtYmVyJyk7XG5jb25zdCBzY3JpcHRTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NjcmlwdF9zaWduYXR1cmUnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgYmlwNjYgPSByZXF1aXJlKCdiaXA2NicpO1xuY29uc3QgZWNjID0gcmVxdWlyZSgndGlueS1zZWNwMjU2azEnKTtcbmNvbnN0IHB1c2hkYXRhID0gcmVxdWlyZSgncHVzaGRhdGEtYml0Y29pbicpO1xuY29uc3QgdHlwZWZvcmNlID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5leHBvcnRzLk9QUyA9IHJlcXVpcmUoJ2JpdGNvaW4tb3BzJyk7XG5jb25zdCBSRVZFUlNFX09QUyA9IHJlcXVpcmUoJ2JpdGNvaW4tb3BzL21hcCcpO1xuY29uc3QgT1BfSU5UX0JBU0UgPSBleHBvcnRzLk9QUy5PUF9SRVNFUlZFRDsgLy8gT1BfMSAtIDFcbmZ1bmN0aW9uIGlzT1BJbnQodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlcy5OdW1iZXIodmFsdWUpICYmXG4gICAgKHZhbHVlID09PSBleHBvcnRzLk9QUy5PUF8wIHx8XG4gICAgICAodmFsdWUgPj0gZXhwb3J0cy5PUFMuT1BfMSAmJiB2YWx1ZSA8PSBleHBvcnRzLk9QUy5PUF8xNikgfHxcbiAgICAgIHZhbHVlID09PSBleHBvcnRzLk9QUy5PUF8xTkVHQVRFKVxuICApO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seUNodW5rKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlcy5CdWZmZXIodmFsdWUpIHx8IGlzT1BJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZXMuQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGlzUHVzaE9ubHlDaHVuayk7XG59XG5leHBvcnRzLmlzUHVzaE9ubHkgPSBpc1B1c2hPbmx5O1xuZnVuY3Rpb24gYXNNaW5pbWFsT1AoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gZXhwb3J0cy5PUFMuT1BfMDtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDEpIHJldHVybjtcbiAgaWYgKGJ1ZmZlclswXSA+PSAxICYmIGJ1ZmZlclswXSA8PSAxNikgcmV0dXJuIE9QX0lOVF9CQVNFICsgYnVmZmVyWzBdO1xuICBpZiAoYnVmZmVyWzBdID09PSAweDgxKSByZXR1cm4gZXhwb3J0cy5PUFMuT1BfMU5FR0FURTtcbn1cbmZ1bmN0aW9uIGNodW5rc0lzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5mdW5jdGlvbiBjaHVua3NJc0FycmF5KGJ1Zikge1xuICByZXR1cm4gdHlwZXMuQXJyYXkoYnVmKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUNodW5rSXNCdWZmZXIoYnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYnVmKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGUoY2h1bmtzKSB7XG4gIC8vIFRPRE86IHJlbW92ZSBtZVxuICBpZiAoY2h1bmtzSXNCdWZmZXIoY2h1bmtzKSkgcmV0dXJuIGNodW5rcztcbiAgdHlwZWZvcmNlKHR5cGVzLkFycmF5LCBjaHVua3MpO1xuICBjb25zdCBidWZmZXJTaXplID0gY2h1bmtzLnJlZHVjZSgoYWNjdW0sIGNodW5rKSA9PiB7XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKGNodW5rKSkge1xuICAgICAgLy8gYWRoZXJlIHRvIEJJUDYyLjMsIG1pbmltYWwgcHVzaCBwb2xpY3lcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDEgJiYgYXNNaW5pbWFsT1AoY2h1bmspICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bSArIHB1c2hkYXRhLmVuY29kaW5nTGVuZ3RoKGNodW5rLmxlbmd0aCkgKyBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIC8vIG9wY29kZVxuICAgIHJldHVybiBhY2N1bSArIDE7XG4gIH0sIDAuMCk7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXJTaXplKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNodW5rcy5mb3JFYWNoKGNodW5rID0+IHtcbiAgICAvLyBkYXRhIGNodW5rXG4gICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAvLyBhZGhlcmUgdG8gQklQNjIuMywgbWluaW1hbCBwdXNoIHBvbGljeVxuICAgICAgY29uc3Qgb3Bjb2RlID0gYXNNaW5pbWFsT1AoY2h1bmspO1xuICAgICAgaWYgKG9wY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wY29kZSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBwdXNoZGF0YS5lbmNvZGUoYnVmZmVyLCBjaHVuay5sZW5ndGgsIG9mZnNldCk7XG4gICAgICBjaHVuay5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAvLyBvcGNvZGVcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLndyaXRlVUludDgoY2h1bmssIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gIH0pO1xuICBpZiAob2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgY2h1bmtzJyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZnVuY3Rpb24gZGVjb21waWxlKGJ1ZmZlcikge1xuICAvLyBUT0RPOiByZW1vdmUgbWVcbiAgaWYgKGNodW5rc0lzQXJyYXkoYnVmZmVyKSkgcmV0dXJuIGJ1ZmZlcjtcbiAgdHlwZWZvcmNlKHR5cGVzLkJ1ZmZlciwgYnVmZmVyKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3Qgb3Bjb2RlID0gYnVmZmVyW2ldO1xuICAgIC8vIGRhdGEgY2h1bmtcbiAgICBpZiAob3Bjb2RlID4gZXhwb3J0cy5PUFMuT1BfMCAmJiBvcGNvZGUgPD0gZXhwb3J0cy5PUFMuT1BfUFVTSERBVEE0KSB7XG4gICAgICBjb25zdCBkID0gcHVzaGRhdGEuZGVjb2RlKGJ1ZmZlciwgaSk7XG4gICAgICAvLyBkaWQgcmVhZGluZyBhIHB1c2hEYXRhSW50IGZhaWw/XG4gICAgICBpZiAoZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBpICs9IGQuc2l6ZTtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCB0b28gbXVjaCBkYXRhP1xuICAgICAgaWYgKGkgKyBkLm51bWJlciA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zbGljZShpLCBpICsgZC5udW1iZXIpO1xuICAgICAgaSArPSBkLm51bWJlcjtcbiAgICAgIC8vIGRlY29tcGlsZSBtaW5pbWFsbHlcbiAgICAgIGNvbnN0IG9wID0gYXNNaW5pbWFsT1AoZGF0YSk7XG4gICAgICBpZiAob3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaHVua3MucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua3MucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIG9wY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua3MucHVzaChvcGNvZGUpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuZXhwb3J0cy5kZWNvbXBpbGUgPSBkZWNvbXBpbGU7XG5mdW5jdGlvbiB0b0FTTShjaHVua3MpIHtcbiAgaWYgKGNodW5rc0lzQnVmZmVyKGNodW5rcykpIHtcbiAgICBjaHVua3MgPSBkZWNvbXBpbGUoY2h1bmtzKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzXG4gICAgLm1hcChjaHVuayA9PiB7XG4gICAgICAvLyBkYXRhP1xuICAgICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgIGNvbnN0IG9wID0gYXNNaW5pbWFsT1AoY2h1bmspO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNodW5rLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgY2h1bmsgPSBvcDtcbiAgICAgIH1cbiAgICAgIC8vIG9wY29kZSFcbiAgICAgIHJldHVybiBSRVZFUlNFX09QU1tjaHVua107XG4gICAgfSlcbiAgICAuam9pbignICcpO1xufVxuZXhwb3J0cy50b0FTTSA9IHRvQVNNO1xuZnVuY3Rpb24gZnJvbUFTTShhc20pIHtcbiAgdHlwZWZvcmNlKHR5cGVzLlN0cmluZywgYXNtKTtcbiAgcmV0dXJuIGNvbXBpbGUoXG4gICAgYXNtLnNwbGl0KCcgJykubWFwKGNodW5rU3RyID0+IHtcbiAgICAgIC8vIG9wY29kZT9cbiAgICAgIGlmIChleHBvcnRzLk9QU1tjaHVua1N0cl0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGV4cG9ydHMuT1BTW2NodW5rU3RyXTtcbiAgICAgIHR5cGVmb3JjZSh0eXBlcy5IZXgsIGNodW5rU3RyKTtcbiAgICAgIC8vIGRhdGEhXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmtTdHIsICdoZXgnKTtcbiAgICB9KSxcbiAgKTtcbn1cbmV4cG9ydHMuZnJvbUFTTSA9IGZyb21BU007XG5mdW5jdGlvbiB0b1N0YWNrKGNodW5rcykge1xuICBjaHVua3MgPSBkZWNvbXBpbGUoY2h1bmtzKTtcbiAgdHlwZWZvcmNlKGlzUHVzaE9ubHksIGNodW5rcyk7XG4gIHJldHVybiBjaHVua3MubWFwKG9wID0+IHtcbiAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihvcCkpIHJldHVybiBvcDtcbiAgICBpZiAob3AgPT09IGV4cG9ydHMuT1BTLk9QXzApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgcmV0dXJuIHNjcmlwdE51bWJlci5lbmNvZGUob3AgLSBPUF9JTlRfQkFTRSk7XG4gIH0pO1xufVxuZXhwb3J0cy50b1N0YWNrID0gdG9TdGFjaztcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsUHViS2V5KGJ1ZmZlcikge1xuICByZXR1cm4gZWNjLmlzUG9pbnQoYnVmZmVyKTtcbn1cbmV4cG9ydHMuaXNDYW5vbmljYWxQdWJLZXkgPSBpc0Nhbm9uaWNhbFB1YktleTtcbmZ1bmN0aW9uIGlzRGVmaW5lZEhhc2hUeXBlKGhhc2hUeXBlKSB7XG4gIGNvbnN0IGhhc2hUeXBlTW9kID0gaGFzaFR5cGUgJiB+MHg4MDtcbiAgLy8gcmV0dXJuIGhhc2hUeXBlTW9kID4gU0lHSEFTSF9BTEwgJiYgaGFzaFR5cGVNb2QgPCBTSUdIQVNIX1NJTkdMRVxuICByZXR1cm4gaGFzaFR5cGVNb2QgPiAweDAwICYmIGhhc2hUeXBlTW9kIDwgMHgwNDtcbn1cbmV4cG9ydHMuaXNEZWZpbmVkSGFzaFR5cGUgPSBpc0RlZmluZWRIYXNoVHlwZTtcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGJ1ZmZlcikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNEZWZpbmVkSGFzaFR5cGUoYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGJpcDY2LmNoZWNrKGJ1ZmZlci5zbGljZSgwLCAtMSkpO1xufVxuZXhwb3J0cy5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSA9IGlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHZhcmlhYmxlLW5hbWVcbmV4cG9ydHMubnVtYmVyID0gc2NyaXB0TnVtYmVyO1xuZXhwb3J0cy5zaWduYXR1cmUgPSBzY3JpcHRTaWduYXR1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlciwgbWF4TGVuZ3RoLCBtaW5pbWFsKSB7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA0O1xuICBtaW5pbWFsID0gbWluaW1hbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG1pbmltYWw7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAwO1xuICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY3JpcHQgbnVtYmVyIG92ZXJmbG93Jyk7XG4gIGlmIChtaW5pbWFsKSB7XG4gICAgaWYgKChidWZmZXJbbGVuZ3RoIC0gMV0gJiAweDdmKSA9PT0gMCkge1xuICAgICAgaWYgKGxlbmd0aCA8PSAxIHx8IChidWZmZXJbbGVuZ3RoIC0gMl0gJiAweDgwKSA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tbWluaW1hbGx5IGVuY29kZWQgc2NyaXB0IG51bWJlcicpO1xuICAgIH1cbiAgfVxuICAvLyA0MC1iaXRcbiAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgIGNvbnN0IGEgPSBidWZmZXIucmVhZFVJbnQzMkxFKDApO1xuICAgIGNvbnN0IGIgPSBidWZmZXIucmVhZFVJbnQ4KDQpO1xuICAgIGlmIChiICYgMHg4MCkgcmV0dXJuIC0oKGIgJiB+MHg4MCkgKiAweDEwMDAwMDAwMCArIGEpO1xuICAgIHJldHVybiBiICogMHgxMDAwMDAwMDAgKyBhO1xuICB9XG4gIC8vIDMyLWJpdCAvIDI0LWJpdCAvIDE2LWJpdCAvIDgtYml0XG4gIGxldCByZXN1bHQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0IHw9IGJ1ZmZlcltpXSA8PCAoOCAqIGkpO1xuICB9XG4gIGlmIChidWZmZXJbbGVuZ3RoIC0gMV0gJiAweDgwKVxuICAgIHJldHVybiAtKHJlc3VsdCAmIH4oMHg4MCA8PCAoOCAqIChsZW5ndGggLSAxKSkpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gc2NyaXB0TnVtU2l6ZShpKSB7XG4gIHJldHVybiBpID4gMHg3ZmZmZmZmZlxuICAgID8gNVxuICAgIDogaSA+IDB4N2ZmZmZmXG4gICAgPyA0XG4gICAgOiBpID4gMHg3ZmZmXG4gICAgPyAzXG4gICAgOiBpID4gMHg3ZlxuICAgID8gMlxuICAgIDogaSA+IDB4MDBcbiAgICA/IDFcbiAgICA6IDA7XG59XG5mdW5jdGlvbiBlbmNvZGUoX251bWJlcikge1xuICBsZXQgdmFsdWUgPSBNYXRoLmFicyhfbnVtYmVyKTtcbiAgY29uc3Qgc2l6ZSA9IHNjcmlwdE51bVNpemUodmFsdWUpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIGNvbnN0IG5lZ2F0aXZlID0gX251bWJlciA8IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUgJiAweGZmLCBpKTtcbiAgICB2YWx1ZSA+Pj0gODtcbiAgfVxuICBpZiAoYnVmZmVyW3NpemUgLSAxXSAmIDB4ODApIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChuZWdhdGl2ZSA/IDB4ODAgOiAweDAwLCBzaXplIC0gMSk7XG4gIH0gZWxzZSBpZiAobmVnYXRpdmUpIHtcbiAgICBidWZmZXJbc2l6ZSAtIDFdIHw9IDB4ODA7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgYmlwNjYgPSByZXF1aXJlKCdiaXA2NicpO1xuY29uc3QgdHlwZWZvcmNlID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBaRVJPID0gQnVmZmVyLmFsbG9jKDEsIDApO1xuZnVuY3Rpb24gdG9ERVIoeCkge1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlICh4W2ldID09PSAwKSArK2k7XG4gIGlmIChpID09PSB4Lmxlbmd0aCkgcmV0dXJuIFpFUk87XG4gIHggPSB4LnNsaWNlKGkpO1xuICBpZiAoeFswXSAmIDB4ODApIHJldHVybiBCdWZmZXIuY29uY2F0KFtaRVJPLCB4XSwgMSArIHgubGVuZ3RoKTtcbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBmcm9tREVSKHgpIHtcbiAgaWYgKHhbMF0gPT09IDB4MDApIHggPSB4LnNsaWNlKDEpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICBjb25zdCBic3RhcnQgPSBNYXRoLm1heCgwLCAzMiAtIHgubGVuZ3RoKTtcbiAgeC5jb3B5KGJ1ZmZlciwgYnN0YXJ0KTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8vIEJJUDYyOiAxIGJ5dGUgaGFzaFR5cGUgZmxhZyAob25seSAweDAxLCAweDAyLCAweDAzLCAweDgxLCAweDgyIGFuZCAweDgzIGFyZSBhbGxvd2VkKVxuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuICBjb25zdCBoYXNoVHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICBjb25zdCBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4ODA7XG4gIGlmIChoYXNoVHlwZU1vZCA8PSAwIHx8IGhhc2hUeXBlTW9kID49IDQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2hUeXBlICcgKyBoYXNoVHlwZSk7XG4gIGNvbnN0IGRlY29kZWQgPSBiaXA2Ni5kZWNvZGUoYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG4gIGNvbnN0IHIgPSBmcm9tREVSKGRlY29kZWQucik7XG4gIGNvbnN0IHMgPSBmcm9tREVSKGRlY29kZWQucyk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW3IsIHNdLCA2NCk7XG4gIHJldHVybiB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHNpZ25hdHVyZSwgaGFzaFR5cGUpIHtcbiAgdHlwZWZvcmNlKFxuICAgIHtcbiAgICAgIHNpZ25hdHVyZTogdHlwZXMuQnVmZmVyTig2NCksXG4gICAgICBoYXNoVHlwZTogdHlwZXMuVUludDgsXG4gICAgfSxcbiAgICB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfSxcbiAgKTtcbiAgY29uc3QgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuICBpZiAoaGFzaFR5cGVNb2QgPD0gMCB8fCBoYXNoVHlwZU1vZCA+PSA0KVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICBjb25zdCBoYXNoVHlwZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG4gIGNvbnN0IHIgPSB0b0RFUihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKTtcbiAgY29uc3QgcyA9IHRvREVSKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2JpcDY2LmVuY29kZShyLCBzKSwgaGFzaFR5cGVCdWZmZXJdKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuZXhwb3J0cy5pbnB1dCA9IGlucHV0O1xuY29uc3Qgb3V0cHV0ID0gcmVxdWlyZSgnLi9vdXRwdXQnKTtcbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gT1BfMCBbc2lnbmF0dXJlcyAuLi5dXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuY29uc3Qgc2NyaXB0XzEgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmZ1bmN0aW9uIHBhcnRpYWxTaWduYXR1cmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gc2NyaXB0XzEuT1BTLk9QXzAgfHwgYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSh2YWx1ZSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrKHNjcmlwdCwgYWxsb3dJbmNvbXBsZXRlKSB7XG4gIGNvbnN0IGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKHNjcmlwdCk7XG4gIGlmIChjaHVua3MubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICBpZiAoY2h1bmtzWzBdICE9PSBzY3JpcHRfMS5PUFMuT1BfMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYWxsb3dJbmNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIGNodW5rcy5zbGljZSgxKS5ldmVyeShwYXJ0aWFsU2lnbmF0dXJlKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzLnNsaWNlKDEpLmV2ZXJ5KGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuY2hlY2sudG9KU09OID0gKCkgPT4ge1xuICByZXR1cm4gJ211bHRpc2lnIGlucHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBtIFtwdWJLZXlzIC4uLl0gbiBPUF9DSEVDS01VTFRJU0lHXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuY29uc3Qgc2NyaXB0XzEgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMnKTtcbmNvbnN0IE9QX0lOVF9CQVNFID0gc2NyaXB0XzEuT1BTLk9QX1JFU0VSVkVEOyAvLyBPUF8xIC0gMVxuZnVuY3Rpb24gY2hlY2soc2NyaXB0LCBhbGxvd0luY29tcGxldGUpIHtcbiAgY29uc3QgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUoc2NyaXB0KTtcbiAgaWYgKGNodW5rcy5sZW5ndGggPCA0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdICE9PSBzY3JpcHRfMS5PUFMuT1BfQ0hFQ0tNVUxUSVNJRykgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXR5cGVzLk51bWJlcihjaHVua3NbMF0pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHlwZXMuTnVtYmVyKGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMl0pKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG0gPSBjaHVua3NbMF0gLSBPUF9JTlRfQkFTRTtcbiAgY29uc3QgbiA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMl0gLSBPUF9JTlRfQkFTRTtcbiAgaWYgKG0gPD0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAobiA+IDE2KSByZXR1cm4gZmFsc2U7XG4gIGlmIChtID4gbikgcmV0dXJuIGZhbHNlO1xuICBpZiAobiAhPT0gY2h1bmtzLmxlbmd0aCAtIDMpIHJldHVybiBmYWxzZTtcbiAgaWYgKGFsbG93SW5jb21wbGV0ZSkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGtleXMgPSBjaHVua3Muc2xpY2UoMSwgLTIpO1xuICByZXR1cm4ga2V5cy5ldmVyeShic2NyaXB0LmlzQ2Fub25pY2FsUHViS2V5KTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICdtdWx0aS1zaWcgb3V0cHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gT1BfUkVUVVJOIHtkYXRhfVxuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5mdW5jdGlvbiBjaGVjayhzY3JpcHQpIHtcbiAgY29uc3QgYnVmZmVyID0gYnNjcmlwdC5jb21waWxlKHNjcmlwdCk7XG4gIHJldHVybiBidWZmZXIubGVuZ3RoID4gMSAmJiBidWZmZXJbMF0gPT09IE9QUy5PUF9SRVRVUk47XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5jaGVjay50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAnbnVsbCBkYXRhIG91dHB1dCc7XG59O1xuY29uc3Qgb3V0cHV0ID0geyBjaGVjayB9O1xuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyB7c2lnbmF0dXJlfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmZ1bmN0aW9uIGNoZWNrKHNjcmlwdCkge1xuICBjb25zdCBjaHVua3MgPSBic2NyaXB0LmRlY29tcGlsZShzY3JpcHQpO1xuICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PT0gMSAmJiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGNodW5rc1swXSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5jaGVjay50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAncHViS2V5IGlucHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB7cHViS2V5fSBPUF9DSEVDS1NJR1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG5mdW5jdGlvbiBjaGVjayhzY3JpcHQpIHtcbiAgY29uc3QgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUoc2NyaXB0KTtcbiAgcmV0dXJuIChcbiAgICBjaHVua3MubGVuZ3RoID09PSAyICYmXG4gICAgYnNjcmlwdC5pc0Nhbm9uaWNhbFB1YktleShjaHVua3NbMF0pICYmXG4gICAgY2h1bmtzWzFdID09PSBzY3JpcHRfMS5PUFMuT1BfQ0hFQ0tTSUdcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICdwdWJLZXkgb3V0cHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB7c2lnbmF0dXJlfSB7cHViS2V5fVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmZ1bmN0aW9uIGNoZWNrKHNjcmlwdCkge1xuICBjb25zdCBjaHVua3MgPSBic2NyaXB0LmRlY29tcGlsZShzY3JpcHQpO1xuICByZXR1cm4gKFxuICAgIGNodW5rcy5sZW5ndGggPT09IDIgJiZcbiAgICBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGNodW5rc1swXSkgJiZcbiAgICBic2NyaXB0LmlzQ2Fub25pY2FsUHViS2V5KGNodW5rc1sxXSlcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICdwdWJLZXlIYXNoIGlucHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBPUF9EVVAgT1BfSEFTSDE2MCB7cHViS2V5SGFzaH0gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuZnVuY3Rpb24gY2hlY2soc2NyaXB0KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IGJzY3JpcHQuY29tcGlsZShzY3JpcHQpO1xuICByZXR1cm4gKFxuICAgIGJ1ZmZlci5sZW5ndGggPT09IDI1ICYmXG4gICAgYnVmZmVyWzBdID09PSBzY3JpcHRfMS5PUFMuT1BfRFVQICYmXG4gICAgYnVmZmVyWzFdID09PSBzY3JpcHRfMS5PUFMuT1BfSEFTSDE2MCAmJlxuICAgIGJ1ZmZlclsyXSA9PT0gMHgxNCAmJlxuICAgIGJ1ZmZlclsyM10gPT09IHNjcmlwdF8xLk9QUy5PUF9FUVVBTFZFUklGWSAmJlxuICAgIGJ1ZmZlclsyNF0gPT09IHNjcmlwdF8xLk9QUy5PUF9DSEVDS1NJR1xuICApO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuY2hlY2sudG9KU09OID0gKCkgPT4ge1xuICByZXR1cm4gJ3B1YktleUhhc2ggb3V0cHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyA8c2NyaXB0U2lnPiB7c2VyaWFsaXplZCBzY3JpcHRQdWJLZXkgc2NyaXB0fVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmNvbnN0IHAybXMgPSByZXF1aXJlKCcuLi9tdWx0aXNpZycpO1xuY29uc3QgcDJwayA9IHJlcXVpcmUoJy4uL3B1YmtleScpO1xuY29uc3QgcDJwa2ggPSByZXF1aXJlKCcuLi9wdWJrZXloYXNoJyk7XG5jb25zdCBwMndwa2hvID0gcmVxdWlyZSgnLi4vd2l0bmVzc3B1YmtleWhhc2gvb3V0cHV0Jyk7XG5jb25zdCBwMndzaG8gPSByZXF1aXJlKCcuLi93aXRuZXNzc2NyaXB0aGFzaC9vdXRwdXQnKTtcbmZ1bmN0aW9uIGNoZWNrKHNjcmlwdCwgYWxsb3dJbmNvbXBsZXRlKSB7XG4gIGNvbnN0IGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKHNjcmlwdCk7XG4gIGlmIChjaHVua3MubGVuZ3RoIDwgMSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihsYXN0Q2h1bmspKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNjcmlwdFNpZ0NodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKFxuICAgIGJzY3JpcHQuY29tcGlsZShjaHVua3Muc2xpY2UoMCwgLTEpKSxcbiAgKTtcbiAgY29uc3QgcmVkZWVtU2NyaXB0Q2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUobGFzdENodW5rKTtcbiAgLy8gaXMgcmVkZWVtU2NyaXB0IGEgdmFsaWQgc2NyaXB0P1xuICBpZiAoIXJlZGVlbVNjcmlwdENodW5rcykgcmV0dXJuIGZhbHNlO1xuICAvLyBpcyByZWRlZW1TY3JpcHRTaWcgcHVzaCBvbmx5P1xuICBpZiAoIWJzY3JpcHQuaXNQdXNoT25seShzY3JpcHRTaWdDaHVua3MpKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlzIHdpdG5lc3M/XG4gIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHAyd3Noby5jaGVjayhyZWRlZW1TY3JpcHRDaHVua3MpIHx8IHAyd3BraG8uY2hlY2socmVkZWVtU2NyaXB0Q2h1bmtzKVxuICAgICk7XG4gIH1cbiAgLy8gbWF0Y2ggdHlwZXNcbiAgaWYgKFxuICAgIHAycGtoLmlucHV0LmNoZWNrKHNjcmlwdFNpZ0NodW5rcykgJiZcbiAgICBwMnBraC5vdXRwdXQuY2hlY2socmVkZWVtU2NyaXB0Q2h1bmtzKVxuICApXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChcbiAgICBwMm1zLmlucHV0LmNoZWNrKHNjcmlwdFNpZ0NodW5rcywgYWxsb3dJbmNvbXBsZXRlKSAmJlxuICAgIHAybXMub3V0cHV0LmNoZWNrKHJlZGVlbVNjcmlwdENodW5rcylcbiAgKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoXG4gICAgcDJway5pbnB1dC5jaGVjayhzY3JpcHRTaWdDaHVua3MpICYmXG4gICAgcDJway5vdXRwdXQuY2hlY2socmVkZWVtU2NyaXB0Q2h1bmtzKVxuICApXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICdzY3JpcHRIYXNoIGlucHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBPUF9IQVNIMTYwIHtzY3JpcHRIYXNofSBPUF9FUVVBTFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG5mdW5jdGlvbiBjaGVjayhzY3JpcHQpIHtcbiAgY29uc3QgYnVmZmVyID0gYnNjcmlwdC5jb21waWxlKHNjcmlwdCk7XG4gIHJldHVybiAoXG4gICAgYnVmZmVyLmxlbmd0aCA9PT0gMjMgJiZcbiAgICBidWZmZXJbMF0gPT09IHNjcmlwdF8xLk9QUy5PUF9IQVNIMTYwICYmXG4gICAgYnVmZmVyWzFdID09PSAweDE0ICYmXG4gICAgYnVmZmVyWzIyXSA9PT0gc2NyaXB0XzEuT1BTLk9QX0VRVUFMXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5jaGVjay50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAnc2NyaXB0SGFzaCBvdXRwdXQnO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBvdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBPUF9SRVRVUk4ge2FhMjFhOWVkfSB7Y29tbWl0bWVudH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuLi8uLi90eXBlcycpO1xuY29uc3QgdHlwZWZvcmNlID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBIRUFERVIgPSBCdWZmZXIuZnJvbSgnYWEyMWE5ZWQnLCAnaGV4Jyk7XG5mdW5jdGlvbiBjaGVjayhzY3JpcHQpIHtcbiAgY29uc3QgYnVmZmVyID0gYnNjcmlwdC5jb21waWxlKHNjcmlwdCk7XG4gIHJldHVybiAoXG4gICAgYnVmZmVyLmxlbmd0aCA+IDM3ICYmXG4gICAgYnVmZmVyWzBdID09PSBzY3JpcHRfMS5PUFMuT1BfUkVUVVJOICYmXG4gICAgYnVmZmVyWzFdID09PSAweDI0ICYmXG4gICAgYnVmZmVyLnNsaWNlKDIsIDYpLmVxdWFscyhIRUFERVIpXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5jaGVjay50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAnV2l0bmVzcyBjb21taXRtZW50IG91dHB1dCc7XG59O1xuZnVuY3Rpb24gZW5jb2RlKGNvbW1pdG1lbnQpIHtcbiAgdHlwZWZvcmNlKHR5cGVzLkhhc2gyNTZiaXQsIGNvbW1pdG1lbnQpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzYpO1xuICBIRUFERVIuY29weShidWZmZXIsIDApO1xuICBjb21taXRtZW50LmNvcHkoYnVmZmVyLCA0KTtcbiAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbc2NyaXB0XzEuT1BTLk9QX1JFVFVSTiwgYnVmZmVyXSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgdHlwZWZvcmNlKGNoZWNrLCBidWZmZXIpO1xuICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYnVmZmVyKVsxXS5zbGljZSg0LCAzNik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIHtzaWduYXR1cmV9IHtwdWJLZXl9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuZnVuY3Rpb24gaXNDb21wcmVzc2VkQ2Fub25pY2FsUHViS2V5KHB1YktleSkge1xuICByZXR1cm4gYnNjcmlwdC5pc0Nhbm9uaWNhbFB1YktleShwdWJLZXkpICYmIHB1YktleS5sZW5ndGggPT09IDMzO1xufVxuZnVuY3Rpb24gY2hlY2soc2NyaXB0KSB7XG4gIGNvbnN0IGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKHNjcmlwdCk7XG4gIHJldHVybiAoXG4gICAgY2h1bmtzLmxlbmd0aCA9PT0gMiAmJlxuICAgIGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoY2h1bmtzWzBdKSAmJlxuICAgIGlzQ29tcHJlc3NlZENhbm9uaWNhbFB1YktleShjaHVua3NbMV0pXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5jaGVjay50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAnd2l0bmVzc1B1YktleUhhc2ggaW5wdXQnO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIE9QXzAge3B1YktleUhhc2h9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuY29uc3Qgc2NyaXB0XzEgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmZ1bmN0aW9uIGNoZWNrKHNjcmlwdCkge1xuICBjb25zdCBidWZmZXIgPSBic2NyaXB0LmNvbXBpbGUoc2NyaXB0KTtcbiAgcmV0dXJuIChcbiAgICBidWZmZXIubGVuZ3RoID09PSAyMiAmJlxuICAgIGJ1ZmZlclswXSA9PT0gc2NyaXB0XzEuT1BTLk9QXzAgJiZcbiAgICBidWZmZXJbMV0gPT09IDB4MTRcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICdXaXRuZXNzIHB1YktleUhhc2ggb3V0cHV0Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyA8c2NyaXB0U2lnPiB7c2VyaWFsaXplZCBzY3JpcHRQdWJLZXkgc2NyaXB0fVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgcDJtcyA9IHJlcXVpcmUoJy4uL211bHRpc2lnJyk7XG5jb25zdCBwMnBrID0gcmVxdWlyZSgnLi4vcHVia2V5Jyk7XG5jb25zdCBwMnBraCA9IHJlcXVpcmUoJy4uL3B1YmtleWhhc2gnKTtcbmZ1bmN0aW9uIGNoZWNrKGNodW5rcywgYWxsb3dJbmNvbXBsZXRlKSB7XG4gIHR5cGVmb3JjZSh0eXBlZm9yY2UuQXJyYXksIGNodW5rcyk7XG4gIGlmIChjaHVua3MubGVuZ3RoIDwgMSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIod2l0bmVzc1NjcmlwdCkpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgd2l0bmVzc1NjcmlwdENodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKHdpdG5lc3NTY3JpcHQpO1xuICAvLyBpcyB3aXRuZXNzU2NyaXB0IGEgdmFsaWQgc2NyaXB0P1xuICBpZiAoIXdpdG5lc3NTY3JpcHRDaHVua3MgfHwgd2l0bmVzc1NjcmlwdENodW5rcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgd2l0bmVzc1Jhd1NjcmlwdFNpZyA9IGJzY3JpcHQuY29tcGlsZShjaHVua3Muc2xpY2UoMCwgLTEpKTtcbiAgLy8gbWF0Y2ggdHlwZXNcbiAgaWYgKFxuICAgIHAycGtoLmlucHV0LmNoZWNrKHdpdG5lc3NSYXdTY3JpcHRTaWcpICYmXG4gICAgcDJwa2gub3V0cHV0LmNoZWNrKHdpdG5lc3NTY3JpcHRDaHVua3MpXG4gIClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKFxuICAgIHAybXMuaW5wdXQuY2hlY2sod2l0bmVzc1Jhd1NjcmlwdFNpZywgYWxsb3dJbmNvbXBsZXRlKSAmJlxuICAgIHAybXMub3V0cHV0LmNoZWNrKHdpdG5lc3NTY3JpcHRDaHVua3MpXG4gIClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKFxuICAgIHAycGsuaW5wdXQuY2hlY2sod2l0bmVzc1Jhd1NjcmlwdFNpZykgJiZcbiAgICBwMnBrLm91dHB1dC5jaGVjayh3aXRuZXNzU2NyaXB0Q2h1bmtzKVxuICApXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNoZWNrLnRvSlNPTiA9ICgpID0+IHtcbiAgcmV0dXJuICd3aXRuZXNzU2NyaXB0SGFzaCBpbnB1dCc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gT1BfMCB7c2NyaXB0SGFzaH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xuZnVuY3Rpb24gY2hlY2soc2NyaXB0KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IGJzY3JpcHQuY29tcGlsZShzY3JpcHQpO1xuICByZXR1cm4gKFxuICAgIGJ1ZmZlci5sZW5ndGggPT09IDM0ICYmXG4gICAgYnVmZmVyWzBdID09PSBzY3JpcHRfMS5PUFMuT1BfMCAmJlxuICAgIGJ1ZmZlclsxXSA9PT0gMHgyMFxuICApO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuY2hlY2sudG9KU09OID0gKCkgPT4ge1xuICByZXR1cm4gJ1dpdG5lc3Mgc2NyaXB0SGFzaCBvdXRwdXQnO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBidWZmZXJ1dGlscyA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKCcuL2J1ZmZlcnV0aWxzJyk7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3Qgc2NyaXB0XzEgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCd2YXJ1aW50LWJpdGNvaW4nKTtcbmZ1bmN0aW9uIHZhclNsaWNlU2l6ZShzb21lU2NyaXB0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNvbWVTY3JpcHQubGVuZ3RoO1xuICByZXR1cm4gdmFydWludC5lbmNvZGluZ0xlbmd0aChsZW5ndGgpICsgbGVuZ3RoO1xufVxuZnVuY3Rpb24gdmVjdG9yU2l6ZShzb21lVmVjdG9yKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNvbWVWZWN0b3IubGVuZ3RoO1xuICByZXR1cm4gKFxuICAgIHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobGVuZ3RoKSArXG4gICAgc29tZVZlY3Rvci5yZWR1Y2UoKHN1bSwgd2l0bmVzcykgPT4ge1xuICAgICAgcmV0dXJuIHN1bSArIHZhclNsaWNlU2l6ZSh3aXRuZXNzKTtcbiAgICB9LCAwKVxuICApO1xufVxuY29uc3QgRU1QVFlfU0NSSVBUID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuY29uc3QgRU1QVFlfV0lUTkVTUyA9IFtdO1xuY29uc3QgWkVSTyA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICdoZXgnLFxuKTtcbmNvbnN0IE9ORSA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICdoZXgnLFxuKTtcbmNvbnN0IFZBTFVFX1VJTlQ2NF9NQVggPSBCdWZmZXIuZnJvbSgnZmZmZmZmZmZmZmZmZmZmZicsICdoZXgnKTtcbmNvbnN0IEJMQU5LX09VVFBVVCA9IHtcbiAgc2NyaXB0OiBFTVBUWV9TQ1JJUFQsXG4gIHZhbHVlQnVmZmVyOiBWQUxVRV9VSU5UNjRfTUFYLFxufTtcbmZ1bmN0aW9uIGlzT3V0cHV0KG91dCkge1xuICByZXR1cm4gb3V0LnZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5sb2NrdGltZSA9IDA7XG4gICAgdGhpcy5pbnMgPSBbXTtcbiAgICB0aGlzLm91dHMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIF9OT19TVFJJQ1QpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmdW5jdGlvbiByZWFkU2xpY2Uobikge1xuICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKG9mZnNldCAtIG4sIG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzIoKSB7XG4gICAgICBjb25zdCBpID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEludDMyKCkge1xuICAgICAgY29uc3QgaSA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFVJbnQ2NCgpIHtcbiAgICAgIGNvbnN0IGkgPSBidWZmZXJ1dGlscy5yZWFkVUludDY0TEUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFZhckludCgpIHtcbiAgICAgIGNvbnN0IHZpID0gdmFydWludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IHZhcnVpbnQuZGVjb2RlLmJ5dGVzO1xuICAgICAgcmV0dXJuIHZpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVmFyU2xpY2UoKSB7XG4gICAgICByZXR1cm4gcmVhZFNsaWNlKHJlYWRWYXJJbnQoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRWZWN0b3IoKSB7XG4gICAgICBjb25zdCBjb3VudCA9IHJlYWRWYXJJbnQoKTtcbiAgICAgIGNvbnN0IHZlY3RvciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB2ZWN0b3IucHVzaChyZWFkVmFyU2xpY2UoKSk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHR4LnZlcnNpb24gPSByZWFkSW50MzIoKTtcbiAgICBjb25zdCBtYXJrZXIgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgY29uc3QgZmxhZyA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSk7XG4gICAgbGV0IGhhc1dpdG5lc3NlcyA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcmtlciA9PT0gVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSICYmXG4gICAgICBmbGFnID09PSBUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHXG4gICAgKSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIGhhc1dpdG5lc3NlcyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHZpbkxlbiA9IHJlYWRWYXJJbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpbkxlbjsgKytpKSB7XG4gICAgICB0eC5pbnMucHVzaCh7XG4gICAgICAgIGhhc2g6IHJlYWRTbGljZSgzMiksXG4gICAgICAgIGluZGV4OiByZWFkVUludDMyKCksXG4gICAgICAgIHNjcmlwdDogcmVhZFZhclNsaWNlKCksXG4gICAgICAgIHNlcXVlbmNlOiByZWFkVUludDMyKCksXG4gICAgICAgIHdpdG5lc3M6IEVNUFRZX1dJVE5FU1MsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgdm91dExlbiA9IHJlYWRWYXJJbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZvdXRMZW47ICsraSkge1xuICAgICAgdHgub3V0cy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHJlYWRVSW50NjQoKSxcbiAgICAgICAgc2NyaXB0OiByZWFkVmFyU2xpY2UoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpbkxlbjsgKytpKSB7XG4gICAgICAgIHR4Lmluc1tpXS53aXRuZXNzID0gcmVhZFZlY3RvcigpO1xuICAgICAgfVxuICAgICAgLy8gd2FzIHRoaXMgcG9pbnRsZXNzP1xuICAgICAgaWYgKCF0eC5oYXNXaXRuZXNzZXMoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgc3VwZXJmbHVvdXMgd2l0bmVzcyBkYXRhJyk7XG4gICAgfVxuICAgIHR4LmxvY2t0aW1lID0gcmVhZFVJbnQzMigpO1xuICAgIGlmIChfTk9fU1RSSUNUKSByZXR1cm4gdHg7XG4gICAgaWYgKG9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIHVuZXhwZWN0ZWQgZGF0YScpO1xuICAgIHJldHVybiB0eDtcbiAgfVxuICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShoZXgsICdoZXgnKSwgZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBpc0NvaW5iYXNlSGFzaChidWZmZXIpIHtcbiAgICB0eXBlZm9yY2UodHlwZXMuSGFzaDI1NmJpdCwgYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIGlmIChidWZmZXJbaV0gIT09IDApIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNDb2luYmFzZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pbnMubGVuZ3RoID09PSAxICYmIFRyYW5zYWN0aW9uLmlzQ29pbmJhc2VIYXNoKHRoaXMuaW5zWzBdLmhhc2gpXG4gICAgKTtcbiAgfVxuICBhZGRJbnB1dChoYXNoLCBpbmRleCwgc2VxdWVuY2UsIHNjcmlwdFNpZykge1xuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKFxuICAgICAgICB0eXBlcy5IYXNoMjU2Yml0LFxuICAgICAgICB0eXBlcy5VSW50MzIsXG4gICAgICAgIHR5cGVzLm1heWJlKHR5cGVzLlVJbnQzMiksXG4gICAgICAgIHR5cGVzLm1heWJlKHR5cGVzLkJ1ZmZlciksXG4gICAgICApLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgaWYgKHR5cGVzLk51bGwoc2VxdWVuY2UpKSB7XG4gICAgICBzZXF1ZW5jZSA9IFRyYW5zYWN0aW9uLkRFRkFVTFRfU0VRVUVOQ0U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgaW5wdXQncyBpbmRleFxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlucy5wdXNoKHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNjcmlwdDogc2NyaXB0U2lnIHx8IEVNUFRZX1NDUklQVCxcbiAgICAgICAgc2VxdWVuY2U6IHNlcXVlbmNlLFxuICAgICAgICB3aXRuZXNzOiBFTVBUWV9XSVRORVNTLFxuICAgICAgfSkgLSAxXG4gICAgKTtcbiAgfVxuICBhZGRPdXRwdXQoc2NyaXB0UHViS2V5LCB2YWx1ZSkge1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlNhdG9zaGkpLCBhcmd1bWVudHMpO1xuICAgIC8vIEFkZCB0aGUgb3V0cHV0IGFuZCByZXR1cm4gdGhlIG91dHB1dCdzIGluZGV4XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3V0cy5wdXNoKHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHRQdWJLZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSkgLSAxXG4gICAgKTtcbiAgfVxuICBoYXNXaXRuZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zLnNvbWUoeCA9PiB7XG4gICAgICByZXR1cm4geC53aXRuZXNzLmxlbmd0aCAhPT0gMDtcbiAgICB9KTtcbiAgfVxuICB3ZWlnaHQoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSk7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLmJ5dGVMZW5ndGgodHJ1ZSk7XG4gICAgcmV0dXJuIGJhc2UgKiAzICsgdG90YWw7XG4gIH1cbiAgdmlydHVhbFNpemUoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLndlaWdodCgpIC8gNCk7XG4gIH1cbiAgYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUyA9IHRydWUpIHtcbiAgICBjb25zdCBoYXNXaXRuZXNzZXMgPSBfQUxMT1dfV0lUTkVTUyAmJiB0aGlzLmhhc1dpdG5lc3NlcygpO1xuICAgIHJldHVybiAoXG4gICAgICAoaGFzV2l0bmVzc2VzID8gMTAgOiA4KSArXG4gICAgICB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMuaW5zLmxlbmd0aCkgK1xuICAgICAgdmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLm91dHMubGVuZ3RoKSArXG4gICAgICB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIDQwICsgdmFyU2xpY2VTaXplKGlucHV0LnNjcmlwdCk7XG4gICAgICB9LCAwKSArXG4gICAgICB0aGlzLm91dHMucmVkdWNlKChzdW0sIG91dHB1dCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIH0sIDApICtcbiAgICAgIChoYXNXaXRuZXNzZXNcbiAgICAgICAgPyB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyB2ZWN0b3JTaXplKGlucHV0LndpdG5lc3MpO1xuICAgICAgICAgIH0sIDApXG4gICAgICAgIDogMClcbiAgICApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1R4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgbmV3VHgudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICBuZXdUeC5sb2NrdGltZSA9IHRoaXMubG9ja3RpbWU7XG4gICAgbmV3VHguaW5zID0gdGhpcy5pbnMubWFwKHR4SW4gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogdHhJbi5oYXNoLFxuICAgICAgICBpbmRleDogdHhJbi5pbmRleCxcbiAgICAgICAgc2NyaXB0OiB0eEluLnNjcmlwdCxcbiAgICAgICAgc2VxdWVuY2U6IHR4SW4uc2VxdWVuY2UsXG4gICAgICAgIHdpdG5lc3M6IHR4SW4ud2l0bmVzcyxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbmV3VHgub3V0cyA9IHRoaXMub3V0cy5tYXAodHhPdXQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0OiB0eE91dC5zY3JpcHQsXG4gICAgICAgIHZhbHVlOiB0eE91dC52YWx1ZSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1R4O1xuICB9XG4gIC8qKlxuICAgKiBIYXNoIHRyYW5zYWN0aW9uIGZvciBzaWduaW5nIGEgc3BlY2lmaWMgaW5wdXQuXG4gICAqXG4gICAqIEJpdGNvaW4gdXNlcyBhIGRpZmZlcmVudCBoYXNoIGZvciBlYWNoIHNpZ25lZCB0cmFuc2FjdGlvbiBpbnB1dC5cbiAgICogVGhpcyBtZXRob2QgY29waWVzIHRoZSB0cmFuc2FjdGlvbiwgbWFrZXMgdGhlIG5lY2Vzc2FyeSBjaGFuZ2VzIGJhc2VkIG9uIHRoZVxuICAgKiBoYXNoVHlwZSwgYW5kIHRoZW4gaGFzaGVzIHRoZSByZXN1bHQuXG4gICAqIFRoaXMgaGFzaCBjYW4gdGhlbiBiZSB1c2VkIHRvIHNpZ24gdGhlIHByb3ZpZGVkIHRyYW5zYWN0aW9uIGlucHV0LlxuICAgKi9cbiAgaGFzaEZvclNpZ25hdHVyZShpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCBoYXNoVHlwZSkge1xuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKHR5cGVzLlVJbnQzMiwgdHlwZXMuQnVmZmVyLCAvKiB0eXBlcy5VSW50OCAqLyB0eXBlcy5OdW1iZXIpLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL21hc3Rlci9zcmMvdGVzdC9zaWdoYXNoX3Rlc3RzLmNwcCNMMjlcbiAgICBpZiAoaW5JbmRleCA+PSB0aGlzLmlucy5sZW5ndGgpIHJldHVybiBPTkU7XG4gICAgLy8gaWdub3JlIE9QX0NPREVTRVBBUkFUT1JcbiAgICBjb25zdCBvdXJTY3JpcHQgPSBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBic2NyaXB0LmRlY29tcGlsZShwcmV2T3V0U2NyaXB0KS5maWx0ZXIoeCA9PiB7XG4gICAgICAgIHJldHVybiB4ICE9PSBzY3JpcHRfMS5PUFMuT1BfQ09ERVNFUEFSQVRPUjtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgY29uc3QgdHhUbXAgPSB0aGlzLmNsb25lKCk7XG4gICAgLy8gU0lHSEFTSF9OT05FOiBpZ25vcmUgYWxsIG91dHB1dHM/ICh3aWxkY2FyZCBwYXllZSlcbiAgICBpZiAoKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgdHhUbXAub3V0cyA9IFtdO1xuICAgICAgLy8gaWdub3JlIHNlcXVlbmNlIG51bWJlcnMgKGV4Y2VwdCBhdCBpbkluZGV4KVxuICAgICAgdHhUbXAuaW5zLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSBpbkluZGV4KSByZXR1cm47XG4gICAgICAgIGlucHV0LnNlcXVlbmNlID0gMDtcbiAgICAgIH0pO1xuICAgICAgLy8gU0lHSEFTSF9TSU5HTEU6IGlnbm9yZSBhbGwgb3V0cHV0cywgZXhjZXB0IGF0IHRoZSBzYW1lIGluZGV4P1xuICAgIH0gZWxzZSBpZiAoKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvbWFzdGVyL3NyYy90ZXN0L3NpZ2hhc2hfdGVzdHMuY3BwI0w2MFxuICAgICAgaWYgKGluSW5kZXggPj0gdGhpcy5vdXRzLmxlbmd0aCkgcmV0dXJuIE9ORTtcbiAgICAgIC8vIHRydW5jYXRlIG91dHB1dHMgYWZ0ZXJcbiAgICAgIHR4VG1wLm91dHMubGVuZ3RoID0gaW5JbmRleCArIDE7XG4gICAgICAvLyBcImJsYW5rXCIgb3V0cHV0cyBiZWZvcmVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5JbmRleDsgaSsrKSB7XG4gICAgICAgIHR4VG1wLm91dHNbaV0gPSBCTEFOS19PVVRQVVQ7XG4gICAgICB9XG4gICAgICAvLyBpZ25vcmUgc2VxdWVuY2UgbnVtYmVycyAoZXhjZXB0IGF0IGluSW5kZXgpXG4gICAgICB0eFRtcC5pbnMuZm9yRWFjaCgoaW5wdXQsIHkpID0+IHtcbiAgICAgICAgaWYgKHkgPT09IGluSW5kZXgpIHJldHVybjtcbiAgICAgICAgaW5wdXQuc2VxdWVuY2UgPSAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNJR0hBU0hfQU5ZT05FQ0FOUEFZOiBpZ25vcmUgaW5wdXRzIGVudGlyZWx5P1xuICAgIGlmIChoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgICB0eFRtcC5pbnMgPSBbdHhUbXAuaW5zW2luSW5kZXhdXTtcbiAgICAgIHR4VG1wLmluc1swXS5zY3JpcHQgPSBvdXJTY3JpcHQ7XG4gICAgICAvLyBTSUdIQVNIX0FMTDogb25seSBpZ25vcmUgaW5wdXQgc2NyaXB0c1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcImJsYW5rXCIgb3RoZXJzIGlucHV0IHNjcmlwdHNcbiAgICAgIHR4VG1wLmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgaW5wdXQuc2NyaXB0ID0gRU1QVFlfU0NSSVBUO1xuICAgICAgfSk7XG4gICAgICB0eFRtcC5pbnNbaW5JbmRleF0uc2NyaXB0ID0gb3VyU2NyaXB0O1xuICAgIH1cbiAgICAvLyBzZXJpYWxpemUgYW5kIGhhc2hcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhUbXAuYnl0ZUxlbmd0aChmYWxzZSkgKyA0KTtcbiAgICBidWZmZXIud3JpdGVJbnQzMkxFKGhhc2hUeXBlLCBidWZmZXIubGVuZ3RoIC0gNCk7XG4gICAgdHhUbXAuX190b0J1ZmZlcihidWZmZXIsIDAsIGZhbHNlKTtcbiAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KGJ1ZmZlcik7XG4gIH1cbiAgaGFzaEZvcldpdG5lc3NWMChpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCB2YWx1ZSwgaGFzaFR5cGUpIHtcbiAgICB0eXBlZm9yY2UoXG4gICAgICB0eXBlcy50dXBsZSh0eXBlcy5VSW50MzIsIHR5cGVzLkJ1ZmZlciwgdHlwZXMuU2F0b3NoaSwgdHlwZXMuVUludDMyKSxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICAgIGxldCB0YnVmZmVyID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGxldCB0b2Zmc2V0ID0gMDtcbiAgICBmdW5jdGlvbiB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgICB0b2Zmc2V0ICs9IHNsaWNlLmNvcHkodGJ1ZmZlciwgdG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVUludDMyKGkpIHtcbiAgICAgIHRvZmZzZXQgPSB0YnVmZmVyLndyaXRlVUludDMyTEUoaSwgdG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVUludDY0KGkpIHtcbiAgICAgIHRvZmZzZXQgPSBidWZmZXJ1dGlscy53cml0ZVVJbnQ2NExFKHRidWZmZXIsIGksIHRvZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZhckludChpKSB7XG4gICAgICB2YXJ1aW50LmVuY29kZShpLCB0YnVmZmVyLCB0b2Zmc2V0KTtcbiAgICAgIHRvZmZzZXQgKz0gdmFydWludC5lbmNvZGUuYnl0ZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVmFyU2xpY2Uoc2xpY2UpIHtcbiAgICAgIHdyaXRlVmFySW50KHNsaWNlLmxlbmd0aCk7XG4gICAgICB3cml0ZVNsaWNlKHNsaWNlKTtcbiAgICB9XG4gICAgbGV0IGhhc2hPdXRwdXRzID0gWkVSTztcbiAgICBsZXQgaGFzaFByZXZvdXRzID0gWkVSTztcbiAgICBsZXQgaGFzaFNlcXVlbmNlID0gWkVSTztcbiAgICBpZiAoIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSkge1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNiAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICB0b2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgIHdyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgICAgd3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hQcmV2b3V0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSAmJlxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFICYmXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FXG4gICAgKSB7XG4gICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKiB0aGlzLmlucy5sZW5ndGgpO1xuICAgICAgdG9mZnNldCA9IDA7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICB3cml0ZVVJbnQzMih0eEluLnNlcXVlbmNlKTtcbiAgICAgIH0pO1xuICAgICAgaGFzaFNlcXVlbmNlID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkVcbiAgICApIHtcbiAgICAgIGNvbnN0IHR4T3V0c1NpemUgPSB0aGlzLm91dHMucmVkdWNlKChzdW0sIG91dHB1dCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIH0sIDApO1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0eE91dHNTaXplKTtcbiAgICAgIHRvZmZzZXQgPSAwO1xuICAgICAgdGhpcy5vdXRzLmZvckVhY2gob3V0ID0+IHtcbiAgICAgICAgd3JpdGVVSW50NjQob3V0LnZhbHVlKTtcbiAgICAgICAgd3JpdGVWYXJTbGljZShvdXQuc2NyaXB0KTtcbiAgICAgIH0pO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgaW5JbmRleCA8IHRoaXMub3V0cy5sZW5ndGhcbiAgICApIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMub3V0c1tpbkluZGV4XTtcbiAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSk7XG4gICAgICB0b2Zmc2V0ID0gMDtcbiAgICAgIHdyaXRlVUludDY0KG91dHB1dC52YWx1ZSk7XG4gICAgICB3cml0ZVZhclNsaWNlKG91dHB1dC5zY3JpcHQpO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfVxuICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTU2ICsgdmFyU2xpY2VTaXplKHByZXZPdXRTY3JpcHQpKTtcbiAgICB0b2Zmc2V0ID0gMDtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5zW2luSW5kZXhdO1xuICAgIHdyaXRlVUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgd3JpdGVTbGljZShoYXNoUHJldm91dHMpO1xuICAgIHdyaXRlU2xpY2UoaGFzaFNlcXVlbmNlKTtcbiAgICB3cml0ZVNsaWNlKGlucHV0Lmhhc2gpO1xuICAgIHdyaXRlVUludDMyKGlucHV0LmluZGV4KTtcbiAgICB3cml0ZVZhclNsaWNlKHByZXZPdXRTY3JpcHQpO1xuICAgIHdyaXRlVUludDY0KHZhbHVlKTtcbiAgICB3cml0ZVVJbnQzMihpbnB1dC5zZXF1ZW5jZSk7XG4gICAgd3JpdGVTbGljZShoYXNoT3V0cHV0cyk7XG4gICAgd3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgd3JpdGVVSW50MzIoaGFzaFR5cGUpO1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gIH1cbiAgZ2V0SGFzaChmb3JXaXRuZXNzKSB7XG4gICAgLy8gd3R4aWQgZm9yIGNvaW5iYXNlIGlzIGFsd2F5cyAzMiBieXRlcyBvZiAweDAwXG4gICAgaWYgKGZvcldpdG5lc3MgJiYgdGhpcy5pc0NvaW5iYXNlKCkpIHJldHVybiBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGhpcy5fX3RvQnVmZmVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmb3JXaXRuZXNzKSk7XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgLy8gdHJhbnNhY3Rpb24gaGFzaCdzIGFyZSBkaXNwbGF5ZWQgaW4gcmV2ZXJzZSBvcmRlclxuICAgIHJldHVybiBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIodGhpcy5nZXRIYXNoKGZhbHNlKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHRvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9CdWZmZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0LCB0cnVlKTtcbiAgfVxuICB0b0hleCgpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcih1bmRlZmluZWQsIHVuZGVmaW5lZCkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHNldElucHV0U2NyaXB0KGluZGV4LCBzY3JpcHRTaWcpIHtcbiAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuTnVtYmVyLCB0eXBlcy5CdWZmZXIpLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5zW2luZGV4XS5zY3JpcHQgPSBzY3JpcHRTaWc7XG4gIH1cbiAgc2V0V2l0bmVzcyhpbmRleCwgd2l0bmVzcykge1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5OdW1iZXIsIFt0eXBlcy5CdWZmZXJdKSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLmluc1tpbmRleF0ud2l0bmVzcyA9IHdpdG5lc3M7XG4gIH1cbiAgX190b0J1ZmZlcihidWZmZXIsIGluaXRpYWxPZmZzZXQsIF9BTExPV19XSVRORVNTID0gZmFsc2UpIHtcbiAgICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUykpO1xuICAgIGxldCBvZmZzZXQgPSBpbml0aWFsT2Zmc2V0IHx8IDA7XG4gICAgZnVuY3Rpb24gd3JpdGVTbGljZShzbGljZSkge1xuICAgICAgb2Zmc2V0ICs9IHNsaWNlLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVJbnQ4KGkpIHtcbiAgICAgIG9mZnNldCA9IGJ1ZmZlci53cml0ZVVJbnQ4KGksIG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVUludDMyKGkpIHtcbiAgICAgIG9mZnNldCA9IGJ1ZmZlci53cml0ZVVJbnQzMkxFKGksIG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlSW50MzIoaSkge1xuICAgICAgb2Zmc2V0ID0gYnVmZmVyLndyaXRlSW50MzJMRShpLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVJbnQ2NChpKSB7XG4gICAgICBvZmZzZXQgPSBidWZmZXJ1dGlscy53cml0ZVVJbnQ2NExFKGJ1ZmZlciwgaSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVWYXJJbnQoaSkge1xuICAgICAgdmFydWludC5lbmNvZGUoaSwgYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RlLmJ5dGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgICB3cml0ZVZhckludChzbGljZS5sZW5ndGgpO1xuICAgICAgd3JpdGVTbGljZShzbGljZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVmVjdG9yKHZlY3Rvcikge1xuICAgICAgd3JpdGVWYXJJbnQodmVjdG9yLmxlbmd0aCk7XG4gICAgICB2ZWN0b3IuZm9yRWFjaCh3cml0ZVZhclNsaWNlKTtcbiAgICB9XG4gICAgd3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgIGNvbnN0IGhhc1dpdG5lc3NlcyA9IF9BTExPV19XSVRORVNTICYmIHRoaXMuaGFzV2l0bmVzc2VzKCk7XG4gICAgaWYgKGhhc1dpdG5lc3Nlcykge1xuICAgICAgd3JpdGVVSW50OChUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9NQVJLRVIpO1xuICAgICAgd3JpdGVVSW50OChUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHKTtcbiAgICB9XG4gICAgd3JpdGVWYXJJbnQodGhpcy5pbnMubGVuZ3RoKTtcbiAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgd3JpdGVTbGljZSh0eEluLmhhc2gpO1xuICAgICAgd3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICB3cml0ZVZhclNsaWNlKHR4SW4uc2NyaXB0KTtcbiAgICAgIHdyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgIH0pO1xuICAgIHdyaXRlVmFySW50KHRoaXMub3V0cy5sZW5ndGgpO1xuICAgIHRoaXMub3V0cy5mb3JFYWNoKHR4T3V0ID0+IHtcbiAgICAgIGlmIChpc091dHB1dCh0eE91dCkpIHtcbiAgICAgICAgd3JpdGVVSW50NjQodHhPdXQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVTbGljZSh0eE91dC52YWx1ZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICB3cml0ZVZhclNsaWNlKHR4T3V0LnNjcmlwdCk7XG4gICAgfSk7XG4gICAgaWYgKGhhc1dpdG5lc3Nlcykge1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIHdyaXRlVmVjdG9yKGlucHV0LndpdG5lc3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHdyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgIC8vIGF2b2lkIHNsaWNpbmcgdW5sZXNzIG5lY2Vzc2FyeVxuICAgIGlmIChpbml0aWFsT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHJldHVybiBidWZmZXIuc2xpY2UoaW5pdGlhbE9mZnNldCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG5UcmFuc2FjdGlvbi5ERUZBVUxUX1NFUVVFTkNFID0gMHhmZmZmZmZmZjtcblRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMID0gMHgwMTtcblRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSA9IDB4MDI7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSA9IDB4MDM7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSA9IDB4ODA7XG5UcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9NQVJLRVIgPSAweDAwO1xuVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBRyA9IDB4MDE7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKCcuL2J1ZmZlcnV0aWxzJyk7XG5jb25zdCBjbGFzc2lmeSA9IHJlcXVpcmUoJy4vY2xhc3NpZnknKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuY29uc3QgRUNQYWlyID0gcmVxdWlyZSgnLi9lY3BhaXInKTtcbmNvbnN0IG5ldHdvcmtzID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xuY29uc3QgcGF5bWVudHMgPSByZXF1aXJlKCcuL3BheW1lbnRzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgU0NSSVBUX1RZUEVTID0gY2xhc3NpZnkudHlwZXM7XG5jb25zdCBQUkVWT1VUX1RZUEVTID0gbmV3IFNldChbXG4gIC8vIFJhd1xuICAncDJwa2gnLFxuICAncDJwaycsXG4gICdwMndwa2gnLFxuICAncDJtcycsXG4gIC8vIFAyU0ggd3JhcHBlZFxuICAncDJzaC1wMnBraCcsXG4gICdwMnNoLXAycGsnLFxuICAncDJzaC1wMndwa2gnLFxuICAncDJzaC1wMm1zJyxcbiAgLy8gUDJXU0ggd3JhcHBlZFxuICAncDJ3c2gtcDJwa2gnLFxuICAncDJ3c2gtcDJwaycsXG4gICdwMndzaC1wMm1zJyxcbiAgLy8gUDJTSC1QMldTSCB3cmFwcGVyXG4gICdwMnNoLXAyd3NoLXAycGtoJyxcbiAgJ3Ayc2gtcDJ3c2gtcDJwaycsXG4gICdwMnNoLXAyd3NoLXAybXMnLFxuXSk7XG5mdW5jdGlvbiB0Zk1lc3NhZ2UodHlwZSwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICB0eXBlZm9yY2UodHlwZSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHR4SXNTdHJpbmcodHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eCA9PT0gJ3N0cmluZycgfHwgdHggaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5mdW5jdGlvbiB0eElzVHJhbnNhY3Rpb24odHgpIHtcbiAgcmV0dXJuIHR4IGluc3RhbmNlb2YgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbjtcbn1cbmNsYXNzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIC8vIFdBUk5JTkc6IG1heGltdW1GZWVSYXRlIGlzIF9fTk9UX18gdG8gYmUgcmVsaWVkIG9uLFxuICAvLyAgICAgICAgICBpdCdzIGp1c3QgYW5vdGhlciBwb3RlbnRpYWwgc2FmZXR5IG1lY2hhbmlzbSAoc2FmZXR5IGluLWRlcHRoKVxuICBjb25zdHJ1Y3RvcihuZXR3b3JrID0gbmV0d29ya3MuYml0Y29pbiwgbWF4aW11bUZlZVJhdGUgPSAyNTAwKSB7XG4gICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICB0aGlzLm1heGltdW1GZWVSYXRlID0gbWF4aW11bUZlZVJhdGU7XG4gICAgdGhpcy5fX1BSRVZfVFhfU0VUID0ge307XG4gICAgdGhpcy5fX0lOUFVUUyA9IFtdO1xuICAgIHRoaXMuX19UWCA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKCk7XG4gICAgdGhpcy5fX1RYLnZlcnNpb24gPSAyO1xuICAgIHRoaXMuX19VU0VfTE9XX1IgPSBmYWxzZTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnRGVwcmVjYXRpb24gV2FybmluZzogVHJhbnNhY3Rpb25CdWlsZGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiAnICtcbiAgICAgICAgJyh2Ni54Lnggb3IgbGF0ZXIpIFBsZWFzZSB1c2UgdGhlIFBzYnQgY2xhc3MgaW5zdGVhZC4gRXhhbXBsZXMgb2YgdXNhZ2UgJyArXG4gICAgICAgICdhcmUgYXZhaWxhYmxlIGluIHRoZSB0cmFuc2FjdGlvbnMtcHNidC5qcyBpbnRlZ3JhdGlvbiB0ZXN0IGZpbGUgb24gb3VyICcgK1xuICAgICAgICAnR2l0aHViLiBBIGhpZ2ggbGV2ZWwgZXhwbGFuYXRpb24gaXMgYXZhaWxhYmxlIGluIHRoZSBwc2J0LnRzIGFuZCBwc2J0LmpzICcgK1xuICAgICAgICAnZmlsZXMgYXMgd2VsbC4nLFxuICAgICk7XG4gIH1cbiAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgbmV0d29yaykge1xuICAgIGNvbnN0IHR4YiA9IG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXIobmV0d29yayk7XG4gICAgLy8gQ29weSB0cmFuc2FjdGlvbiBmaWVsZHNcbiAgICB0eGIuc2V0VmVyc2lvbih0cmFuc2FjdGlvbi52ZXJzaW9uKTtcbiAgICB0eGIuc2V0TG9ja1RpbWUodHJhbnNhY3Rpb24ubG9ja3RpbWUpO1xuICAgIC8vIENvcHkgb3V0cHV0cyAoZG9uZSBmaXJzdCB0byBhdm9pZCBzaWduYXR1cmUgaW52YWxpZGF0aW9uKVxuICAgIHRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaCh0eE91dCA9PiB7XG4gICAgICB0eGIuYWRkT3V0cHV0KHR4T3V0LnNjcmlwdCwgdHhPdXQudmFsdWUpO1xuICAgIH0pO1xuICAgIC8vIENvcHkgaW5wdXRzXG4gICAgdHJhbnNhY3Rpb24uaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICB0eGIuX19hZGRJbnB1dFVuc2FmZSh0eEluLmhhc2gsIHR4SW4uaW5kZXgsIHtcbiAgICAgICAgc2VxdWVuY2U6IHR4SW4uc2VxdWVuY2UsXG4gICAgICAgIHNjcmlwdDogdHhJbi5zY3JpcHQsXG4gICAgICAgIHdpdG5lc3M6IHR4SW4ud2l0bmVzcyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIGZpeCBzb21lIHRoaW5ncyBub3QgcG9zc2libGUgdGhyb3VnaCB0aGUgcHVibGljIEFQSVxuICAgIHR4Yi5fX0lOUFVUUy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgZml4TXVsdGlzaWdPcmRlcihpbnB1dCwgdHJhbnNhY3Rpb24sIGkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0eGI7XG4gIH1cbiAgc2V0TG93UihzZXR0aW5nKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVmb3JjZS5tYXliZSh0eXBlZm9yY2UuQm9vbGVhbiksIHNldHRpbmcpO1xuICAgIGlmIChzZXR0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldHRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9fVVNFX0xPV19SID0gc2V0dGluZztcbiAgICByZXR1cm4gc2V0dGluZztcbiAgfVxuICBzZXRMb2NrVGltZShsb2NrdGltZSkge1xuICAgIHR5cGVmb3JjZSh0eXBlcy5VSW50MzIsIGxvY2t0aW1lKTtcbiAgICAvLyBpZiBhbnkgc2lnbmF0dXJlcyBleGlzdCwgdGhyb3dcbiAgICBpZiAoXG4gICAgICB0aGlzLl9fSU5QVVRTLnNvbWUoaW5wdXQgPT4ge1xuICAgICAgICBpZiAoIWlucHV0LnNpZ25hdHVyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGlucHV0LnNpZ25hdHVyZXMuc29tZShzID0+IHMgIT09IHVuZGVmaW5lZCk7XG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObywgdGhpcyB3b3VsZCBpbnZhbGlkYXRlIHNpZ25hdHVyZXMnKTtcbiAgICB9XG4gICAgdGhpcy5fX1RYLmxvY2t0aW1lID0gbG9ja3RpbWU7XG4gIH1cbiAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLlVJbnQzMiwgdmVyc2lvbik7XG4gICAgLy8gWFhYOiB0aGlzIG1pZ2h0IGV2ZW50dWFsbHkgYmVjb21lIG1vcmUgY29tcGxleCBkZXBlbmRpbmcgb24gd2hhdCB0aGUgdmVyc2lvbnMgcmVwcmVzZW50XG4gICAgdGhpcy5fX1RYLnZlcnNpb24gPSB2ZXJzaW9uO1xuICB9XG4gIGFkZElucHV0KHR4SGFzaCwgdm91dCwgc2VxdWVuY2UsIHByZXZPdXRTY3JpcHQpIHtcbiAgICBpZiAoIXRoaXMuX19jYW5Nb2RpZnlJbnB1dHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObywgdGhpcyB3b3VsZCBpbnZhbGlkYXRlIHNpZ25hdHVyZXMnKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlO1xuICAgIC8vIGlzIGl0IGEgaGV4IHN0cmluZz9cbiAgICBpZiAodHhJc1N0cmluZyh0eEhhc2gpKSB7XG4gICAgICAvLyB0cmFuc2FjdGlvbiBoYXNocydzIGFyZSBkaXNwbGF5ZWQgaW4gcmV2ZXJzZSBvcmRlciwgdW4tcmV2ZXJzZSBpdFxuICAgICAgdHhIYXNoID0gYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHR4SGFzaCwgJ2hleCcpKTtcbiAgICAgIC8vIGlzIGl0IGEgVHJhbnNhY3Rpb24gb2JqZWN0P1xuICAgIH0gZWxzZSBpZiAodHhJc1RyYW5zYWN0aW9uKHR4SGFzaCkpIHtcbiAgICAgIGNvbnN0IHR4T3V0ID0gdHhIYXNoLm91dHNbdm91dF07XG4gICAgICBwcmV2T3V0U2NyaXB0ID0gdHhPdXQuc2NyaXB0O1xuICAgICAgdmFsdWUgPSB0eE91dC52YWx1ZTtcbiAgICAgIHR4SGFzaCA9IHR4SGFzaC5nZXRIYXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19hZGRJbnB1dFVuc2FmZSh0eEhhc2gsIHZvdXQsIHtcbiAgICAgIHNlcXVlbmNlLFxuICAgICAgcHJldk91dFNjcmlwdCxcbiAgICAgIHZhbHVlLFxuICAgIH0pO1xuICB9XG4gIGFkZE91dHB1dChzY3JpcHRQdWJLZXksIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl9fY2FuTW9kaWZ5T3V0cHV0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vLCB0aGlzIHdvdWxkIGludmFsaWRhdGUgc2lnbmF0dXJlcycpO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIGdldCBhIHNjcmlwdCBpZiBpdCdzIGEgYmFzZTU4IG9yIGJlY2gzMiBhZGRyZXNzIHN0cmluZ1xuICAgIGlmICh0eXBlb2Ygc2NyaXB0UHViS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgc2NyaXB0UHViS2V5ID0gYmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoc2NyaXB0UHViS2V5LCB0aGlzLm5ldHdvcmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX1RYLmFkZE91dHB1dChzY3JpcHRQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2J1aWxkKGZhbHNlKTtcbiAgfVxuICBidWlsZEluY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19idWlsZCh0cnVlKTtcbiAgfVxuICBzaWduKFxuICAgIHNpZ25QYXJhbXMsXG4gICAga2V5UGFpcixcbiAgICByZWRlZW1TY3JpcHQsXG4gICAgaGFzaFR5cGUsXG4gICAgd2l0bmVzc1ZhbHVlLFxuICAgIHdpdG5lc3NTY3JpcHQsXG4gICkge1xuICAgIHRyeVNpZ24oXG4gICAgICBnZXRTaWduaW5nRGF0YShcbiAgICAgICAgdGhpcy5uZXR3b3JrLFxuICAgICAgICB0aGlzLl9fSU5QVVRTLFxuICAgICAgICB0aGlzLl9fbmVlZHNPdXRwdXRzLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMuX19UWCxcbiAgICAgICAgc2lnblBhcmFtcyxcbiAgICAgICAga2V5UGFpcixcbiAgICAgICAgcmVkZWVtU2NyaXB0LFxuICAgICAgICBoYXNoVHlwZSxcbiAgICAgICAgd2l0bmVzc1ZhbHVlLFxuICAgICAgICB3aXRuZXNzU2NyaXB0LFxuICAgICAgICB0aGlzLl9fVVNFX0xPV19SLFxuICAgICAgKSxcbiAgICApO1xuICB9XG4gIF9fYWRkSW5wdXRVbnNhZmUodHhIYXNoLCB2b3V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uaXNDb2luYmFzZUhhc2godHhIYXNoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2luYmFzZSBpbnB1dHMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2VHhPdXQgPSB0eEhhc2gudG9TdHJpbmcoJ2hleCcpICsgJzonICsgdm91dDtcbiAgICBpZiAodGhpcy5fX1BSRVZfVFhfU0VUW3ByZXZUeE91dF0gIT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIFR4T3V0OiAnICsgcHJldlR4T3V0KTtcbiAgICBsZXQgaW5wdXQgPSB7fTtcbiAgICAvLyBkZXJpdmUgd2hhdCB3ZSBjYW4gZnJvbSB0aGUgc2NyaXB0U2lnXG4gICAgaWYgKG9wdGlvbnMuc2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlucHV0ID0gZXhwYW5kSW5wdXQob3B0aW9ucy5zY3JpcHQsIG9wdGlvbnMud2l0bmVzcyB8fCBbXSk7XG4gICAgfVxuICAgIC8vIGlmIGFuIGlucHV0IHZhbHVlIHdhcyBnaXZlbiwgcmV0YWluIGl0XG4gICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5wdXQudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgICAvLyBkZXJpdmUgd2hhdCB3ZSBjYW4gZnJvbSB0aGUgcHJldmlvdXMgdHJhbnNhY3Rpb25zIG91dHB1dCBzY3JpcHRcbiAgICBpZiAoIWlucHV0LnByZXZPdXRTY3JpcHQgJiYgb3B0aW9ucy5wcmV2T3V0U2NyaXB0KSB7XG4gICAgICBsZXQgcHJldk91dFR5cGU7XG4gICAgICBpZiAoIWlucHV0LnB1YmtleXMgJiYgIWlucHV0LnNpZ25hdHVyZXMpIHtcbiAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRPdXRwdXQob3B0aW9ucy5wcmV2T3V0U2NyaXB0KTtcbiAgICAgICAgaWYgKGV4cGFuZGVkLnB1YmtleXMpIHtcbiAgICAgICAgICBpbnB1dC5wdWJrZXlzID0gZXhwYW5kZWQucHVia2V5cztcbiAgICAgICAgICBpbnB1dC5zaWduYXR1cmVzID0gZXhwYW5kZWQuc2lnbmF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICBwcmV2T3V0VHlwZSA9IGV4cGFuZGVkLnR5cGU7XG4gICAgICB9XG4gICAgICBpbnB1dC5wcmV2T3V0U2NyaXB0ID0gb3B0aW9ucy5wcmV2T3V0U2NyaXB0O1xuICAgICAgaW5wdXQucHJldk91dFR5cGUgPSBwcmV2T3V0VHlwZSB8fCBjbGFzc2lmeS5vdXRwdXQob3B0aW9ucy5wcmV2T3V0U2NyaXB0KTtcbiAgICB9XG4gICAgY29uc3QgdmluID0gdGhpcy5fX1RYLmFkZElucHV0KFxuICAgICAgdHhIYXNoLFxuICAgICAgdm91dCxcbiAgICAgIG9wdGlvbnMuc2VxdWVuY2UsXG4gICAgICBvcHRpb25zLnNjcmlwdFNpZyxcbiAgICApO1xuICAgIHRoaXMuX19JTlBVVFNbdmluXSA9IGlucHV0O1xuICAgIHRoaXMuX19QUkVWX1RYX1NFVFtwcmV2VHhPdXRdID0gdHJ1ZTtcbiAgICByZXR1cm4gdmluO1xuICB9XG4gIF9fYnVpbGQoYWxsb3dJbmNvbXBsZXRlKSB7XG4gICAgaWYgKCFhbGxvd0luY29tcGxldGUpIHtcbiAgICAgIGlmICghdGhpcy5fX1RYLmlucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIGlucHV0cycpO1xuICAgICAgaWYgKCF0aGlzLl9fVFgub3V0cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIG91dHB1dHMnKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB0aGlzLl9fVFguY2xvbmUoKTtcbiAgICAvLyBjcmVhdGUgc2NyaXB0IHNpZ25hdHVyZXMgZnJvbSBpbnB1dHNcbiAgICB0aGlzLl9fSU5QVVRTLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICBpZiAoIWlucHV0LnByZXZPdXRUeXBlICYmICFhbGxvd0luY29tcGxldGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBidWlsZChpbnB1dC5wcmV2T3V0VHlwZSwgaW5wdXQsIGFsbG93SW5jb21wbGV0ZSk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBpZiAoIWFsbG93SW5jb21wbGV0ZSAmJiBpbnB1dC5wcmV2T3V0VHlwZSA9PT0gU0NSSVBUX1RZUEVTLk5PTlNUQU5EQVJEKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnB1dCB0eXBlJyk7XG4gICAgICAgIGlmICghYWxsb3dJbmNvbXBsZXRlKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBlbm91Z2ggaW5mb3JtYXRpb24nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHguc2V0SW5wdXRTY3JpcHQoaSwgcmVzdWx0LmlucHV0KTtcbiAgICAgIHR4LnNldFdpdG5lc3MoaSwgcmVzdWx0LndpdG5lc3MpO1xuICAgIH0pO1xuICAgIGlmICghYWxsb3dJbmNvbXBsZXRlKSB7XG4gICAgICAvLyBkbyBub3QgcmVseSBvbiB0aGlzLCBpdHMgbWVyZWx5IGEgbGFzdCByZXNvcnRcbiAgICAgIGlmICh0aGlzLl9fb3Zlck1heGltdW1GZWVzKHR4LnZpcnR1YWxTaXplKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIGFic3VyZCBmZWVzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eDtcbiAgfVxuICBfX2Nhbk1vZGlmeUlucHV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX0lOUFVUUy5ldmVyeShpbnB1dCA9PiB7XG4gICAgICBpZiAoIWlucHV0LnNpZ25hdHVyZXMpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGlucHV0LnNpZ25hdHVyZXMuZXZlcnkoc2lnbmF0dXJlID0+IHtcbiAgICAgICAgaWYgKCFzaWduYXR1cmUpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBoYXNoVHlwZSA9IHNpZ25hdHVyZUhhc2hUeXBlKHNpZ25hdHVyZSk7XG4gICAgICAgIC8vIGlmIFNJR0hBU0hfQU5ZT05FQ0FOUEFZIGlzIHNldCwgc2lnbmF0dXJlcyB3b3VsZCBub3RcbiAgICAgICAgLy8gYmUgaW52YWxpZGF0ZWQgYnkgbW9yZSBpbnB1dHNcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaGFzaFR5cGUgJiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSAhPT0gMFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX19uZWVkc091dHB1dHMoc2lnbmluZ0hhc2hUeXBlKSB7XG4gICAgaWYgKHNpZ25pbmdIYXNoVHlwZSA9PT0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19UWC5vdXRzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgLy8gaWYgaW5wdXRzIGFyZSBiZWluZyBzaWduZWQgd2l0aCBTSUdIQVNIX05PTkUsIHdlIGRvbid0IHN0cmljdGx5IG5lZWQgb3V0cHV0c1xuICAgIC8vIC5idWlsZCgpIHdpbGwgZmFpbCwgYnV0IC5idWlsZEluY29tcGxldGUoKSBpcyBPS1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9fVFgub3V0cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHRoaXMuX19JTlBVVFMuc29tZShpbnB1dCA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuc2lnbmF0dXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gaW5wdXQuc2lnbmF0dXJlcy5zb21lKHNpZ25hdHVyZSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYXR1cmUpIHJldHVybiBmYWxzZTsgLy8gbm8gc2lnbmF0dXJlLCBubyBpc3N1ZVxuICAgICAgICAgIGNvbnN0IGhhc2hUeXBlID0gc2lnbmF0dXJlSGFzaFR5cGUoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoaGFzaFR5cGUgJiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkgcmV0dXJuIGZhbHNlOyAvLyBTSUdIQVNIX05PTkUgZG9lc24ndCBjYXJlIGFib3V0IG91dHB1dHNcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU0lHSEFTSF8qIGRvZXMgY2FyZVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBfX2Nhbk1vZGlmeU91dHB1dHMoKSB7XG4gICAgY29uc3QgbklucHV0cyA9IHRoaXMuX19UWC5pbnMubGVuZ3RoO1xuICAgIGNvbnN0IG5PdXRwdXRzID0gdGhpcy5fX1RYLm91dHMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9fSU5QVVRTLmV2ZXJ5KGlucHV0ID0+IHtcbiAgICAgIGlmIChpbnB1dC5zaWduYXR1cmVzID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGlucHV0LnNpZ25hdHVyZXMuZXZlcnkoc2lnbmF0dXJlID0+IHtcbiAgICAgICAgaWYgKCFzaWduYXR1cmUpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBoYXNoVHlwZSA9IHNpZ25hdHVyZUhhc2hUeXBlKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGhhc2hUeXBlTW9kID0gaGFzaFR5cGUgJiAweDFmO1xuICAgICAgICBpZiAoaGFzaFR5cGVNb2QgPT09IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc2hUeXBlTW9kID09PSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgICAgICAgLy8gaWYgU0lHSEFTSF9TSU5HTEUgaXMgc2V0LCBhbmQgbklucHV0cyA+IG5PdXRwdXRzXG4gICAgICAgICAgLy8gc29tZSBzaWduYXR1cmVzIHdvdWxkIGJlIGludmFsaWRhdGVkIGJ5IHRoZSBhZGRpdGlvblxuICAgICAgICAgIC8vIG9mIG1vcmUgb3V0cHV0c1xuICAgICAgICAgIHJldHVybiBuSW5wdXRzIDw9IG5PdXRwdXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9fb3Zlck1heGltdW1GZWVzKGJ5dGVzKSB7XG4gICAgLy8gbm90IGFsbCBpbnB1dHMgd2lsbCBoYXZlIC52YWx1ZSBkZWZpbmVkXG4gICAgY29uc3QgaW5jb21pbmcgPSB0aGlzLl9fSU5QVVRTLnJlZHVjZSgoYSwgeCkgPT4gYSArICh4LnZhbHVlID4+PiAwKSwgMCk7XG4gICAgLy8gYnV0IGFsbCBvdXRwdXRzIGRvLCBhbmQgaWYgd2UgaGF2ZSBhbnkgaW5wdXQgdmFsdWVcbiAgICAvLyB3ZSBjYW4gaW1tZWRpYXRlbHkgZGV0ZXJtaW5lIGlmIHRoZSBvdXRwdXRzIGFyZSB0b28gc21hbGxcbiAgICBjb25zdCBvdXRnb2luZyA9IHRoaXMuX19UWC5vdXRzLnJlZHVjZSgoYSwgeCkgPT4gYSArIHgudmFsdWUsIDApO1xuICAgIGNvbnN0IGZlZSA9IGluY29taW5nIC0gb3V0Z29pbmc7XG4gICAgY29uc3QgZmVlUmF0ZSA9IGZlZSAvIGJ5dGVzO1xuICAgIHJldHVybiBmZWVSYXRlID4gdGhpcy5tYXhpbXVtRmVlUmF0ZTtcbiAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbkJ1aWxkZXIgPSBUcmFuc2FjdGlvbkJ1aWxkZXI7XG5mdW5jdGlvbiBleHBhbmRJbnB1dChzY3JpcHRTaWcsIHdpdG5lc3NTdGFjaywgdHlwZSwgc2NyaXB0UHViS2V5KSB7XG4gIGlmIChzY3JpcHRTaWcubGVuZ3RoID09PSAwICYmIHdpdG5lc3NTdGFjay5sZW5ndGggPT09IDApIHJldHVybiB7fTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgbGV0IHNzVHlwZSA9IGNsYXNzaWZ5LmlucHV0KHNjcmlwdFNpZywgdHJ1ZSk7XG4gICAgbGV0IHdzVHlwZSA9IGNsYXNzaWZ5LndpdG5lc3Mod2l0bmVzc1N0YWNrLCB0cnVlKTtcbiAgICBpZiAoc3NUeXBlID09PSBTQ1JJUFRfVFlQRVMuTk9OU1RBTkRBUkQpIHNzVHlwZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAod3NUeXBlID09PSBTQ1JJUFRfVFlQRVMuTk9OU1RBTkRBUkQpIHdzVHlwZSA9IHVuZGVmaW5lZDtcbiAgICB0eXBlID0gc3NUeXBlIHx8IHdzVHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMldQS0g6IHtcbiAgICAgIGNvbnN0IHsgb3V0cHV0LCBwdWJrZXksIHNpZ25hdHVyZSB9ID0gcGF5bWVudHMucDJ3cGtoKHtcbiAgICAgICAgd2l0bmVzczogd2l0bmVzc1N0YWNrLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmV2T3V0U2NyaXB0OiBvdXRwdXQsXG4gICAgICAgIHByZXZPdXRUeXBlOiBTQ1JJUFRfVFlQRVMuUDJXUEtILFxuICAgICAgICBwdWJrZXlzOiBbcHVia2V5XSxcbiAgICAgICAgc2lnbmF0dXJlczogW3NpZ25hdHVyZV0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMlBLSDoge1xuICAgICAgY29uc3QgeyBvdXRwdXQsIHB1YmtleSwgc2lnbmF0dXJlIH0gPSBwYXltZW50cy5wMnBraCh7XG4gICAgICAgIGlucHV0OiBzY3JpcHRTaWcsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZXZPdXRTY3JpcHQ6IG91dHB1dCxcbiAgICAgICAgcHJldk91dFR5cGU6IFNDUklQVF9UWVBFUy5QMlBLSCxcbiAgICAgICAgcHVia2V5czogW3B1YmtleV0sXG4gICAgICAgIHNpZ25hdHVyZXM6IFtzaWduYXR1cmVdLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBTQ1JJUFRfVFlQRVMuUDJQSzoge1xuICAgICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IHBheW1lbnRzLnAycGsoeyBpbnB1dDogc2NyaXB0U2lnIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJldk91dFR5cGU6IFNDUklQVF9UWVBFUy5QMlBLLFxuICAgICAgICBwdWJrZXlzOiBbdW5kZWZpbmVkXSxcbiAgICAgICAgc2lnbmF0dXJlczogW3NpZ25hdHVyZV0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMk1TOiB7XG4gICAgICBjb25zdCB7IG0sIHB1YmtleXMsIHNpZ25hdHVyZXMgfSA9IHBheW1lbnRzLnAybXMoXG4gICAgICAgIHtcbiAgICAgICAgICBpbnB1dDogc2NyaXB0U2lnLFxuICAgICAgICAgIG91dHB1dDogc2NyaXB0UHViS2V5LFxuICAgICAgICB9LFxuICAgICAgICB7IGFsbG93SW5jb21wbGV0ZTogdHJ1ZSB9LFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZXZPdXRUeXBlOiBTQ1JJUFRfVFlQRVMuUDJNUyxcbiAgICAgICAgcHVia2V5cyxcbiAgICAgICAgc2lnbmF0dXJlcyxcbiAgICAgICAgbWF4U2lnbmF0dXJlczogbSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICh0eXBlID09PSBTQ1JJUFRfVFlQRVMuUDJTSCkge1xuICAgIGNvbnN0IHsgb3V0cHV0LCByZWRlZW0gfSA9IHBheW1lbnRzLnAyc2goe1xuICAgICAgaW5wdXQ6IHNjcmlwdFNpZyxcbiAgICAgIHdpdG5lc3M6IHdpdG5lc3NTdGFjayxcbiAgICB9KTtcbiAgICBjb25zdCBvdXRwdXRUeXBlID0gY2xhc3NpZnkub3V0cHV0KHJlZGVlbS5vdXRwdXQpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kSW5wdXQoXG4gICAgICByZWRlZW0uaW5wdXQsXG4gICAgICByZWRlZW0ud2l0bmVzcyxcbiAgICAgIG91dHB1dFR5cGUsXG4gICAgICByZWRlZW0ub3V0cHV0LFxuICAgICk7XG4gICAgaWYgKCFleHBhbmRlZC5wcmV2T3V0VHlwZSkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7XG4gICAgICBwcmV2T3V0U2NyaXB0OiBvdXRwdXQsXG4gICAgICBwcmV2T3V0VHlwZTogU0NSSVBUX1RZUEVTLlAyU0gsXG4gICAgICByZWRlZW1TY3JpcHQ6IHJlZGVlbS5vdXRwdXQsXG4gICAgICByZWRlZW1TY3JpcHRUeXBlOiBleHBhbmRlZC5wcmV2T3V0VHlwZSxcbiAgICAgIHdpdG5lc3NTY3JpcHQ6IGV4cGFuZGVkLndpdG5lc3NTY3JpcHQsXG4gICAgICB3aXRuZXNzU2NyaXB0VHlwZTogZXhwYW5kZWQud2l0bmVzc1NjcmlwdFR5cGUsXG4gICAgICBwdWJrZXlzOiBleHBhbmRlZC5wdWJrZXlzLFxuICAgICAgc2lnbmF0dXJlczogZXhwYW5kZWQuc2lnbmF0dXJlcyxcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlID09PSBTQ1JJUFRfVFlQRVMuUDJXU0gpIHtcbiAgICBjb25zdCB7IG91dHB1dCwgcmVkZWVtIH0gPSBwYXltZW50cy5wMndzaCh7XG4gICAgICBpbnB1dDogc2NyaXB0U2lnLFxuICAgICAgd2l0bmVzczogd2l0bmVzc1N0YWNrLFxuICAgIH0pO1xuICAgIGNvbnN0IG91dHB1dFR5cGUgPSBjbGFzc2lmeS5vdXRwdXQocmVkZWVtLm91dHB1dCk7XG4gICAgbGV0IGV4cGFuZGVkO1xuICAgIGlmIChvdXRwdXRUeXBlID09PSBTQ1JJUFRfVFlQRVMuUDJXUEtIKSB7XG4gICAgICBleHBhbmRlZCA9IGV4cGFuZElucHV0KHJlZGVlbS5pbnB1dCwgcmVkZWVtLndpdG5lc3MsIG91dHB1dFR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRlZCA9IGV4cGFuZElucHV0KFxuICAgICAgICBic2NyaXB0LmNvbXBpbGUocmVkZWVtLndpdG5lc3MpLFxuICAgICAgICBbXSxcbiAgICAgICAgb3V0cHV0VHlwZSxcbiAgICAgICAgcmVkZWVtLm91dHB1dCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZXhwYW5kZWQucHJldk91dFR5cGUpIHJldHVybiB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJldk91dFNjcmlwdDogb3V0cHV0LFxuICAgICAgcHJldk91dFR5cGU6IFNDUklQVF9UWVBFUy5QMldTSCxcbiAgICAgIHdpdG5lc3NTY3JpcHQ6IHJlZGVlbS5vdXRwdXQsXG4gICAgICB3aXRuZXNzU2NyaXB0VHlwZTogZXhwYW5kZWQucHJldk91dFR5cGUsXG4gICAgICBwdWJrZXlzOiBleHBhbmRlZC5wdWJrZXlzLFxuICAgICAgc2lnbmF0dXJlczogZXhwYW5kZWQuc2lnbmF0dXJlcyxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJldk91dFR5cGU6IFNDUklQVF9UWVBFUy5OT05TVEFOREFSRCxcbiAgICBwcmV2T3V0U2NyaXB0OiBzY3JpcHRTaWcsXG4gIH07XG59XG4vLyBjb3VsZCBiZSBkb25lIGluIGV4cGFuZElucHV0LCBidXQgcmVxdWlyZXMgdGhlIG9yaWdpbmFsIFRyYW5zYWN0aW9uIGZvciBoYXNoRm9yU2lnbmF0dXJlXG5mdW5jdGlvbiBmaXhNdWx0aXNpZ09yZGVyKGlucHV0LCB0cmFuc2FjdGlvbiwgdmluKSB7XG4gIGlmIChpbnB1dC5yZWRlZW1TY3JpcHRUeXBlICE9PSBTQ1JJUFRfVFlQRVMuUDJNUyB8fCAhaW5wdXQucmVkZWVtU2NyaXB0KVxuICAgIHJldHVybjtcbiAgaWYgKGlucHV0LnB1YmtleXMubGVuZ3RoID09PSBpbnB1dC5zaWduYXR1cmVzLmxlbmd0aCkgcmV0dXJuO1xuICBjb25zdCB1bm1hdGNoZWQgPSBpbnB1dC5zaWduYXR1cmVzLmNvbmNhdCgpO1xuICBpbnB1dC5zaWduYXR1cmVzID0gaW5wdXQucHVia2V5cy5tYXAocHViS2V5ID0+IHtcbiAgICBjb25zdCBrZXlQYWlyID0gRUNQYWlyLmZyb21QdWJsaWNLZXkocHViS2V5KTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gY2hlY2sgZm9yIGEgc2lnbmF0dXJlXG4gICAgdW5tYXRjaGVkLnNvbWUoKHNpZ25hdHVyZSwgaSkgPT4ge1xuICAgICAgLy8gc2tpcCBpZiB1bmRlZmluZWQgfHwgT1BfMFxuICAgICAgaWYgKCFzaWduYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIFRPRE86IGF2b2lkIE8obikgaGFzaEZvclNpZ25hdHVyZVxuICAgICAgY29uc3QgcGFyc2VkID0gYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlKHNpZ25hdHVyZSk7XG4gICAgICBjb25zdCBoYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvclNpZ25hdHVyZShcbiAgICAgICAgdmluLFxuICAgICAgICBpbnB1dC5yZWRlZW1TY3JpcHQsXG4gICAgICAgIHBhcnNlZC5oYXNoVHlwZSxcbiAgICAgICk7XG4gICAgICAvLyBza2lwIGlmIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBwdWJLZXlcbiAgICAgIGlmICgha2V5UGFpci52ZXJpZnkoaGFzaCwgcGFyc2VkLnNpZ25hdHVyZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHJlbW92ZSBtYXRjaGVkIHNpZ25hdHVyZSBmcm9tIHVubWF0Y2hlZFxuICAgICAgdW5tYXRjaGVkW2ldID0gdW5kZWZpbmVkO1xuICAgICAgbWF0Y2ggPSBzaWduYXR1cmU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xufVxuZnVuY3Rpb24gZXhwYW5kT3V0cHV0KHNjcmlwdCwgb3VyUHViS2V5KSB7XG4gIHR5cGVmb3JjZSh0eXBlcy5CdWZmZXIsIHNjcmlwdCk7XG4gIGNvbnN0IHR5cGUgPSBjbGFzc2lmeS5vdXRwdXQoc2NyaXB0KTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTQ1JJUFRfVFlQRVMuUDJQS0g6IHtcbiAgICAgIGlmICghb3VyUHViS2V5KSByZXR1cm4geyB0eXBlIH07XG4gICAgICAvLyBkb2VzIG91ciBoYXNoMTYwKHB1YktleSkgbWF0Y2ggdGhlIG91dHB1dCBzY3JpcHRzP1xuICAgICAgY29uc3QgcGtoMSA9IHBheW1lbnRzLnAycGtoKHsgb3V0cHV0OiBzY3JpcHQgfSkuaGFzaDtcbiAgICAgIGNvbnN0IHBraDIgPSBiY3J5cHRvLmhhc2gxNjAob3VyUHViS2V5KTtcbiAgICAgIGlmICghcGtoMS5lcXVhbHMocGtoMikpIHJldHVybiB7IHR5cGUgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHB1YmtleXM6IFtvdXJQdWJLZXldLFxuICAgICAgICBzaWduYXR1cmVzOiBbdW5kZWZpbmVkXSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgU0NSSVBUX1RZUEVTLlAyV1BLSDoge1xuICAgICAgaWYgKCFvdXJQdWJLZXkpIHJldHVybiB7IHR5cGUgfTtcbiAgICAgIC8vIGRvZXMgb3VyIGhhc2gxNjAocHViS2V5KSBtYXRjaCB0aGUgb3V0cHV0IHNjcmlwdHM/XG4gICAgICBjb25zdCB3cGtoMSA9IHBheW1lbnRzLnAyd3BraCh7IG91dHB1dDogc2NyaXB0IH0pLmhhc2g7XG4gICAgICBjb25zdCB3cGtoMiA9IGJjcnlwdG8uaGFzaDE2MChvdXJQdWJLZXkpO1xuICAgICAgaWYgKCF3cGtoMS5lcXVhbHMod3BraDIpKSByZXR1cm4geyB0eXBlIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwdWJrZXlzOiBbb3VyUHViS2V5XSxcbiAgICAgICAgc2lnbmF0dXJlczogW3VuZGVmaW5lZF0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMlBLOiB7XG4gICAgICBjb25zdCBwMnBrID0gcGF5bWVudHMucDJwayh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHVia2V5czogW3AycGsucHVia2V5XSxcbiAgICAgICAgc2lnbmF0dXJlczogW3VuZGVmaW5lZF0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMk1TOiB7XG4gICAgICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHVia2V5czogcDJtcy5wdWJrZXlzLFxuICAgICAgICBzaWduYXR1cmVzOiBwMm1zLnB1YmtleXMubWFwKCgpID0+IHVuZGVmaW5lZCksXG4gICAgICAgIG1heFNpZ25hdHVyZXM6IHAybXMubSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVJbnB1dChpbnB1dCwgb3VyUHViS2V5LCByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQpIHtcbiAgaWYgKHJlZGVlbVNjcmlwdCAmJiB3aXRuZXNzU2NyaXB0KSB7XG4gICAgY29uc3QgcDJ3c2ggPSBwYXltZW50cy5wMndzaCh7XG4gICAgICByZWRlZW06IHsgb3V0cHV0OiB3aXRuZXNzU2NyaXB0IH0sXG4gICAgfSk7XG4gICAgY29uc3QgcDJ3c2hBbHQgPSBwYXltZW50cy5wMndzaCh7IG91dHB1dDogcmVkZWVtU2NyaXB0IH0pO1xuICAgIGNvbnN0IHAyc2ggPSBwYXltZW50cy5wMnNoKHsgcmVkZWVtOiB7IG91dHB1dDogcmVkZWVtU2NyaXB0IH0gfSk7XG4gICAgY29uc3QgcDJzaEFsdCA9IHBheW1lbnRzLnAyc2goeyByZWRlZW06IHAyd3NoIH0pO1xuICAgIC8vIGVuZm9yY2VzIFAyU0goUDJXU0goLi4uKSlcbiAgICBpZiAoIXAyd3NoLmhhc2guZXF1YWxzKHAyd3NoQWx0Lmhhc2gpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRuZXNzIHNjcmlwdCBpbmNvbnNpc3RlbnQgd2l0aCBwcmV2T3V0U2NyaXB0Jyk7XG4gICAgaWYgKCFwMnNoLmhhc2guZXF1YWxzKHAyc2hBbHQuaGFzaCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZGVlbSBzY3JpcHQgaW5jb25zaXN0ZW50IHdpdGggcHJldk91dFNjcmlwdCcpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kT3V0cHV0KHAyd3NoLnJlZGVlbS5vdXRwdXQsIG91clB1YktleSk7XG4gICAgaWYgKCFleHBhbmRlZC5wdWJrZXlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBleHBhbmRlZC50eXBlICtcbiAgICAgICAgICAnIG5vdCBzdXBwb3J0ZWQgYXMgd2l0bmVzc1NjcmlwdCAoJyArXG4gICAgICAgICAgYnNjcmlwdC50b0FTTSh3aXRuZXNzU2NyaXB0KSArXG4gICAgICAgICAgJyknLFxuICAgICAgKTtcbiAgICBpZiAoaW5wdXQuc2lnbmF0dXJlcyAmJiBpbnB1dC5zaWduYXR1cmVzLnNvbWUoeCA9PiB4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBleHBhbmRlZC5zaWduYXR1cmVzID0gaW5wdXQuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgY29uc3Qgc2lnblNjcmlwdCA9IHdpdG5lc3NTY3JpcHQ7XG4gICAgaWYgKGV4cGFuZGVkLnR5cGUgPT09IFNDUklQVF9UWVBFUy5QMldQS0gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1AyU0goUDJXU0goUDJXUEtIKSkgaXMgYSBjb25zZW5zdXMgZmFpbHVyZScpO1xuICAgIHJldHVybiB7XG4gICAgICByZWRlZW1TY3JpcHQsXG4gICAgICByZWRlZW1TY3JpcHRUeXBlOiBTQ1JJUFRfVFlQRVMuUDJXU0gsXG4gICAgICB3aXRuZXNzU2NyaXB0LFxuICAgICAgd2l0bmVzc1NjcmlwdFR5cGU6IGV4cGFuZGVkLnR5cGUsXG4gICAgICBwcmV2T3V0VHlwZTogU0NSSVBUX1RZUEVTLlAyU0gsXG4gICAgICBwcmV2T3V0U2NyaXB0OiBwMnNoLm91dHB1dCxcbiAgICAgIGhhc1dpdG5lc3M6IHRydWUsXG4gICAgICBzaWduU2NyaXB0LFxuICAgICAgc2lnblR5cGU6IGV4cGFuZGVkLnR5cGUsXG4gICAgICBwdWJrZXlzOiBleHBhbmRlZC5wdWJrZXlzLFxuICAgICAgc2lnbmF0dXJlczogZXhwYW5kZWQuc2lnbmF0dXJlcyxcbiAgICAgIG1heFNpZ25hdHVyZXM6IGV4cGFuZGVkLm1heFNpZ25hdHVyZXMsXG4gICAgfTtcbiAgfVxuICBpZiAocmVkZWVtU2NyaXB0KSB7XG4gICAgY29uc3QgcDJzaCA9IHBheW1lbnRzLnAyc2goeyByZWRlZW06IHsgb3V0cHV0OiByZWRlZW1TY3JpcHQgfSB9KTtcbiAgICBpZiAoaW5wdXQucHJldk91dFNjcmlwdCkge1xuICAgICAgbGV0IHAyc2hBbHQ7XG4gICAgICB0cnkge1xuICAgICAgICBwMnNoQWx0ID0gcGF5bWVudHMucDJzaCh7IG91dHB1dDogaW5wdXQucHJldk91dFNjcmlwdCB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmV2T3V0U2NyaXB0IG11c3QgYmUgUDJTSCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFwMnNoLmhhc2guZXF1YWxzKHAyc2hBbHQuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkZWVtIHNjcmlwdCBpbmNvbnNpc3RlbnQgd2l0aCBwcmV2T3V0U2NyaXB0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kT3V0cHV0KHAyc2gucmVkZWVtLm91dHB1dCwgb3VyUHViS2V5KTtcbiAgICBpZiAoIWV4cGFuZGVkLnB1YmtleXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGV4cGFuZGVkLnR5cGUgK1xuICAgICAgICAgICcgbm90IHN1cHBvcnRlZCBhcyByZWRlZW1TY3JpcHQgKCcgK1xuICAgICAgICAgIGJzY3JpcHQudG9BU00ocmVkZWVtU2NyaXB0KSArXG4gICAgICAgICAgJyknLFxuICAgICAgKTtcbiAgICBpZiAoaW5wdXQuc2lnbmF0dXJlcyAmJiBpbnB1dC5zaWduYXR1cmVzLnNvbWUoeCA9PiB4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBleHBhbmRlZC5zaWduYXR1cmVzID0gaW5wdXQuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgbGV0IHNpZ25TY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgaWYgKGV4cGFuZGVkLnR5cGUgPT09IFNDUklQVF9UWVBFUy5QMldQS0gpIHtcbiAgICAgIHNpZ25TY3JpcHQgPSBwYXltZW50cy5wMnBraCh7IHB1YmtleTogZXhwYW5kZWQucHVia2V5c1swXSB9KS5vdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWRlZW1TY3JpcHQsXG4gICAgICByZWRlZW1TY3JpcHRUeXBlOiBleHBhbmRlZC50eXBlLFxuICAgICAgcHJldk91dFR5cGU6IFNDUklQVF9UWVBFUy5QMlNILFxuICAgICAgcHJldk91dFNjcmlwdDogcDJzaC5vdXRwdXQsXG4gICAgICBoYXNXaXRuZXNzOiBleHBhbmRlZC50eXBlID09PSBTQ1JJUFRfVFlQRVMuUDJXUEtILFxuICAgICAgc2lnblNjcmlwdCxcbiAgICAgIHNpZ25UeXBlOiBleHBhbmRlZC50eXBlLFxuICAgICAgcHVia2V5czogZXhwYW5kZWQucHVia2V5cyxcbiAgICAgIHNpZ25hdHVyZXM6IGV4cGFuZGVkLnNpZ25hdHVyZXMsXG4gICAgICBtYXhTaWduYXR1cmVzOiBleHBhbmRlZC5tYXhTaWduYXR1cmVzLFxuICAgIH07XG4gIH1cbiAgaWYgKHdpdG5lc3NTY3JpcHQpIHtcbiAgICBjb25zdCBwMndzaCA9IHBheW1lbnRzLnAyd3NoKHsgcmVkZWVtOiB7IG91dHB1dDogd2l0bmVzc1NjcmlwdCB9IH0pO1xuICAgIGlmIChpbnB1dC5wcmV2T3V0U2NyaXB0KSB7XG4gICAgICBjb25zdCBwMndzaEFsdCA9IHBheW1lbnRzLnAyd3NoKHsgb3V0cHV0OiBpbnB1dC5wcmV2T3V0U2NyaXB0IH0pO1xuICAgICAgaWYgKCFwMndzaC5oYXNoLmVxdWFscyhwMndzaEFsdC5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRuZXNzIHNjcmlwdCBpbmNvbnNpc3RlbnQgd2l0aCBwcmV2T3V0U2NyaXB0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kT3V0cHV0KHAyd3NoLnJlZGVlbS5vdXRwdXQsIG91clB1YktleSk7XG4gICAgaWYgKCFleHBhbmRlZC5wdWJrZXlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBleHBhbmRlZC50eXBlICtcbiAgICAgICAgICAnIG5vdCBzdXBwb3J0ZWQgYXMgd2l0bmVzc1NjcmlwdCAoJyArXG4gICAgICAgICAgYnNjcmlwdC50b0FTTSh3aXRuZXNzU2NyaXB0KSArXG4gICAgICAgICAgJyknLFxuICAgICAgKTtcbiAgICBpZiAoaW5wdXQuc2lnbmF0dXJlcyAmJiBpbnB1dC5zaWduYXR1cmVzLnNvbWUoeCA9PiB4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBleHBhbmRlZC5zaWduYXR1cmVzID0gaW5wdXQuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgY29uc3Qgc2lnblNjcmlwdCA9IHdpdG5lc3NTY3JpcHQ7XG4gICAgaWYgKGV4cGFuZGVkLnR5cGUgPT09IFNDUklQVF9UWVBFUy5QMldQS0gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1AyV1NIKFAyV1BLSCkgaXMgYSBjb25zZW5zdXMgZmFpbHVyZScpO1xuICAgIHJldHVybiB7XG4gICAgICB3aXRuZXNzU2NyaXB0LFxuICAgICAgd2l0bmVzc1NjcmlwdFR5cGU6IGV4cGFuZGVkLnR5cGUsXG4gICAgICBwcmV2T3V0VHlwZTogU0NSSVBUX1RZUEVTLlAyV1NILFxuICAgICAgcHJldk91dFNjcmlwdDogcDJ3c2gub3V0cHV0LFxuICAgICAgaGFzV2l0bmVzczogdHJ1ZSxcbiAgICAgIHNpZ25TY3JpcHQsXG4gICAgICBzaWduVHlwZTogZXhwYW5kZWQudHlwZSxcbiAgICAgIHB1YmtleXM6IGV4cGFuZGVkLnB1YmtleXMsXG4gICAgICBzaWduYXR1cmVzOiBleHBhbmRlZC5zaWduYXR1cmVzLFxuICAgICAgbWF4U2lnbmF0dXJlczogZXhwYW5kZWQubWF4U2lnbmF0dXJlcyxcbiAgICB9O1xuICB9XG4gIGlmIChpbnB1dC5wcmV2T3V0VHlwZSAmJiBpbnB1dC5wcmV2T3V0U2NyaXB0KSB7XG4gICAgLy8gZW1iZWRkZWQgc2NyaXB0cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgZXh0cmEgaW5mb3JtYXRpb25cbiAgICBpZiAoaW5wdXQucHJldk91dFR5cGUgPT09IFNDUklQVF9UWVBFUy5QMlNIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUHJldk91dFNjcmlwdCBpcyAnICsgaW5wdXQucHJldk91dFR5cGUgKyAnLCByZXF1aXJlcyByZWRlZW1TY3JpcHQnLFxuICAgICAgKTtcbiAgICBpZiAoaW5wdXQucHJldk91dFR5cGUgPT09IFNDUklQVF9UWVBFUy5QMldTSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1ByZXZPdXRTY3JpcHQgaXMgJyArIGlucHV0LnByZXZPdXRUeXBlICsgJywgcmVxdWlyZXMgd2l0bmVzc1NjcmlwdCcsXG4gICAgICApO1xuICAgIGlmICghaW5wdXQucHJldk91dFNjcmlwdCkgdGhyb3cgbmV3IEVycm9yKCdQcmV2T3V0U2NyaXB0IGlzIG1pc3NpbmcnKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZE91dHB1dChpbnB1dC5wcmV2T3V0U2NyaXB0LCBvdXJQdWJLZXkpO1xuICAgIGlmICghZXhwYW5kZWQucHVia2V5cylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXhwYW5kZWQudHlwZSArXG4gICAgICAgICAgJyBub3Qgc3VwcG9ydGVkICgnICtcbiAgICAgICAgICBic2NyaXB0LnRvQVNNKGlucHV0LnByZXZPdXRTY3JpcHQpICtcbiAgICAgICAgICAnKScsXG4gICAgICApO1xuICAgIGlmIChpbnB1dC5zaWduYXR1cmVzICYmIGlucHV0LnNpZ25hdHVyZXMuc29tZSh4ID0+IHggIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGV4cGFuZGVkLnNpZ25hdHVyZXMgPSBpbnB1dC5zaWduYXR1cmVzO1xuICAgIH1cbiAgICBsZXQgc2lnblNjcmlwdCA9IGlucHV0LnByZXZPdXRTY3JpcHQ7XG4gICAgaWYgKGV4cGFuZGVkLnR5cGUgPT09IFNDUklQVF9UWVBFUy5QMldQS0gpIHtcbiAgICAgIHNpZ25TY3JpcHQgPSBwYXltZW50cy5wMnBraCh7IHB1YmtleTogZXhwYW5kZWQucHVia2V5c1swXSB9KS5vdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwcmV2T3V0VHlwZTogZXhwYW5kZWQudHlwZSxcbiAgICAgIHByZXZPdXRTY3JpcHQ6IGlucHV0LnByZXZPdXRTY3JpcHQsXG4gICAgICBoYXNXaXRuZXNzOiBleHBhbmRlZC50eXBlID09PSBTQ1JJUFRfVFlQRVMuUDJXUEtILFxuICAgICAgc2lnblNjcmlwdCxcbiAgICAgIHNpZ25UeXBlOiBleHBhbmRlZC50eXBlLFxuICAgICAgcHVia2V5czogZXhwYW5kZWQucHVia2V5cyxcbiAgICAgIHNpZ25hdHVyZXM6IGV4cGFuZGVkLnNpZ25hdHVyZXMsXG4gICAgICBtYXhTaWduYXR1cmVzOiBleHBhbmRlZC5tYXhTaWduYXR1cmVzLFxuICAgIH07XG4gIH1cbiAgY29uc3QgcHJldk91dFNjcmlwdCA9IHBheW1lbnRzLnAycGtoKHsgcHVia2V5OiBvdXJQdWJLZXkgfSkub3V0cHV0O1xuICByZXR1cm4ge1xuICAgIHByZXZPdXRUeXBlOiBTQ1JJUFRfVFlQRVMuUDJQS0gsXG4gICAgcHJldk91dFNjcmlwdCxcbiAgICBoYXNXaXRuZXNzOiBmYWxzZSxcbiAgICBzaWduU2NyaXB0OiBwcmV2T3V0U2NyaXB0LFxuICAgIHNpZ25UeXBlOiBTQ1JJUFRfVFlQRVMuUDJQS0gsXG4gICAgcHVia2V5czogW291clB1YktleV0sXG4gICAgc2lnbmF0dXJlczogW3VuZGVmaW5lZF0sXG4gIH07XG59XG5mdW5jdGlvbiBidWlsZCh0eXBlLCBpbnB1dCwgYWxsb3dJbmNvbXBsZXRlKSB7XG4gIGNvbnN0IHB1YmtleXMgPSBpbnB1dC5wdWJrZXlzIHx8IFtdO1xuICBsZXQgc2lnbmF0dXJlcyA9IGlucHV0LnNpZ25hdHVyZXMgfHwgW107XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU0NSSVBUX1RZUEVTLlAyUEtIOiB7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IHB1YmtleTogcHVia2V5c1swXSwgc2lnbmF0dXJlOiBzaWduYXR1cmVzWzBdIH0pO1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMldQS0g6IHtcbiAgICAgIGlmIChwdWJrZXlzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICBpZiAoc2lnbmF0dXJlcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IHB1YmtleTogcHVia2V5c1swXSwgc2lnbmF0dXJlOiBzaWduYXR1cmVzWzBdIH0pO1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMlBLOiB7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnBrKHsgc2lnbmF0dXJlOiBzaWduYXR1cmVzWzBdIH0pO1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMk1TOiB7XG4gICAgICBjb25zdCBtID0gaW5wdXQubWF4U2lnbmF0dXJlcztcbiAgICAgIGlmIChhbGxvd0luY29tcGxldGUpIHtcbiAgICAgICAgc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMubWFwKHggPT4geCB8fCBzY3JpcHRfMS5PUFMuT1BfMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYXR1cmVzID0gc2lnbmF0dXJlcy5maWx0ZXIoeCA9PiB4KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBub3Qgbm90IGNvbXBsZXRlIChjb21wbGV0ZSksIG9yIGlmIHNpZ25hdHVyZXMubGVuZ3RoID09PSBtLCB2YWxpZGF0ZVxuICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgbnVtYmVyIG9mIE9QXzAncyBtYXkgYmUgPj0gbSwgc28gZG9uJ3QgdmFsaWRhdGUgKGJvbylcbiAgICAgIGNvbnN0IHZhbGlkYXRlID0gIWFsbG93SW5jb21wbGV0ZSB8fCBtID09PSBzaWduYXR1cmVzLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXltZW50cy5wMm1zKFxuICAgICAgICB7IG0sIHB1YmtleXMsIHNpZ25hdHVyZXMgfSxcbiAgICAgICAgeyBhbGxvd0luY29tcGxldGUsIHZhbGlkYXRlIH0sXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMlNIOiB7XG4gICAgICBjb25zdCByZWRlZW0gPSBidWlsZChpbnB1dC5yZWRlZW1TY3JpcHRUeXBlLCBpbnB1dCwgYWxsb3dJbmNvbXBsZXRlKTtcbiAgICAgIGlmICghcmVkZWVtKSByZXR1cm47XG4gICAgICByZXR1cm4gcGF5bWVudHMucDJzaCh7XG4gICAgICAgIHJlZGVlbToge1xuICAgICAgICAgIG91dHB1dDogcmVkZWVtLm91dHB1dCB8fCBpbnB1dC5yZWRlZW1TY3JpcHQsXG4gICAgICAgICAgaW5wdXQ6IHJlZGVlbS5pbnB1dCxcbiAgICAgICAgICB3aXRuZXNzOiByZWRlZW0ud2l0bmVzcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXNlIFNDUklQVF9UWVBFUy5QMldTSDoge1xuICAgICAgY29uc3QgcmVkZWVtID0gYnVpbGQoaW5wdXQud2l0bmVzc1NjcmlwdFR5cGUsIGlucHV0LCBhbGxvd0luY29tcGxldGUpO1xuICAgICAgaWYgKCFyZWRlZW0pIHJldHVybjtcbiAgICAgIHJldHVybiBwYXltZW50cy5wMndzaCh7XG4gICAgICAgIHJlZGVlbToge1xuICAgICAgICAgIG91dHB1dDogaW5wdXQud2l0bmVzc1NjcmlwdCxcbiAgICAgICAgICBpbnB1dDogcmVkZWVtLmlucHV0LFxuICAgICAgICAgIHdpdG5lc3M6IHJlZGVlbS53aXRuZXNzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYW5TaWduKGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQuc2lnblNjcmlwdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgaW5wdXQuc2lnblR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIGlucHV0LnB1YmtleXMgIT09IHVuZGVmaW5lZCAmJlxuICAgIGlucHV0LnNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgIGlucHV0LnNpZ25hdHVyZXMubGVuZ3RoID09PSBpbnB1dC5wdWJrZXlzLmxlbmd0aCAmJlxuICAgIGlucHV0LnB1YmtleXMubGVuZ3RoID4gMCAmJlxuICAgIChpbnB1dC5oYXNXaXRuZXNzID09PSBmYWxzZSB8fCBpbnB1dC52YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICApO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlSGFzaFR5cGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbkFyZ3MoaW5wdXRzLCBzaWduUGFyYW1zKSB7XG4gIGlmICghUFJFVk9VVF9UWVBFUy5oYXMoc2lnblBhcmFtcy5wcmV2T3V0U2NyaXB0VHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFVua25vd24gcHJldk91dFNjcmlwdFR5cGUgXCIke3NpZ25QYXJhbXMucHJldk91dFNjcmlwdFR5cGV9XCJgLFxuICAgICk7XG4gIH1cbiAgdGZNZXNzYWdlKFxuICAgIHR5cGVmb3JjZS5OdW1iZXIsXG4gICAgc2lnblBhcmFtcy52aW4sXG4gICAgYHNpZ24gbXVzdCBpbmNsdWRlIHZpbiBwYXJhbWV0ZXIgYXMgTnVtYmVyIChpbnB1dCBpbmRleClgLFxuICApO1xuICB0Zk1lc3NhZ2UoXG4gICAgdHlwZXMuU2lnbmVyLFxuICAgIHNpZ25QYXJhbXMua2V5UGFpcixcbiAgICBgc2lnbiBtdXN0IGluY2x1ZGUga2V5UGFpciBwYXJhbWV0ZXIgYXMgU2lnbmVyIGludGVyZmFjZWAsXG4gICk7XG4gIHRmTWVzc2FnZShcbiAgICB0eXBlZm9yY2UubWF5YmUodHlwZWZvcmNlLk51bWJlciksXG4gICAgc2lnblBhcmFtcy5oYXNoVHlwZSxcbiAgICBgc2lnbiBoYXNoVHlwZSBwYXJhbWV0ZXIgbXVzdCBiZSBhIG51bWJlcmAsXG4gICk7XG4gIGNvbnN0IHByZXZPdXRUeXBlID0gKGlucHV0c1tzaWduUGFyYW1zLnZpbl0gfHwgW10pLnByZXZPdXRUeXBlO1xuICBjb25zdCBwb3NUeXBlID0gc2lnblBhcmFtcy5wcmV2T3V0U2NyaXB0VHlwZTtcbiAgc3dpdGNoIChwb3NUeXBlKSB7XG4gICAgY2FzZSAncDJwa2gnOlxuICAgICAgaWYgKHByZXZPdXRUeXBlICYmIHByZXZPdXRUeXBlICE9PSAncHVia2V5aGFzaCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgaW5wdXQgIyR7c2lnblBhcmFtcy52aW59IGlzIG5vdCBvZiB0eXBlIHAycGtoOiAke3ByZXZPdXRUeXBlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NTY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIE5PIHdpdG5lc3NTY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLnZhbHVlKHVuZGVmaW5lZCksXG4gICAgICAgIHNpZ25QYXJhbXMucmVkZWVtU2NyaXB0LFxuICAgICAgICBgJHtwb3NUeXBlfSByZXF1aXJlcyBOTyByZWRlZW1TY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLnZhbHVlKHVuZGVmaW5lZCksXG4gICAgICAgIHNpZ25QYXJhbXMud2l0bmVzc1ZhbHVlLFxuICAgICAgICBgJHtwb3NUeXBlfSByZXF1aXJlcyBOTyB3aXRuZXNzVmFsdWVgLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3AycGsnOlxuICAgICAgaWYgKHByZXZPdXRUeXBlICYmIHByZXZPdXRUeXBlICE9PSAncHVia2V5Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBpbnB1dCAjJHtzaWduUGFyYW1zLnZpbn0gaXMgbm90IG9mIHR5cGUgcDJwazogJHtwcmV2T3V0VHlwZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UudmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgc2lnblBhcmFtcy53aXRuZXNzU2NyaXB0LFxuICAgICAgICBgJHtwb3NUeXBlfSByZXF1aXJlcyBOTyB3aXRuZXNzU2NyaXB0YCxcbiAgICAgICk7XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLnJlZGVlbVNjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gcmVkZWVtU2NyaXB0YCxcbiAgICAgICk7XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NWYWx1ZSxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gd2l0bmVzc1ZhbHVlYCxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwMndwa2gnOlxuICAgICAgaWYgKHByZXZPdXRUeXBlICYmIHByZXZPdXRUeXBlICE9PSAnd2l0bmVzc3B1YmtleWhhc2gnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYGlucHV0ICMke3NpZ25QYXJhbXMudmlufSBpcyBub3Qgb2YgdHlwZSBwMndwa2g6ICR7cHJldk91dFR5cGV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLnZhbHVlKHVuZGVmaW5lZCksXG4gICAgICAgIHNpZ25QYXJhbXMud2l0bmVzc1NjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gd2l0bmVzc1NjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UudmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgc2lnblBhcmFtcy5yZWRlZW1TY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIE5PIHJlZGVlbVNjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlcy5TYXRvc2hpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NWYWx1ZSxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgd2l0bmVzc1ZhbHVlYCxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwMm1zJzpcbiAgICAgIGlmIChwcmV2T3V0VHlwZSAmJiBwcmV2T3V0VHlwZSAhPT0gJ211bHRpc2lnJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBpbnB1dCAjJHtzaWduUGFyYW1zLnZpbn0gaXMgbm90IG9mIHR5cGUgcDJtczogJHtwcmV2T3V0VHlwZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UudmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgc2lnblBhcmFtcy53aXRuZXNzU2NyaXB0LFxuICAgICAgICBgJHtwb3NUeXBlfSByZXF1aXJlcyBOTyB3aXRuZXNzU2NyaXB0YCxcbiAgICAgICk7XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLnJlZGVlbVNjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gcmVkZWVtU2NyaXB0YCxcbiAgICAgICk7XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NWYWx1ZSxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gd2l0bmVzc1ZhbHVlYCxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwMnNoLXAyd3BraCc6XG4gICAgICBpZiAocHJldk91dFR5cGUgJiYgcHJldk91dFR5cGUgIT09ICdzY3JpcHRoYXNoJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBpbnB1dCAjJHtzaWduUGFyYW1zLnZpbn0gaXMgbm90IG9mIHR5cGUgcDJzaC1wMndwa2g6ICR7cHJldk91dFR5cGV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLnZhbHVlKHVuZGVmaW5lZCksXG4gICAgICAgIHNpZ25QYXJhbXMud2l0bmVzc1NjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgTk8gd2l0bmVzc1NjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UuQnVmZmVyLFxuICAgICAgICBzaWduUGFyYW1zLnJlZGVlbVNjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgcmVkZWVtU2NyaXB0YCxcbiAgICAgICk7XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVzLlNhdG9zaGksXG4gICAgICAgIHNpZ25QYXJhbXMud2l0bmVzc1ZhbHVlLFxuICAgICAgICBgJHtwb3NUeXBlfSByZXF1aXJlcyB3aXRuZXNzVmFsdWVgLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Ayc2gtcDJtcyc6XG4gICAgY2FzZSAncDJzaC1wMnBrJzpcbiAgICBjYXNlICdwMnNoLXAycGtoJzpcbiAgICAgIGlmIChwcmV2T3V0VHlwZSAmJiBwcmV2T3V0VHlwZSAhPT0gJ3NjcmlwdGhhc2gnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYGlucHV0ICMke3NpZ25QYXJhbXMudmlufSBpcyBub3Qgb2YgdHlwZSAke3Bvc1R5cGV9OiAke3ByZXZPdXRUeXBlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS52YWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NTY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIE5PIHdpdG5lc3NTY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLkJ1ZmZlcixcbiAgICAgICAgc2lnblBhcmFtcy5yZWRlZW1TY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIHJlZGVlbVNjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UudmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgc2lnblBhcmFtcy53aXRuZXNzVmFsdWUsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIE5PIHdpdG5lc3NWYWx1ZWAsXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncDJ3c2gtcDJtcyc6XG4gICAgY2FzZSAncDJ3c2gtcDJwayc6XG4gICAgY2FzZSAncDJ3c2gtcDJwa2gnOlxuICAgICAgaWYgKHByZXZPdXRUeXBlICYmIHByZXZPdXRUeXBlICE9PSAnd2l0bmVzc3NjcmlwdGhhc2gnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYGlucHV0ICMke3NpZ25QYXJhbXMudmlufSBpcyBub3Qgb2YgdHlwZSAke3Bvc1R5cGV9OiAke3ByZXZPdXRUeXBlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0Zk1lc3NhZ2UoXG4gICAgICAgIHR5cGVmb3JjZS5CdWZmZXIsXG4gICAgICAgIHNpZ25QYXJhbXMud2l0bmVzc1NjcmlwdCxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgd2l0bmVzc1NjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UudmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgc2lnblBhcmFtcy5yZWRlZW1TY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIE5PIHJlZGVlbVNjcmlwdGAsXG4gICAgICApO1xuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlcy5TYXRvc2hpLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NWYWx1ZSxcbiAgICAgICAgYCR7cG9zVHlwZX0gcmVxdWlyZXMgd2l0bmVzc1ZhbHVlYCxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwMnNoLXAyd3NoLXAybXMnOlxuICAgIGNhc2UgJ3Ayc2gtcDJ3c2gtcDJwayc6XG4gICAgY2FzZSAncDJzaC1wMndzaC1wMnBraCc6XG4gICAgICBpZiAocHJldk91dFR5cGUgJiYgcHJldk91dFR5cGUgIT09ICdzY3JpcHRoYXNoJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBpbnB1dCAjJHtzaWduUGFyYW1zLnZpbn0gaXMgbm90IG9mIHR5cGUgJHtwb3NUeXBlfTogJHtwcmV2T3V0VHlwZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGZNZXNzYWdlKFxuICAgICAgICB0eXBlZm9yY2UuQnVmZmVyLFxuICAgICAgICBzaWduUGFyYW1zLndpdG5lc3NTY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIHdpdG5lc3NTY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZWZvcmNlLkJ1ZmZlcixcbiAgICAgICAgc2lnblBhcmFtcy5yZWRlZW1TY3JpcHQsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIHdpdG5lc3NTY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIHRmTWVzc2FnZShcbiAgICAgICAgdHlwZXMuU2F0b3NoaSxcbiAgICAgICAgc2lnblBhcmFtcy53aXRuZXNzVmFsdWUsXG4gICAgICAgIGAke3Bvc1R5cGV9IHJlcXVpcmVzIHdpdG5lc3NTY3JpcHRgLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiB0cnlTaWduKHtcbiAgaW5wdXQsXG4gIG91clB1YktleSxcbiAga2V5UGFpcixcbiAgc2lnbmF0dXJlSGFzaCxcbiAgaGFzaFR5cGUsXG4gIHVzZUxvd1IsXG59KSB7XG4gIC8vIGVuZm9yY2UgaW4gb3JkZXIgc2lnbmluZyBvZiBwdWJsaWMga2V5c1xuICBsZXQgc2lnbmVkID0gZmFsc2U7XG4gIGZvciAoY29uc3QgW2ksIHB1YktleV0gb2YgaW5wdXQucHVia2V5cy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIW91clB1YktleS5lcXVhbHMocHViS2V5KSkgY29udGludWU7XG4gICAgaWYgKGlucHV0LnNpZ25hdHVyZXNbaV0pIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgLy8gVE9ETzogYWRkIHRlc3RzXG4gICAgaWYgKG91clB1YktleS5sZW5ndGggIT09IDMzICYmIGlucHV0Lmhhc1dpdG5lc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0JJUDE0MyByZWplY3RzIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cyBpbiBQMldQS0ggb3IgUDJXU0gnLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0ga2V5UGFpci5zaWduKHNpZ25hdHVyZUhhc2gsIHVzZUxvd1IpO1xuICAgIGlucHV0LnNpZ25hdHVyZXNbaV0gPSBic2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBoYXNoVHlwZSk7XG4gICAgc2lnbmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoIXNpZ25lZCkgdGhyb3cgbmV3IEVycm9yKCdLZXkgcGFpciBjYW5ub3Qgc2lnbiBmb3IgdGhpcyBpbnB1dCcpO1xufVxuZnVuY3Rpb24gZ2V0U2lnbmluZ0RhdGEoXG4gIG5ldHdvcmssXG4gIGlucHV0cyxcbiAgbmVlZHNPdXRwdXRzLFxuICB0eCxcbiAgc2lnblBhcmFtcyxcbiAga2V5UGFpcixcbiAgcmVkZWVtU2NyaXB0LFxuICBoYXNoVHlwZSxcbiAgd2l0bmVzc1ZhbHVlLFxuICB3aXRuZXNzU2NyaXB0LFxuICB1c2VMb3dSLFxuKSB7XG4gIGxldCB2aW47XG4gIGlmICh0eXBlb2Ygc2lnblBhcmFtcyA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnREVQUkVDQVRFRDogVHJhbnNhY3Rpb25CdWlsZGVyIHNpZ24gbWV0aG9kIGFyZ3VtZW50cyAnICtcbiAgICAgICAgJ3dpbGwgY2hhbmdlIGluIHY2LCBwbGVhc2UgdXNlIHRoZSBUeGJTaWduQXJnIGludGVyZmFjZScsXG4gICAgKTtcbiAgICB2aW4gPSBzaWduUGFyYW1zO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzaWduUGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIGNoZWNrU2lnbkFyZ3MoaW5wdXRzLCBzaWduUGFyYW1zKTtcbiAgICAoe1xuICAgICAgdmluLFxuICAgICAga2V5UGFpcixcbiAgICAgIHJlZGVlbVNjcmlwdCxcbiAgICAgIGhhc2hUeXBlLFxuICAgICAgd2l0bmVzc1ZhbHVlLFxuICAgICAgd2l0bmVzc1NjcmlwdCxcbiAgICB9ID0gc2lnblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUcmFuc2FjdGlvbkJ1aWxkZXIgc2lnbiBmaXJzdCBhcmcgbXVzdCBiZSBUeGJTaWduQXJnIG9yIG51bWJlcicsXG4gICAgKTtcbiAgfVxuICBpZiAoa2V5UGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIHJlcXVpcmVzIGtleXBhaXInKTtcbiAgfVxuICAvLyBUT0RPOiByZW1vdmUga2V5UGFpci5uZXR3b3JrIG1hdGNoaW5nIGluIDQuMC4wXG4gIGlmIChrZXlQYWlyLm5ldHdvcmsgJiYga2V5UGFpci5uZXR3b3JrICE9PSBuZXR3b3JrKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luY29uc2lzdGVudCBuZXR3b3JrJyk7XG4gIGlmICghaW5wdXRzW3Zpbl0pIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgYXQgaW5kZXg6ICcgKyB2aW4pO1xuICBoYXNoVHlwZSA9IGhhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gIGlmIChuZWVkc091dHB1dHMoaGFzaFR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIG5lZWRzIG91dHB1dHMnKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dHNbdmluXTtcbiAgLy8gaWYgcmVkZWVtU2NyaXB0IHdhcyBwcmV2aW91c2x5IHByb3ZpZGVkLCBlbmZvcmNlIGNvbnNpc3RlbmN5XG4gIGlmIChcbiAgICBpbnB1dC5yZWRlZW1TY3JpcHQgIT09IHVuZGVmaW5lZCAmJlxuICAgIHJlZGVlbVNjcmlwdCAmJlxuICAgICFpbnB1dC5yZWRlZW1TY3JpcHQuZXF1YWxzKHJlZGVlbVNjcmlwdClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgcmVkZWVtU2NyaXB0Jyk7XG4gIH1cbiAgY29uc3Qgb3VyUHViS2V5ID1cbiAgICBrZXlQYWlyLnB1YmxpY0tleSB8fCAoa2V5UGFpci5nZXRQdWJsaWNLZXkgJiYga2V5UGFpci5nZXRQdWJsaWNLZXkoKSk7XG4gIGlmICghY2FuU2lnbihpbnB1dCkpIHtcbiAgICBpZiAod2l0bmVzc1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnB1dC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlucHV0LnZhbHVlICE9PSB3aXRuZXNzVmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGlkIG5vdCBtYXRjaCB3aXRuZXNzVmFsdWUnKTtcbiAgICAgIHR5cGVmb3JjZSh0eXBlcy5TYXRvc2hpLCB3aXRuZXNzVmFsdWUpO1xuICAgICAgaW5wdXQudmFsdWUgPSB3aXRuZXNzVmFsdWU7XG4gICAgfVxuICAgIGlmICghY2FuU2lnbihpbnB1dCkpIHtcbiAgICAgIGNvbnN0IHByZXBhcmVkID0gcHJlcGFyZUlucHV0KFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgb3VyUHViS2V5LFxuICAgICAgICByZWRlZW1TY3JpcHQsXG4gICAgICAgIHdpdG5lc3NTY3JpcHQsXG4gICAgICApO1xuICAgICAgLy8gdXBkYXRlcyBpbmxpbmVcbiAgICAgIE9iamVjdC5hc3NpZ24oaW5wdXQsIHByZXBhcmVkKTtcbiAgICB9XG4gICAgaWYgKCFjYW5TaWduKGlucHV0KSkgdGhyb3cgRXJyb3IoaW5wdXQucHJldk91dFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICAvLyByZWFkeSB0byBzaWduXG4gIGxldCBzaWduYXR1cmVIYXNoO1xuICBpZiAoaW5wdXQuaGFzV2l0bmVzcykge1xuICAgIHNpZ25hdHVyZUhhc2ggPSB0eC5oYXNoRm9yV2l0bmVzc1YwKFxuICAgICAgdmluLFxuICAgICAgaW5wdXQuc2lnblNjcmlwdCxcbiAgICAgIGlucHV0LnZhbHVlLFxuICAgICAgaGFzaFR5cGUsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzaWduYXR1cmVIYXNoID0gdHguaGFzaEZvclNpZ25hdHVyZSh2aW4sIGlucHV0LnNpZ25TY3JpcHQsIGhhc2hUeXBlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlucHV0LFxuICAgIG91clB1YktleSxcbiAgICBrZXlQYWlyLFxuICAgIHNpZ25hdHVyZUhhc2gsXG4gICAgaGFzaFR5cGUsXG4gICAgdXNlTG93UjogISF1c2VMb3dSLFxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgVUlOVDMxX01BWCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG5mdW5jdGlvbiBVSW50MzEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVmb3JjZS5VSW50MzIodmFsdWUpICYmIHZhbHVlIDw9IFVJTlQzMV9NQVg7XG59XG5leHBvcnRzLlVJbnQzMSA9IFVJbnQzMTtcbmZ1bmN0aW9uIEJJUDMyUGF0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZWZvcmNlLlN0cmluZyh2YWx1ZSkgJiYgISF2YWx1ZS5tYXRjaCgvXihtXFwvKT8oXFxkKyc/XFwvKSpcXGQrJz8kLyk7XG59XG5leHBvcnRzLkJJUDMyUGF0aCA9IEJJUDMyUGF0aDtcbkJJUDMyUGF0aC50b0pTT04gPSAoKSA9PiB7XG4gIHJldHVybiAnQklQMzIgZGVyaXZhdGlvbiBwYXRoJztcbn07XG5mdW5jdGlvbiBTaWduZXIob2JqKSB7XG4gIHJldHVybiAoXG4gICAgKHR5cGVmb3JjZS5CdWZmZXIob2JqLnB1YmxpY0tleSkgfHxcbiAgICAgIHR5cGVvZiBvYmouZ2V0UHVibGljS2V5ID09PSAnZnVuY3Rpb24nKSAmJlxuICAgIHR5cGVvZiBvYmouc2lnbiA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuZXhwb3J0cy5TaWduZXIgPSBTaWduZXI7XG5jb25zdCBTQVRPU0hJX01BWCA9IDIxICogMWUxNDtcbmZ1bmN0aW9uIFNhdG9zaGkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVmb3JjZS5VSW50NTModmFsdWUpICYmIHZhbHVlIDw9IFNBVE9TSElfTUFYO1xufVxuZXhwb3J0cy5TYXRvc2hpID0gU2F0b3NoaTtcbi8vIGV4dGVybmFsIGRlcGVuZGVudCB0eXBlc1xuZXhwb3J0cy5FQ1BvaW50ID0gdHlwZWZvcmNlLnF1YWNrc0xpa2UoJ1BvaW50Jyk7XG4vLyBleHBvc2VkLCBleHRlcm5hbCBBUElcbmV4cG9ydHMuTmV0d29yayA9IHR5cGVmb3JjZS5jb21waWxlKHtcbiAgbWVzc2FnZVByZWZpeDogdHlwZWZvcmNlLm9uZU9mKHR5cGVmb3JjZS5CdWZmZXIsIHR5cGVmb3JjZS5TdHJpbmcpLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogdHlwZWZvcmNlLlVJbnQzMixcbiAgICBwcml2YXRlOiB0eXBlZm9yY2UuVUludDMyLFxuICB9LFxuICBwdWJLZXlIYXNoOiB0eXBlZm9yY2UuVUludDgsXG4gIHNjcmlwdEhhc2g6IHR5cGVmb3JjZS5VSW50OCxcbiAgd2lmOiB0eXBlZm9yY2UuVUludDgsXG59KTtcbmV4cG9ydHMuQnVmZmVyMjU2Yml0ID0gdHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuZXhwb3J0cy5IYXNoMTYwYml0ID0gdHlwZWZvcmNlLkJ1ZmZlck4oMjApO1xuZXhwb3J0cy5IYXNoMjU2Yml0ID0gdHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuZXhwb3J0cy5OdW1iZXIgPSB0eXBlZm9yY2UuTnVtYmVyOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIHZhcmlhYmxlLW5hbWVcbmV4cG9ydHMuQXJyYXkgPSB0eXBlZm9yY2UuQXJyYXk7XG5leHBvcnRzLkJvb2xlYW4gPSB0eXBlZm9yY2UuQm9vbGVhbjsgLy8gdHNsaW50OmRpc2FibGUtbGluZSB2YXJpYWJsZS1uYW1lXG5leHBvcnRzLlN0cmluZyA9IHR5cGVmb3JjZS5TdHJpbmc7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgdmFyaWFibGUtbmFtZVxuZXhwb3J0cy5CdWZmZXIgPSB0eXBlZm9yY2UuQnVmZmVyO1xuZXhwb3J0cy5IZXggPSB0eXBlZm9yY2UuSGV4O1xuZXhwb3J0cy5tYXliZSA9IHR5cGVmb3JjZS5tYXliZTtcbmV4cG9ydHMudHVwbGUgPSB0eXBlZm9yY2UudHVwbGU7XG5leHBvcnRzLlVJbnQ4ID0gdHlwZWZvcmNlLlVJbnQ4O1xuZXhwb3J0cy5VSW50MzIgPSB0eXBlZm9yY2UuVUludDMyO1xuZXhwb3J0cy5GdW5jdGlvbiA9IHR5cGVmb3JjZS5GdW5jdGlvbjtcbmV4cG9ydHMuQnVmZmVyTiA9IHR5cGVmb3JjZS5CdWZmZXJOO1xuZXhwb3J0cy5OdWxsID0gdHlwZWZvcmNlLk51bGw7XG5leHBvcnRzLm9uZU9mID0gdHlwZWZvcmNlLm9uZU9mO1xuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByIDw8PSA0O1xuXG4gICAgICAvLyAnYScgLSAnZidcbiAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcbiAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJyAtICdGJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcbiAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciB8PSBjICYgMHhmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgfVxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuc3RyaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwidmFyIHI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmFuZChsZW4pIHtcbiAgaWYgKCFyKVxuICAgIHIgPSBuZXcgUmFuZChudWxsKTtcblxuICByZXR1cm4gci5nZW5lcmF0ZShsZW4pO1xufTtcblxuZnVuY3Rpb24gUmFuZChyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQ7XG59XG5tb2R1bGUuZXhwb3J0cy5SYW5kID0gUmFuZDtcblxuUmFuZC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3JhbmQobGVuKTtcbn07XG5cbi8vIEVtdWxhdGUgY3J5cHRvIEFQSSB1c2luZyByYW5keVxuUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gIGlmICh0aGlzLnJhbmQuZ2V0Qnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMucmFuZC5nZXRCeXRlcyhuKTtcblxuICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgIHJlc1tpXSA9IHRoaXMucmFuZC5nZXRCeXRlKCk7XG4gIHJldHVybiByZXM7XG59O1xuXG5pZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnKSB7XG4gIGlmIChzZWxmLmNyeXB0byAmJiBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGYubXNDcnlwdG8gJiYgc2VsZi5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBJRVxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgc2VsZi5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAvLyBTYWZhcmkncyBXZWJXb3JrZXJzIGRvIG5vdCBoYXZlIGBjcnlwdG9gXG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBPbGQganVua1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICAvLyBOb2RlLmpzIG9yIFdlYiB3b3JrZXIgd2l0aCBubyBjcnlwdG8gc3VwcG9ydFxuICB0cnkge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCcpO1xuXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuIiwidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNTggPSByZXF1aXJlKCdiczU4JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGVja3N1bUZuKSB7XG4gIC8vIEVuY29kZSBhIGJ1ZmZlciBhcyBhIGJhc2U1OC1jaGVjayBlbmNvZGVkIHN0cmluZ1xuICBmdW5jdGlvbiBlbmNvZGUgKHBheWxvYWQpIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBjaGVja3N1bUZuKHBheWxvYWQpXG5cbiAgICByZXR1cm4gYmFzZTU4LmVuY29kZShCdWZmZXIuY29uY2F0KFtcbiAgICAgIHBheWxvYWQsXG4gICAgICBjaGVja3N1bVxuICAgIF0sIHBheWxvYWQubGVuZ3RoICsgNCkpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVSYXcgKGJ1ZmZlcikge1xuICAgIHZhciBwYXlsb2FkID0gYnVmZmVyLnNsaWNlKDAsIC00KVxuICAgIHZhciBjaGVja3N1bSA9IGJ1ZmZlci5zbGljZSgtNClcbiAgICB2YXIgbmV3Q2hlY2tzdW0gPSBjaGVja3N1bUZuKHBheWxvYWQpXG5cbiAgICBpZiAoY2hlY2tzdW1bMF0gXiBuZXdDaGVja3N1bVswXSB8XG4gICAgICAgIGNoZWNrc3VtWzFdIF4gbmV3Q2hlY2tzdW1bMV0gfFxuICAgICAgICBjaGVja3N1bVsyXSBeIG5ld0NoZWNrc3VtWzJdIHxcbiAgICAgICAgY2hlY2tzdW1bM10gXiBuZXdDaGVja3N1bVszXSkgcmV0dXJuXG5cbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgLy8gRGVjb2RlIGEgYmFzZTU4LWNoZWNrIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLCBubyByZXN1bHQgaWYgY2hlY2tzdW0gaXMgd3JvbmdcbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gYmFzZTU4LmRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKCFidWZmZXIpIHJldHVyblxuXG4gICAgcmV0dXJuIGRlY29kZVJhdyhidWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBiYXNlNTguZGVjb2RlKHN0cmluZylcbiAgICB2YXIgcGF5bG9hZCA9IGRlY29kZVJhdyhidWZmZXIsIGNoZWNrc3VtRm4pXG4gICAgaWYgKCFwYXlsb2FkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKVxuICAgIHJldHVybiBwYXlsb2FkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBiczU4Y2hlY2tCYXNlID0gcmVxdWlyZSgnLi9iYXNlJylcblxuLy8gU0hBMjU2KFNIQTI1NihidWZmZXIpKVxuZnVuY3Rpb24gc2hhMjU2eDIgKGJ1ZmZlcikge1xuICB2YXIgdG1wID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KClcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZSh0bXApLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnM1OGNoZWNrQmFzZShzaGEyNTZ4MilcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIGlmICh0aGlzLl9maW5hbCkge1xuICAgIHRoaXMuX19maW5hbCA9IHRoaXMuX2ZpbmFsXG4gICAgdGhpcy5fZmluYWwgPSBudWxsXG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgaW5wdXRFbmMpXG4gIH1cblxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkgcmV0dXJuIHRoaXNcblxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuXG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfVxuXG4gIGRvbmUoZXJyKVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fX2ZpbmFsKCkgfHwgQnVmZmVyLmFsbG9jKDApXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcblxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbikge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaCAoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBuZXcgTUQ1KClcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cbiIsInZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBNRDUoKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG5cbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIHZhciBoYXNoID0gYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYShhbGcpXG4gICAga2V5ID0gaGFzaC51cGRhdGUoa2V5KS5kaWdlc3QoKVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG4gIHRoaXMuX2hhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgdGhpcy5faGFzaC51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhtYWMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBoYXNoID0gdGhpcy5fYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYSh0aGlzLl9hbGcpXG4gIHJldHVybiBoYXNoLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjIChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSB7XG4gICAgcmV0dXJuIG5ldyBIbWFjKCdybWQxNjAnLCBrZXkpXG4gIH1cbiAgaWYgKGFsZyA9PT0gJ21kNScpIHtcbiAgICByZXR1cm4gbmV3IExlZ2FjeShtZDUsIGtleSlcbiAgfVxuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBibG9ja3NpemUgPSA2NFxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGFsZyhrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gW2lwYWRdXG59XG5cbmluaGVyaXRzKEhtYWMsIEJhc2UpXG5cbkhtYWMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnB1c2goZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2FsZyhCdWZmZXIuY29uY2F0KHRoaXMuX2hhc2gpKVxuICByZXR1cm4gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQoW3RoaXMuX29wYWQsIGhdKSlcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBnZXROQUYgPSB1dGlscy5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHMuZ2V0SlNGO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0KHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEsIHRoaXMuX2JpdExlbmd0aCk7XG4gIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICBJIC89IDM7XG5cbiAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG4gIHZhciByZXByID0gW107XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICB2YXIgbmFmVyA9IDA7XG4gICAgZm9yICh2YXIgayA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBrID49IGo7IGstLSlcbiAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltrXTtcbiAgICByZXByLnB1c2gobmFmVyk7XG4gIH1cblxuICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgYiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSAvKiA3ICovXG4gICAgXTtcblxuICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcbiAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBbXG4gICAgICAtMywgLyogLTEgLTEgKi9cbiAgICAgIC0xLCAvKiAtMSAwICovXG4gICAgICAtNSwgLyogLTEgMSAqL1xuICAgICAgLTcsIC8qIDAgLTEgKi9cbiAgICAgIDAsIC8qIDAgMCAqL1xuICAgICAgNywgLyogMCAxICovXG4gICAgICA1LCAvKiAxIC0xICovXG4gICAgICAxLCAvKiAxIDAgKi9cbiAgICAgIDMgIC8qIDEgMSAqL1xuICAgIF07XG5cbiAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcbiAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4OyBqKyspIHtcbiAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG4gICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG4gICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG4gICAgICBuYWZbYl1bal0gPSAwO1xuICAgICAgd25kW2FdID0gY29tYjtcbiAgICB9XG4gIH1cblxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAodmFyIGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghemVybylcbiAgICAgICAgYnJlYWs7XG4gICAgICBrKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgeiA9IHRtcFtqXTtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB3bmRbaV0gPSBudWxsO1xuXG4gIGlmIChqYWNvYmlhblJlc3VsdClcbiAgICByZXR1cm4gYWNjO1xuICBlbHNlXG4gICAgcmV0dXJuIGFjYy50b1AoKTtcbn07XG5cbmZ1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSwgdHlwZSkge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xufVxuQmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKC8qb3RoZXIqLykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIGJ5dGVzID0gdXRpbHMudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG4gICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcblxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoKGJ5dGVzWzBdID09PSAweDAyIHx8IGJ5dGVzWzBdID09PSAweDAzKSAmJlxuICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkID0gZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3QpIHtcbiAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG4gIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuXG4gIGlmIChjb21wYWN0KVxuICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cbiAgcmV0dXJuIFsgMHgwNCBdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpIDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuICB2YXIgcmVzID0gWyB0aGlzIF07XG4gIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG4gIHJldHVybiB7XG4gICAgd25kOiB3bmQsXG4gICAgcG9pbnRzOiByZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcbiAgICByID0gci5kYmwoKTtcbiAgcmV0dXJuIHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBFZHdhcmRzQ3VydmUoY29uZikge1xuICAvLyBOT1RFOiBJbXBvcnRhbnQgYXMgd2UgYXJlIGNyZWF0aW5nIHBvaW50IGluIEJhc2UuY2FsbCgpXG4gIHRoaXMudHdpc3RlZCA9IChjb25mLmEgfCAwKSAhPT0gMTtcbiAgdGhpcy5tT25lQSA9IHRoaXMudHdpc3RlZCAmJiAoY29uZi5hIHwgMCkgPT09IC0xO1xuICB0aGlzLmV4dGVuZGVkID0gdGhpcy5tT25lQTtcblxuICBCYXNlLmNhbGwodGhpcywgJ2Vkd2FyZHMnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudW1vZCh0aGlzLnJlZC5tKTtcbiAgdGhpcy5hID0gdGhpcy5hLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jID0gbmV3IEJOKGNvbmYuYywgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jMiA9IHRoaXMuYy5yZWRTcXIoKTtcbiAgdGhpcy5kID0gbmV3IEJOKGNvbmYuZCwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5kZCA9IHRoaXMuZC5yZWRBZGQodGhpcy5kKTtcblxuICBhc3NlcnQoIXRoaXMudHdpc3RlZCB8fCB0aGlzLmMuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDApO1xuICB0aGlzLm9uZUMgPSAoY29uZi5jIHwgMCkgPT09IDE7XG59XG5pbmhlcml0cyhFZHdhcmRzQ3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBFZHdhcmRzQ3VydmU7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEEgPSBmdW5jdGlvbiBfbXVsQShudW0pIHtcbiAgaWYgKHRoaXMubU9uZUEpXG4gICAgcmV0dXJuIG51bS5yZWROZWcoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmEucmVkTXVsKG51bSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxDID0gZnVuY3Rpb24gX211bEMobnVtKSB7XG4gIGlmICh0aGlzLm9uZUMpXG4gICAgcmV0dXJuIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmMucmVkTXVsKG51bSk7XG59O1xuXG4vLyBKdXN0IGZvciBjb21wYXRpYmlsaXR5IHdpdGggU2hvcnQgY3VydmVcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSwgeiwgdCk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkU3ViKHRoaXMuYS5yZWRNdWwoeDIpKTtcbiAgdmFyIGxocyA9IHRoaXMub25lLnJlZFN1Yih0aGlzLmMyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh4MikpO1xuXG4gIHZhciB5MiA9IHJocy5yZWRNdWwobGhzLnJlZEludm0oKSk7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVkgPSBmdW5jdGlvbiBwb2ludEZyb21ZKHksIG9kZCkge1xuICB5ID0gbmV3IEJOKHksIDE2KTtcbiAgaWYgKCF5LnJlZClcbiAgICB5ID0geS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8geF4yID0gKHleMiAtIGNeMikgLyAoY14yIGQgeV4yIC0gYSlcbiAgdmFyIHkyID0geS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHkyLnJlZFN1Yih0aGlzLmMyKTtcbiAgdmFyIHJocyA9IHkyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh0aGlzLmMyKS5yZWRTdWIodGhpcy5hKTtcbiAgdmFyIHgyID0gbGhzLnJlZE11bChyaHMucmVkSW52bSgpKTtcblxuICBpZiAoeDIuY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAob2RkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgfVxuXG4gIHZhciB4ID0geDIucmVkU3FydCgpO1xuICBpZiAoeC5yZWRTcXIoKS5yZWRTdWIoeDIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIGlmICh4LmZyb21SZWQoKS5pc09kZCgpICE9PSBvZGQpXG4gICAgeCA9IHgucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgQk4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgQk4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgKHRoaXMueS5jbXAodGhpcy56KSA9PT0gMCB8fFxuICAgICh0aGlzLnpPbmUgJiYgdGhpcy55LmNtcCh0aGlzLmN1cnZlLmMpID09PSAwKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICB2YXIgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgLy8gRiA9IEUgKyBEXG4gICAgdmFyIGYgPSBlLnJlZEFkZChkKTtcbiAgICBpZiAodGhpcy56T25lKSB7XG4gICAgICAvLyBYMyA9IChCIC0gQyAtIEQpICogKEYgLSAyKVxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRTdWIoZCkucmVkTXVsKGYucmVkU3ViKHRoaXMuY3VydmUudHdvKSk7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRl4yIC0gMiAqIEZcbiAgICAgIG56ID0gZi5yZWRTcXIoKS5yZWRTdWIoZikucmVkU3ViKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIID0gWjFeMlxuICAgICAgdmFyIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAvLyBKID0gRiAtIDIgKiBIXG4gICAgICB2YXIgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgdmFyIGUgPSBjLnJlZEFkZChkKTtcbiAgICAvLyBIID0gKGMgKiBaMSleMlxuICAgIHZhciBoID0gdGhpcy5jdXJ2ZS5fbXVsQyh0aGlzLnopLnJlZFNxcigpO1xuICAgIC8vIEogPSBFIC0gMiAqIEhcbiAgICB2YXIgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIGZhbHNlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0aGlzLnopO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEJhc2VDdXJ2ZVxuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jdXJ2ZS5zaG9ydCA9IHJlcXVpcmUoJy4vc2hvcnQnKTtcbmN1cnZlLm1vbnQgPSByZXF1aXJlKCcuL21vbnQnKTtcbmN1cnZlLmVkd2FyZHMgPSByZXF1aXJlKCcuL2Vkd2FyZHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IEJOKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQodXRpbHMudG9BcnJheShieXRlcywgZW5jKSwgMSk7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHopO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIC8vIE5vLW9wXG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcblxuICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChiaXRzW2ldID09PSAwKSB7XG4gICAgICAvLyBOICogUSArIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSkgKyAoTiAvIDIpICogUVxuICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRID0gMiAqICgoTiAvIDIpICogUSArIFEpKVxuICAgICAgYiA9IGIuZGJsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE4gKiBRID0gKChOIC8gMikgKiBRICsgUSkgKyAoKE4gLyAyKSAqIFEpXG4gICAgICBiID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgKyBRID0gMiAqICgoTiAvIDIpICogUSArIFEpXG4gICAgICBhID0gYS5kYmwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmp1bWxBZGQgPSBmdW5jdGlvbiBqdW1sQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdGhpcy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHMoU2hvcnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0KHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpc1xuICB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG4gIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcbiAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG4gIC8vXG4gIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogQk4ubW9udChudW0pO1xuICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuICB2YXIgcyA9IG5ldyBCTigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cbiAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcbiAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcbiAgcmV0dXJuIFsgbDEsIGwyIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcbiAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG4gIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB5MSA9IG5ldyBCTigwKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuICB2YXIgeTIgPSBuZXcgQk4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5uZWdhdGl2ZSkge1xuICAgIGExID0gYTEubmVnKCk7XG4gICAgYjEgPSBiMS5uZWcoKTtcbiAgfVxuICBpZiAoYTIubmVnYXRpdmUpIHtcbiAgICBhMiA9IGEyLm5lZygpO1xuICAgIGIyID0gYjIubmVnKCk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgYTogYTEsIGI6IGIxIH0sXG4gICAgeyBhOiBhMiwgYjogYjIgfVxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgIH1cblxuICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBlbHNlIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0JylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLmVkd2FyZHMob3B0aW9ucyk7XG4gIGVsc2VcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLm1vbnQob3B0aW9ucyk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cbiAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuICBhc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSwgJ0ludmFsaWQgY3VydmUsIEcqTiAhPSBPJyk7XG59XG5jdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY3VydmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH1cbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AyMjQnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjU2Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcbiAgbjogJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyxcbiAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZidcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwNTIxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG4gICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcbiAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcbiAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG4gICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG4gIGhhc2g6IGhhc2guc2hhNTEyLFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcbiAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG4gICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG4gICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMScsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCdcbiAgXVxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSByZXF1aXJlKCcuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMScpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnXG4gICAgfVxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmVcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgSG1hY0RSQkcgPSByZXF1aXJlKCdobWFjLWRyYmcnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi4vY3VydmVzJyk7XG52YXIgcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCByYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4J1xuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgdHJ1ZTsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXG4gIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG4gICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICB2YXIgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0KGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydChrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG59O1xuXG4vLyBFQ0RIXG5LZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcblxuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG4gIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuICAgIHJldHVybiBpbml0aWFsO1xuICB9XG4gIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG4gIHZhciB2YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG4gICAgdmFsIDw8PSA4O1xuICAgIHZhbCB8PSBidWZbb2ZmXTtcbiAgfVxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCAmJiAoclsxXSAmIDB4ODApKSB7XG4gICAgciA9IHIuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHNbMF0gPT09IDAgJiYgKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuLi9jdXJ2ZXMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgdmFyIGN1cnZlID0gY3VydmVzW2N1cnZlXS5jdXJ2ZTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShjdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgdGhpcy5wb2ludENsYXNzID0gY3VydmUucG9pbnQoKS5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5lbmNvZGluZ0xlbmd0aCA9IE1hdGguY2VpbChjdXJ2ZS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVERFNBO1xuXG4vKipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEtleVBhaXJ9IHNlY3JldCAtIHNlY3JldCBieXRlcyBvciBhIGtleXBhaXJcbiogQHJldHVybnMge1NpZ25hdHVyZX0gLSBzaWduYXR1cmVcbiovXG5FRERTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0KSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gIHZhciByID0gdGhpcy5oYXNoSW50KGtleS5tZXNzYWdlUHJlZml4KCksIG1lc3NhZ2UpO1xuICB2YXIgUiA9IHRoaXMuZy5tdWwocik7XG4gIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gIHZhciBzXyA9IHRoaXMuaGFzaEludChSZW5jb2RlZCwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgaWYgKHRoaXMuX3B1YkJ5dGVzKVxuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZy5tdWwodGhpcy5wcml2KCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdicsIGZ1bmN0aW9uIHByaXYoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnaGFzaCcsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ21lc3NhZ2VQcmVmaXgnLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUycsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1InLCBmdW5jdGlvbiBSKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1JlbmNvZGVkJywgZnVuY3Rpb24gUmVuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTZW5jb2RlZCcsIGZ1bmN0aW9uIFNlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gdG9IZXgoKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG91Ymxlczoge1xuICAgIHN0ZXA6IDQsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdlNjBmY2U5M2I1OWU5ZWM1MzAxMWFhYmMyMWMyM2U5N2IyYTMxMzY5Yjg3YTVhZTljNDRlZTg5ZTJhNmRlYzBhJyxcbiAgICAgICAgJ2Y3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI4MjI2MzIxMmM2MDlkOWVhMmE2ZTNlMTcyZGUyMzhkOGMzOWNhYmQ1YWMxY2ExMDY0NmUyM2ZkNWY1MTUwOCcsXG4gICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNjNkOTBkNDQ3YjAwYzljOTljZWFjMDViNjI2MmVlMDUzNDQxYzdlNTU1NTJmZmU1MjZiYWQ4ZjgzZmY0NjQwJyxcbiAgICAgICAgJzRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YjRiNWYxNjVkZjNjMmJlOGM2MjQ0YjViNzQ1NjM4ODQzZTRhNzgxYTE1YmNkMWI2OWY3OWE1NWRmZmRmODBjJyxcbiAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlYmZhNGQ0OTNiZWJmOThiYTVmZWVjODEyYzJkM2I1MDk0Nzk2MTIzN2E5MTk4MzlhNTMzZWNhMGU3ZGQ3ZmEnLFxuICAgICAgICAnNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMDBmNDRkYTY5NmU3MTY3Mjc5MWQwYTA5YjdiZGU0NTlmMTIxNWEyOWIzYzAzYmZlZmQ3ODM1YjM5YTQ4ZGIwJyxcbiAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlZWE2Y2FlNDZkNTViNTMwYWMyODM5ZjE0M2JkN2VjNWNmOGIyNjZhNDFkNmFmNTJkNWU2ODhkOTA5NDY5NmQnLFxuICAgICAgICAnZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY3YTkxZDkxMDQ5Y2RjYjM2N2JlNGJlNmZmY2EzY2ZlZWQ2NTdkODA4NTgzZGUzM2ZhOTc4YmMxZWM2Y2IxJyxcbiAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlN2JjZDBiZDM1OTgzYTc3MTljY2E3NzY0Y2E5MDY3NzliNTNhMDQzYTliOGJjYWVmZjk1OWY0M2FkODYwNDcnLFxuICAgICAgICAnMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczODVlZWQzNGMxY2RmZjIxZTZkMDgxODY4OWI4MWJkZTcxYTdmNGYxODM5N2U2NjkwYTg0MWUxNTk5YzQzODYyJyxcbiAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzMyMmQ0MDEyNDNjNGUyNTgyYTIxNDdjMTA0ZDZlY2JmNzc0ZDE2M2RiMGY1ZTUzMTNiN2UwZTc0MmQwZTZiZCcsXG4gICAgICAgICc1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1NjcyYzdkMmRlMGI3ZGEyYmQxNzcwZDg5NjY1ODY4NzQxYjNmOWFmNzY0MzM5NzcyMWQ3NGQyODEzNGFiODMnLFxuICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MjYwY2U3ZjQ2MTgwMWMzNGYwNjdjZTBmMDI4NzNhOGYxYjBlNDRkZmM2OTc1MmFjY2VjZDgxOWYzOGZkOGU4JyxcbiAgICAgICAgJ2JjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTUwMzdkZTBhZmMxZDhkNDNkODM0ODQxNGJiZjQxMDMwNDNlYzhmNTc1YmZkYzQzMjk1M2NjOGQyMDM3ZmEyZCcsXG4gICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyMTNjN2E3MTVjZDVkNDUzNThkMGJiZjlkYzBjZTAyMjA0YjEwYmRkZTJhM2Y1ODU0MGFkNjkwOGQwNTU5NzU0JyxcbiAgICAgICAgJzRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU3YzI3MmE3YWY0YjM0ZThkYmI5MzUyYTU0MTlhODdlMjgzOGM3MGFkYzYyY2RkZjBjYzNhM2IwOGZiZDUzYycsXG4gICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NmU2NDExM2Y2NzdjZjBlMTBhMjU3MGQ1OTk5NjhkMzE1NDRlMTc5Yjc2MDQzMjk1MmMwMmE0NDE3YmRkZTM5JyxcbiAgICAgICAgJ2M5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzczOGM1NmIwM2IyYWJlMWU4MjgxYmFhNzQzZjhmOWE4ZjdjYzY0M2RmMjZjYmVlM2FiMTUwMjQyYmNiYjg5MScsXG4gICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiOGRhOTQwMzJhOTU3NTE4ZWIwZjY0MzM1NzFlODc2MWNlZmZjNzM2OTNlODRlZGQ0OTE1MGE1NjRmNjc2ZTAzJyxcbiAgICAgICAgJzI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTgwZmVhMTQ0NDFmYjMzYTdkOGFkYWI5NDc1ZDdmYWIyMDE5ZWZmYjUxNTZhNzkyZjFhMTE3NzhlM2MwZGY1ZCcsXG4gICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MGFkODViMzg5ZDZiOTM2NDYzZjlkMDUxMjY3OGRlMjA4Y2MzMzBiMTEzMDdmZmZhYjdhYzYzZTNmYjA0ZWQ0JyxcbiAgICAgICAgJ2U1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZjY4YjlkMmY2M2I1ZjMzOTIzOWMxYWQ5ODFmMTYyZWU4OGM1Njc4NzIzZWEzMzUxYjdiNDQ0YzllYzRjMGRhJyxcbiAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMDBmYTliMThlYmYzMzFlYjk2MTUzN2E0NWE0MjY2YzcwMzRmMmYwZDRlMWQwNzE2ZmI2ZWFlMjBlYWUyOWUnLFxuICAgICAgICAnZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlN2EyNmNlNjlkZDQ4MjlmM2UxMGNlYzBhOWU5OGVkMzE0M2QwODRmMzA4YjkyYzA5OTdmZGRmYzYwY2IzZTQxJyxcbiAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDY4YTgwYzgyODBiYjg0MDc5MzIzNGFhMTE4ZjA2MjMxZDZmMWZjNjdlNzNjNWE1ZGVkYTBmNWI0OTY5NDNlOCcsXG4gICAgICAgICdkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyNGFlZDdkZjY1YzgwNDI1MmRjMDI3MDkwN2EzMGIwOTYxMmFlYjk3MzQ0OWNlYTQwOTU5ODBmYzI4ZDNkNWQnLFxuICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzljMzkxOWE4NGE0NzQ4NzBmYWVkOGE5YzFjYzY2MDIxNTIzNDg5MDU0ZDdmMDMwOGNiZmM5OWM4YWMxZjk4Y2QnLFxuICAgICAgICAnZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDU3MTcwYjFkZDEyZmRmOGRlMDVmMjgxZDhlMDZiYjkxZTE0OTNhOGI5MWQ0Y2M1YTIxMzgyMTIwYTk1OWU1JyxcbiAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NzhhNzhjMjhkZWMzZTMwYTA1ZmU5NjI5ZGU4YzM4YmIzMGQxZjVjZjlhM2EyMDhmNzYzODg5YmU1OGFkNzEnLFxuICAgICAgICAnMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5Mjg5NTVlZTYzN2E4NDQ2MzcyOWZkMzBlN2FmZDJlZDVmOTYyNzRlNWFkN2U1Y2IwOWVkYTljMDZkOTAzYWMnLFxuICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYyYjBkY2U5N2VlY2U5N2MxYzliNjA0MTc5OGI4NWRmZGZiNmQ4ODgyZGEyMDMwOGY1NDA0ODI0NTI2MDg3ZScsXG4gICAgICAgICc0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyN2ZiYmU0YjFlODgwZWE5ZWQyYjJlNjMwMWIyMTJiNTdmMWVlMTQ4Y2Q2ZGQyODc4MGU1ZTJjZjg1NmUyNDEnLFxuICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRhNDJkNDNjNWNmMTY5ZDkzOTFkZjZkZWNmNDJlZTU0MWI2ZDhmMGM5YTEzNzQwMWUyMzYzMmRkYTM0ZDI0ZicsXG4gICAgICAgICc0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlYzgwZmVmMzYwY2JkZDk1NDE2MGZhZGFiMzUyYjZiOTJiNTM1NzZhODhmZWE0OTQ3MTczYjlkNDMwMGJmMTknLFxuICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmE1MGMwZjYxZDIyZTVmMDdlM2FjZWJiMWFhMDdiMTI4ZDAwMTIyMDlhMjhiOTc3NmQ3NmE4NzkzMTgwZWVmOScsXG4gICAgICAgICc2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhMWQ2MWQwY2E3MjFhMTFiMWE1YmY2YjdkODhlODQyMWEyODhhYjVkNWJiYTUyMjBlNTNkMzJiNWYwNjdlYzInLFxuICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc0YTUzYjljOWEyODU4NzJkMzllNTZlNjkxM2NhYjE1ZDU5YjFmYTUxMjUwOGMwMjJmMzgyZGU4MzE5NDk3YycsXG4gICAgICAgICdjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk1OTM5Njk4MTk0Mzc4NWMzZDNlNTdlZGY1MDE4Y2RiZTAzOWU3MzBlNDkxOGIzZDg4NGZkZmYwOTQ3NWI3YmEnLFxuICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjQ1ODdlMjMzNTQ3MWViODkwZWU3ODk2ZDdjZmRjODY2YmFjYmRiZDM4MzkzMTdiMzQzNmY5YjQ1NjE3ZTA3MycsXG4gICAgICAgICdkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0ODFiZGUwZTRlNGQ4ODViM2E1NDZkM2U1NDlkZTA0MmYwYWE2Y2VhMjUwZTdmZDM1OGQ2Yzg2ZGQ0NWU0NTgnLFxuICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmM0YTlkZjViNzEzZmUyZTlhZWY0MzBiY2MxZGM5N2EwY2Q5Y2NlZGUyZjI4NTg4Y2FkYTNhMGQyZDgzZjM2NicsXG4gICAgICAgICdkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMyOGE5N2JmODI5OGJjMGQyM2Q4Yzc0OTQ1MmEzMmU2OTRiNjVlMzBhOTQ3MmEzOTU0YWIzMGZlNTMyNGNhYScsXG4gICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RkMzYyNWZhZWY1YmEwNjA3NDY2OTcxNmJiZDM3ODhkODliZGRlODE1OTU5OTY4MDkyZjc2Y2M0ZWI5YTk3ODcnLFxuICAgICAgICAnN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmNzEwZDc5ZDllYjk2MjI5N2U0ZjYyMzJiNDBlOGY3ZmViMmJjNjM4MTQ2MTRkNjkyYzEyZGU3NTI0MDgyMjFlJyxcbiAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBuYWY6IHtcbiAgICB3bmQ6IDcsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgJzM4OGY3YjBmNjMyZGU4MTQwZmUzMzdlNjJhMzdmMzU2NjUwMGE5OTkzNGMyMjMxYjZjYjlmZDc1ODRiOGU2NzInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmMnLFxuICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgJ2NjMzM4OTIxYjBhN2Q5ZmQ2NDM4MDk3MTc2M2I2MWU5YWRkODg4YTQzNzVmOGUwZjA1Y2MyNjJhYzY0ZjljMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYTgnLFxuICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAnNTgxZTI4NzJhODZjNzJhNjgzODQyZWMyMjhjYzZkZWZlYTQwYWYyYmQ4OTZkM2E1YzUwNGRjOWZmNmEyNmI1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2YycsXG4gICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAnMzIxZWI0MDc1MzQ4ZjUzNGQ1OWMxODI1OWRkYTNlMWY0YTFiM2IyZTcxYjEwMzljNjdiZDNkOGJjZjgxOTk4YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0JyxcbiAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICdhNjlkY2U0YTdkNmM5OGU4ZDRhMWFjYTg3ZWY4ZDcwMDNmODNjMjMwZjNhZmE3MjZhYjQwZTUyMjkwYmUxYzU1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0JyxcbiAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICdiOWMzOThmMTg2ODA2ZjVkMjc1NjE1MDZlNDU1NzQzM2EyY2YxNTAwOWU0OThhZTdhZGVlOWQ2M2QwMWIyMzk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2QnLFxuICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgJzFjMzgzMDNmMWNjNWMzMGYyNmU2NmJhZDdmZTcyZjcwYTY1ZWVkNGNiZTcwMjRlYjFhYTAxZjU2NDMwYmQ1N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOScsXG4gICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICc3NThmM2Y0MWFmZDZlZDQyOGIzMDgxYjA1MTJmZDYyYTU0YzNmM2FmYmI1YjY3NjRiNjUzMDUyYTEyOTQ5YzlhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwJyxcbiAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICc1ZWQ0MzBkNzhjMjk2YzM1NDMxMTQzMDZkZDg2MjJkN2M2MjJlMjdjOTcwYTFkZTMxY2IzNzdiMDFhZjczMDdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxJyxcbiAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICc0MTE5Yjg4NzUzYzE1YmQ2YTY5M2IwM2ZjZGRiYjQ1ZDVhYzZiZTc0YWI1ZjBlZjQ0YjBiZTk0NzVhN2U0YjQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMTgnLFxuICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAnNTljOWUwYmJhMzk0ZTc2ZjQwYzBhYTU4Mzc5YTNjYjZhNWEyMjgzOTkzZTkwYzQxNjcwMDJhZjQ5MjBlMzdmNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZicsXG4gICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAnZWZhZTljOGRiYzE0MTMwNjYxZThjZWMwMzBjODlhZDBjMTNjNjZjMGQxN2EyOTA1Y2RjNzA2YWI3Mzk5YTg2OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NScsXG4gICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAnNzQ0YjExNTJlYWNiZTVlMzhkY2M4ODc5ODBkYTM4Yjg5NzU4NGE2NWZhMDZjZWRkMmM5MjRmOTdjYmFjNTk5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOCcsXG4gICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAnMzBlOTNlODY0ZTY2OWQ4MjIyNGI5NjdjMzAyMGI4ZmE4ZDFlNGUzNTBiNmNiY2M1MzdhNDhiNTc4NDExNjNhMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYicsXG4gICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAnZWYwYWZiYjIwNTYyMDU0NDhlMTY1MmM0OGU4MTI3ZmM2MDM5ZTc3YzE1YzIzNzhiN2U3ZDE1YTBkZTI5MzMxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMCcsXG4gICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAnZjU0MzVhMmJkMmJhZGY3ZDQ4NWE0ZDhiOGRiOWZjY2UzZTFlZjhlMDIwMWU0NTc4YzU0NjczYmMxZGM1ZWExZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MCcsXG4gICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAnYTg1NWJhYmFkNWNkNjBjODhiNDMwYTY5ZjUzYTFhN2EzODI4OTE1NDk2NDc5OWJlNDNkMDZkNzdkMzFkYTA2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmJyxcbiAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgJzRjYjk1OTU3ZTgzZDQwYjBmNzNhZjQ1NDRjY2NmNmIxZjRiMDhkM2MwN2IyN2ZiOGQ4YzI5NjJhNDAwNzY2ZDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmYnLFxuICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgJzhlYzBiYTIzOGI5NmJlYzBjYmRkZGNhZTBhYTQ0MjU0MmVlZTFmZjUwYzk4NmVhNmIzOTg0N2IzY2MwOTJmZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjUnLFxuICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgJ2Y2NWY1ZDNlMjkyYzJlMDgxOWE1MjgzOTFjOTk0NjI0ZDc4NDg2OWQ3ZTZlYTY3ZmIxODA0MTAyNGVkYzA3ZGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNScsXG4gICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAnMjA0YjVkNmY4NDgyMmMzMDdlNGI0YTcxNDA3MzdhZWMyM2ZjNjNiNjViMzVmODZhMTAwMjZkYmQyZDg2NGU2YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxJyxcbiAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgJzM5ZjIzZjM2NjgwOTA4NWJlZWJmYzcxMTgxMzEzNzc1YTk5YzlhZWQ3ZDhiYTM4YjE2MTM4NGM3NDYwMTI4NjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNicsXG4gICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAnNmZkY2VmMDlmMmY2ZDBhMDQ0ZTY1NGFlZjYyNDEzNmY1MDNkNDU5YzNlODk4NDU4NThhNDdhOTEyOWNkZDI0ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxJyxcbiAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICdiNGM0ZmU5OWM3NzVhNjA2ZTJkODg2MjE3OTEzOWZmZGE2MWRjODYxYzAxOWU1NWNkMjg3NmViMmEyN2Q4NGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNScsXG4gICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAnNmZiOGQ1NTkxYjQ2NmY4ZmM2M2RiNTBmMWMwZjFjNjkwMTNmOTk2ODg3YjgyNDRkMmNkZWM0MTdhZmVhOGZhMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZicsXG4gICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgJzJhZWFiZTdlNDUzMTUxMDExNjIxN2YwN2JmNGQwNzMwMGRlOTdlNDg3NGY4MWY1MzM0MjBhNzJlZWIwYmQ2YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODQnLFxuICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgJ2IyMjg0Mjc5OTk1YTM0ZTJmOWQ0ZGU3Mzk2ZmMxOGI4MGY5YjhiOWZkZDI3MGY2NjYxZjc5Y2E0YzgxYmQyNTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTcnLFxuICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAnYzM1OWQ2OTIzYmIzOThmN2ZkNDQ3M2UxNmZlMWMyODQ3NWI3NDBkZDA5ODA3NWU2YzBlODY0OTExM2RjM2EzOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4JyxcbiAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICc0OWI5NjcxNWFiNjg3OGE3OWU3OGYwN2NlNTY4MGM1ZDY2NzMwNTFiNDkzNWJkODk3ZmVhODI0Yjc3ZGMyMDhhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyJyxcbiAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICdiZTUyZDEwN2JjZmEwOWQ4YmNiOTczNmE4MjhjZmE3ZmFjOGRiMTdiZjdhNzZhMmM0MmFkOTYxNDA5MDE4Y2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2JyxcbiAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICc2MmRmYWYwN2EwZjc4ZmViMzBlMzBkNjI5NTg1M2NlMTg5ZTEyNzc2MGFkNmNmN2ZhZTE2NGUxMjJhMjA4ZDU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhJyxcbiAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICdjZDQ1MGVjMzM1NDM4OTg2ZGZlZmExMGM1N2ZlYTliY2M1MjFhMDk1OWIyZDgwYmJmNzRiMTkwZGNhNzEyZDEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjJyxcbiAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICdmZWY1YTNjNjgwNTlhNmRlYzVkNjI0MTE0YmYxZTkxYWFjMmI5ZGE1NjhkNmFiZWIyNTcwZDU1NjQ2YjhhZGYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwJyxcbiAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICc0MzgxMzZkNjAzZTg1OGEzYTVjNDQwYzM4ZWNjYmFkZGMxZDI5NDIxMTRlMmVkZGQ0NzQwZDA5OGNlZDFmMGQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzJyxcbiAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgJzZkODlhZDdiYTQ4NzZiMGIyMmMyY2EyODBjNjgyODYyZjM0MmM4NTkxZjFkYWY1MTcwZTA3YmZkOWNjYWZhN2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDAnLFxuICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAnZWUxODQ5ZjUxM2RmNzFlMzJlZmMzODk2ZWUyODI2MGM3M2JiODA1NDdhZTIyNzViYTQ5NzIzNzc5NGM4NzUzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOCcsXG4gICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAnNjcxNjNlOTAzMjM2Mjg5Zjc3NmYyMmMyNWZiOGEzYWZjMTczMmYyYjg0YjRlOTVkYmRhNDdhZTVhMDg1MjY0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiJyxcbiAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICdmOTQyOWU3MzhiOGU1M2I5NjhlOTkwMTZjMDU5NzA3NzgyZTE0ZjQ1MzUzNTlkNTgyZmM0MTY5MTBiM2VlYTg3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3JyxcbiAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICc3YzEwZGZiMTY0YzM0MjVmNWM3MWEzZjlkNzk5MjAzOGYxMDY1MjI0ZjcyYmI5ZDFkOTAyYTZkMTMwMzdiNDdjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyJyxcbiAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICdiZDFhZWIyMWFkMjJlYmIyMmExMGYwMzAzNDE3YzZkOTY0ZjhjZGQ3ZGYwYWNhNjE0YjEwZGMxNGQxMjVhYzQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3JyxcbiAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICdjYzYxNTdlZjE4YzljNjNjZDYxOTNkODM2MzFiYmVhMDA5M2UwOTY4OTQyZThjMzNkNTczN2ZkNzkwZTBkYjA4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3JyxcbiAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgJ2VkOGNjOWQwNGIyOWViODc3ZDI3MGI0ODc4ZGM0M2MxOWFlZmQzMWY0ZWVlMDllZTdiNDc4MzRjMWZhNGIxYzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjEnLFxuICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgJzQwMzZlZGM5MzFhNjBhZTg4OTM1M2Y3N2ZkNTNkZTRhMjcwOGIyNmI2ZjVkYTcyYWQzMzk0MTE5ZGFmNDA4ZjknXG4gICAgICBdXG4gICAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBtaW5Bc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgbWluVXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG5cbnV0aWxzLmFzc2VydCA9IG1pbkFzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSBtaW5VdGlscy50b0FycmF5O1xudXRpbHMuemVybzIgPSBtaW5VdGlscy56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gbWluVXRpbHMudG9IZXg7XG51dGlscy5lbmNvZGUgPSBtaW5VdGlscy5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3LCBiaXRzKSB7XG4gIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuICBuYWYuZmlsbCgwKTtcblxuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgejtcbiAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuXG4gICAgbmFmW2ldID0gejtcbiAgICBrLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2Zyb21cIjogXCJlbGxpcHRpY0BeNi40LjBcIixcbiAgXCJfaWRcIjogXCJlbGxpcHRpY0A2LjUuMlwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLWY0eDcwb2t6WmJJUWwvTlNSTGtJLyt0dGVWLzlXcUw5OHp4K1NRNjlLYlh4bVZybWp3c05VUG4vZ1lKSjBzSHZFYWsyNGNaZ0hJUGVnUmVQQXRBL3h3PT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvZWxsaXB0aWNcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwidHlwZVwiOiBcInJhbmdlXCIsXG4gICAgXCJyZWdpc3RyeVwiOiB0cnVlLFxuICAgIFwicmF3XCI6IFwiZWxsaXB0aWNAXjYuNC4wXCIsXG4gICAgXCJuYW1lXCI6IFwiZWxsaXB0aWNcIixcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiZWxsaXB0aWNcIixcbiAgICBcInJhd1NwZWNcIjogXCJeNi40LjBcIixcbiAgICBcInNhdmVTcGVjXCI6IG51bGwsXG4gICAgXCJmZXRjaFNwZWNcIjogXCJeNi40LjBcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi90aW55LXNlY3AyNTZrMVwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZWxsaXB0aWMvLS9lbGxpcHRpYy02LjUuMi50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiMDVjNTY3OGQ3MTczYzA0OWQ4Y2E0MzM1NTIyMjRhNDk1ZDBlMzc2MlwiLFxuICBcIl9zcGVjXCI6IFwiZWxsaXB0aWNAXjYuNC4wXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcVXNlcnNcXFxcZW1tYW5cXFxcRGVza3RvcFxcXFxicm93c2VyaWZ5X2ludHJvXFxcXG5vZGVfbW9kdWxlc1xcXFx0aW55LXNlY3AyNTZrMVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRmVkb3IgSW5kdXRueVwiLFxuICAgIFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXNcIlxuICB9LFxuICBcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBmYWxzZSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYm4uanNcIjogXCJeNC40LjBcIixcbiAgICBcImJyb3JhbmRcIjogXCJeMS4wLjFcIixcbiAgICBcImhhc2guanNcIjogXCJeMS4wLjBcIixcbiAgICBcImhtYWMtZHJiZ1wiOiBcIl4xLjAuMFwiLFxuICAgIFwiaW5oZXJpdHNcIjogXCJeMi4wLjFcIixcbiAgICBcIm1pbmltYWxpc3RpYy1hc3NlcnRcIjogXCJeMS4wLjBcIixcbiAgICBcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIjogXCJeMS4wLjBcIlxuICB9LFxuICBcImRlcHJlY2F0ZWRcIjogZmFsc2UsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQyBjcnlwdG9ncmFwaHlcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJmc1wiOiBcIl4xLjQuM1wiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwiXjMuMC44XCIsXG4gICAgXCJncnVudFwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl41LjAuMFwiLFxuICAgIFwiZ3J1bnQtY2xpXCI6IFwiXjEuMi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMS4wLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMS4wLjFcIixcbiAgICBcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG4gICAgXCJncnVudC1zYXVjZWxhYnNcIjogXCJeOS4wLjFcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuNC4yXCIsXG4gICAgXCJqc2NzXCI6IFwiXjMuMC43XCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi4xMC4zXCIsXG4gICAgXCJtb2NoYVwiOiBcIl42LjIuMlwiXG4gIH0sXG4gIFwiZmlsZXNcIjogW1xuICAgIFwibGliXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiRUNcIixcbiAgICBcIkVsbGlwdGljXCIsXG4gICAgXCJjdXJ2ZVwiLFxuICAgIFwiQ3J5cHRvZ3JhcGh5XCJcbiAgXSxcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9lbGxpcHRpYy5qc1wiLFxuICBcIm5hbWVcIjogXCJlbGxpcHRpY1wiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImpzY3NcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJqc2hpbnRcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJsaW50XCI6IFwibnBtIHJ1biBqc2NzICYmIG5wbSBydW4ganNoaW50XCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdW5pdFwiLFxuICAgIFwidW5pdFwiOiBcImlzdGFuYnVsIHRlc3QgX21vY2hhIC0tcmVwb3J0ZXI9c3BlYyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiZ3J1bnQgZGlzdCAmJiBnaXQgYWRkIGRpc3QvXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiNi41LjJcIlxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyICh2YWwsIHByZWZpeCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcmVmaXggKyAnIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIEhhc2hCYXNlIChibG9ja1NpemUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja1NpemUpXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgdGhpcy5fbGVuZ3RoID0gWzAsIDAsIDAsIDBdXG5cbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcblxuSGFzaEJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyKGRhdGEsICdEYXRhJylcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxuXG4gIC8vIGNvbnN1bWUgZGF0YVxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgb2Zmc2V0ID0gMFxuICB3aGlsZSAodGhpcy5fYmxvY2tPZmZzZXQgKyBkYXRhLmxlbmd0aCAtIG9mZnNldCA+PSB0aGlzLl9ibG9ja1NpemUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG4gIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXVxuXG4gIC8vIHVwZGF0ZSBsZW5ndGhcbiAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gZGF0YS5sZW5ndGggKiA4OyBjYXJyeSA+IDA7ICsraikge1xuICAgIHRoaXMuX2xlbmd0aFtqXSArPSBjYXJyeVxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXG4gICAgaWYgKGNhcnJ5ID4gMCkgdGhpcy5fbGVuZ3RoW2pdIC09IDB4MDEwMDAwMDAwMCAqIGNhcnJ5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIGlzIG5vdCBpbXBsZW1lbnRlZCcpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXG5cbiAgdmFyIGRpZ2VzdCA9IHRoaXMuX2RpZ2VzdCgpXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSBkaWdlc3QgPSBkaWdlc3QudG9TdHJpbmcoZW5jb2RpbmcpXG5cbiAgLy8gcmVzZXQgc3RhdGVcbiAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHRoaXMuX2xlbmd0aFtpXSA9IDBcblxuICByZXR1cm4gZGlnZXN0XG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxuIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxuZXhwb3J0cy5CbG9ja0hhc2ggPSBCbG9ja0hhc2g7XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuICBlbHNlXG4gICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG4gIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcbiAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG4gICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcbiAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcbiAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cbiAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG4gIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG4gIHJlc1swXSA9IDB4ODA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG5cbiAgLy8gQXBwZW5kIGxlbmd0aFxuICBsZW4gPDw9IDM7XG4gIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG5cbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuXG4gICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDZhO1xuICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xufTtcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxuZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xufVxudXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5SSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5SSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBBID0gdGhpcy5oWzBdO1xuICB2YXIgQiA9IHRoaXMuaFsxXTtcbiAgdmFyIEMgPSB0aGlzLmhbMl07XG4gIHZhciBEID0gdGhpcy5oWzNdO1xuICB2YXIgRSA9IHRoaXMuaFs0XTtcbiAgdmFyIEFoID0gQTtcbiAgdmFyIEJoID0gQjtcbiAgdmFyIENoID0gQztcbiAgdmFyIERoID0gRDtcbiAgdmFyIEVoID0gRTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgdmFyIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG4gICAgICAgIHNbal0pLFxuICAgICAgRSk7XG4gICAgQSA9IEU7XG4gICAgRSA9IEQ7XG4gICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgQyA9IEI7XG4gICAgQiA9IFQ7XG4gICAgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuICAgICAgICBzaFtqXSksXG4gICAgICBFaCk7XG4gICAgQWggPSBFaDtcbiAgICBFaCA9IERoO1xuICAgIERoID0gcm90bDMyKENoLCAxMCk7XG4gICAgQ2ggPSBCaDtcbiAgICBCaCA9IFQ7XG4gIH1cbiAgVCA9IHN1bTMyXzModGhpcy5oWzFdLCBDLCBEaCk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gIHRoaXMuaFsyXSA9IHN1bTMyXzModGhpcy5oWzNdLCBFLCBBaCk7XG4gIHRoaXMuaFszXSA9IHN1bTMyXzModGhpcy5oWzRdLCBBLCBCaCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gIHRoaXMuaFswXSA9IFQ7XG59O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG59O1xuXG5mdW5jdGlvbiBmKGosIHgsIHksIHopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgZWxzZVxuICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcbn1cblxuZnVuY3Rpb24gSyhqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVhODI3OTk5O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZlZDllYmExO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDhmMWJiY2RjO1xuICBlbHNlXG4gICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG59XG5cbmZ1bmN0aW9uIEtoKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4NTBhMjhiZTY7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG4gIGVsc2VcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbn1cblxudmFyIHIgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl07XG5cbnZhciByaCA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXTtcblxudmFyIHMgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dO1xuXG52YXIgc2ggPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIFNIQTI1NiA9IHJlcXVpcmUoJy4vMjU2Jyk7XG5cbmZ1bmN0aW9uIFNIQTIyNCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgcmV0dXJuIG5ldyBTSEEyMjQoKTtcblxuICBTSEEyNTYuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuLzUxMicpO1xuXG5mdW5jdGlvbiBTSEEzODQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKVxuICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG5cbiAgU0hBNTEyLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihtc2csIGkpIHtcbiAgaWYgKChtc2cuY2hhckNvZGVBdChpKSAmIDB4RkMwMCkgIT09IDB4RDgwMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICAvLyBJbnNwaXJlZCBieSBzdHJpbmdUb1V0ZjhCeXRlQXJyYXkoKSBpbiBjbG9zdXJlLWxpYnJhcnkgYnkgR29vZ2xlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iLzg1OThkODcyNDJhZjU5YWFjMjMzMjcwNzQyYzg5ODRlMmIyYmRiZTAvY2xvc3VyZS9nb29nL2NyeXB0L2NyeXB0LmpzI0wxMTctTDE0M1xuICAgICAgLy8gQXBhY2hlIExpY2Vuc2UgMi4wXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICB2YXIgcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHJlc1twKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSkge1xuICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM0ZGKSA8PCAxMCkgKyAobXNnLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNGRik7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXggPSB0b0hleDtcblxuZnVuY3Rpb24gaHRvbmwodykge1xuICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG4gICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuICByZXR1cm4gcmVzID4+PiAwO1xufVxuZXhwb3J0cy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG4gICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcbiAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcbiAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3BsaXQzMiA9IHNwbGl0MzI7XG5cbmZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG4gIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMiA9IHN1bTMyO1xuXG5mdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzUgPSBzdW0zMl81O1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9oaSA9IHN1bTY0X2hpO1xuXG5mdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSBhbCArIGJsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuXG5mdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9oaSA9IHJvdHI2NF9oaTtcblxuZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn1cbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBwZXJzID0gdXRpbHMudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMuX3Jlc2VlZCsrO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoQmFzZSA9IHJlcXVpcmUoJ2hhc2gtYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbmZ1bmN0aW9uIE1ENSAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbn1cblxuaW5oZXJpdHMoTUQ1LCBIYXNoQmFzZSlcblxuTUQ1LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTSA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBNW2ldID0gdGhpcy5fYmxvY2sucmVhZEludDMyTEUoaSAqIDQpXG5cbiAgdmFyIGEgPSB0aGlzLl9hXG4gIHZhciBiID0gdGhpcy5fYlxuICB2YXIgYyA9IHRoaXMuX2NcbiAgdmFyIGQgPSB0aGlzLl9kXG5cbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzBdLCAweGQ3NmFhNDc4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMV0sIDB4ZThjN2I3NTYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMl0sIDB4MjQyMDcwZGIsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bM10sIDB4YzFiZGNlZWUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bNF0sIDB4ZjU3YzBmYWYsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVs1XSwgMHg0Nzg3YzYyYSwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVs2XSwgMHhhODMwNDYxMywgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVs3XSwgMHhmZDQ2OTUwMSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs4XSwgMHg2OTgwOThkOCwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzldLCAweDhiNDRmN2FmLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmZmNWJiMSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxMV0sIDB4ODk1Y2Q3YmUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMTJdLCAweDZiOTAxMTIyLCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMTNdLCAweGZkOTg3MTkzLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzE0XSwgMHhhNjc5NDM4ZSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxNV0sIDB4NDliNDA4MjEsIDIyKVxuXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxXSwgMHhmNjFlMjU2MiwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzZdLCAweGMwNDBiMzQwLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTFdLCAweDI2NWU1YTUxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzBdLCAweGU5YjZjN2FhLCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzVdLCAweGQ2MmYxMDVkLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTBdLCAweDAyNDQxNDUzLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTVdLCAweGQ4YTFlNjgxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzRdLCAweGU3ZDNmYmM4LCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzldLCAweDIxZTFjZGU2LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTRdLCAweGMzMzcwN2Q2LCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bM10sIDB4ZjRkNTBkODcsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bOF0sIDB4NDU1YTE0ZWQsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bMTNdLCAweGE5ZTNlOTA1LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMl0sIDB4ZmNlZmEzZjgsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVs3XSwgMHg2NzZmMDJkOSwgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVsxMl0sIDB4OGQyYTRjOGEsIDIwKVxuXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs1XSwgMHhmZmZhMzk0MiwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzhdLCAweDg3NzFmNjgxLCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzExXSwgMHg2ZDlkNjEyMiwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxNF0sIDB4ZmRlNTM4MGMsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMV0sIDB4YTRiZWVhNDQsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVs0XSwgMHg0YmRlY2ZhOSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVs3XSwgMHhmNmJiNGI2MCwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxMF0sIDB4YmViZmJjNzAsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMTNdLCAweDI4OWI3ZWM2LCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bMF0sIDB4ZWFhMTI3ZmEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bM10sIDB4ZDRlZjMwODUsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bNl0sIDB4MDQ4ODFkMDUsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bOV0sIDB4ZDlkNGQwMzksIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVsxMl0sIDB4ZTZkYjk5ZTUsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTVdLCAweDFmYTI3Y2Y4LCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzJdLCAweGM0YWM1NjY1LCAyMylcblxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZjQyOTIyNDQsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVs3XSwgMHg0MzJhZmY5NywgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxNF0sIDB4YWI5NDIzYTcsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bNV0sIDB4ZmM5M2EwMzksIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMTJdLCAweDY1NWI1OWMzLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bM10sIDB4OGYwY2NjOTIsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZWZmNDdkLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzFdLCAweDg1ODQ1ZGQxLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzhdLCAweDZmYTg3ZTRmLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTVdLCAweGZlMmNlNmUwLCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzZdLCAweGEzMDE0MzE0LCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzEzXSwgMHg0ZTA4MTFhMSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVs0XSwgMHhmNzUzN2U4MiwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzExXSwgMHhiZDNhZjIzNSwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsyXSwgMHgyYWQ3ZDJiYiwgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs5XSwgMHhlYjg2ZDM5MSwgMjEpXG5cbiAgdGhpcy5fYSA9ICh0aGlzLl9hICsgYSkgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYiArIGIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9kICsgZCkgfCAwXG59XG5cbk1ENS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmcgYW5kIGhhbmRsZSBibG9ja3NcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXG4gIGlmICh0aGlzLl9ibG9ja09mZnNldCA+IDU2KSB7XG4gICAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNjQpXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFswXSwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcbiAgdGhpcy5fdXBkYXRlKClcblxuICAvLyBwcm9kdWNlIHJlc3VsdFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbkYgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuRyAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5IIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5JIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYyBeIChiIHwgKH5kKSkpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTUQ1XG4iLCIvLyBjb25zdGFudC1zcGFjZSBtZXJrbGUgcm9vdCBjYWxjdWxhdGlvbiBhbGdvcml0aG1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmFzdFJvb3QgKHZhbHVlcywgZGlnZXN0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWVzIEFycmF5JylcbiAgaWYgKHR5cGVvZiBkaWdlc3RGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBkaWdlc3QgRnVuY3Rpb24nKVxuXG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoXG4gIHZhciByZXN1bHRzID0gdmFsdWVzLmNvbmNhdCgpXG5cbiAgd2hpbGUgKGxlbmd0aCA+IDEpIHtcbiAgICB2YXIgaiA9IDBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIsICsraikge1xuICAgICAgdmFyIGxlZnQgPSByZXN1bHRzW2ldXG4gICAgICB2YXIgcmlnaHQgPSBpICsgMSA9PT0gbGVuZ3RoID8gbGVmdCA6IHJlc3VsdHNbaSArIDFdXG4gICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2xlZnQsIHJpZ2h0XSlcblxuICAgICAgcmVzdWx0c1tqXSA9IGRpZ2VzdEZuKGRhdGEpXG4gICAgfVxuXG4gICAgbGVuZ3RoID0galxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHNbMF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcbiIsImV4cG9ydHMucGJrZGYyID0gcmVxdWlyZSgnLi9saWIvYXN5bmMnKVxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcmVxdWlyZSgnLi9saWIvc3luYycpXG4iLCJ2YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxudmFyIGRlZmF1bHRFbmNvZGluZyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1lbmNvZGluZycpXG52YXIgc3luYyA9IHJlcXVpcmUoJy4vc3luYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFpFUk9fQlVGXG52YXIgc3VidGxlID0gZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLnN1YnRsZVxudmFyIHRvQnJvd3NlciA9IHtcbiAgJ3NoYSc6ICdTSEEtMScsXG4gICdzaGEtMSc6ICdTSEEtMScsXG4gICdzaGExJzogJ1NIQS0xJyxcbiAgJ3NoYTI1Nic6ICdTSEEtMjU2JyxcbiAgJ3NoYS0yNTYnOiAnU0hBLTI1NicsXG4gICdzaGEzODQnOiAnU0hBLTM4NCcsXG4gICdzaGEtMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTUxMic6ICdTSEEtNTEyJyxcbiAgJ3NoYTUxMic6ICdTSEEtNTEyJ1xufVxudmFyIGNoZWNrcyA9IFtdXG5mdW5jdGlvbiBjaGVja05hdGl2ZSAoYWxnbykge1xuICBpZiAoZ2xvYmFsLnByb2Nlc3MgJiYgIWdsb2JhbC5wcm9jZXNzLmJyb3dzZXIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmICghc3VidGxlIHx8ICFzdWJ0bGUuaW1wb3J0S2V5IHx8ICFzdWJ0bGUuZGVyaXZlQml0cykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gIH1cbiAgaWYgKGNoZWNrc1thbGdvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNoZWNrc1thbGdvXVxuICB9XG4gIFpFUk9fQlVGID0gWkVST19CVUYgfHwgQnVmZmVyLmFsbG9jKDgpXG4gIHZhciBwcm9tID0gYnJvd3NlclBia2RmMihaRVJPX0JVRiwgWkVST19CVUYsIDEwLCAxMjgsIGFsZ28pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICBjaGVja3NbYWxnb10gPSBwcm9tXG4gIHJldHVybiBwcm9tXG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJQYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBsZW5ndGgsIGFsZ28pIHtcbiAgcmV0dXJuIHN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsIHBhc3N3b3JkLCB7bmFtZTogJ1BCS0RGMid9LCBmYWxzZSwgWydkZXJpdmVCaXRzJ11cbiAgKS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3VidGxlLmRlcml2ZUJpdHMoe1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICBzYWx0OiBzYWx0LFxuICAgICAgaXRlcmF0aW9uczogaXRlcmF0aW9ucyxcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogYWxnb1xuICAgICAgfVxuICAgIH0sIGtleSwgbGVuZ3RoIDw8IDMpXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9taXNlIChwcm9taXNlLCBjYWxsYmFjaykge1xuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG91dCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgb3V0KVxuICAgIH0pXG4gIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH0pXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcbiAgdmFyIGFsZ28gPSB0b0Jyb3dzZXJbZGlnZXN0LnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFhbGdvIHx8IHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvdXRcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9XG5cbiAgY2hlY2tQYXJhbWV0ZXJzKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIHJlc29sdmVQcm9taXNlKGNoZWNrTmF0aXZlKGFsZ28pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBpZiAocmVzcCkgcmV0dXJuIGJyb3dzZXJQYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbylcblxuICAgIHJldHVybiBzeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgfSksIGNhbGxiYWNrKVxufVxuIiwidmFyIGRlZmF1bHRFbmNvZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZGVmYXVsdEVuY29kaW5nID0gJ3V0Zi04J1xufSBlbHNlIHtcbiAgdmFyIHBWZXJzaW9uTWFqb3IgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKVswXS5zbGljZSgxKSwgMTApXG5cbiAgZGVmYXVsdEVuY29kaW5nID0gcFZlcnNpb25NYWpvciA+PSA2ID8gJ3V0Zi04JyA6ICdiaW5hcnknXG59XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRFbmNvZGluZ1xuIiwidmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5cbmZ1bmN0aW9uIGNoZWNrQnVmZmVyIChidWYsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBidWYgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZSArICcgbXVzdCBiZSBhIGJ1ZmZlciBvciBzdHJpbmcnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pIHtcbiAgY2hlY2tCdWZmZXIocGFzc3dvcmQsICdQYXNzd29yZCcpXG4gIGNoZWNrQnVmZmVyKHNhbHQsICdTYWx0JylcblxuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXlsZW4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGtleWxlbiA8IDAgfHwga2V5bGVuID4gTUFYX0FMTE9DIHx8IGtleWxlbiAhPT0ga2V5bGVuKSB7IC8qIGVzbGludCBuby1zZWxmLWNvbXBhcmU6IDAgKi9cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cbn1cbiIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIGNoZWNrUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9uJylcbnZhciBkZWZhdWx0RW5jb2RpbmcgPSByZXF1aXJlKCcuL2RlZmF1bHQtZW5jb2RpbmcnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxudmFyIHNpemVzID0ge1xuICBtZDU6IDE2LFxuICBzaGExOiAyMCxcbiAgc2hhMjI0OiAyOCxcbiAgc2hhMjU2OiAzMixcbiAgc2hhMzg0OiA0OCxcbiAgc2hhNTEyOiA2NCxcbiAgcm1kMTYwOiAyMCxcbiAgcmlwZW1kMTYwOiAyMFxufVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSwgc2FsdExlbikge1xuICB2YXIgaGFzaCA9IGdldERpZ2VzdChhbGcpXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBoYXNoKGtleSlcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIHZhciBvcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB2YXIgaXBhZDEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplICsgc2FsdExlbiArIDQpXG4gIGlwYWQuY29weShpcGFkMSwgMCwgMCwgYmxvY2tzaXplKVxuICB0aGlzLmlwYWQxID0gaXBhZDFcbiAgdGhpcy5pcGFkMiA9IGlwYWRcbiAgdGhpcy5vcGFkID0gb3BhZFxuICB0aGlzLmFsZyA9IGFsZ1xuICB0aGlzLmJsb2Nrc2l6ZSA9IGJsb2Nrc2l6ZVxuICB0aGlzLmhhc2ggPSBoYXNoXG4gIHRoaXMuc2l6ZSA9IHNpemVzW2FsZ11cbn1cblxuSG1hYy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGRhdGEsIGlwYWQpIHtcbiAgZGF0YS5jb3B5KGlwYWQsIHRoaXMuYmxvY2tzaXplKVxuICB2YXIgaCA9IHRoaXMuaGFzaChpcGFkKVxuICBoLmNvcHkodGhpcy5vcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgcmV0dXJuIHRoaXMuaGFzaCh0aGlzLm9wYWQpXG59XG5cbmZ1bmN0aW9uIGdldERpZ2VzdCAoYWxnKSB7XG4gIGZ1bmN0aW9uIHNoYUZ1bmMgKGRhdGEpIHtcbiAgICByZXR1cm4gc2hhKGFsZykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cbiAgZnVuY3Rpb24gcm1kMTYwRnVuYyAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cblxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSByZXR1cm4gcm1kMTYwRnVuY1xuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG1kNVxuICByZXR1cm4gc2hhRnVuY1xufVxuXG5mdW5jdGlvbiBwYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBjaGVja1BhcmFtZXRlcnMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbilcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIGRlZmF1bHRFbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCBkZWZhdWx0RW5jb2RpbmcpXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIHZhciBobWFjID0gbmV3IEhtYWMoZGlnZXN0LCBwYXNzd29yZCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIERLID0gQnVmZmVyLmFsbG9jVW5zYWZlKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzYWx0Lmxlbmd0aCArIDQpXG4gIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciBkZXN0UG9zID0gMFxuICB2YXIgaExlbiA9IHNpemVzW2RpZ2VzdF1cbiAgdmFyIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICBibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcblxuICAgIHZhciBUID0gaG1hYy5ydW4oYmxvY2sxLCBobWFjLmlwYWQxKVxuICAgIHZhciBVID0gVFxuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgIFUgPSBobWFjLnJ1bihVLCBobWFjLmlwYWQyKVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIFRba10gXj0gVVtrXVxuICAgIH1cblxuICAgIFQuY29weShESywgZGVzdFBvcylcbiAgICBkZXN0UG9zICs9IGhMZW5cbiAgfVxuXG4gIHJldHVybiBES1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBia2RmMlxuIiwidmFyIE9QUyA9IHJlcXVpcmUoJ2JpdGNvaW4tb3BzJylcblxuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKGkpIHtcbiAgcmV0dXJuIGkgPCBPUFMuT1BfUFVTSERBVEExID8gMVxuICA6IGkgPD0gMHhmZiA/IDJcbiAgOiBpIDw9IDB4ZmZmZiA/IDNcbiAgOiA1XG59XG5cbmZ1bmN0aW9uIGVuY29kZSAoYnVmZmVyLCBudW1iZXIsIG9mZnNldCkge1xuICB2YXIgc2l6ZSA9IGVuY29kaW5nTGVuZ3RoKG51bWJlcilcblxuICAvLyB+NiBiaXRcbiAgaWYgKHNpemUgPT09IDEpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChudW1iZXIsIG9mZnNldClcblxuICAvLyA4IGJpdFxuICB9IGVsc2UgaWYgKHNpemUgPT09IDIpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChPUFMuT1BfUFVTSERBVEExLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDgobnVtYmVyLCBvZmZzZXQgKyAxKVxuXG4gIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKHNpemUgPT09IDMpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChPUFMuT1BfUFVTSERBVEEyLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDE2TEUobnVtYmVyLCBvZmZzZXQgKyAxKVxuXG4gIC8vIDMyIGJpdFxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KE9QUy5PUF9QVVNIREFUQTQsIG9mZnNldClcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShudW1iZXIsIG9mZnNldCArIDEpXG4gIH1cblxuICByZXR1cm4gc2l6ZVxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciBvcGNvZGUgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldClcbiAgdmFyIG51bWJlciwgc2l6ZVxuXG4gIC8vIH42IGJpdFxuICBpZiAob3Bjb2RlIDwgT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgIG51bWJlciA9IG9wY29kZVxuICAgIHNpemUgPSAxXG5cbiAgLy8gOCBiaXRcbiAgfSBlbHNlIGlmIChvcGNvZGUgPT09IE9QUy5PUF9QVVNIREFUQTEpIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsXG4gICAgbnVtYmVyID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAxKVxuICAgIHNpemUgPSAyXG5cbiAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAob3Bjb2RlID09PSBPUFMuT1BfUFVTSERBVEEyKSB7XG4gICAgaWYgKG9mZnNldCArIDMgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgIG51bWJlciA9IGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSlcbiAgICBzaXplID0gM1xuXG4gIC8vIDMyIGJpdFxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyA1ID4gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICBpZiAob3Bjb2RlICE9PSBPUFMuT1BfUFVTSERBVEE0KSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3Bjb2RlJylcblxuICAgIG51bWJlciA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSlcbiAgICBzaXplID0gNVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcGNvZGU6IG9wY29kZSxcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICBzaXplOiBzaXplXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kaW5nTGVuZ3RoOiBlbmNvZGluZ0xlbmd0aCxcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlXVxudmFyIGhyID0gWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcbn1cblxuaW5oZXJpdHMoUklQRU1EMTYwLCBIYXNoQmFzZSlcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd29yZHMgPSBBUlJBWTE2XG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikgd29yZHNbal0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShqICogNClcblxuICB2YXIgYWwgPSB0aGlzLl9hIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9iIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lIHwgMFxuXG4gIHZhciBhciA9IHRoaXMuX2EgfCAwXG4gIHZhciBiciA9IHRoaXMuX2IgfCAwXG4gIHZhciBjciA9IHRoaXMuX2MgfCAwXG4gIHZhciBkciA9IHRoaXMuX2QgfCAwXG4gIHZhciBlciA9IHRoaXMuX2UgfCAwXG5cbiAgLy8gY29tcHV0YXRpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdmFyIHRsXG4gICAgdmFyIHRyXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdGwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzBdLCBzbFtpXSlcbiAgICAgIHRyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclswXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHRsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsxXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuNChhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMV0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0bCA9IGZuMyhhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMl0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjMoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzJdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdGwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzNdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4yKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclszXSwgc3JbaV0pXG4gICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcbiAgICAgIHRsID0gZm41KGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFs0XSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbNF0sIHNyW2ldKVxuICAgIH1cblxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0bFxuXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRyXG4gIH1cblxuICAvLyB1cGRhdGUgc3RhdGVcbiAgdmFyIHQgPSAodGhpcy5fYiArIGNsICsgZHIpIHwgMFxuICB0aGlzLl9iID0gKHRoaXMuX2MgKyBkbCArIGVyKSB8IDBcbiAgdGhpcy5fYyA9ICh0aGlzLl9kICsgZWwgKyBhcikgfCAwXG4gIHRoaXMuX2QgPSAodGhpcy5fZSArIGFsICsgYnIpIHwgMFxuICB0aGlzLl9lID0gKHRoaXMuX2EgKyBibCArIGNyKSB8IDBcbiAgdGhpcy5fYSA9IHRcbn1cblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoMjApIDogbmV3IEJ1ZmZlcigyMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9hLCAwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2IsIDQpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYywgOClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9kLCAxMilcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9lLCAxNilcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gZm4xIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4yIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjMgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiIHwgKH5jKSkgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNCAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm41IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gKGMgfCAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJJUEVNRDE2MFxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsImNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKVxuY29uc3QgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG5jb25zdCBzZWNwMjU2azEgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG5jb25zdCBkZXRlcm1pbmlzdGljR2VuZXJhdGVLID0gcmVxdWlyZSgnLi9yZmM2OTc5JylcblxuY29uc3QgWkVSTzMyID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbSgnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsICdoZXgnKVxuY29uc3QgRUNfUCA9IEJ1ZmZlci5mcm9tKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJywgJ2hleCcpXG5cbmNvbnN0IG4gPSBzZWNwMjU2azEuY3VydmUublxuY29uc3QgbkRpdjIgPSBuLnNocm4oMSlcbmNvbnN0IEcgPSBzZWNwMjU2azEuY3VydmUuZ1xuXG5jb25zdCBUSFJPV19CQURfUFJJVkFURSA9ICdFeHBlY3RlZCBQcml2YXRlJ1xuY29uc3QgVEhST1dfQkFEX1BPSU5UID0gJ0V4cGVjdGVkIFBvaW50J1xuY29uc3QgVEhST1dfQkFEX1RXRUFLID0gJ0V4cGVjdGVkIFR3ZWFrJ1xuY29uc3QgVEhST1dfQkFEX0hBU0ggPSAnRXhwZWN0ZWQgSGFzaCdcbmNvbnN0IFRIUk9XX0JBRF9TSUdOQVRVUkUgPSAnRXhwZWN0ZWQgU2lnbmF0dXJlJ1xuY29uc3QgVEhST1dfQkFEX0VYVFJBX0RBVEEgPSAnRXhwZWN0ZWQgRXh0cmEgRGF0YSAoMzIgYnl0ZXMpJ1xuXG5mdW5jdGlvbiBpc1NjYWxhciAoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMlxufVxuXG5mdW5jdGlvbiBpc09yZGVyU2NhbGFyICh4KSB7XG4gIGlmICghaXNTY2FsYXIoeCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4geC5jb21wYXJlKEVDX0dST1VQX09SREVSKSA8IDAgLy8gPCBHXG59XG5cbmZ1bmN0aW9uIGlzUG9pbnQgKHApIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocCkpIHJldHVybiBmYWxzZVxuICBpZiAocC5sZW5ndGggPCAzMykgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdCA9IHBbMF1cbiAgY29uc3QgeCA9IHAuc2xpY2UoMSwgMzMpXG4gIGlmICh4LmNvbXBhcmUoWkVSTzMyKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICh4LmNvbXBhcmUoRUNfUCkgPj0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICgodCA9PT0gMHgwMiB8fCB0ID09PSAweDAzKSAmJiBwLmxlbmd0aCA9PT0gMzMpIHtcbiAgICB0cnkgeyBkZWNvZGVGcm9tKHApIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlIH0gLy8gVE9ETzogdGVtcG9yYXJ5XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IHkgPSBwLnNsaWNlKDMzKVxuICBpZiAoeS5jb21wYXJlKFpFUk8zMikgPT09IDApIHJldHVybiBmYWxzZVxuICBpZiAoeS5jb21wYXJlKEVDX1ApID49IDApIHJldHVybiBmYWxzZVxuICBpZiAodCA9PT0gMHgwNCAmJiBwLmxlbmd0aCA9PT0gNjUpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBfX2lzUG9pbnRDb21wcmVzc2VkIChwKSB7XG4gIHJldHVybiBwWzBdICE9PSAweDA0XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRDb21wcmVzc2VkIChwKSB7XG4gIGlmICghaXNQb2ludChwKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBfX2lzUG9pbnRDb21wcmVzc2VkKHApXG59XG5cbmZ1bmN0aW9uIGlzUHJpdmF0ZSAoeCkge1xuICBpZiAoIWlzU2NhbGFyKHgpKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHguY29tcGFyZShaRVJPMzIpID4gMCAmJiAvLyA+IDBcbiAgICB4LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMCAvLyA8IEdcbn1cblxuZnVuY3Rpb24gaXNTaWduYXR1cmUgKHZhbHVlKSB7XG4gIGNvbnN0IHIgPSB2YWx1ZS5zbGljZSgwLCAzMilcbiAgY29uc3QgcyA9IHZhbHVlLnNsaWNlKDMyLCA2NClcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA2NCAmJlxuICAgIHIuY29tcGFyZShFQ19HUk9VUF9PUkRFUikgPCAwICYmXG4gICAgcy5jb21wYXJlKEVDX0dST1VQX09SREVSKSA8IDBcbn1cblxuZnVuY3Rpb24gYXNzdW1lQ29tcHJlc3Npb24gKHZhbHVlLCBwdWJrZXkpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgcHVia2V5ICE9PSB1bmRlZmluZWQpIHJldHVybiBfX2lzUG9pbnRDb21wcmVzc2VkKHB1YmtleSlcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlXG4gIHJldHVybiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyIChkKSB7IHJldHVybiBuZXcgQk4oZCkgfVxuZnVuY3Rpb24gdG9CdWZmZXIgKGQpIHsgcmV0dXJuIGQudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikgfVxuZnVuY3Rpb24gZGVjb2RlRnJvbSAoUCkgeyByZXR1cm4gc2VjcDI1NmsxLmN1cnZlLmRlY29kZVBvaW50KFApIH1cbmZ1bmN0aW9uIGdldEVuY29kZWQgKFAsIGNvbXByZXNzZWQpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKFAuX2VuY29kZShjb21wcmVzc2VkKSkgfVxuXG5mdW5jdGlvbiBwb2ludEFkZCAocEEsIHBCLCBfX2NvbXByZXNzZWQpIHtcbiAgaWYgKCFpc1BvaW50KHBBKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG4gIGlmICghaXNQb2ludChwQikpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuXG4gIGNvbnN0IGEgPSBkZWNvZGVGcm9tKHBBKVxuICBjb25zdCBiID0gZGVjb2RlRnJvbShwQilcbiAgY29uc3QgcHAgPSBhLmFkZChiKVxuICBpZiAocHAuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHBBKVxuICByZXR1cm4gZ2V0RW5jb2RlZChwcCwgY29tcHJlc3NlZClcbn1cblxuZnVuY3Rpb24gcG9pbnRBZGRTY2FsYXIgKHAsIHR3ZWFrLCBfX2NvbXByZXNzZWQpIHtcbiAgaWYgKCFpc1BvaW50KHApKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QT0lOVClcbiAgaWYgKCFpc09yZGVyU2NhbGFyKHR3ZWFrKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfVFdFQUspXG5cbiAgY29uc3QgY29tcHJlc3NlZCA9IGFzc3VtZUNvbXByZXNzaW9uKF9fY29tcHJlc3NlZCwgcClcbiAgY29uc3QgcHAgPSBkZWNvZGVGcm9tKHApXG4gIGlmICh0d2Vhay5jb21wYXJlKFpFUk8zMikgPT09IDApIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxuXG4gIGNvbnN0IHR0ID0gZnJvbUJ1ZmZlcih0d2VhaylcbiAgY29uc3QgcXEgPSBHLm11bCh0dClcbiAgY29uc3QgdXUgPSBwcC5hZGQocXEpXG4gIGlmICh1dS5pc0luZmluaXR5KCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGdldEVuY29kZWQodXUsIGNvbXByZXNzZWQpXG59XG5cbmZ1bmN0aW9uIHBvaW50Q29tcHJlc3MgKHAsIGNvbXByZXNzZWQpIHtcbiAgaWYgKCFpc1BvaW50KHApKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QT0lOVClcblxuICBjb25zdCBwcCA9IGRlY29kZUZyb20ocClcbiAgaWYgKHBwLmlzSW5maW5pdHkoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG5cbiAgcmV0dXJuIGdldEVuY29kZWQocHAsIGNvbXByZXNzZWQpXG59XG5cbmZ1bmN0aW9uIHBvaW50RnJvbVNjYWxhciAoZCwgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQcml2YXRlKGQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QUklWQVRFKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCBwcCA9IEcubXVsKGRkKVxuICBpZiAocHAuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQpXG4gIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwb2ludE11bHRpcGx5IChwLCB0d2VhaywgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHApXG4gIGNvbnN0IHBwID0gZGVjb2RlRnJvbShwKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IHFxID0gcHAubXVsKHR0KVxuICBpZiAocXEuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBnZXRFbmNvZGVkKHFxLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwcml2YXRlQWRkIChkLCB0d2Vhaykge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUFJJVkFURSlcbiAgaWYgKCFpc09yZGVyU2NhbGFyKHR3ZWFrKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfVFdFQUspXG5cbiAgY29uc3QgZGQgPSBmcm9tQnVmZmVyKGQpXG4gIGNvbnN0IHR0ID0gZnJvbUJ1ZmZlcih0d2VhaylcbiAgY29uc3QgZHQgPSB0b0J1ZmZlcihkZC5hZGQodHQpLnVtb2QobikpXG4gIGlmICghaXNQcml2YXRlKGR0KSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZHRcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZVN1YiAoZCwgdHdlYWspIHtcbiAgaWYgKCFpc1ByaXZhdGUoZCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IGR0ID0gdG9CdWZmZXIoZGQuc3ViKHR0KS51bW9kKG4pKVxuICBpZiAoIWlzUHJpdmF0ZShkdCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGR0XG59XG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIHgpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4KVxufVxuXG5mdW5jdGlvbiBzaWduV2l0aEVudHJvcHkgKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4LCBhZGREYXRhKVxufVxuXG5mdW5jdGlvbiBfX3NpZ24gKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgaWYgKCFpc1NjYWxhcihoYXNoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfSEFTSClcbiAgaWYgKCFpc1ByaXZhdGUoeCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmIChhZGREYXRhICE9PSB1bmRlZmluZWQgJiYgIWlzU2NhbGFyKGFkZERhdGEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9FWFRSQV9EQVRBKVxuXG4gIGNvbnN0IGQgPSBmcm9tQnVmZmVyKHgpXG4gIGNvbnN0IGUgPSBmcm9tQnVmZmVyKGhhc2gpXG5cbiAgbGV0IHIsIHNcbiAgY29uc3QgY2hlY2tTaWcgPSBmdW5jdGlvbiAoaykge1xuICAgIGNvbnN0IGtJID0gZnJvbUJ1ZmZlcihrKVxuICAgIGNvbnN0IFEgPSBHLm11bChrSSlcblxuICAgIGlmIChRLmlzSW5maW5pdHkoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICByID0gUS54LnVtb2QobilcbiAgICBpZiAoci5pc1plcm8oKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgICBzID0ga0lcbiAgICAgIC5pbnZtKG4pXG4gICAgICAubXVsKGUuYWRkKGQubXVsKHIpKSlcbiAgICAgIC51bW9kKG4pXG4gICAgaWYgKHMuaXNaZXJvKCkgPT09IDApIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoaGFzaCwgeCwgY2hlY2tTaWcsIGlzUHJpdmF0ZSwgYWRkRGF0YSlcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNtcChuRGl2MikgPiAwKSB7XG4gICAgcyA9IG4uc3ViKHMpXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG4gIHRvQnVmZmVyKHIpLmNvcHkoYnVmZmVyLCAwKVxuICB0b0J1ZmZlcihzKS5jb3B5KGJ1ZmZlciwgMzIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gdmVyaWZ5IChoYXNoLCBxLCBzaWduYXR1cmUpIHtcbiAgaWYgKCFpc1NjYWxhcihoYXNoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfSEFTSClcbiAgaWYgKCFpc1BvaW50KHEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QT0lOVClcblxuICAvLyAxLjQuMSBFbmZvcmNlIHIgYW5kIHMgYXJlIGJvdGggaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFsxLCBuIOKIkiAxXSAoMSwgaXNTaWduYXR1cmUgZW5mb3JjZXMgJzwgbiAtIDEnKVxuICBpZiAoIWlzU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1NJR05BVFVSRSlcblxuICBjb25zdCBRID0gZGVjb2RlRnJvbShxKVxuICBjb25zdCByID0gZnJvbUJ1ZmZlcihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKVxuICBjb25zdCBzID0gZnJvbUJ1ZmZlcihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSlcblxuICAvLyAxLjQuMSBFbmZvcmNlIHIgYW5kIHMgYXJlIGJvdGggaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFsxLCBuIOKIkiAxXSAoMiwgZW5mb3JjZXMgJz4gMCcpXG4gIGlmIChyLmd0bigwKSA8PSAwIC8qIHx8IHIuY29tcGFyZVRvKG4pID49IDAgKi8pIHJldHVybiBmYWxzZVxuICBpZiAocy5ndG4oMCkgPD0gMCAvKiB8fCBzLmNvbXBhcmVUbyhuKSA+PSAwICovKSByZXR1cm4gZmFsc2VcblxuICAvLyAxLjQuMiBIID0gSGFzaChNKSwgYWxyZWFkeSBkb25lIGJ5IHRoZSB1c2VyXG4gIC8vIDEuNC4zIGUgPSBIXG4gIGNvbnN0IGUgPSBmcm9tQnVmZmVyKGhhc2gpXG5cbiAgLy8gQ29tcHV0ZSBzXi0xXG4gIGNvbnN0IHNJbnYgPSBzLmludm0obilcblxuICAvLyAxLjQuNCBDb21wdXRlIHUxID0gZXNe4oiSMSBtb2QgblxuICAvLyAgICAgICAgICAgICAgIHUyID0gcnNe4oiSMSBtb2QgblxuICBjb25zdCB1MSA9IGUubXVsKHNJbnYpLnVtb2QobilcbiAgY29uc3QgdTIgPSByLm11bChzSW52KS51bW9kKG4pXG5cbiAgLy8gMS40LjUgQ29tcHV0ZSBSID0gKHhSLCB5UilcbiAgLy8gICAgICAgICAgICAgICBSID0gdTFHICsgdTJRXG4gIGNvbnN0IFIgPSBHLm11bEFkZCh1MSwgUSwgdTIpXG5cbiAgLy8gMS40LjUgKGNvbnQuKSBFbmZvcmNlIFIgaXMgbm90IGF0IGluZmluaXR5XG4gIGlmIChSLmlzSW5maW5pdHkoKSkgcmV0dXJuIGZhbHNlXG5cbiAgLy8gMS40LjYgQ29udmVydCB0aGUgZmllbGQgZWxlbWVudCBSLnggdG8gYW4gaW50ZWdlclxuICBjb25zdCB4UiA9IFIueFxuXG4gIC8vIDEuNC43IFNldCB2ID0geFIgbW9kIG5cbiAgY29uc3QgdiA9IHhSLnVtb2QobilcblxuICAvLyAxLjQuOCBJZiB2ID0gciwgb3V0cHV0IFwidmFsaWRcIiwgYW5kIGlmIHYgIT0gciwgb3V0cHV0IFwiaW52YWxpZFwiXG4gIHJldHVybiB2LmVxKHIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1BvaW50LFxuICBpc1BvaW50Q29tcHJlc3NlZCxcbiAgaXNQcml2YXRlLFxuICBwb2ludEFkZCxcbiAgcG9pbnRBZGRTY2FsYXIsXG4gIHBvaW50Q29tcHJlc3MsXG4gIHBvaW50RnJvbVNjYWxhcixcbiAgcG9pbnRNdWx0aXBseSxcbiAgcHJpdmF0ZUFkZCxcbiAgcHJpdmF0ZVN1YixcbiAgc2lnbixcbiAgc2lnbldpdGhFbnRyb3B5LFxuICB2ZXJpZnlcbn1cbiIsImNvbnN0IGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbmNvbnN0IE9ORTEgPSBCdWZmZXIuYWxsb2MoMSwgMSlcbmNvbnN0IFpFUk8xID0gQnVmZmVyLmFsbG9jKDEsIDApXG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTc5I3NlY3Rpb24tMy4yXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljR2VuZXJhdGVLIChoYXNoLCB4LCBjaGVja1NpZywgaXNQcml2YXRlLCBleHRyYUVudHJvcHkpIHtcbiAgLy8gU3RlcCBBLCBpZ25vcmVkIGFzIGhhc2ggYWxyZWFkeSBwcm92aWRlZFxuICAvLyBTdGVwIEJcbiAgLy8gU3RlcCBDXG4gIGxldCBrID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICBsZXQgdiA9IEJ1ZmZlci5hbGxvYygzMiwgMSlcblxuICAvLyBTdGVwIERcbiAgayA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC51cGRhdGUoWkVSTzEpXG4gICAgLnVwZGF0ZSh4KVxuICAgIC51cGRhdGUoaGFzaClcbiAgICAudXBkYXRlKGV4dHJhRW50cm9weSB8fCAnJylcbiAgICAuZGlnZXN0KClcblxuICAvLyBTdGVwIEVcbiAgdiA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuXG4gIC8vIFN0ZXAgRlxuICBrID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShPTkUxKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLnVwZGF0ZShleHRyYUVudHJvcHkgfHwgJycpXG4gICAgLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBHXG4gIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICAvLyBTdGVwIEgxL0gyYSwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAvLyBTdGVwIEgyYlxuICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgbGV0IFQgPSB2XG5cbiAgLy8gU3RlcCBIMywgcmVwZWF0IHVudGlsIFQgaXMgd2l0aGluIHRoZSBpbnRlcnZhbCBbMSwgbiAtIDFdIGFuZCBpcyBzdWl0YWJsZSBmb3IgRUNEU0FcbiAgd2hpbGUgKCFpc1ByaXZhdGUoVCkgfHwgIWNoZWNrU2lnKFQpKSB7XG4gICAgayA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspXG4gICAgICAudXBkYXRlKHYpXG4gICAgICAudXBkYXRlKFpFUk8xKVxuICAgICAgLmRpZ2VzdCgpXG5cbiAgICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgICAvLyBTdGVwIEgxL0gyYSwgYWdhaW4sIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgICAvLyBTdGVwIEgyYiBhZ2FpblxuICAgIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgICBUID0gdlxuICB9XG5cbiAgcmV0dXJuIFRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmlzdGljR2VuZXJhdGVLXG4iLCJ2YXIgbmF0aXZlID0gcmVxdWlyZSgnLi9uYXRpdmUnKVxuXG5mdW5jdGlvbiBnZXRUeXBlTmFtZSAoZm4pIHtcbiAgcmV0dXJuIGZuLm5hbWUgfHwgZm4udG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb24gKC4qPylcXHMqXFwoLylbMV1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVUeXBlTmFtZSAodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZS5OaWwodmFsdWUpID8gJycgOiBnZXRUeXBlTmFtZSh2YWx1ZS5jb25zdHJ1Y3Rvcilcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKHZhbHVlKSB7XG4gIGlmIChuYXRpdmUuRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gJydcbiAgaWYgKG5hdGl2ZS5TdHJpbmcodmFsdWUpKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gIGlmICh2YWx1ZSAmJiBuYXRpdmUuT2JqZWN0KHZhbHVlKSkgcmV0dXJuICcnXG4gIHJldHVybiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZSAoZSwgdCkge1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlLCB0KVxuICB9XG59XG5cbmZ1bmN0aW9uIHRmSlNPTiAodHlwZSkge1xuICBpZiAobmF0aXZlLkZ1bmN0aW9uKHR5cGUpKSByZXR1cm4gdHlwZS50b0pTT04gPyB0eXBlLnRvSlNPTigpIDogZ2V0VHlwZU5hbWUodHlwZSlcbiAgaWYgKG5hdGl2ZS5BcnJheSh0eXBlKSkgcmV0dXJuICdBcnJheSdcbiAgaWYgKHR5cGUgJiYgbmF0aXZlLk9iamVjdCh0eXBlKSkgcmV0dXJuICdPYmplY3QnXG5cbiAgcmV0dXJuIHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiAnJ1xufVxuXG5mdW5jdGlvbiB0ZkVycm9yU3RyaW5nICh0eXBlLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSkge1xuICB2YXIgdmFsdWVKc29uID0gZ2V0VmFsdWUodmFsdWUpXG5cbiAgcmV0dXJuICdFeHBlY3RlZCAnICsgdGZKU09OKHR5cGUpICsgJywgZ290JyArXG4gICAgKHZhbHVlVHlwZU5hbWUgIT09ICcnID8gJyAnICsgdmFsdWVUeXBlTmFtZSA6ICcnKSArXG4gICAgKHZhbHVlSnNvbiAhPT0gJycgPyAnICcgKyB2YWx1ZUpzb24gOiAnJylcbn1cblxuZnVuY3Rpb24gVGZUeXBlRXJyb3IgKHR5cGUsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKSB7XG4gIHZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lIHx8IGdldFZhbHVlVHlwZU5hbWUodmFsdWUpXG4gIHRoaXMubWVzc2FnZSA9IHRmRXJyb3JTdHJpbmcodHlwZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpXG5cbiAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGZUeXBlRXJyb3IpXG4gIHRoaXMuX190eXBlID0gdHlwZVxuICB0aGlzLl9fdmFsdWUgPSB2YWx1ZVxuICB0aGlzLl9fdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZU5hbWVcbn1cblxuVGZUeXBlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5UZlR5cGVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZlR5cGVFcnJvclxuXG5mdW5jdGlvbiB0ZlByb3BlcnR5RXJyb3JTdHJpbmcgKHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSkge1xuICB2YXIgZGVzY3JpcHRpb24gPSAnXCIgb2YgdHlwZSAnXG4gIGlmIChsYWJlbCA9PT0gJ2tleScpIGRlc2NyaXB0aW9uID0gJ1wiIHdpdGgga2V5IHR5cGUgJ1xuXG4gIHJldHVybiB0ZkVycm9yU3RyaW5nKCdwcm9wZXJ0eSBcIicgKyB0ZkpTT04obmFtZSkgKyBkZXNjcmlwdGlvbiArIHRmSlNPTih0eXBlKSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpXG59XG5cbmZ1bmN0aW9uIFRmUHJvcGVydHlUeXBlRXJyb3IgKHR5cGUsIHByb3BlcnR5LCBsYWJlbCwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICB2YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlTmFtZSB8fCBnZXRWYWx1ZVR5cGVOYW1lKHZhbHVlKVxuICAgIHRoaXMubWVzc2FnZSA9IHRmUHJvcGVydHlFcnJvclN0cmluZyh0eXBlLCBsYWJlbCwgcHJvcGVydHksIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKVxuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9ICdVbmV4cGVjdGVkIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiJ1xuICB9XG5cbiAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGZUeXBlRXJyb3IpXG4gIHRoaXMuX19sYWJlbCA9IGxhYmVsXG4gIHRoaXMuX19wcm9wZXJ0eSA9IHByb3BlcnR5XG4gIHRoaXMuX190eXBlID0gdHlwZVxuICB0aGlzLl9fdmFsdWUgPSB2YWx1ZVxuICB0aGlzLl9fdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZU5hbWVcbn1cblxuVGZQcm9wZXJ0eVR5cGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblRmUHJvcGVydHlUeXBlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGZUeXBlRXJyb3JcblxuZnVuY3Rpb24gdGZDdXN0b21FcnJvciAoZXhwZWN0ZWQsIGFjdHVhbCkge1xuICByZXR1cm4gbmV3IFRmVHlwZUVycm9yKGV4cGVjdGVkLCB7fSwgYWN0dWFsKVxufVxuXG5mdW5jdGlvbiB0ZlN1YkVycm9yIChlLCBwcm9wZXJ0eSwgbGFiZWwpIHtcbiAgLy8gc3ViIGNoaWxkP1xuICBpZiAoZSBpbnN0YW5jZW9mIFRmUHJvcGVydHlUeXBlRXJyb3IpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5ICsgJy4nICsgZS5fX3Byb3BlcnR5XG5cbiAgICBlID0gbmV3IFRmUHJvcGVydHlUeXBlRXJyb3IoXG4gICAgICBlLl9fdHlwZSwgcHJvcGVydHksIGUuX19sYWJlbCwgZS5fX3ZhbHVlLCBlLl9fdmFsdWVUeXBlTmFtZVxuICAgIClcblxuICAvLyBjaGlsZD9cbiAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgVGZUeXBlRXJyb3IpIHtcbiAgICBlID0gbmV3IFRmUHJvcGVydHlUeXBlRXJyb3IoXG4gICAgICBlLl9fdHlwZSwgcHJvcGVydHksIGxhYmVsLCBlLl9fdmFsdWUsIGUuX192YWx1ZVR5cGVOYW1lXG4gICAgKVxuICB9XG5cbiAgY2FwdHVyZVN0YWNrVHJhY2UoZSlcbiAgcmV0dXJuIGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRmVHlwZUVycm9yOiBUZlR5cGVFcnJvcixcbiAgVGZQcm9wZXJ0eVR5cGVFcnJvcjogVGZQcm9wZXJ0eVR5cGVFcnJvcixcbiAgdGZDdXN0b21FcnJvcjogdGZDdXN0b21FcnJvcixcbiAgdGZTdWJFcnJvcjogdGZTdWJFcnJvcixcbiAgdGZKU09OOiB0ZkpTT04sXG4gIGdldFZhbHVlVHlwZU5hbWU6IGdldFZhbHVlVHlwZU5hbWVcbn1cbiIsInZhciBOQVRJVkUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG52YXIgRVJST1JTID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuXG5mdW5jdGlvbiBfQnVmZmVyICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBIZXggKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFswLTlhLWZdezJ9KSskL2kudGVzdCh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gX0xlbmd0aE4gKHR5cGUsIGxlbmd0aCkge1xuICB2YXIgbmFtZSA9IHR5cGUudG9KU09OKClcblxuICBmdW5jdGlvbiBMZW5ndGggKHZhbHVlKSB7XG4gICAgaWYgKCF0eXBlKHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoKSByZXR1cm4gdHJ1ZVxuXG4gICAgdGhyb3cgRVJST1JTLnRmQ3VzdG9tRXJyb3IobmFtZSArICcoTGVuZ3RoOiAnICsgbGVuZ3RoICsgJyknLCBuYW1lICsgJyhMZW5ndGg6ICcgKyB2YWx1ZS5sZW5ndGggKyAnKScpXG4gIH1cbiAgTGVuZ3RoLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWUgfVxuXG4gIHJldHVybiBMZW5ndGhcbn1cblxudmFyIF9BcnJheU4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIE5BVElWRS5BcnJheSlcbnZhciBfQnVmZmVyTiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgX0J1ZmZlcilcbnZhciBfSGV4TiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgSGV4KVxudmFyIF9TdHJpbmdOID0gX0xlbmd0aE4uYmluZChudWxsLCBOQVRJVkUuU3RyaW5nKVxuXG5mdW5jdGlvbiBSYW5nZSAoYSwgYiwgZikge1xuICBmID0gZiB8fCBOQVRJVkUuTnVtYmVyXG4gIGZ1bmN0aW9uIF9yYW5nZSAodmFsdWUsIHN0cmljdCkge1xuICAgIHJldHVybiBmKHZhbHVlLCBzdHJpY3QpICYmICh2YWx1ZSA+IGEpICYmICh2YWx1ZSA8IGIpXG4gIH1cbiAgX3JhbmdlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYCR7Zi50b0pTT04oKX0gYmV0d2VlbiBbJHthfSwgJHtifV1gXG4gIH1cbiAgcmV0dXJuIF9yYW5nZVxufVxuXG52YXIgSU5UNTNfTUFYID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG5mdW5jdGlvbiBGaW5pdGUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKVxufVxuZnVuY3Rpb24gSW50OCAodmFsdWUpIHsgcmV0dXJuICgodmFsdWUgPDwgMjQpID4+IDI0KSA9PT0gdmFsdWUgfVxuZnVuY3Rpb24gSW50MTYgKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlIDw8IDE2KSA+PiAxNikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDMyICh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIHwgMCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDUzICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID49IC1JTlQ1M19NQVggJiZcbiAgICB2YWx1ZSA8PSBJTlQ1M19NQVggJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWVcbn1cbmZ1bmN0aW9uIFVJbnQ4ICh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlICYgMHhmZikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQxNiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAmIDB4ZmZmZikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQzMiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA+Pj4gMCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQ1MyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+PSAwICYmXG4gICAgdmFsdWUgPD0gSU5UNTNfTUFYICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgQXJyYXlOOiBfQXJyYXlOLFxuICBCdWZmZXI6IF9CdWZmZXIsXG4gIEJ1ZmZlck46IF9CdWZmZXJOLFxuICBGaW5pdGU6IEZpbml0ZSxcbiAgSGV4OiBIZXgsXG4gIEhleE46IF9IZXhOLFxuICBJbnQ4OiBJbnQ4LFxuICBJbnQxNjogSW50MTYsXG4gIEludDMyOiBJbnQzMixcbiAgSW50NTM6IEludDUzLFxuICBSYW5nZTogUmFuZ2UsXG4gIFN0cmluZ046IF9TdHJpbmdOLFxuICBVSW50ODogVUludDgsXG4gIFVJbnQxNjogVUludDE2LFxuICBVSW50MzI6IFVJbnQzMixcbiAgVUludDUzOiBVSW50NTNcbn1cblxuZm9yICh2YXIgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgdHlwZXNbdHlwZU5hbWVdLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHRcbiAgfS5iaW5kKG51bGwsIHR5cGVOYW1lKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzXG4iLCJ2YXIgRVJST1JTID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxudmFyIE5BVElWRSA9IHJlcXVpcmUoJy4vbmF0aXZlJylcblxuLy8gc2hvcnQtaGFuZFxudmFyIHRmSlNPTiA9IEVSUk9SUy50ZkpTT05cbnZhciBUZlR5cGVFcnJvciA9IEVSUk9SUy5UZlR5cGVFcnJvclxudmFyIFRmUHJvcGVydHlUeXBlRXJyb3IgPSBFUlJPUlMuVGZQcm9wZXJ0eVR5cGVFcnJvclxudmFyIHRmU3ViRXJyb3IgPSBFUlJPUlMudGZTdWJFcnJvclxudmFyIGdldFZhbHVlVHlwZU5hbWUgPSBFUlJPUlMuZ2V0VmFsdWVUeXBlTmFtZVxuXG52YXIgVFlQRVMgPSB7XG4gIGFycmF5T2Y6IGZ1bmN0aW9uIGFycmF5T2YgKHR5cGUsIG9wdGlvbnMpIHtcbiAgICB0eXBlID0gY29tcGlsZSh0eXBlKVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlPZiAoYXJyYXksIHN0cmljdCkge1xuICAgICAgaWYgKCFOQVRJVkUuQXJyYXkoYXJyYXkpKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChOQVRJVkUuTmlsKGFycmF5KSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAob3B0aW9ucy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCAmJiBhcnJheS5sZW5ndGggPCBvcHRpb25zLm1pbkxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAob3B0aW9ucy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBhcnJheS5sZW5ndGggPiBvcHRpb25zLm1heExlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiBhcnJheS5sZW5ndGggIT09IG9wdGlvbnMubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICAgICAgcmV0dXJuIGFycmF5LmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0eXBlZm9yY2UodHlwZSwgdmFsdWUsIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX2FycmF5T2YudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ciA9ICdbJyArIHRmSlNPTih0eXBlKSArICddJ1xuICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RyICs9ICd7JyArIG9wdGlvbnMubGVuZ3RoICsgJ30nXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHIgKz0gJ3snICtcbiAgICAgICAgICAob3B0aW9ucy5taW5MZW5ndGggPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLm1pbkxlbmd0aCkgKyAnLCcgK1xuICAgICAgICAgIChvcHRpb25zLm1heExlbmd0aCA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBvcHRpb25zLm1heExlbmd0aCkgKyAnfSdcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycmF5T2ZcbiAgfSxcblxuICBtYXliZTogZnVuY3Rpb24gbWF5YmUgKHR5cGUpIHtcbiAgICB0eXBlID0gY29tcGlsZSh0eXBlKVxuXG4gICAgZnVuY3Rpb24gX21heWJlICh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gTkFUSVZFLk5pbCh2YWx1ZSkgfHwgdHlwZSh2YWx1ZSwgc3RyaWN0LCBtYXliZSlcbiAgICB9XG4gICAgX21heWJlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc/JyArIHRmSlNPTih0eXBlKSB9XG5cbiAgICByZXR1cm4gX21heWJlXG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiBtYXAgKHByb3BlcnR5VHlwZSwgcHJvcGVydHlLZXlUeXBlKSB7XG4gICAgcHJvcGVydHlUeXBlID0gY29tcGlsZShwcm9wZXJ0eVR5cGUpXG4gICAgaWYgKHByb3BlcnR5S2V5VHlwZSkgcHJvcGVydHlLZXlUeXBlID0gY29tcGlsZShwcm9wZXJ0eUtleVR5cGUpXG5cbiAgICBmdW5jdGlvbiBfbWFwICh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICBpZiAoIU5BVElWRS5PYmplY3QodmFsdWUpKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChOQVRJVkUuTmlsKHZhbHVlKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eUtleVR5cGUpIHtcbiAgICAgICAgICAgIHR5cGVmb3JjZShwcm9wZXJ0eUtleVR5cGUsIHByb3BlcnR5TmFtZSwgc3RyaWN0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lLCAna2V5JylcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSB2YWx1ZVtwcm9wZXJ0eU5hbWVdXG4gICAgICAgICAgdHlwZWZvcmNlKHByb3BlcnR5VHlwZSwgcHJvcGVydHlWYWx1ZSwgc3RyaWN0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgdGZTdWJFcnJvcihlLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlLZXlUeXBlKSB7XG4gICAgICBfbWFwLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICd7JyArIHRmSlNPTihwcm9wZXJ0eUtleVR5cGUpICsgJzogJyArIHRmSlNPTihwcm9wZXJ0eVR5cGUpICsgJ30nXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9tYXAudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3snICsgdGZKU09OKHByb3BlcnR5VHlwZSkgKyAnfScgfVxuICAgIH1cblxuICAgIHJldHVybiBfbWFwXG4gIH0sXG5cbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QgKHVuY29tcGlsZWQpIHtcbiAgICB2YXIgdHlwZSA9IHt9XG5cbiAgICBmb3IgKHZhciB0eXBlUHJvcGVydHlOYW1lIGluIHVuY29tcGlsZWQpIHtcbiAgICAgIHR5cGVbdHlwZVByb3BlcnR5TmFtZV0gPSBjb21waWxlKHVuY29tcGlsZWRbdHlwZVByb3BlcnR5TmFtZV0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29iamVjdCAodmFsdWUsIHN0cmljdCkge1xuICAgICAgaWYgKCFOQVRJVkUuT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgICB2YXIgcHJvcGVydHlOYW1lXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAocHJvcGVydHlOYW1lIGluIHR5cGUpIHtcbiAgICAgICAgICB2YXIgcHJvcGVydHlUeXBlID0gdHlwZVtwcm9wZXJ0eU5hbWVdXG4gICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSB2YWx1ZVtwcm9wZXJ0eU5hbWVdXG5cbiAgICAgICAgICB0eXBlZm9yY2UocHJvcGVydHlUeXBlLCBwcm9wZXJ0eVZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgdGZTdWJFcnJvcihlLCBwcm9wZXJ0eU5hbWUpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZVtwcm9wZXJ0eU5hbWVdKSBjb250aW51ZVxuXG4gICAgICAgICAgdGhyb3cgbmV3IFRmUHJvcGVydHlUeXBlRXJyb3IodW5kZWZpbmVkLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgX29iamVjdC50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZkpTT04odHlwZSkgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RcbiAgfSxcblxuICBhbnlPZjogZnVuY3Rpb24gYW55T2YgKCkge1xuICAgIHZhciB0eXBlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoY29tcGlsZSlcblxuICAgIGZ1bmN0aW9uIF9hbnlPZiAodmFsdWUsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX2FueU9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzLm1hcCh0ZkpTT04pLmpvaW4oJ3wnKSB9XG5cbiAgICByZXR1cm4gX2FueU9mXG4gIH0sXG5cbiAgYWxsT2Y6IGZ1bmN0aW9uIGFsbE9mICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKGNvbXBpbGUpXG5cbiAgICBmdW5jdGlvbiBfYWxsT2YgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0eXBlZm9yY2UodHlwZSwgdmFsdWUsIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBfYWxsT2YudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXMubWFwKHRmSlNPTikuam9pbignICYgJykgfVxuXG4gICAgcmV0dXJuIF9hbGxPZlxuICB9LFxuXG4gIHF1YWNrc0xpa2U6IGZ1bmN0aW9uIHF1YWNrc0xpa2UgKHR5cGUpIHtcbiAgICBmdW5jdGlvbiBfcXVhY2tzTGlrZSAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlID09PSBnZXRWYWx1ZVR5cGVOYW1lKHZhbHVlKVxuICAgIH1cbiAgICBfcXVhY2tzTGlrZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlIH1cblxuICAgIHJldHVybiBfcXVhY2tzTGlrZVxuICB9LFxuXG4gIHR1cGxlOiBmdW5jdGlvbiB0dXBsZSAoKSB7XG4gICAgdmFyIHR5cGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChjb21waWxlKVxuXG4gICAgZnVuY3Rpb24gX3R1cGxlICh2YWx1ZXMsIHN0cmljdCkge1xuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWVzKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbCh2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoc3RyaWN0ICYmICh2YWx1ZXMubGVuZ3RoICE9PSB0eXBlcy5sZW5ndGgpKSByZXR1cm4gZmFsc2VcblxuICAgICAgcmV0dXJuIHR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVmb3JjZSh0eXBlLCB2YWx1ZXNbaV0sIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX3R1cGxlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcoJyArIHR5cGVzLm1hcCh0ZkpTT04pLmpvaW4oJywgJykgKyAnKScgfVxuXG4gICAgcmV0dXJuIF90dXBsZVxuICB9LFxuXG4gIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSAoZXhwZWN0ZWQpIHtcbiAgICBmdW5jdGlvbiBfdmFsdWUgKGFjdHVhbCkge1xuICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWRcbiAgICB9XG4gICAgX3ZhbHVlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cGVjdGVkIH1cblxuICAgIHJldHVybiBfdmFsdWVcbiAgfVxufVxuXG4vLyBUT0RPOiBkZXByZWNhdGVcblRZUEVTLm9uZU9mID0gVFlQRVMuYW55T2ZcblxuZnVuY3Rpb24gY29tcGlsZSAodHlwZSkge1xuICBpZiAoTkFUSVZFLlN0cmluZyh0eXBlKSkge1xuICAgIGlmICh0eXBlWzBdID09PSAnPycpIHJldHVybiBUWVBFUy5tYXliZSh0eXBlLnNsaWNlKDEpKVxuXG4gICAgcmV0dXJuIE5BVElWRVt0eXBlXSB8fCBUWVBFUy5xdWFja3NMaWtlKHR5cGUpXG4gIH0gZWxzZSBpZiAodHlwZSAmJiBOQVRJVkUuT2JqZWN0KHR5cGUpKSB7XG4gICAgaWYgKE5BVElWRS5BcnJheSh0eXBlKSkge1xuICAgICAgaWYgKHR5cGUubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBjb21waWxlKCkgcGFyYW1ldGVyIG9mIHR5cGUgQXJyYXkgb2YgbGVuZ3RoIDEnKVxuICAgICAgcmV0dXJuIFRZUEVTLmFycmF5T2YodHlwZVswXSlcbiAgICB9XG5cbiAgICByZXR1cm4gVFlQRVMub2JqZWN0KHR5cGUpXG4gIH0gZWxzZSBpZiAoTkFUSVZFLkZ1bmN0aW9uKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIHJldHVybiBUWVBFUy52YWx1ZSh0eXBlKVxufVxuXG5mdW5jdGlvbiB0eXBlZm9yY2UgKHR5cGUsIHZhbHVlLCBzdHJpY3QsIHN1cnJvZ2F0ZSkge1xuICBpZiAoTkFUSVZFLkZ1bmN0aW9uKHR5cGUpKSB7XG4gICAgaWYgKHR5cGUodmFsdWUsIHN0cmljdCkpIHJldHVybiB0cnVlXG5cbiAgICB0aHJvdyBuZXcgVGZUeXBlRXJyb3Ioc3Vycm9nYXRlIHx8IHR5cGUsIHZhbHVlKVxuICB9XG5cbiAgLy8gSklUXG4gIHJldHVybiB0eXBlZm9yY2UoY29tcGlsZSh0eXBlKSwgdmFsdWUsIHN0cmljdClcbn1cblxuLy8gYXNzaWduIHR5cGVzIHRvIHR5cGVmb3JjZSBmdW5jdGlvblxuZm9yICh2YXIgdHlwZU5hbWUgaW4gTkFUSVZFKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBOQVRJVkVbdHlwZU5hbWVdXG59XG5cbmZvciAodHlwZU5hbWUgaW4gVFlQRVMpIHtcbiAgdHlwZWZvcmNlW3R5cGVOYW1lXSA9IFRZUEVTW3R5cGVOYW1lXVxufVxuXG52YXIgRVhUUkEgPSByZXF1aXJlKCcuL2V4dHJhJylcbmZvciAodHlwZU5hbWUgaW4gRVhUUkEpIHtcbiAgdHlwZWZvcmNlW3R5cGVOYW1lXSA9IEVYVFJBW3R5cGVOYW1lXVxufVxuXG50eXBlZm9yY2UuY29tcGlsZSA9IGNvbXBpbGVcbnR5cGVmb3JjZS5UZlR5cGVFcnJvciA9IFRmVHlwZUVycm9yXG50eXBlZm9yY2UuVGZQcm9wZXJ0eVR5cGVFcnJvciA9IFRmUHJvcGVydHlUeXBlRXJyb3JcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlZm9yY2VcbiIsInZhciB0eXBlcyA9IHtcbiAgQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfSxcbiAgQm9vbGVhbjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB9LFxuICBGdW5jdGlvbjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfSxcbiAgTmlsOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgfSxcbiAgTnVtYmVyOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfSxcbiAgT2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfSxcbiAgU3RyaW5nOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfSxcbiAgJyc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxufVxuXG4vLyBUT0RPOiBkZXByZWNhdGVcbnR5cGVzLk51bGwgPSB0eXBlcy5OaWxcblxuZm9yICh2YXIgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgdHlwZXNbdHlwZU5hbWVdLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHRcbiAgfS5iaW5kKG51bGwsIHR5cGVOYW1lKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzXG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxXG5cbmZ1bmN0aW9uIGNoZWNrVUludDUzIChuKSB7XG4gIGlmIChuIDwgMCB8fCBuID4gTUFYX1NBRkVfSU5URUdFUiB8fCBuICUgMSAhPT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIGVuY29kZSAobnVtYmVyLCBidWZmZXIsIG9mZnNldCkge1xuICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgaWYgKCFidWZmZXIpIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChudW1iZXIpKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgLy8gOCBiaXRcbiAgaWYgKG51bWJlciA8IDB4ZmQpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChudW1iZXIsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSAxXG5cbiAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAobnVtYmVyIDw9IDB4ZmZmZikge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmQsIG9mZnNldClcbiAgICBidWZmZXIud3JpdGVVSW50MTZMRShudW1iZXIsIG9mZnNldCArIDEpXG4gICAgZW5jb2RlLmJ5dGVzID0gM1xuXG4gIC8vIDMyIGJpdFxuICB9IGVsc2UgaWYgKG51bWJlciA8PSAweGZmZmZmZmZmKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZSwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG51bWJlciwgb2Zmc2V0ICsgMSlcbiAgICBlbmNvZGUuYnl0ZXMgPSA1XG5cbiAgLy8gNjQgYml0XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG51bWJlciA+Pj4gMCwgb2Zmc2V0ICsgMSlcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRSgobnVtYmVyIC8gMHgxMDAwMDAwMDApIHwgMCwgb2Zmc2V0ICsgNSlcbiAgICBlbmNvZGUuYnl0ZXMgPSA5XG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciBmaXJzdCA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KVxuXG4gIC8vIDggYml0XG4gIGlmIChmaXJzdCA8IDB4ZmQpIHtcbiAgICBkZWNvZGUuYnl0ZXMgPSAxXG4gICAgcmV0dXJuIGZpcnN0XG5cbiAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAoZmlyc3QgPT09IDB4ZmQpIHtcbiAgICBkZWNvZGUuYnl0ZXMgPSAzXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSlcblxuICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZSkge1xuICAgIGRlY29kZS5ieXRlcyA9IDVcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKVxuXG4gIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIGRlY29kZS5ieXRlcyA9IDlcbiAgICB2YXIgbG8gPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpXG4gICAgdmFyIGhpID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA1KVxuICAgIHZhciBudW1iZXIgPSBoaSAqIDB4MDEwMDAwMDAwMCArIGxvXG4gICAgY2hlY2tVSW50NTMobnVtYmVyKVxuXG4gICAgcmV0dXJuIG51bWJlclxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChudW1iZXIpIHtcbiAgY2hlY2tVSW50NTMobnVtYmVyKVxuXG4gIHJldHVybiAoXG4gICAgbnVtYmVyIDwgMHhmZCA/IDFcbiAgICAgIDogbnVtYmVyIDw9IDB4ZmZmZiA/IDNcbiAgICAgICAgOiBudW1iZXIgPD0gMHhmZmZmZmZmZiA/IDVcbiAgICAgICAgICA6IDlcbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZW5jb2RlOiBlbmNvZGUsIGRlY29kZTogZGVjb2RlLCBlbmNvZGluZ0xlbmd0aDogZW5jb2RpbmdMZW5ndGggfVxuIiwidmFyIGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpXG5cbmZ1bmN0aW9uIGRlY29kZVJhdyAoYnVmZmVyLCB2ZXJzaW9uKSB7XG4gIC8vIGNoZWNrIHZlcnNpb24gb25seSBpZiBkZWZpbmVkXG4gIGlmICh2ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgYnVmZmVyWzBdICE9PSB2ZXJzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbmV0d29yayB2ZXJzaW9uJylcblxuICAvLyB1bmNvbXByZXNzZWRcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDMzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IGJ1ZmZlclswXSxcbiAgICAgIHByaXZhdGVLZXk6IGJ1ZmZlci5zbGljZSgxLCAzMyksXG4gICAgICBjb21wcmVzc2VkOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIGludmFsaWQgbGVuZ3RoXG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSAzNCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdJRiBsZW5ndGgnKVxuXG4gIC8vIGludmFsaWQgY29tcHJlc3Npb24gZmxhZ1xuICBpZiAoYnVmZmVyWzMzXSAhPT0gMHgwMSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGZsYWcnKVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogYnVmZmVyWzBdLFxuICAgIHByaXZhdGVLZXk6IGJ1ZmZlci5zbGljZSgxLCAzMyksXG4gICAgY29tcHJlc3NlZDogdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVJhdyAodmVyc2lvbiwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEJ1ZmZlcihjb21wcmVzc2VkID8gMzQgOiAzMylcblxuICByZXN1bHQud3JpdGVVSW50OCh2ZXJzaW9uLCAwKVxuICBwcml2YXRlS2V5LmNvcHkocmVzdWx0LCAxKVxuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcmVzdWx0WzMzXSA9IDB4MDFcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcsIHZlcnNpb24pIHtcbiAgcmV0dXJuIGRlY29kZVJhdyhiczU4Y2hlY2suZGVjb2RlKHN0cmluZyksIHZlcnNpb24pXG59XG5cbmZ1bmN0aW9uIGVuY29kZSAodmVyc2lvbiwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSByZXR1cm4gYnM1OGNoZWNrLmVuY29kZShlbmNvZGVSYXcodmVyc2lvbiwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkpXG5cbiAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUoXG4gICAgZW5jb2RlUmF3KFxuICAgICAgdmVyc2lvbi52ZXJzaW9uLFxuICAgICAgdmVyc2lvbi5wcml2YXRlS2V5LFxuICAgICAgdmVyc2lvbi5jb21wcmVzc2VkXG4gICAgKVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNvZGU6IGRlY29kZSxcbiAgZGVjb2RlUmF3OiBkZWNvZGVSYXcsXG4gIGVuY29kZTogZW5jb2RlLFxuICBlbmNvZGVSYXc6IGVuY29kZVJhd1xufVxuIl19
